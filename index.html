<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>代海峰</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="eating my owner dog food">
<meta property="og:type" content="website">
<meta property="og:title" content="代海峰">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="代海峰">
<meta property="og:description" content="eating my owner dog food">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="代海峰">
<meta name="twitter:description" content="eating my owner dog food">
  
    <link rel="alternate" href="/atom.xml" title="代海峰" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">代海峰</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">个人博客</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Servlets" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/02/Servlets/" class="article-date">
  <time datetime="2018-11-02T04:01:40.000Z" itemprop="datePublished">2018-11-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习心得/">学习心得</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/02/Servlets/">Servlets</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Servlet-API概览"><a href="#Servlet-API概览" class="headerlink" title="Servlet API概览"></a>Servlet API概览</h2><p>Servlet API有以下4个java包</p>
<ol>
<li>javax.servlet，其中包含定义Servlet和Servlet容器之间契约的类和接口</li>
<li>javax.servlet.http，其中包含定义HTTPServlet和Servlet容器之间契约的类和接口</li>
<li>javax.servlet.annotion,其中包含标注Servlet，Filter,Listener的标注，它还为被标注元件定义元数据</li>
<li>javax.servlet.descriptor,其中包含提供程序化登录web应用程序的配置信息的类型<br>Servlet技术的核心时Servlet，它是所有Servlet类必须直接或间接实现的一个接口，在编写实现Servlet的Servlet类时，直接实现它（我们不这样做），或者间接实现它<br><strong>Servlet接口定义了Servlet和Servlet容器之间的契约</strong>，这个契约总结起来就是，Servlet容器将Servlet类载入内存，并在Servlet实例上调用具体的方法，在一个应用程序中，每种Servlet类型只能有一个实例<br>用户请求致使Servlet容器调用Servlet的Servlet方法，并传入一个ServletRequest实例和一个ServletResponse实例，Servlet中封装了当前的HTTP请求，因此，Servlet开发人员不必解析和操作原始的HTTP数据（由Servlet容器完成这些），ServletResponse表示当前用户的HTTP响应，使得将响应发回给用户变得十分容易<h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2>Servlet接口包含了一下5个方法</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>void init(ServletConfig config)throws ServletException</td>
<td>当该Servlet第一次被请求时，Servlet容器会调用这个方法，这个方法在后续的请求中不会再被调用，我们可以利用这个方法执行相应初始化工作，调用这个方法时，Servlet容器会传入一个ServletConfig赋给一个类变量，因此这个对象可以通过Servlet类的其他点来使用</td>
</tr>
<tr>
<td>void Service(ServletRequest request,ServletResponse response)</td>
<td>每当请求Servlet的时候，Servlet容器就会调用这个方法，编写代码时，是假设Servlet要在这里被请求，第一次请求Servlet时，Servlet容器调用init()和service(),后续的请求将只调用service()方法</td>
</tr>
<tr>
<td>destory()</td>
<td>当要销毁Servlet时，Servlet容器就会调用这个方法，当要卸载应用程序，或者当要关闭容器时，就会发生这种情况，一般会在这个方法中编写清除代码</td>
</tr>
<tr>
<td>java.lang.String getServletInfo()</td>
<td>返回Servlet的描述</td>
</tr>
<tr>
<td>ServletConfig getServletConfig</td>
<td>这个方法会返回由Servlet容器传给init(ServletConfig config)方法的ServletConfig，但是为了让getServletConfig返回一个非null值，必须将传给init方法的ServletConfig赋给一个类级变量</td>
</tr>
</tbody>
</table>
<p>注意线程安全，Servlet实例会被一个应用程序中的所有用户共享，因此不建议使用类级变量，除非它们是只读的，或者是java.util.concuurent.atomic包的成员</p>
<h2 id="应用程序的目录结构"><a href="#应用程序的目录结构" class="headerlink" title="应用程序的目录结构"></a>应用程序的目录结构</h2><p>目录结构的最上层是应用程序目录，在应用程序目录下，是WEB-INF目录，它有两个子目录</p>
<ul>
<li>classes。Servlet类及其他Java类必须放在这里面，类以下的目录反映了类包的结构</li>
<li>lib。Servlet应用程序所需的JAR文件要在这里部署，但ServletAPI的JAR文件不需要在这里部署，因为Servlet容器已经有它的备份<br>Servlet/JSP应用程序一般都有JSP页面，HTML文件，图片文件以及其他资料，这些应该都放在应用程序目录下，例如，所有的图片文件都可以放在一个image目录下，所有的JSP文件都可以放在jsp目录下，等等<br><strong>放在应用程序下的任何资源，用户只要输入资源的URL,都可以直接访问到，如果想让某个资源可以被Servlet访问，但不可以被用户访问，那么就可以把它放在WEB-INF目录下</strong><br>部署应用程序的时候，建议将它部署成一个WAR文件，例如，当启动Tomcat时，Tomcat就会自动解压这个war文件，部署成WAR文件在所有的Servlet容器中都适用<h2 id="ServletRequest"><a href="#ServletRequest" class="headerlink" title="ServletRequest"></a>ServletRequest</h2><strong>对于每一个请求，Servlet容器都会创建一个ServletRequest实例</strong>，并将它传给Servlet的service(ServletRequest request,ServletResponse response)方法,<strong>ServletReuest封装了关于这个请求的信息</strong>，ServletRequest接口有一些方法</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>public int getContentLength()</td>
<td>返回主体的字节数，如果不知道字节长度，返回-1</td>
</tr>
<tr>
<td>public java.lang.String getContentType()</td>
<td>返回请求主体的类型，如果不知道类型，则返回null</td>
</tr>
<tr>
<td>public java.lang.String getParameter(java.lang.String name)</td>
<td>返回指定请求参数的值</td>
</tr>
<tr>
<td>public java.lang.String getProtocol()</td>
<td>返回这个HTTP请求的协议名称和版本</td>
</tr>
</tbody>
</table>
<h2 id="ServletResponse"><a href="#ServletResponse" class="headerlink" title="ServletResponse"></a>ServletResponse</h2><p>Javax.servlet.ServletResponse接口表示一个Servlet响应，在调用Servlet的service方法前，由Servlet容器创建并作为第二个参数传给service方法，<strong>ServletResponse隐藏了向浏览器发送响应的复杂过程</strong><br>在ServletReponse中定义的方法之一是getWriter方法，它返回了一个可以向客户端发送文本的java.io.PrintWriter,默认情况下，PrintWriter对象使用的是IOS-8859-1编码<br>注意，还有一个方法可以用来向浏览器发送输出，它就是OutputStream，但是这个方法是用来发送二进制数据的，因此，大多数情况下使用的是getWriter<br>在发送任何HTML标签之前，应该先调用setContentType方法，设置响应的内容类型，并将“text/html”作为一个参数传入。这是告诉浏览器，内容类型为HTML,如果不进行设置，大多数浏览器也都会默认将响应渲染成HTML</p>
<h2 id="ServletConfig"><a href="#ServletConfig" class="headerlink" title="ServletConfig"></a>ServletConfig</h2><p>当Servlet容器初始化的时候，Servlet容器会给Servlet的inti方法传入一个ServletConfig，ServletCOnfig封装可以通过@WebServlet或者部署描述符传给Servlet的配置信息，这样传入的每一条信息就叫一个初始参数，一个初始化参数有key和value两个元件<br>可从ServletConfig调用的方法有</p>
<table>
<thead>
<tr>
<th></th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>String getInitParameter(String name)</td>
<td>返回初始参数的值</td>
</tr>
<tr>
<td>Enumeration<string> getInitParameterNames()</string></td>
<td>返回所有初始参数名称的Enumeration</td>
</tr>
<tr>
<td>ServletContext  getServletContext()</td>
<td>从Servlet内部获取ServletContext</td>
</tr>
</tbody>
</table>
<p>看一下使用注释时如何设置ServletConfig<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>&#123;</span><br><span class="line">  name=<span class="string">"ServletConfigDemoServlet"</span>,</span><br><span class="line">  urlPatterns=&#123;<span class="string">"servletConfigDemo"</span>&#125;,</span><br><span class="line">  initParams=&#123;</span><br><span class="line">       <span class="meta">@WebInitParam</span>&#123;name=<span class="string">"admin"</span>,value=<span class="string">"Harry Taciak"</span>&#125;,</span><br><span class="line">       <span class="meta">@WebInitParam</span>&#123;name=<span class="string">"email"</span> value=<span class="string">"admin#example.com"</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h2><p>ServletContext表示Servlet应用程序，每个WEB应用只有一个上下文<br>通过在ServletConfig中调用getServletContext()，就可以获得ServletContext<br>有了ServletContext，就可以共享从应用程序中的所有资料处访问到的信息，并且可以动态注册Web对象，由ServletContext内部的一个Map保存，保存在ServletContext中的对象被称作属性<br>下面是关于属性的几个常用的ServletContext的方法</p>
<table>
<thead>
<tr>
<th></th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Object getAttribute(String name)</td>
<td>返回ServletContext中保存的属性的值</td>
</tr>
<tr>
<td>Enumeration<string> getAttributeNames()</string></td>
<td>返回所有的属性名称的Enumeration</td>
</tr>
<tr>
<td>void setAttribute(String name,Object object)</td>
<td>在ServletContext中设置属性，以内部的Map保存</td>
</tr>
<tr>
<td>void removeAttribute(String name)</td>
<td>移除属性</td>
</tr>
</tbody>
</table>
<h2 id="GenericServlet"><a href="#GenericServlet" class="headerlink" title="GenericServlet"></a>GenericServlet</h2><p>我们可以通过直接实现Servlet接口编写Servlet，但是这要求必须实现Servlet接口中的所有的5个方法，即使有一些根本就不包含任何代码，而且我们还要自己将Servlet容器创建的ServletConfig保存到Servlet的一个类级变量<br>所幸，GenericServlet抽象类的出现，GenericServlet实现了Servlet和ServletConfig接口，并完成了一下任务</p>
<ul>
<li>将init方法中的ServletConfig赋给一个类级变量，以便可以通过调用getServletConfig获取</li>
<li>为Servlet接口中的所有方法提供了默认实现（除了Service()方法）</li>
<li>提供方法，包围ServletConfig中的方法（也就是说提供了以往必须通过ServletConfig才能调用的方法吗，如getInitParametr(String)和getInitParameterNames（））</li>
</ul>
<p>下面是使用IDEA工具查看到的GenericServlet<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">// IntelliJ API Decompiler stub source generated from a class file</span></span><br><span class="line">  <span class="comment">// Implementation of methods is not available</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> javax.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericServlet</span> <span class="keyword">implements</span> <span class="title">javax</span>.<span class="title">servlet</span>.<span class="title">Servlet</span>, <span class="title">javax</span>.<span class="title">servlet</span>.<span class="title">ServletConfig</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> javax.servlet.ServletConfig config;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericServlet</span><span class="params">()</span> </span>&#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getInitParameter</span><span class="params">(java.lang.String name)</span> </span>&#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> java.util.Enumeration&lt;java.lang.String&gt; getInitParameterNames() &#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> javax.servlet.<span class="function">ServletConfig <span class="title">getServletConfig</span><span class="params">()</span> </span>&#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> javax.servlet.<span class="function">ServletContext <span class="title">getServletContext</span><span class="params">()</span> </span>&#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getServletInfo</span><span class="params">()</span> </span>&#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(javax.servlet.ServletConfig config)</span> <span class="keyword">throws</span> javax.servlet.ServletException </span>&#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> javax.servlet.ServletException </span>&#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(java.lang.String msg)</span> </span>&#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(java.lang.String message, java.lang.Throwable t)</span> </span>&#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(javax.servlet.ServletRequest servletRequest, javax.servlet.ServletResponse servletResponse)</span> <span class="keyword">throws</span> javax.servlet.ServletException, java.io.IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getServletName</span><span class="params">()</span> </span>&#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们再看下GenericServlet的init()方法的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config）throw ServletException&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">this</span>.servletConfig=servletConfig;</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">this</span>.init()</span></span>;<span class="comment">//重点在这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>上面的代码表明我们可以直接覆盖GenericServlet的无参init方法来进行初始化</strong>，而不需要担心ServletConfig的保存问题</p>
<h2 id="Http-Servlets"><a href="#Http-Servlets" class="headerlink" title="Http Servlets"></a>Http Servlets</h2><p>不说全部，至少大部分应用程序都要和HTTP结合起来使用，这意味着可以利用HTTP提供的特性，javax.servlet.http包是Servblet API中的第二个包，其中包括了用于编写Servlet应用程序的类和接口，javax.servlet.http中的许多类型都覆盖了javax.servlet中的类型</p>
<h3 id="HttpServlet"><a href="#HttpServlet" class="headerlink" title="HttpServlet"></a>HttpServlet</h3><p>HttpServlet类覆盖了javax.servlet.GenericServlet类。使用HttpServlet时，还要借助Servlet请求和Servlet响应的HttpServletRequest和HttpServletResponse对象，HttpServletRequest扩展了javax.servlet.ServletRequest,HttpServletResponse扩展了javax.servlet.ServletResponse<br>HttpService覆盖了GenericServlet中的方法，并通过下列的签名添加一个service方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> </span></span><br><span class="line"><span class="function"> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"><span class="comment">/* compiled code */</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们再来看下HttpServlet覆盖的GeneicServlet的service(ServletRequest request,ServletResponse response)的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req,ServletResponse res)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException,IOException</span>&#123;</span><br><span class="line">  HttpServletRequest request;</span><br><span class="line">  HttpServletResponse response;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">     request=(HttpServleRequest)req;</span><br><span class="line">     response=(HttpServletResponse)res;</span><br><span class="line">  &#125;<span class="keyword">catch</span>(ClassCastException e)&#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(e);</span><br><span class="line">  &#125;</span><br><span class="line">  Service(request,response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>原始的Service方法将Servlet容器的request和response对象分别转换为HttpServletRequest和HttpServletResponse，并调用新的service()方法，这种转换总是成功的，因为在调用Servlet的service方法时，Servlet容器总会传入一个HttpServletRequest和HttpServletResponse<br>然后。HttpServlet中的service方法将会检验用来发送请求的HTTP方法（通过调用request.getMethod()），并调用一下方法之一，doGet().doPost(),doTrace(),doOptions(),doDelete()，这7种方法中，每一个都表示一个HTTP方法，因此不需要再覆盖service方法，只要覆盖doGet()，doPost()等上面的7中方法即可<br>总之，HttpServlet有两个特性时GenericService所不具备的</p>
<ul>
<li>不用覆盖service方法，而是覆盖doGet或者doPost，或者覆盖doGet()和doPost()，在少数的情况下，还可以覆盖上述的任意方法</li>
<li>使用HttpServletRequest和HttpServletResposne，而不是ServletRequest和ServletResponse</li>
</ul>
<p>最后我们看一下HttpServlet的API，对理解更清楚一些<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">// IntelliJ API Decompiler stub source generated from a class file</span></span><br><span class="line">  <span class="comment">// Implementation of methods is not available</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> javax.servlet.http;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServlet</span> <span class="keyword">extends</span> <span class="title">javax</span>.<span class="title">servlet</span>.<span class="title">GenericServlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String METHOD_DELETE = <span class="string">"DELETE"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String METHOD_HEAD = <span class="string">"HEAD"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String METHOD_GET = <span class="string">"GET"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String METHOD_OPTIONS = <span class="string">"OPTIONS"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String METHOD_POST = <span class="string">"POST"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String METHOD_PUT = <span class="string">"PUT"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String METHOD_TRACE = <span class="string">"TRACE"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String HEADER_IFMODSINCE = <span class="string">"If-Modified-Since"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String HEADER_LASTMOD = <span class="string">"Last-Modified"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String LSTRING_FILE = <span class="string">"javax.servlet.http.LocalStrings"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.util.ResourceBundle lStrings;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpServlet</span><span class="params">()</span> </span>&#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse resp)</span> <span class="keyword">throws</span> javax.servlet.ServletException, java.io.IOException </span>&#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">getLastModified</span><span class="params">(javax.servlet.http.HttpServletRequest req)</span> </span>&#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doHead</span><span class="params">(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse resp)</span> <span class="keyword">throws</span> javax.servlet.ServletException, java.io.IOException </span>&#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse resp)</span> <span class="keyword">throws</span> javax.servlet.ServletException, java.io.IOException </span>&#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPut</span><span class="params">(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse resp)</span> <span class="keyword">throws</span> javax.servlet.ServletException, java.io.IOException </span>&#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDelete</span><span class="params">(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse resp)</span> <span class="keyword">throws</span> javax.servlet.ServletException, java.io.IOException </span>&#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> java.lang.reflect.Method[] getAllDeclaredMethods(java.lang.Class&lt;?&gt; c) &#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doOptions</span><span class="params">(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse resp)</span> <span class="keyword">throws</span> javax.servlet.ServletException, java.io.IOException </span>&#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doTrace</span><span class="params">(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse resp)</span> <span class="keyword">throws</span> javax.servlet.ServletException, java.io.IOException </span>&#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse resp)</span> <span class="keyword">throws</span> javax.servlet.ServletException, java.io.IOException </span>&#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">maybeSetLastModified</span><span class="params">(javax.servlet.http.HttpServletResponse resp, <span class="keyword">long</span> lastModified)</span> </span>&#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(javax.servlet.ServletRequest req, javax.servlet.ServletResponse res)</span> <span class="keyword">throws</span> javax.servlet.ServletException, java.io.IOException </span>&#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="HttpServletRequest"><a href="#HttpServletRequest" class="headerlink" title="HttpServletRequest"></a>HttpServletRequest</h3><p>HttpServletRequest扩展了ServletRequest的接口，并添加了以下几个方法</p>
<table>
<thead>
<tr>
<th></th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>String getContextPath()</td>
<td>返回表示上下文请求的URL部分</td>
</tr>
<tr>
<td>Cookie[] getCookies()</td>
<td>返回一个Cookie对象数组</td>
</tr>
<tr>
<td>String getHeader(String name)</td>
<td>返回指定HTTP标题的值</td>
</tr>
<tr>
<td>String getMethod()</td>
<td>返回生成这个请求的HTTP方法名称</td>
</tr>
<tr>
<td>String getQueryString()</td>
<td>返回请求URL中的查询字符串</td>
</tr>
<tr>
<td>HttpSession getSession()</td>
<td>返回与这个请求相关的会话对象，如果没有，将创建一个新的会话对象</td>
</tr>
<tr>
<td>HttpSession getSession(boolean create)</td>
<td>返回与这个请求相关的会话对象，如果有，并且create参数为true，将创建一个新的会话对象</td>
</tr>
</tbody>
</table>
<p>下面是完整的HttpServletRequest接口的API<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">// IntelliJ API Decompiler stub source generated from a class file</span></span><br><span class="line">  <span class="comment">// Implementation of methods is not available</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> javax.servlet.http;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpServletRequest</span> <span class="keyword">extends</span> <span class="title">javax</span>.<span class="title">servlet</span>.<span class="title">ServletRequest</span> </span>&#123;</span><br><span class="line">    java.lang.String BASIC_AUTH = <span class="string">"BASIC"</span>;</span><br><span class="line">    java.lang.String FORM_AUTH = <span class="string">"FORM"</span>;</span><br><span class="line">    java.lang.String CLIENT_CERT_AUTH = <span class="string">"CLIENT_CERT"</span>;</span><br><span class="line">    java.lang.String DIGEST_AUTH = <span class="string">"DIGEST"</span>;</span><br><span class="line"></span><br><span class="line">    java.lang.<span class="function">String <span class="title">getAuthType</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    javax.servlet.http.Cookie[] getCookies();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getDateHeader</span><span class="params">(java.lang.String s)</span></span>;</span><br><span class="line"></span><br><span class="line">    java.lang.<span class="function">String <span class="title">getHeader</span><span class="params">(java.lang.String s)</span></span>;</span><br><span class="line"></span><br><span class="line">    java.util.Enumeration&lt;java.lang.String&gt; getHeaders(java.lang.String s);</span><br><span class="line"></span><br><span class="line">    java.util.Enumeration&lt;java.lang.String&gt; getHeaderNames();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getIntHeader</span><span class="params">(java.lang.String s)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> javax.servlet.http.<span class="function">HttpServletMapping <span class="title">getHttpServletMapping</span><span class="params">()</span> </span>&#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line"></span><br><span class="line">    java.lang.<span class="function">String <span class="title">getMethod</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    java.lang.<span class="function">String <span class="title">getPathInfo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    java.lang.<span class="function">String <span class="title">getPathTranslated</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> javax.servlet.http.<span class="function">PushBuilder <span class="title">newPushBuilder</span><span class="params">()</span> </span>&#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line"></span><br><span class="line">    java.lang.<span class="function">String <span class="title">getContextPath</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    java.lang.<span class="function">String <span class="title">getQueryString</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    java.lang.<span class="function">String <span class="title">getRemoteUser</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isUserInRole</span><span class="params">(java.lang.String s)</span></span>;</span><br><span class="line"></span><br><span class="line">    java.security.<span class="function">Principal <span class="title">getUserPrincipal</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    java.lang.<span class="function">String <span class="title">getRequestedSessionId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    java.lang.<span class="function">String <span class="title">getRequestURI</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    java.lang.<span class="function">StringBuffer <span class="title">getRequestURL</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    java.lang.<span class="function">String <span class="title">getServletPath</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    javax.servlet.http.<span class="function">HttpSession <span class="title">getSession</span><span class="params">(<span class="keyword">boolean</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line">    javax.servlet.http.<span class="function">HttpSession <span class="title">getSession</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    java.lang.<span class="function">String <span class="title">changeSessionId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRequestedSessionIdValid</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRequestedSessionIdFromCookie</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRequestedSessionIdFromURL</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@deprecated</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@java</span>.lang.Deprecated</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRequestedSessionIdFromUrl</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">authenticate</span><span class="params">(javax.servlet.http.HttpServletResponse httpServletResponse)</span> <span class="keyword">throws</span> java.io.IOException, javax.servlet.ServletException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">login</span><span class="params">(java.lang.String s, java.lang.String s1)</span> <span class="keyword">throws</span> javax.servlet.ServletException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">logout</span><span class="params">()</span> <span class="keyword">throws</span> javax.servlet.ServletException</span>;</span><br><span class="line"></span><br><span class="line">    java.util.Collection&lt;javax.servlet.http.Part&gt; getParts() <span class="keyword">throws</span> java.io.IOException, javax.servlet.ServletException;</span><br><span class="line"></span><br><span class="line">    javax.servlet.http.<span class="function">Part <span class="title">getPart</span><span class="params">(java.lang.String s)</span> <span class="keyword">throws</span> java.io.IOException, javax.servlet.ServletException</span>;</span><br><span class="line"></span><br><span class="line">    &lt;T extends javax.servlet.http.HttpUpgradeHandler&gt; <span class="function">T <span class="title">upgrade</span><span class="params">(java.lang.Class&lt;T&gt; aClass)</span> <span class="keyword">throws</span> java.io.IOException, javax.servlet.ServletException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> java.util.Map&lt;java.lang.String,java.lang.String&gt; getTrailerFields() &#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isTrailerFieldsReady</span><span class="params">()</span> </span>&#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="HttpServletResponse"><a href="#HttpServletResponse" class="headerlink" title="HttpServletResponse"></a>HttpServletResponse</h3><p>扩展了ServletResposne接口，下面是添加的方法</p>
<table>
<thead>
<tr>
<th></th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>void addCookie(Cookie cookie)</td>
<td>给这个响应对象添加一个Cookie</td>
</tr>
<tr>
<td>void addHeader(String name,String value)</td>
<td>给这个响应对象添加一个Header</td>
</tr>
<tr>
<td>void sendRedirect(String loction)</td>
<td>发送一条响应码，将浏览器跳转到指定的位置</td>
</tr>
</tbody>
</table>
<p>下面是HttpServletResponse接口的完整API<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">// IntelliJ API Decompiler stub source generated from a class file</span></span><br><span class="line">  <span class="comment">// Implementation of methods is not available</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> javax.servlet.http;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpServletResponse</span> <span class="keyword">extends</span> <span class="title">javax</span>.<span class="title">servlet</span>.<span class="title">ServletResponse</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> SC_CONTINUE = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> SC_SWITCHING_PROTOCOLS = <span class="number">101</span>;</span><br><span class="line">    <span class="keyword">int</span> SC_OK = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">int</span> SC_CREATED = <span class="number">201</span>;</span><br><span class="line">    <span class="keyword">int</span> SC_ACCEPTED = <span class="number">202</span>;</span><br><span class="line">    <span class="keyword">int</span> SC_NON_AUTHORITATIVE_INFORMATION = <span class="number">203</span>;</span><br><span class="line">    <span class="keyword">int</span> SC_NO_CONTENT = <span class="number">204</span>;</span><br><span class="line">    <span class="keyword">int</span> SC_RESET_CONTENT = <span class="number">205</span>;</span><br><span class="line">    <span class="keyword">int</span> SC_PARTIAL_CONTENT = <span class="number">206</span>;</span><br><span class="line">    <span class="keyword">int</span> SC_MULTIPLE_CHOICES = <span class="number">300</span>;</span><br><span class="line">    <span class="keyword">int</span> SC_MOVED_PERMANENTLY = <span class="number">301</span>;</span><br><span class="line">    <span class="keyword">int</span> SC_MOVED_TEMPORARILY = <span class="number">302</span>;</span><br><span class="line">    <span class="keyword">int</span> SC_FOUND = <span class="number">302</span>;</span><br><span class="line">    <span class="keyword">int</span> SC_SEE_OTHER = <span class="number">303</span>;</span><br><span class="line">    <span class="keyword">int</span> SC_NOT_MODIFIED = <span class="number">304</span>;</span><br><span class="line">    <span class="keyword">int</span> SC_USE_PROXY = <span class="number">305</span>;</span><br><span class="line">    <span class="keyword">int</span> SC_TEMPORARY_REDIRECT = <span class="number">307</span>;</span><br><span class="line">    <span class="keyword">int</span> SC_BAD_REQUEST = <span class="number">400</span>;</span><br><span class="line">    <span class="keyword">int</span> SC_UNAUTHORIZED = <span class="number">401</span>;</span><br><span class="line">    <span class="keyword">int</span> SC_PAYMENT_REQUIRED = <span class="number">402</span>;</span><br><span class="line">    <span class="keyword">int</span> SC_FORBIDDEN = <span class="number">403</span>;</span><br><span class="line">    <span class="keyword">int</span> SC_NOT_FOUND = <span class="number">404</span>;</span><br><span class="line">    <span class="keyword">int</span> SC_METHOD_NOT_ALLOWED = <span class="number">405</span>;</span><br><span class="line">    <span class="keyword">int</span> SC_NOT_ACCEPTABLE = <span class="number">406</span>;</span><br><span class="line">    <span class="keyword">int</span> SC_PROXY_AUTHENTICATION_REQUIRED = <span class="number">407</span>;</span><br><span class="line">    <span class="keyword">int</span> SC_REQUEST_TIMEOUT = <span class="number">408</span>;</span><br><span class="line">    <span class="keyword">int</span> SC_CONFLICT = <span class="number">409</span>;</span><br><span class="line">    <span class="keyword">int</span> SC_GONE = <span class="number">410</span>;</span><br><span class="line">    <span class="keyword">int</span> SC_LENGTH_REQUIRED = <span class="number">411</span>;</span><br><span class="line">    <span class="keyword">int</span> SC_PRECONDITION_FAILED = <span class="number">412</span>;</span><br><span class="line">    <span class="keyword">int</span> SC_REQUEST_ENTITY_TOO_LARGE = <span class="number">413</span>;</span><br><span class="line">    <span class="keyword">int</span> SC_REQUEST_URI_TOO_LONG = <span class="number">414</span>;</span><br><span class="line">    <span class="keyword">int</span> SC_UNSUPPORTED_MEDIA_TYPE = <span class="number">415</span>;</span><br><span class="line">    <span class="keyword">int</span> SC_REQUESTED_RANGE_NOT_SATISFIABLE = <span class="number">416</span>;</span><br><span class="line">    <span class="keyword">int</span> SC_EXPECTATION_FAILED = <span class="number">417</span>;</span><br><span class="line">    <span class="keyword">int</span> SC_INTERNAL_SERVER_ERROR = <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">int</span> SC_NOT_IMPLEMENTED = <span class="number">501</span>;</span><br><span class="line">    <span class="keyword">int</span> SC_BAD_GATEWAY = <span class="number">502</span>;</span><br><span class="line">    <span class="keyword">int</span> SC_SERVICE_UNAVAILABLE = <span class="number">503</span>;</span><br><span class="line">    <span class="keyword">int</span> SC_GATEWAY_TIMEOUT = <span class="number">504</span>;</span><br><span class="line">    <span class="keyword">int</span> SC_HTTP_VERSION_NOT_SUPPORTED = <span class="number">505</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addCookie</span><span class="params">(javax.servlet.http.Cookie cookie)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsHeader</span><span class="params">(java.lang.String s)</span></span>;</span><br><span class="line"></span><br><span class="line">    java.lang.<span class="function">String <span class="title">encodeURL</span><span class="params">(java.lang.String s)</span></span>;</span><br><span class="line"></span><br><span class="line">    java.lang.<span class="function">String <span class="title">encodeRedirectURL</span><span class="params">(java.lang.String s)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@deprecated</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@java</span>.lang.Deprecated</span><br><span class="line">    java.lang.<span class="function">String <span class="title">encodeUrl</span><span class="params">(java.lang.String s)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@deprecated</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@java</span>.lang.Deprecated</span><br><span class="line">    java.lang.<span class="function">String <span class="title">encodeRedirectUrl</span><span class="params">(java.lang.String s)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendError</span><span class="params">(<span class="keyword">int</span> i, java.lang.String s)</span> <span class="keyword">throws</span> java.io.IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendError</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">throws</span> java.io.IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendRedirect</span><span class="params">(java.lang.String s)</span> <span class="keyword">throws</span> java.io.IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setDateHeader</span><span class="params">(java.lang.String s, <span class="keyword">long</span> l)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addDateHeader</span><span class="params">(java.lang.String s, <span class="keyword">long</span> l)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setHeader</span><span class="params">(java.lang.String s, java.lang.String s1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addHeader</span><span class="params">(java.lang.String s, java.lang.String s1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setIntHeader</span><span class="params">(java.lang.String s, <span class="keyword">int</span> i)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addIntHeader</span><span class="params">(java.lang.String s, <span class="keyword">int</span> i)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setStatus</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@deprecated</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@java</span>.lang.Deprecated</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setStatus</span><span class="params">(<span class="keyword">int</span> i, java.lang.String s)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getStatus</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    java.lang.<span class="function">String <span class="title">getHeader</span><span class="params">(java.lang.String s)</span></span>;</span><br><span class="line"></span><br><span class="line">    java.util.Collection&lt;java.lang.String&gt; getHeaders(java.lang.String s);</span><br><span class="line"></span><br><span class="line">    java.util.Collection&lt;java.lang.String&gt; getHeaderNames();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">setTrailerFields</span><span class="params">(java.util.function.Supplier&lt;java.util.Map&lt;java.lang.String,java.lang.String&gt;&gt; supplier)</span> </span>&#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> java.util.function.Supplier&lt;java.util.Map&lt;java.lang.String,java.lang.String&gt;&gt; getTrailerFields() &#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/02/Servlets/" data-id="cjnzv2pnd000rcorz8m7o82aj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Servlet-JSP/">Servlet&JSP</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-并发" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/27/并发/" class="article-date">
  <time datetime="2018-10-27T06:39:53.000Z" itemprop="datePublished">2018-10-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习心得/">学习心得</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/27/并发/">并发</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="基本的线程机制"><a href="#基本的线程机制" class="headerlink" title="基本的线程机制"></a>基本的线程机制</h2><p>并发编程使得我们可以将程序划分为多个分离，独立运行的任务，通过使用多线程机制，这些独立任务（也被称为子任务）中的每一个都将由执行线程来驱动，一个线程就是在进程中的一个单一的顺序控制流，因此，单个进程可以拥有多个并发执行的任务，但是你的程序使得每个任务都好像有其自己的CPU一样，其地城机制划分CPU时间，但通常你不必考虑它<br>线程模型为编程带来了便利，它简化了在单一程序中同时交织在一起的多个操作的处理，在使用线程时，CPU将轮流给每个任务分配其占用时间，每个任务都觉得自己在一直占用CPU，但实际上CPU时间是划分成片段分配给了所有的任务（例外情况是程序确实运行在多CPU之上），<strong>线程的一大好处是可以使用你从这个层次抽身出来，即代码不必知道它是运行在具有一个还是多个CPU的机器上，所以，使用线程机制是一种建立透明的，可扩展的程序的方法</strong>，如线运行的太慢，为机器添加CPU就能很容易地加快程序的运行速度，多任务和多线程往往是使用多处理器系统的最合理方式</p>
<h3 id="定义任务"><a href="#定义任务" class="headerlink" title="定义任务"></a>定义任务</h3><p><strong>线程可以驱动任务，因此你需要一种描述任务的方式，这可以由Runnable接口来提供，</strong>要想定义任务，只需实现这个接口并实现run()方法，使得该任务可以执行你的命令<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LiftOff</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> countDown=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">int</span> taskCounter=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id =taskCounter++;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LiftOff</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LiftOff</span><span class="params">(<span class="keyword">int</span> countDown)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.countDown=countDown;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">status</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"#"</span>+id+<span class="string">"("</span>+</span><br><span class="line">                (countDown&gt;<span class="number">0</span>?countDown:<span class="string">"LiftDown!"</span>)+<span class="string">"),"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(countDown-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(status());</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>任务的run()方法通常总会有某种形式的循环（这也是我们编写多线程的惯例，使得线程一直保持存在，并在获得时间片的时候，重新做某些条件检查），使得线程一直运行下去直到不再需要，所以要设定跳出循环的条件（一种选择是直接从run()返回），通常，run()被写成无限循环的形式，这就意味着，除非有某个条件使得run()终结，否则它将永远运行下去<br>在run()中对静态方法Thread.yield()调用是对<strong>线程调度器</strong>（java线程机制的一部分，可以将CPU从一个线程转移给另一个线程）的一种建议，它声明：“我已经执行完生命周期中最重要的部分了，此刻正是切换给其他任务执行一段时间的大好时机”，这完全是选择性的，但是这里使用它是因为它会在这些示例中产生更加有趣的输出:你更可能会看到任务换进换出的证据</p>
<p>看下面的一个例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        LiftOff launch=<span class="keyword">new</span> LiftOff();</span><br><span class="line">        launch.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>这例子中的run()不是由单独的线程驱动的</strong>，它是在main方法中直接调用的（实际上，这里仍然使用了线程，即总是分配给main()的那个线程）<br><strong>当从Runnable导出一个类时，它必须具有run()方法，但是这个方法并无特殊之处——它不会缠身任何内在的线程能力，要实现线程的行为，你必须显式地将一个任务附着到线程上</strong></p>
<h3 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h3><p>将Runnable对象转变为工作任务的传统方式是把它提交给一个Thread构造器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Thread t=<span class="keyword">new</span> Thread(<span class="keyword">new</span> LiftOff());</span><br><span class="line">        t.start();</span><br><span class="line">        System.out.println(<span class="string">"waiting for LiftOff"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Thread构造器只需要一个Runnable对象，调用Thread对象的start()方法为该线程执行必要的初始化操作，然后调用Runnable的run()方法，以便在这个新线程中启动该任务，尽管start()方法看起来是产生了一个对长期运行方法的调用，但是从输出中可以看到，start()迅速地返回了，因此你仍旧可以执行main()线程中的其他操作，main()和LiftOff.run()是程序中与其他贤臣“同时”执行的代码<br>你可以很容易地添加更多的线程去驱动更多的任务<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoreBasicThreads</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> LiftOff()).start();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"waiting for liftdowm"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当main()创建Thread对象时，它并没有捕获任何这些对象的引用，每个Thread都“注册”了它自己，因此确实有一个对它的引用，而且在它的任务退出其run()并死亡之前，垃圾回收器是无法清除它的，因此一个线程会创建一个但多的执行线程，在对start()的调用之后，它仍旧会继续存在                                                                                                                                   </p>
<h3 id="使用Executor"><a href="#使用Executor" class="headerlink" title="使用Executor"></a>使用Executor</h3><p>Java SE5的java.util.concurrennt包中的执行器（Executor）将为你管理Thread对象，从而简化了并发编程，Executor在客户端和任务执行之间提供了一个间接层，与客户端直接执行任务不同，这个中介对象将执行任务，Executor允许你管理异步任务的执行，而无须显式地管理线程的生命周期，Executor在java SE5/6中是启动任务的优选方法<br>我们使用executor来代替上面例子中显式地创建Thread对象，LiftOff对象知道如何运行具体的任务，与命令模式一眼，它暴露了要执行的单一方法，<strong>ExecutorService（具有服务生命周期的Executor，例如关闭）知道如何创建恰当的上下文来执行Runnable</strong>,下面的示例中，CachedThreadPool将为每个任务都创建一个线程，注意，ExecutorService对象是使用静态的Excutors的方法创建的额，这个方法可以确定其Executor类型<br>非常常见的情况是，单个的Executor被用来创建和管理系统中所有的任务<br>对shutdown()方法的调用可以防止新任务被提交给这个Executor，当前线程（在本例中，即驱动main()的线程）将继续运行在shutdown()被调用之前提交的所有任务，这个程序将在Executor中所有任务完成之后尽快提出<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachedThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> LiftOff());</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以很容易地将前面的实例中的CachedThreadPool替换成不同类型的Executor，下面是FixedThreadPool使用了有限的线程集来执行所提交的任务<br>有了FixedThreadPool，你就可以一次性地预先执行代价高昂的线程分配，因而也就可以限制线程的数量了，这可以节省时间，因为你不用为每一个任务都固定地付出创建线程的开销<br><strong>注意，在任何线程池中，现有的线程在可能的情况下，都会被自动复用</strong><br>尽管在线程学习中，我们将使用CachedThreadPool，但是也应当考虑在产生线程的代码中使用FixedTheadPool，CachedThreadPool在程序执行过程中通常会创建与所需数量相同的线程，然后它在回收旧线程时停止创建新线程，因此它是合理的Executor的首选，只有当这种方式会引发问题时，你才需要切换到FixedThreadPool<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FixedThreadpool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] ars)</span></span>&#123;</span><br><span class="line">        ExecutorService exec= Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> LiftOff());</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也可以使用SingleThreadPool,SingleThreadPool就像是线程数量为1的FixedThreadPool,这对于你希望在另一个线程中连续运行的任何事物来说，都是很有用的，如果想SingleThreadPool提交了多个任务，那么这些任务将排队，每个任务都会在下一个任务开始之前结束，因此，SingleThreadPool会序列化所有提交给它的额任务，并会维护它自己（隐藏）的悬挂任务队列<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ExecutorService exec= Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> LiftOff());</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="从任务中产生返回值"><a href="#从任务中产生返回值" class="headerlink" title="从任务中产生返回值"></a>从任务中产生返回值</h3><p>Runnable是执行工作的独立任务，但是它不返回任何值，如果你希望任务在完成时能够返回一个值，那么可以实现Callable接口而不是Runnable接口，在java SE5中引入的Callable是一中具有类型参数的泛型，它的类型参数表示的是从方法call()(而不是run())中返回的值，并且必须使用ExecutorService.sumbit()方法调用它<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        ArrayList&lt;Future&lt;String&gt;&gt; results=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            results.add(exec.submit(<span class="keyword">new</span> TaskWithResult(i)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Future&lt;String&gt; fs:results)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                System.out.println(fs.get());</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                System.out.println(e);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(ExecutionException e)&#123;</span><br><span class="line">                System.out.println(e);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                exec.shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>sumbit()方法会产生Future对象，它用Callable返回结果的特定类型进行参数化，你可以isDone()方法来查询Future是否已经完成，当任务完成时，它具有一个结果，你可以调用get()方法来获取该结果，你也可以不用isDone()进行检查就直接调用get()，在这种情况下，get()将阻塞，直至结果准备就绪，你还可以在试图调用get()来获取结果之前，先调用具有超时的get()或者调用isDone()来查看任务是否完成</p>
<h3 id="休眠"><a href="#休眠" class="headerlink" title="休眠"></a>休眠</h3><p>影响任务行为的一种简单的方法就是调用sleep(),它将使任务中止执行给定的时间<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepingTask</span>  <span class="keyword">extends</span> <span class="title">LiftOff</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(countDown-- &gt;<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(status());</span><br><span class="line">                <span class="comment">//Old-style</span></span><br><span class="line">                <span class="comment">//Thread.sleep(100)</span></span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            System.err.println(<span class="string">"Interrupted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> SleepingTask());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>对sleep()的调用可以抛出InterruptedException异常，它在run()中被捕获，因为异常不能跨线程传播会mai(),所以你需要在本地处理所有在任务内部产生的异常</strong><br>java SE5引入了更加显式的sleep()版本，作为TimeUtil类的一部分，这个方法允许你指定sleep()延迟的时间单元，因此可以提供更好的阅读性</p>
<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>线程的优先级将线程的重要性传递给了调度器，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimplePriorities</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>  countDown=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">double</span> d;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> priority;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimplePriorities</span><span class="params">(<span class="keyword">int</span> priority)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.priority=priority;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread()+<span class="string">":"</span>+countDown;<span class="comment">//Thread.currentThread()返回Thread之后调用它的toString()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         Thread.currentThread().setPriority(priority);<span class="comment">//设置执行当前线程的优先级</span></span><br><span class="line">         <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">100000</span>;i++)&#123;</span><br><span class="line">                 d+=(Math.PI+Math.E)/(<span class="keyword">double</span>)i;</span><br><span class="line">                 <span class="keyword">if</span>(i%<span class="number">1000</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                     Thread.yield();</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             System.out.println(<span class="keyword">this</span>);</span><br><span class="line">             <span class="keyword">if</span>(--countDown==<span class="number">0</span>)</span><br><span class="line">                 <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">           exec.execute(<span class="keyword">new</span> SimplePriorities(Thread.MIN_PRIORITY));</span><br><span class="line">        &#125;</span><br><span class="line">        exec.execute(<span class="keyword">new</span> SimplePriorities(Thread.MAX_PRIORITY));</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-6 10,mian]:5</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-6 10,mian]:4</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-6 10,mian]:3</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-6 10,mian]:2</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-6 10,mian]:1</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-3 1,mian]:5</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-2 10,mian]:5</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-1 10,mian]:5</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-5 10,mian]:5</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-4 10,mian]:5</span></span><br><span class="line"><span class="comment">.....</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<p>通过上面程序的输出，我们能够看出来，优先级越高的线程，所分配得的时间片越多，注意，优先级的设定是在run()的开头部分设定，在构造器中设置它们不会有任何好处，因为Executor在此刻还没有开始执行任务（也就是说，只有在执行run（）时任务才被传递给一个线程，在此之前它是不知道哪个线程将会执行它），我们也知道通过调用Thread.currentthread()来获得对<strong>驱动</strong>（理解驱动的概念）该任务的Threa的引用<br>尽管JDK有10个优先级，但它与多数操作系统都不能映射的很好，比如windows有7个优先级且不是固定的，所有这种映射关系也不是固定的，对于不同的操作系统来说，唯一可一直的方法是当调整优先级的时候，只使用MAX_PRIORITYY，NORM_PRIORITY,MIN_PRIORITYY三种</p>
<h3 id="让步"><a href="#让步" class="headerlink" title="让步"></a>让步</h3><p>如果知道已经完成了在run()方法的循环的一次迭代过程中所需的工作，就可以给线程调度机制一个暗示；你的工作已经做的差不多了，可以让别的线程使用CPU了，这个暗示将通过调用yield()方法来作出（不过只是个暗示，没有任何机制保证它将会被采纳），当调用yield()时，你也是在建议具有相同优先级的其他线程可以运行，yield()可以使得任务之间产生良好的处理机制，但是不要依赖yield(),实际上，yield经常被滥用</p>
<h3 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h3><p>所谓后台（daemon）线程，是指在程序运行的时候在后台提供的一种通用服务的线程，并且这种线程并不属于程序中不可或缺的部分，因此，当所有的非后台线程结束时，程序也就终止了，同时还会杀死进程中的所有后台线程，反过来说，只要有任何非后台线程还在运行，程序就不会终止，比如，执行main()就是一个非后台线程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDaemons</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">                System.out.println(Thread.currentThread()+<span class="string">" "</span>+<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"sleep() interrupted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            Thread daemon=<span class="keyword">new</span> Thread(<span class="keyword">new</span> SimpleDaemons());</span><br><span class="line">            daemon.setDaemon(<span class="keyword">true</span>);<span class="comment">//must call before start</span></span><br><span class="line">            daemon.start();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"All daemon started"</span>);</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">175</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的例子一旦main()完成其工作，就没什么能阻止程序终止了，因为除了后台线程外，已经没有什么线程在运行了<br>SimpleDaemons.java创建了显式的线程，以便可以显式设置它们的标志，通过编写定制的ThreadFactory可以定制由Executor创建的线程的属性（后台，优先级，名称）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(@NotNull Runnable r)</span> </span>&#123;</span><br><span class="line">        Thread t=<span class="keyword">new</span> Thread(r);</span><br><span class="line">        t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在你可用一个全新的DeamnoThreadFactory作为参数传递给Executors.newCachedThreadPool()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeamonFromFactory</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                TimeUnit.MICROSECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">                System.out.println(Thread.currentThread()+<span class="string">" "</span>+<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Interrupted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//接受ThreadFactory参数用来创建新的线程</span></span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool(<span class="keyword">new</span> DaemonThreadFactory());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> DeamonFromFactory());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以通过调用isDaeamon()方法来确定线程是否是一个后台线程，如果是一个后台线程，那么它创建的任何线程将被自动设置成后台线程<br>Daemon线程被设置成后台线程，然后派生出许多子线程，这些线程并没有被显式地设置为后台模式，不过它们的确是后台线程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DaemponSpawn</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Daemon</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Thread[] t=<span class="keyword">new</span> Thread[<span class="number">10</span>];</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            t[i]=<span class="keyword">new</span> Thread(<span class="keyword">new</span> DaemponSpawn());</span><br><span class="line">            t[i].start();</span><br><span class="line">            System.out.println(<span class="string">"DaemonSpawn"</span>+i+<span class="string">"  started"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t.length;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">"t["</span>+i+<span class="string">"].isDaemon()="</span>+t[i].isDaemon());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Daemons</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Thread d=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Daemon());</span><br><span class="line">        d.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        d.start();</span><br><span class="line">        System.out.println(<span class="string">"d,isDaemon()="</span>+d.isDaemon());</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你应该意识到后台线程在不执行finally子句的情况下就会终止其run()方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ADaemon</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">          System.out.println(<span class="string">"Starting Daemon"</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Exiting via InterruptedException"</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"this should always run?"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeamonsDonotRunFinally</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Thread t=<span class="keyword">new</span> Thread(<span class="keyword">new</span> ADaemon());</span><br><span class="line">        t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output</span></span><br><span class="line"><span class="comment">Starting ADaemon</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
<p>当你运行这个程序时，将会看到finally子句就不会执行但是如果你注释掉对setDaemon的调用，就会看到finally子句将会执行<br>这种行为是对的，因为，当一个后台非后台线程终止时，后台线程会“突然”终止，因此一旦main()退出，jav就会立即关闭所有的后台进程，而不会有任何你希望出现的确认形式，因为你不能以优雅的方式关闭后台线程，所以它们几乎不是一种好的思想，非后台线程的Executor通常是一种更好的方式，因为Executor控制的所有任务可以同时被关闭，这种关闭时以有序的方式进行的</p>
<h3 id="编码的变体"><a href="#编码的变体" class="headerlink" title="编码的变体"></a>编码的变体</h3><p>当目前位置，在你所看到的示例中，任务类都实现了Runnable，在非常简单的情况下，你可能会希望使用直接从Thread继承这种可替换的方式，就像下面这样<br>你可以通过调用适当的Thread构造器为Thread对象赋予具体的名字这个名字可以通过使用getName()获得<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> countDown=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> threadCount=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(Integer.toString(++threadCount));</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"#"</span>+getName()+<span class="string">"("</span>+countDown+<span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span>(--countDown==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> SimpleThread();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另一种可能会看到的惯用法是自管理的Runnable,自管理的代码看起来好像晦涩难懂一些，但是好处就会可以继承其他的类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelfManaged</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> countDown=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> Thread t=<span class="keyword">new</span> Thread(<span class="keyword">this</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SelfManaged</span><span class="params">()</span></span>&#123;t.start();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName()+<span class="string">"("</span>+countDown+<span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>);</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> SimpleThread();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意。start()方法是在构造器中调用的，这个示例比较简单，因此可能是安全的，但是我们知道构造器应该尽量简单的只是做一些初始化的工作，在构造器中调用start()，这意味着任务是访问一个不稳定的对象（对象在全部执行完初始化动作时才是稳定的），这也是优选Executor而不是Thread的原因<br>有时通过使用内部类来将线程代码隐藏在类中将会很有用，其中的一个原因是，当你使用内部类的任务类的代码时，外围类的对象已经创建好了<br>下面看这些示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="comment">//Using a named Inner class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerThread1</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> countDown=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> Inner inner;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        Inner(String name)&#123;</span><br><span class="line">            <span class="keyword">super</span>(name);</span><br><span class="line">            start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">if</span>(--countDown==<span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    sleep(<span class="number">10</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                System.out.println(<span class="string">"Interrupted"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getName()+<span class="string">":"</span>+countDown;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InnerThread1</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        inner=<span class="keyword">new</span> Inner(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Using a anonymous inner class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> countDown=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> Thread t;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InnerThread2</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        t=<span class="keyword">new</span> Thread(name)&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">                        <span class="keyword">if</span> (-countDown == <span class="number">0</span>)</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"Interrupted"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Thread.currentThread().getName()+<span class="string">"("</span>+countDown+<span class="string">")"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Using a named Runnable Implementation</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerRunnable1</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> countDown=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> Inner inner;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InnerRunnable1</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Inner(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        Inner(String name)&#123;</span><br><span class="line">            t=<span class="keyword">new</span> Thread(<span class="keyword">this</span>,name);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">if</span> (--countDown == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                System.out.println(<span class="string">"interrupted"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> t.getName() + <span class="string">"("</span> + countDown + <span class="string">")"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Using an anonymous Runnable implementation</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerRunnable2</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> countDown=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> Thread t;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InnerRunnable2</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        t=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">                        <span class="keyword">if</span> (--countDown == <span class="number">0</span>)</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"Interrupted"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Thread.currentThread().getName()+<span class="string">"("</span>+countDown+<span class="string">")"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,name);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//a separator method to run some code as a task</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadMethod</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> countDown=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> Thread t;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadMethod</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runTask</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="keyword">null</span>)&#123;</span><br><span class="line">            t=<span class="keyword">new</span> Thread(name)&#123;</span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                  <span class="keyword">try</span>&#123;</span><br><span class="line">                      <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                          System.out.println(<span class="keyword">this</span>);</span><br><span class="line">                          <span class="keyword">if</span>(--countDown==<span class="number">0</span>)</span><br><span class="line">                              <span class="keyword">return</span>;</span><br><span class="line">                          sleep(<span class="number">10</span>);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                        System.out.println(<span class="string">"interrupted"</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">                  <span class="keyword">return</span> getName()+<span class="string">"("</span>+countDown+<span class="string">")"</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadVariations</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> InnerThread1(<span class="string">"InnerThread1"</span>);</span><br><span class="line">        <span class="keyword">new</span> InnerThread2(<span class="string">"InnerThread2"</span>);</span><br><span class="line">        <span class="keyword">new</span> InnerRunnable1(<span class="string">"InnerRunnable1"</span>);</span><br><span class="line">        <span class="keyword">new</span> InnerRunnable2(<span class="string">"InnerRunnable2"</span>);</span><br><span class="line">        <span class="keyword">new</span> ThreadMethod(<span class="string">"ThreadMethod"</span>).runTask();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p>在java中，你可以选择如何实现并发编程，并且这个选择会令人困惑，这个问题通常来自于用来描述并发程序技术的术语，特别是涉及线程的那些<br>当目前位置，你应该能够看到要执行的任务和驱动它的线程之间的差异这个差异在java类库尤为明显，因为你对Thread类实际没有任何控制权（并且这种隔离在使用执行器时更加明显，因为执行器将替你处理线程的创建和管理），你创建任务，并通过某种方式讲一个线程附着在任务上，以使得这个线程可以执行任务<br>在java中，Thread类本身不执行任何操作，它只是驱动赋予它的任务，但是线程研究中总是不变的使用“线程执行这项或那项任务”这样的语言，因此，你得到的印象就是“线程就是任务”这种错误的想法，线程与任务之间有一种明显的“是一个”关系，这会诱使人这样想“我应该从Thread中继承一个任务”，哈哈，这些想法都是错的<br>从概念上讲，我们希望创建独立于其他任务的任务，因此我们应该能够定义任何，然后说“开始”，并且不用操心其细节，<strong>但是在物理上，创建线程可能会代价高昂，因此必须保存并管理它们，这样，从现实的角度看，将任务从线程中分离出来时有意义的</strong><br>为了澄清这些讨论，我们接下来，将尝试着在描述将要执行的工作时使用术语“任务”，只有在引用到驱动任务的具体机制是，才使用“线程”</p>
<h3 id="加入一个线程"><a href="#加入一个线程" class="headerlink" title="加入一个线程"></a>加入一个线程</h3><p>一个线程可以在其他线程上调用join()方法，其效果是等待一段时间直到第二个线程结束才继续执行，如果某个线程是在另一个线程t上调用t.join()，此线程将被挂起，直到目标线程结束才恢复（即isAlive()返回false）<br>也可以在调用join()时带上一个超时参数（单位可以是毫秒，或者毫秒和纳秒），这样如果目标线程在这段时间到期时还没有结束的话，join()方法总能返回<br>对join()方法的调用可以被中断，做法是在调用线程上调用interrupt()方法，这时需要用到try{}catch(){}<br>下面演示这些操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sleeper</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> duration;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sleeper</span><span class="params">(String name,<span class="keyword">int</span> sleepTime)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        duration=sleepTime;</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sleep(duration);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            System.out.println(getName()+<span class="string">"was interrupted"</span></span><br><span class="line">            +<span class="string">"isInterrupted()"</span>+isInterrupted());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(getName()+<span class="string">"has awakened"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Joiner</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Sleeper sleeper;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Joiner</span><span class="params">(String name,Sleeper sleeper)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.sleeper=sleeper;</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sleeper.join();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"interrupted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(getName()+<span class="string">"join completed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Joining</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Sleeper sleepy=<span class="keyword">new</span> Sleeper(<span class="string">"Sleepy"</span>,<span class="number">1500</span>);</span><br><span class="line">        Sleeper grumpy=<span class="keyword">new</span> Sleeper(<span class="string">"Grumpy"</span>,<span class="number">1500</span>);</span><br><span class="line">        Joiner dopey=<span class="keyword">new</span> Joiner(<span class="string">"Dopey"</span>,sleepy);</span><br><span class="line">        Joiner doc=<span class="keyword">new</span> Joiner(<span class="string">"Doc"</span>,grumpy);</span><br><span class="line">        grumpy.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output</span></span><br><span class="line"><span class="comment">Grumpy was interrupted isInterrupted() false isInterrupted()总是返回false</span></span><br><span class="line"><span class="comment">Doc join completed</span></span><br><span class="line"><span class="comment">Sleepy has awakened</span></span><br><span class="line"><span class="comment">Dppey join completed</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
<p>Sleepy是一个Thread类型，我们通过向其构造器传入一个休眠的时间参数，让它休眠一段时间，sleep()方法有可能在指定时间返回，也可能被中断，在catch子句中，将根据IsInterrupted()的返回值报告这个中断，当另一个线程在该线程上调用interrupt()时，将给线程设定一个标识，标识这个线程的中断状态，然而异常被捕获时将清理这个标志，所以在catch子句中，在异常被捕获的时候这个标志总是为假，除了异常之外，这个标志还可用于其他情况，比如线程可能会检测其中断状态<br>Joiner线程将通过在Sleep对象上调用join()方法来等待Sleeper醒来，在main()中，每个Sleeper都有个Joiner,这可以从输出中发现，如果sleeper被中断或者正常结束，Joiner将和Sleeper一同结束<br>注意Java SE5de java.util.concurrent类库包含诸如CyclicBarrier,这样的工具，可能比最初的线程类型的join()更加合适</p>
<h3 id="创建有响应的用户界面"><a href="#创建有响应的用户界面" class="headerlink" title="创建有响应的用户界面"></a>创建有响应的用户界面</h3><h3 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h3><p>线程组持有线程的一个集合</p>
<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p>由于线程的本质特性，使得你不能捕获从线程中逃逸的异常，一旦异常逃逸出任务的run()方法它就会向外传播到控制台，除非你才有特殊的步骤捕获这种错误的异常，在java SE5之前，你需要线程组来捕获这些异常，现在你可以使用Executor来解决这个问题，因此你不再需要了解线程组的知识了<br>我们看下面的两个代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        exec.execute(<span class="keyword">new</span> ExceptionThread());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的程序运行之后会打印出栈信息<br>下面我们试着将上面关于线程的代码放在main()所在线程的try{}catch()里面看看会发生什么<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NaiaveExceptionHandling</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">            exec.execute(<span class="keyword">new</span> ExceptionThread());</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Exception has been handled"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果和上面一样，异常也是未被捕获<br><strong>为了解决这个问题，我们修改Executor产生线程的方式，Thread.UncaughtExceptionHandler是java SE5的新接口，它运行你在每个Thread对象上都附着一个异常处理器，Thread.UncaughtExceptionHandler.uncaughtException()会在线程因未捕获的异常而临近死亡时被调用</strong><br>为了使用它，我们创建一个新类型的ThreadFactory,它将在每个新创建的Thread对象上附着一个Threaed.UncaughtExceptionHandler,我们将这个工厂传递给Executors创建新的ExcutorService的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.jetbrains.annotations.NotNull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个任务将会抛出异常并打印出驱动它的线程和线程上的异常处理器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExceptionThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t=Thread.currentThread();</span><br><span class="line">        System.out.println(<span class="string">"run() by"</span>+t);</span><br><span class="line">        System.out.println(<span class="string">"eh="</span>+t.getUncaughtExceptionHandler());</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个异常处理器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyUncaughtExceptionHandler</span> <span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"caught"</span>+e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线程工厂,new的Thread都附着一个异常处理器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HandlerThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(@NotNull Runnable r)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>+<span class="string">"creating new Thread"</span>);</span><br><span class="line">        Thread t=<span class="keyword">new</span> Thread(r);</span><br><span class="line">        t.setUncaughtExceptionHandler(<span class="keyword">new</span> MyUncaughtExceptionHandler());</span><br><span class="line">        System.out.println(</span><br><span class="line">          <span class="string">"eh="</span>+t.getUncaughtExceptionHandler()</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span>  t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnCaptureUncaughtException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool(<span class="keyword">new</span> HandlerThreadFactory());</span><br><span class="line">        exec.execute(<span class="keyword">new</span> ExceptionThread2());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行上面的程序，将会看到任务抛出的异常将会被线程上的异常处理器捕获<br>上面的示例使得你可以按照具体情况逐个地设置处理器，如果你知道将要在代码中处处使用相同的异常处理器，那么更简单的方法是在Thread类中设置一个静态域，并将这个处理器设置为默认的未捕获异常处理器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SettingDefaultHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread.setDefaultUncaughtExceptionHandler(</span><br><span class="line">                <span class="keyword">new</span> MyUncaughtExceptionHandler()</span><br><span class="line">        );</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        exec.execute(<span class="keyword">new</span> ExceptionThread2());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个处理器只有在不存在线程专有的未捕获异常处理器的情况下才会被调用，系统会建厂线程专有版本，如果没有发现，则检查线程组中是否有其专有的unCaughtException()方法，如果还没有，再调用defaultUncaughtExceptionHandler</p>
<h2 id="共享受限资源"><a href="#共享受限资源" class="headerlink" title="共享受限资源"></a>共享受限资源</h2><p>可以把单线程程序当作问题域求解的单一实体，每次只能做一件事，因为只有一个实体，所以永远不用担心诸如“两个实体试图使用同一个资源”的问题<br>有了并发就可以同时做很多事情了，但是，两个或者多个线程彼此互相干涉的问题也就出现了</p>
<h3 id="不正确地访问资源"><a href="#不正确地访问资源" class="headerlink" title="不正确地访问资源"></a>不正确地访问资源</h3><p>考虑下面一个例子，其中一个任务产生偶数，而其他任务消费这些数字，这里消费者任务的唯一工作就是检查偶数的有效性<br>我们先定义一个Intgenerator，即生产者，再定义一个消费者，EvenChecker<br>下面定义了一个抽象类<br>IntGnerator有个cancel()方法，可以修改boolean类型的canceled标志的状态，各个在线程中执行的任务可以通过这个canceled来选择是否终止执行（线程驱动的任务终结），<strong>因为canceled标志是boolean类型的，所以它是原子性的，既诸如赋值和返回值这样的简单操作在发生时没有中断的可能，因此你就不会看到这个域处于只允许这些简单操作的过程的中间状态</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">IntGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> canceled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>&#123;canceled=<span class="keyword">true</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCanceled</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> canceled;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，在本例中可以被撤销的类不是Runnable，而是所有依赖于IntGennerator对象的EvenChceker任务将测试它，以查看他首发已经被撤销了，通过这种方式。共享公共资源的任务可以观察该类的终止信号（这里是canceled），这样就消除所谓竞争条件，即两个或更多的任务竞争响应某个条件，因此产生冲突或者不一致结果的情况，你可以执行考虑并防范系统失败的所有可能途径，例如，一个任务不能依赖另一个任务，因为任务关闭的顺序得不到保证，这里，<strong>通过使任务依赖于非任务对象，我们可以消除潜在的竞争条</strong><br>EvenChecker任务总是读取和测试从其相关的IntGenerator返回的值，注意，如果generator.isCanceled()为true，则run()返回，这将告知EvenChecker.test()中的Excutor该任务完成了，任何EvenChecker任务都可以与其相关联的IntGenerator上调用cancel()，这将导致所有其他使用该IntGenerator的EvenChecker得体地关闭<br>下面的例子执行之后，执行一段时间（经过执行，发现这段时间很短，几乎使得所有的线程执行的任务都退出了）后，会发现EvneGenerator产生了奇数，这在单线程是不可能存在的，但是在多线程中，线程是通过线程调度器取得的时间片段，在执行next()的时候，可能未将next()完之后就切换到其他线程开始继续执行，那么就会使EvenGenerator处于“不恰当”的状态，因此得出结论是如果想要使得多线程能够正常的执行，就必须保证这些共享资源（这里的共享资源是EvenGenerator）必须每一时刻（即使在切换线程前后）都要是“安全”的状态<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvenChecker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IntGenerator generator;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EvenChecker</span><span class="params">(IntGenerator g,<span class="keyword">int</span> ident)</span></span>&#123;</span><br><span class="line">        generator=g;</span><br><span class="line">        id=ident;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!generator.isCanceled())&#123;</span><br><span class="line">            <span class="keyword">int</span> val=generator.next();</span><br><span class="line">            <span class="keyword">if</span>(val%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(val+<span class="string">"note even!"</span>);</span><br><span class="line">                generator.cancel();<span class="comment">//cancels all EvenChecker</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//创建线程池，将任务传递给执行器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(IntGenerator gp,<span class="keyword">int</span> counter)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Press control-c to exit"</span>);</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;counter;i++)&#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> EvenChecker(gp,i));</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(IntGenerator gp)</span></span>&#123;</span><br><span class="line">        test(gp,<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvenGenerator</span> <span class="keyword">extends</span> <span class="title">IntGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentEvenValue=<span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ++currentEvenValue;<span class="comment">//danger point here</span></span><br><span class="line">        ++currentEvenValue;</span><br><span class="line">        <span class="keyword">return</span> currentEvenValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        EvenChecker.test(<span class="keyword">new</span> EvenGenerator());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解决共享资源竞争"><a href="#解决共享资源竞争" class="headerlink" title="解决共享资源竞争"></a>解决共享资源竞争</h3><p>前面的示例展示了使用线程的一个基本问题：你永远不知道一个线程何时在运行，这就导致一个问题，当你的线程开始去执行任务（对共享对象进行访问），此时这个共享对象的状态突然发生预期外的改变（通过其他线程的作用），这个时候你接下来的要访问的共享资源不再是你想要访问的共享资源了，这个时候就有可能会发生问题，我将这种情形解释为：“谁动了我的奶酪”，其实谁动了我的奶酪没有太大关系，重点是，如果这块奶酪依然可以被我享用，OK,其他人拿走了它，但是在我打算吃它的时候，有将它放在原处，没有问题，在我打算吃之前有人在上面加了一颗草莓也没什么太大关系，至少它还是奶酪啊，虽然它的状态发生了变化，也还好，但是如果有人在上面吐了一口水，那我就不能在吃了<br>这就关系到了线程协作问题，每一个线程都应该尽力保证当处理完共享资源的时候，贡献资源的状态应该是正常的<br><strong>对于并发问题，你需要某种方式来防止两个任务访问相同的资源</strong>（如果不加限制，在多处理器中，两个任务同时访问相同的资源是很正常的事情）至少在关键阶段不能出现这种情况<br><strong>防止这种冲突的方法就是当资源被一个任务使用时，在其上加锁，第一个访问某项资源的任务必须锁定这项资源，使得其他任务在其被解锁之前，就无法访问它了，而在其解锁之后，另一个任务就可以锁定并使用它，以此类推</strong><br><strong>基本上所有的并发模式在解决线程冲突问题的时候，都是采用序列化访问共享资源的方案</strong>，着意味着在给定的时刻只允许一个任务可以运行这段代码，<strong>因为锁语句产生了一种互相排斥的效果，所以这种机制常常被称为互斥量（mutex）</strong><br>java提供关键字synchronized的形式，为防止资源冲突提供了内置支持，当任务要执行被synchronized关键字保护的代码片段的时候，它将检查锁是否可用，然后获得锁，执行代码，释放锁<br>共享资源一般是以对象形式存在的内存片段，但也可以是文件hi安，输入和输出端口，或者是打印机，要控制对共享资源的访问，得先把它们包装在一个对象，然后把所有要访问这个资源的方法标记为synchronized<br>synchronized void f()<br>synchronized void g()<br>所有对象都自动含有单一的锁（也称为监视器），当在对象上调用其任意synchronized方法的时候，此对象就会被加锁，这时该对象上的其他synchronized方法只有等到前一个方法调用完毕并释放了锁之后才能被调用<br><strong>对于某个特定对象而言，其所有synchronized方法共享同一个锁</strong>，因此，当一个任务访问f()方法获得锁的时候，其他任务访问g()时也会遭到“拒绝”<br><strong>注意，在使用并发时，将域设置为private是非常重要的，否则，synchronized关键字就不能防止其他任务直接访问域，这样就会产生冲突</strong><br><strong>一个任务可以多次获得对象的锁，</strong>如果一个方法在同一个对象上调用第二个方法，后者又调用了同一个对象上的另一个方法，就会发生这种情况，jvm负责跟着对象被加锁的次数，如果一个对象被解锁（即锁被完全释放），其计数变0，在任务第一次给对象加锁的时候，计数变1，每当这个任务在这个对象上获得锁的时候，计数都会递增，显然，只有首先获得了锁的任务才能继续获取多个锁，每当任务离开一个synchronized方法的时候幂级数递减，当计数为0的时候，锁完全被释放，此时别的任务就可以使用此资源了<br><strong>针对每个类，也有一个锁（作为类的Class对象的一部分），所以synchronized static方法可以在类的范围内防止对static数据的并发访问</strong><br>你应该在什么时候同步呢？可以运用Brian的同步规则</p>
<blockquote>
<p>如果你正在写一个变量，它可能接下来将被另一个线程读取，或者正在读取一个上一次已经被其他线程写过的变量，那么你必须使用同步，并且，读写线程都必须使用相同的监视器锁同步<br><strong>如果你的类中有超过一个方法在处理临界数据，那么你必须同步所有相关的方法</strong>，如果只同步一个方法，那么其他的方法会随意地忽略这个对象锁，并可以在无任何惩罚的情况下被调用，这是很重要的一点，每个访问临界共享资源的方法都必须被同步，否则它们就不会正确地工作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedEvenGenerator</span> <span class="keyword">extends</span> <span class="title">IntGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentEvenValue=<span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span>  <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ++currentEvenValue;<span class="comment">//danger point here</span></span><br><span class="line">        Thread.yield();<span class="comment">//cause failure faster</span></span><br><span class="line">        ++currentEvenValue;</span><br><span class="line">        <span class="keyword">return</span> currentEvenValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        EvenChecker.test(<span class="keyword">new</span> EvenGenerator());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>使用Thread.yield()，以提高在currentEvenValue是奇数状态时上下文切换的可能性。因为互斥防止多个任务同时进入<strong>临界区</strong>，所以这不会产生任何失败</p>
<h4 id="使用显式的Lock对象"><a href="#使用显式的Lock对象" class="headerlink" title="使用显式的Lock对象"></a>使用显式的Lock对象</h4><p>java SE5的java.util.concuurent类库还包含有定义在java.util.concurrent.locks中的显式的互斥机制，Lock对象必须被显式地创建，锁定和释放，因此，它与内建的锁形式相比，代码缺乏优雅性，但是，对于解决某些类型的问题来说，它更灵活<br>下面是使用Lock重写的是SynChronizedEvenGenerator.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutexEvenGenerator</span> <span class="keyword">extends</span> <span class="title">IntGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentEvenValue=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ++currentEvenValue;</span><br><span class="line">            Thread.yield();</span><br><span class="line">            ++currentEvenValue;</span><br><span class="line">            <span class="keyword">return</span> currentEvenValue;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">          lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>MutexEvenGenerator添加了互斥调用的锁，并使用lock()和unlock()方法在next()内部创建临界资源，将这里所示的惯用法内部化是很重要的，紧接着是对lock()的调用，你必须放置在finally子句中带有unlock()的try-finally语句中，注意，return与语句必须在try子句中出现，以确保unlock()不会过早发生，从而将数据暴露给了第二个任务<br>尽管try-catch所需的代码比synchronized关键字多，但是这也代表了显示的Lock对象的优点之一：<strong>如果在使用synchronized关键字时，某些事物失败了，那么就会抛出一个异常，但是你没有机会去做任何清理工作，以维护系统使其处于良好状态，有了显式的Lock对象，你就可以使用finally子句将系统维护在正确的状态了</strong><br>一般情况下我们还是使用synchronized,因为代码量少，并且用户错误出现的可能性也会降低，因此通常只有在解决特殊问题时，才使用显式的Lock对象，例如，用synchronized关键字不能尝试着获取锁且最终获取锁会失败，或者尝试着获取锁一段时间，然后释放它，要实现这些，你必须使用concurrent类库<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AttemptLocking</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">untimed</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> captured=lock.tryLock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"tryLock()"</span>+captured);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(captured)&#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timed</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> captured=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            captured=lock.tryLock(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"tryLock(2.TimeUnit.SECONDS)"</span>+</span><br><span class="line">            captured);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(captured)&#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> AttemptLocking al=<span class="keyword">new</span> AttemptLocking();</span><br><span class="line">        al.untimed();<span class="comment">//true---lock is available;</span></span><br><span class="line">        al.timed();<span class="comment">//true --- lock is available;</span></span><br><span class="line">        <span class="comment">//Now create s separate task to grap the lock</span></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            &#123;setDaemon(<span class="keyword">true</span>);&#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                al.lock.lock();</span><br><span class="line">                System.out.println(<span class="string">"acquired"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        Thread.yield();</span><br><span class="line">        al.untimed();<span class="comment">//false--lock grabbed by task</span></span><br><span class="line">        al.timed();<span class="comment">//false--lock grabbed by task</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="原子性与易变性"><a href="#原子性与易变性" class="headerlink" title="原子性与易变性"></a>原子性与易变性</h3><p>在关于java线程的讨论中，一个不正常的知识是：“原子操作不需要进行同步控制”，原子操作是不能被线程调度机制中断的操作，一旦操作开始，那么它一定可以在可能发生的“上下文切换”前（切换到其他线程执行）执行完毕，依赖原子性是很棘手且危险的，记住，如果你是一个并发专家，你才应该使用原子性来替代同步，否则不要去考虑<br>了解原子性是很有用的，并且知道原子性与其他高级技术一道，在java.util.concurrent类库中已经实现了某些更加巧妙的构件，但是要坚决抵挡住完全依赖自己的能力去进行处理的这种欲望<br>原子性可以应用于除了long和double之外的所有基本类型之上的“简单操作”对于读取和写入除long和double之外的基本类型变量这样的操作，可以保证它们会被当作不可分（原子）的操作来操作内存，但是JVM可以将64位（long和double变量）的读取和写入当作两个分离的32位操作来执行，这就产生了在读取和写入的操作中间发生上下文切换，从而导致不同的任务可以看到不正常结果的可能性（有时这被称为“字撕裂”），因为你可能看到部分被修改的数值，当你定义long和double变量时，如果使用volatile关键字，就会获得（简单的赋值和返回操作的）原子性，不同的JVM可以任意地保证提供更强的保证，但是你不应该依赖于平台相关的特性<br>在多处理器系统（现在以多核处理器的形式出现，即在单个芯片上有多个CPU）上，相对于单线程系统而言，可视性问题远比原子性问题多得多，一个任务做出的修改，<strong>即使在不中断的意义上讲是原子性的，对其他任务也可能是不可视的，（例如，修改只是暂时性地存储在本地处理器的缓存上），因此不同的任务对应用有不同的视图，另一方面，同步机制强制在处理器系统中，一个任务做出的修改必须在应用中是可视的，如果没有同步机制，那么修改时可视就无法确定</strong><br><strong>volatile关键字还确保了应用中的可视性，如果你讲一个域声明为volatile的，那么只要对这个域产生了写操作，那么所有的写操作都可以看到这个修改，即使使用了本地缓存，情况也确实如此</strong>，volatile域会被写入到<strong>主存</strong>中，而读取操作就发生在<strong>主存</strong>上<br><strong>理解原子性和易变性是不同的概念这一点很重要</strong>，在非volatile域上的原子操作不必刷新到主存中去，因此其他读取该域的任务也不必看到这个新值，如果多个任务在同时访问某个域，那么这个域应该是volatile的，否则这个域就应该只能经由同步访问（也就是说，原子性只是保证了操作的完整性，而并不能保证在这些操作完成之后，其他的任务能够看到这些操作所做的修改），<strong>同步会导致向主存刷新</strong>，因此，如果一个域完全由synchronizied方法或语句块来防护（synchronized起到了两个效果，原子性和可视性都能得到保证），那就不必将其设置为valatile的<br><strong>一个任务所做的任何写操作对这个任务来说都是可视的，因此如果它只需要在这个任务内部可视，那么你就不需要将其设置为volatile</strong>(记住的是，每个任务或者说线程都对自己的操作是可视的，也就是说，我知道我做过那些事情，以及这些操作完成之后的，域的状态是什么，我都能获悉，所有对应我自己独有的域，不需要与其他任务共享的域来说，我不需要使用volatile关键字修饰域使得别的任务能够立即看到我做操作的结果，当操作结束之后不必刷新到主存，只要我自己能够看到它就可以)<br>当一个域的值依赖于它之前的值时（也就是说下次的计算要能获得上次正确的数），例如递增一个计数器，volatile就无法工作，如果某个域的值受到其他域的值的限制，那么valatile也无法工作，例如Range类的lower和upper边界就必须遵循lower&lt;upper<br>使用volatile而不是synchronized的唯一安全的情况是类中只有一个可变的域，再次提醒，你的第一选择是synchronized关键字，这是最安全的方式，而尝试其他任何方式都是有风险的<br>什么才属原子操作？对域中的值做赋值和返回操作通常都是原子性的，但是在java中<br>i++;<br>i+=2;<br>都不是原子性的，上述这些操作实际被分成了几个指令，因此在获取和放置指令之间，另一个任务可能会修改这个域，所有这些操作都不是原子性的<br>如果你盲目的使用原子性概念，那么你就会看到下面程序中的getValue()符合上面的描述<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicityTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> i;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">evenIncrement</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            evenIncrement();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ExecutorService exec=Executors.newCachedThreadPool();</span><br><span class="line">        AtomicityTest at=<span class="keyword">new</span> AtomicityTest();</span><br><span class="line">        exec.execute(at);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> val=at.getValue();</span><br><span class="line">            <span class="keyword">if</span> (val% <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(val);</span><br><span class="line">                System.exit(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的程序当找到奇数就终止，<strong>虽然reture i 确实是原子性的，但是缺乏同步（同步的意思也就是我拿到数据的时候和你的数据要保持一致，这就是同步的概念）使得其数值可以处在不稳定的中间状态时被读取，除此之外，由于i也不是volatile的，因此还存在可视性的问题，getValue()和evenIncrument()必须都是synchronized的</strong>，<br>第二个示例，考虑一些更简单的事情，一个产生序列数字的类，每当nextSerialNumber()被调用的时候，它必须向调用者返回唯一的值<br>SerialNumberGenerator很简单，如果在C++中serialNumber++这种递增操作是原子性的，因为C++递增可以作为一条微处理器指令来实现，但是在java，这种递增操作却不是，这里设立了一个读一个写操作，（我的理解是，本质上应该说这是JVM虚拟机造成的，对于相同意图的操作，各虚拟机的实现是不同的，因此也就造成了，相同的操作在不同的语言中的原子性不同）<br>基本上，如果一个域可能会被多个任务同时访问，或者这些任务中至少有一个是写入任务，那么你就应该将这个域设置为volatile的，如果你将一个域设置成volatile，那么它就会告诉编译器不要执行任何移出（原文写到是移除，我觉得应该是写错了）读取和写入操作的优化，这些操作的目的是用线程中的局部变量维护对这个域的精确同步。实际上，读取和写入都是针对内存的，而却没有被缓存，但是<strong>，volatile并不能对递增不是原子性操作这一事实产生影响</strong><br>我们从这两个例子得出的经验是，原子性操作并不会导致同步，原子性只保证操作是完整不可分的，但是多个任务的视图不一定相同<br>volatile导致了同步，但是不能保证操作的原子性<br>也就是为什么我们synchronized是我们并发编程的首选，因为这个关键字既保证了原子性，又保证了同步<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialNumberGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> serialNumber=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextSerialNumber</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serialNumber++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了测试SerialNumberGenerator，我们需要不会耗尽内存的集（Set）下面例子的CricularSet就是这样一个集合，这个例子很简单，我们创建了多个线程竞争序列数，判断集合中有无线程取到的序列数，如果没有，则将产生的序列数放入数组，如果集合中包含了该任务产生的序列数，那么说明了之前的线程产生的序列数和现在线程拿到的序列数相同了，如果nextSerialNumber()的操作是原子性的，不会发生这种情况，<strong>得出结论就是volatile保证了同步但是不能保证操作的原子性</strong><br>对基本类型的读取和赋值操作被认为是安全的原子性操作，但是，正如在AtomicityTest.java中看到的，当对象处于不稳定状态时，仍然很可能使用原子性来访问它们，对这个问题的假设是棘手和危险的，最明智的做法是遵循同步规则<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CricularSet</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CricularSet</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        array=<span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        len=size;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            array[i]=-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        array[index]=i;</span><br><span class="line">        <span class="comment">//wrap index and write over old element</span></span><br><span class="line">        index=++index%len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i]==val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialNumberChecker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CricularSet serials=<span class="keyword">new</span> CricularSet(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialChecker</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">               <span class="keyword">int</span> serial=SerialNumberGenerator.nextSerialNumber();</span><br><span class="line">               <span class="keyword">if</span>(serials.contains(serial))&#123;</span><br><span class="line">                   System.out.println(<span class="string">"Duplicate:"</span>+serial);</span><br><span class="line">                   System.exit(<span class="number">1</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               serials.add(serial);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;SIZE;i++)&#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> SerialChecker());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(args.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Integer(args[<span class="number">0</span>]));</span><br><span class="line">            System.out.println(<span class="string">"no duplicates detected"</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h3><p>Java SE5引入了诸如AtomicInteger,AtomicLong,AtomicReference等特殊的原子性变量类，它们提供了下面形式的原子性条件更新操作<br>boolean comparaAndSet(expectedValue,updateValue)<br>这些类被调整为可以使用在某些现代处理器上的可获得的，并且是在机器级别上的原子类，因此使用它们时，通常不需要担心，对于常规编程来说，它们很少会派上用场，但是涉及性能调优上，它们就大有用武之地了，例如，我们可以使用AtomicInteger来重写AtomicityTest.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Time;</span><br><span class="line"><span class="keyword">import</span> java.util.Timer;</span><br><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger i=<span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> i.get();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">evenIncrement</span><span class="params">()</span></span>&#123;i.addAndGet(<span class="number">2</span>);&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">           evenIncrement();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Timer().schedule(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.err.println(<span class="string">"Aborting"</span>);</span><br><span class="line">                System.exit(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">5000</span>);</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        AtomicIntegerTest ait=<span class="keyword">new</span> AtomicIntegerTest();</span><br><span class="line">        exec.execute(ait);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> val=ait.getValue();</span><br><span class="line">            <span class="keyword">if</span>(val%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(val);</span><br><span class="line">                System.exit(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们通过使用AtomicInterger而消除了synchronized关键字，因为这个程序不会失败，所以我们添加了一个Timer，以便在5秒后终结程序<br>Atomic类被设计的目的主要是为了重建java.util.concurrent中的类，因此只有在特殊情况下才会使用它们，通常依赖锁更安全一些（要么使用synchronized关键字或者显式的Lock）</p>
<h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p><strong>有时，你只是希望防止多个线程同时访问方法内部的部分代码而不是防止整个方法，通过这种方式分离出来的代码段被称为临界区（critical section）</strong>，它也是使用synchronized建立的，这里synchronized被用来指定某个对象，此对象的锁可以被用来对花括号内的代码进行同步的控制<br>    synchronized(synObject){<br>      //this code can be accessed<br>      //by only one task at a time<br>    }<br>这样被称为同步块，在进入此段代码前，必须得到synObject对象的锁，如果其他线程已经得到了这个锁，那么就得等到锁被释放以后，才能进入临界区<br>通过同步块，而不是对整个方法进行同步控制，可以使得多个任务访问对象的时间性能得到显著的提升<br>下面的例子演示了，如何将一个非保护类型的类，在其他类的保护和控制之下，应用于多线程的环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line">package xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">class Pair&#123;</span><br><span class="line">    private int x;</span><br><span class="line">    private int y;</span><br><span class="line">    public Pair(int x,int y)&#123;</span><br><span class="line">        this.x=x;</span><br><span class="line">        this.y=y;</span><br><span class="line">    &#125;</span><br><span class="line">    public Pair()&#123;this.x=0;this.y=0;&#125;</span><br><span class="line">    public int getX()&#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getY()&#123;</span><br><span class="line">        return y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void incrementX()&#123;x++;&#125;</span><br><span class="line">    public void incrementY()&#123;y++;&#125;</span><br><span class="line">    public String toString()&#123;</span><br><span class="line">        return &quot;x:&quot;+x+&quot;,y:&quot;+y;</span><br><span class="line">    &#125;</span><br><span class="line">    public class PairValuesNoEqualException</span><br><span class="line">    extends Exception&#123;</span><br><span class="line">        public PairValuesNoEqualException()&#123;</span><br><span class="line">            super(&quot;Pair values not equals&quot;+Pair.this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void checkState()throws PairValuesNoEqualException&#123;</span><br><span class="line">        if(x!=y)&#123;</span><br><span class="line">            throw new PairValuesNoEqualException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract class PairManager&#123;</span><br><span class="line">    AtomicInteger checkcounter=new AtomicInteger(0);</span><br><span class="line">    protected Pair pair=new Pair();</span><br><span class="line">    private List&lt;Pair&gt; storage= Collections.synchronizedList(new ArrayList&lt;Pair&gt;());</span><br><span class="line">    public synchronized Pair getPair()&#123;</span><br><span class="line">        return new Pair(pair.getX(),pair.getY());</span><br><span class="line">    &#125;</span><br><span class="line">    protected void store(Pair pair)&#123;</span><br><span class="line">        storage.add(pair);</span><br><span class="line">        try&#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(50);//在这里故意增加了持有锁的时间</span><br><span class="line">        &#125;catch(InterruptedException e)&#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract void increment();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PairManager1 extends PairManager&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public synchronized  void increment() &#123;</span><br><span class="line">       pair.incrementX();</span><br><span class="line">       pair.incrementY();</span><br><span class="line">       store(getPair());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PairManager2 extends PairManager&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void increment() &#123;</span><br><span class="line">        Pair temp;</span><br><span class="line">        synchronized (this)&#123;</span><br><span class="line">           pair.incrementX();</span><br><span class="line">           pair.incrementY();</span><br><span class="line">           temp=getPair();</span><br><span class="line">        &#125;</span><br><span class="line">        store(temp);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PairManipulator implements Runnable&#123;</span><br><span class="line">    private PairManager pm;</span><br><span class="line">    public PairManipulator(PairManager pm)&#123;</span><br><span class="line">        this.pm=pm;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            pm.increment();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String toString()&#123;</span><br><span class="line">        return &quot;Pair:&quot;+pm.getPair()+&quot;checkCouter=&quot;+pm.checkcounter.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PairChecker implements Runnable&#123;</span><br><span class="line">    private PairManager pm;</span><br><span class="line">    public PairChecker(PairManager pm)&#123;</span><br><span class="line">        this.pm=pm;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                pm.checkcounter.incrementAndGet();</span><br><span class="line">                pm.getPair().checkState();</span><br><span class="line">            &#125;catch(Pair.PairValuesNoEqualException e)&#123;</span><br><span class="line">                System.out.println(&quot;NoEqual&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class CriticalSection &#123;</span><br><span class="line">    static void testApproaches(PairManager pman1,PairManager pman2)&#123;</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        PairManipulator pm1=new PairManipulator(pman1);</span><br><span class="line">        PairManipulator pm2=new PairManipulator(pman2);</span><br><span class="line">        PairChecker pc1=new PairChecker(pman1);</span><br><span class="line">        PairChecker pc2=new PairChecker(pman2);</span><br><span class="line">        exec.execute(pm1);</span><br><span class="line">        exec.execute(pm2);</span><br><span class="line">        exec.execute(pc1);</span><br><span class="line">        exec.execute(pc2);</span><br><span class="line">        try&#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(500);</span><br><span class="line">        &#125;catch(InterruptedException e)&#123;</span><br><span class="line">            System.out.println(&quot;Sleep interrupted&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;pm1:&quot;+pm1+&quot;\npm2&quot;+pm2);</span><br><span class="line">        System.exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main()&#123;</span><br><span class="line">        PairManager pman1=new PairManager1();</span><br><span class="line">        PairManager pman2=new PairManager2();</span><br><span class="line">        testApproaches(pman1,pman2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的例子Pair不是线程安全的，因为它的约束条件（虽然是任意的）需要两个变量维持成相同的值，，在本例中，自增加操作不是线程安全的，并且因为没有任何方法被标记为synchronzied，所以不能保证一个Pair对象在多个线程中不会被破环<br>想象这样一种情况，<strong>你有一个非线程安全的Pair类，而你需要在一个线程安全的环境中去使用它，通过创建PairManager类可以做到这一点</strong>，PairManager持有一个Pair对象并控制它的一切访问，注意唯一public方法是getPair(),它是同步的（它也应当是同步的，要想在线程安全的情况下访问一个线程不安全的对象，此时必须保证访问这个对象的时候，对于这个类的视图必须是最新且是状态是正常的）,对于抽象方法increment()，对于同步的控制将在子类的实现中进行处理，<strong>我们可以看到在子类实现的方法中添加了synchronized关键字，因为不属于方法签名的一部分，所有这是被允许的</strong><br>store()方法将一个Pair对象添加到了synchronizedArrayList中，所以这个方法是安全的，不需要进行防护<br>PairManager1和PairManager2对increment()的实现不同，一个是对整个方法进行同步控制，一个是对方法的一部分进行同步控，PairMainpulate被创建来测试这两个不同实现，而PairCheck是在另一个任务中执行，为了跟踪可以运行测试的额度，PairChecker在每次成功时都会递增checkcounter<br>每次运行的结果都会不一样，但一般的来说，对于PairChecker的检查频率，PairManager1.increment()没有PairManager2.increment()多（因为前者持有锁的时间比较长，对于getPair()的调用也需要获得锁，因此，相同的时间，它获取锁的次数就少），后者采用的是同步块进行同步，所以对象不加锁的时间更长，这也是宁愿使用同步控制块而不是对整个方法进行同步控制的典型原因，使得其他线程能够更多地访问（在安全的情况下尽可能多）<br>结论就是，不要让一个方法持有锁的时间过长，这样会增加其他的线程访问这个类其他synchronized方法（包含持有锁的方法本身）的等待时间，性能大打折扣<br>解决方案就是，只在方法内部对那些访问线程不安全的类的方法进行同步，对线程安全的类的访问不加同步控制，上面的例子，Pair是非线程安全的类，对它的访问，incrementX()和incrementY()加上synchronized访问控制，对线程安全的synchronizedArrayList的add()方法不加同步控制<br>你也可以使用显示的Lock对象来创建临界区,下面的两个例子简单看下就好<br>//synchronized the entire method<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExplicitPairManager1</span> <span class="keyword">extends</span> <span class="title">PairManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            pair.incrementX();</span><br><span class="line">            pair.incrementY();</span><br><span class="line">            store(getPair());</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>//Use a critical section<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExplicitPairManager2</span> <span class="keyword">extends</span> <span class="title">PairManager</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">           lock.lock();</span><br><span class="line">           pair.incrementX();</span><br><span class="line">           pair.incrementY();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        store(getPair());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="在其他对象上同步"><a href="#在其他对象上同步" class="headerlink" title="在其他对象上同步"></a>在其他对象上同步</h3><p>synchronized块必须给定一个在其上进行同步的对象，并且最合理的方式，使用其方式正在被调用的当前对象，synchronized(this)<br><strong>有时必须在另一个对象上同步，但是如果你要这么做，就必须确保所有相关的任务都是在同一个对象上同步的</strong><br>下面演示了两个任务可以同时进入同一个对象，只要这两个对象上的方法是在不同的锁上同步的即可<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DualSynch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object synObject=<span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span>  <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">"f()"</span>);</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (synObject)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">                System.out.println(<span class="string">"g()"</span>);</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> DualSynch dualSynch=<span class="keyword">new</span> DualSynch();</span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">               dualSynch.f();</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        dualSynch.g();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从输出可以看出，因为对不同的对象进行同步，所有这两个方法的执行是同时进行的，没有任何一一个方法阻塞了另一个方法</p>
<h3 id="线程本地存储"><a href="#线程本地存储" class="headerlink" title="线程本地存储"></a>线程本地存储</h3><p><strong>防止线程在共享资源上产生冲突的第二种方式是根除对变量的共享</strong>，线程本地存储是一种自动化机制，可以为使用相同变量的每个不同的线程都创建不同的存储，因此如果你有5个线程都要使用变量x所表示的对象，那线程本地存储会产生5个用于x的不同的存储块，主要是它们使得你可以将状态与线程关联起来<br>创建和管理线程本地存储可以由java.lang.ThreadLocal类来实现，如下所示、<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Accessor</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Accessor</span><span class="params">(<span class="keyword">int</span> ident)</span></span>&#123;<span class="keyword">this</span>.id=ident;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">            ThreadLocalVariableHolder.increment();</span><br><span class="line">            System.out.println(<span class="keyword">this</span>);</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"#"</span>+id+<span class="string">":"</span>+</span><br><span class="line">                ThreadLocalVariableHolder.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalVariableHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; value=</span><br><span class="line">            <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;()&#123;</span><br><span class="line">               <span class="keyword">private</span> Random rand=<span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">               <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Integer <span class="title">initialValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">                   <span class="keyword">return</span> rand.nextInt(<span class="number">1000</span>);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</span><br><span class="line">        value.set(value.get()+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> value.get();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> Accessor(i));</span><br><span class="line">        &#125;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);<span class="comment">//run for a while</span></span><br><span class="line">        exec.shutdownNow();<span class="comment">//all Accessors will quit</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output</span></span><br><span class="line"><span class="comment">#0:953</span></span><br><span class="line"><span class="comment">#1:823</span></span><br><span class="line"><span class="comment">#2:834</span></span><br><span class="line"><span class="comment">#3:453</span></span><br><span class="line"><span class="comment">#4:324</span></span><br><span class="line"><span class="comment">#0:954</span></span><br><span class="line"><span class="comment">#1:824</span></span><br><span class="line"><span class="comment">#2:835</span></span><br><span class="line"><span class="comment">#3:454</span></span><br><span class="line"><span class="comment">#4:325</span></span><br><span class="line"><span class="comment">....</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
<p>TheadLocal对象通常作为静态域存储，在创建ThreadLocal时，你只能通过get()和set()方法来访问该对象的内容，其中，get()将返回与其线程相关联的对象的副本，而set()方法会将参数插入到其为线程存储的对象中，并返回存储中原有的对象，上面的输出也说明了，ThreadLocal<integer>对象为每一个线程都创建了不同的存储来保存Integer的值，这些值在线程间是不共享的，只对自己的线程可见</integer></p>
<h2 id="终结任务"><a href="#终结任务" class="headerlink" title="终结任务"></a>终结任务</h2><p>我们在前面的示例中看到cancel()和isCancel()方法被放在了一个所有任务都可以看到的类中（也就说canceled变量是共享的，通过这个标志来控制线程的终止，任务结束线程终止），对于这个问题来说，这是一种合理的情况，但是，在某些情况下，任务必须更加突然地终止（在之前的例子中，任务是通过判断条件来终止的）<br>下面是一个仿真程序，花园委员会希望了解每天通过多个大门进入公园的总人数，每个大门都有一个十字转门或某种其他形式的计数器，并且任何一个十字转门的计数值递增时，就表示公园中的总人数的共享计数器也会递增</p>
<h3 id="装饰性花园"><a href="#装饰性花园" class="headerlink" title="装饰性花园"></a>装饰性花园</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Count</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Random rand=<span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">increment</span><span class="params">()</span></span>&#123;<span class="comment">//因为Count是共享资源，所以对它读写要同步</span></span><br><span class="line">        <span class="keyword">int</span> temp=count;</span><br><span class="line">        <span class="keyword">if</span>(rand.nextBoolean())&#123; <span class="comment">//yield half the time</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (count=++temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>&#123;<span class="comment">//同步读取，这样避免获得count变量的中间状态</span></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Entrance</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Count count=<span class="keyword">new</span> Count();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Entrance&gt; enterances=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span>  <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> canceled=<span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">concel</span><span class="params">()</span></span>&#123;canceled=<span class="keyword">true</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Entrance</span><span class="params">(<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id=d;</span><br><span class="line">        enterances.add(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!canceled)&#123;</span><br><span class="line">        <span class="comment">//这里Thinking in java的作者对于number加synchronized是有必要的,因为它创建了5个任务实体交给线程去执行，也就是说每个线程与一个任务相关联，它只执行和它相关联的任务，所以就对每个Runnable（既Entrance）没有产生竞争，产生竞争的是Count，而不是任务</span></span><br><span class="line">        可以先看main()方法中创建线程的方式就可以明了 </span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">                ++number;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>+<span class="string">"   Total: "</span>+count.increment());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"sleep interrupted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Stoping "</span>+<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>&#123;<span class="comment">//加synchronized是没有必要的</span></span><br><span class="line">        <span class="keyword">return</span>  number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Entrance"</span>+id+<span class="string">":"</span>+getValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getTotalCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count.value();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sumEntrances</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Entrance enterance:enterances)&#123;</span><br><span class="line">            sum+=enterance.getValue();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrnametalGargen</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">    <span class="comment">//这里是为每一个线程都创建一个任务实体，也就是说每一个线程去驱动任务实体中的run方法，</span></span><br><span class="line">    <span class="comment">//对于每一个任务实体来说，它不是共享的，因此也就不会产生竞争，像下面这样，</span></span><br><span class="line">    <span class="comment">//就会产生竞争，对任务实体来说，对它的读写才要进行同步</span></span><br><span class="line">    <span class="comment">//            Entrance entrance=new Entrance();</span></span><br><span class="line">    <span class="comment">//            exec.execute(entrance)</span></span><br><span class="line">          exec.execute(<span class="keyword">new</span> Entrance(i));</span><br><span class="line">        &#125;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        Entrance.concel();<span class="comment">//将标志位canceled设为true，使各线程结束运行</span></span><br><span class="line"></span><br><span class="line">        exec.shutdown();</span><br><span class="line">        <span class="comment">//TimeUnit.SECONDS.sleep(1);我在这里可以使主线程再休眠1秒，这样1秒后线程池里就不在有等待终结的线程了（理论上是这样的）</span></span><br><span class="line">        <span class="keyword">if</span>(!exec.awaitTermination(<span class="number">250</span>,TimeUnit.MILLISECONDS))&#123;<span class="comment">//250是设置的一个超时时间，我在上面可以多加1秒的时间</span></span><br><span class="line">            System.out.println(<span class="string">"Some tasks ware not terminated!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Total"</span>+Entrance.getTotalCount());</span><br><span class="line">        System.out.println(<span class="string">"Sum of Entrance:"</span>+Entrance.sumEntrances());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用单个Count对象来跟着花园参观者的主总计值，并且将其当作Entrance类中的一个静态域进行存储，Count.increment()和Count.value()都是synchronized的，用来控制对Count的访问，increment()方法使用了Random对象，目的是在从把count读取到temp中，到递增temp并将其存储回count的这段时间里，大约一般的时间产生让步，如果你讲synchronized关键字注释掉，那么程序就会崩溃，因为多个任务将同时访问并修改count（yield()会使问题更快地发生），所有这里对count的操作要是synchronized修饰，即要同步<br>每个Entrance任务都维护着一个本地值number，它包含了通过某个特定入口进入的参观者的数量，这提供了对count对象的双重检查，以确保其记录的参观者数量是正确的，Entrance.run()只是递增number和count对象，然后休眠100毫秒<br>因为Entrance.canceled是一个volatile（保证同步）布尔标志，而它只会被读取和赋值（也就是说这些操作是原子性的）（不会与其他线程域组合在一起读取），所有不需要对其进的访问，就可以安全地操作它，如果你对诸如此类的情况有疑问的话，那么最好总是使用synchronized<br>这个程序在以稳定的方式关闭所有事物方面还有一些小麻烦，其部分原因是为了说明在终止多线程程序时你必须相当小心，而另一部分原因是为了演示interrupt()的值，稍后会学到这个知识<br>在三秒之后，main()向Entrance发送static cancel()消息，然后调用exec对象的shutdown()方法，之后调用exec上的awaitTermination()方法，ExecutorService.awaitTermination()等待每个任务结束，如果所有的任务在超时时间到达之前全部结束，则返回true，否则返回fasle,表示不是所有任务都已经结束，尽管这会导致每个任务都会退出run()，并因此作为任务而终止，但是Entrance对象仍然有效，因为在构造器中，每个Entrance都存储在被称为entrances的静态List<entrance>中，因此，宿命Entrances()仍旧可以工作于这些有效的Entrance对象上（这给了我们启示，要想任务对象在任务结束后仍旧有效，可以用一个引用能够引用到它，这样才不会被垃圾回收机制回收掉）</entrance></p>
<h3 id="在阻塞时终结"><a href="#在阻塞时终结" class="headerlink" title="在阻塞时终结"></a>在阻塞时终结</h3><p>前面的示例中的Entrance.run()在其循环中包含了对sleep的调用，我们知道，sleep()最终将唤醒，上面的示例，当线程“醒来时”，又重新从while开始处检查canceled的标志，以决定是否跳出循环，结束任务，但是，<strong>sleep()的一种情况，它使任务从执行状态变为阻塞状态，而有时你必须终止被阻塞的任务</strong></p>
<h4 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h4><p>一个线程可以处于一下四种状态之一：</p>
<ol>
<li>新建（new）：当下线程被创建时，它只会短暂地处于这种状态，此时它已经分配了必须的系统资源，并执行了初始化，此刻线程已经有资格获得CPU时间了，之后调度器将把这个线程转变为可运行状态或阻塞</li>
<li>就绪（Runnbale）:在这种状态下，只要调度器把时间片分配给线程，线程就可以运行，也就是说，在任意时刻，线程可以运行也可以不运行，只要调度器能分配时间片给线程，它就可以运行，这不同于死亡或阻塞状态</li>
<li>阻塞（Blocked）:线程能够运行，但有某个条件阻止它的运行，当线程处于阻塞状态时，调度器将忽略线程，不会分配线程任何CPU时间，直到线程重新进入就绪状态，它才有可能执行操作</li>
<li>死亡（Dead）：处于死亡或终止状态的线程将不再是可调度的，并且再也不会得到CPU时间，它的任务已经结束，或不再是可运行的，任务死亡的通常方式是从run()返回，但是任务的线程还可以被中断<h4 id="进入阻塞状态"><a href="#进入阻塞状态" class="headerlink" title="进入阻塞状态"></a>进入阻塞状态</h4>一个任务进入阻塞状态，可能有如下原因：</li>
<li>通过调用sleep(milliseconds)使任务进入休眠状态，在这这种情况下，任务在指定的时间内不会运行</li>
<li>你通过调用wait()是线程挂起，直到线程得到notify()或者notifyAll()消息（或者在java SE5的java.util.concurent类库中等价的signal()或signalAll()消息），线程才会进入就绪状态</li>
<li>任务在等待某个输入/输出完成</li>
<li>任务试图在某个对象上调用其同步控制方法，但是对象锁不可用，因为另一个任务已经获取了这个锁<br>在较早的代码中可能会看到suspend()和resume()来阻塞和唤醒线程，但是在现代java中这些方法已经 被废止了（因为可能导致死锁），所以不再讨论，stop()方法也废止了，不需要去研究<br>我们来看看我们的问题：有时你希望能够终止处于阻塞状态的任务。如果对于处于阻塞状态的任务，你不能等待其达到代码中可以检查其状态值这一点，因而决定让他主动地终止，那么你就必须强制这个任务跳出阻塞状态</li>
</ol>
<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>正如你所想象的，在Runnable.run()的方法内部打断它，与等待该方法到达对cancel标志（之前的示例）的测试，或者到达程序员准备好离开该方法的其他地方相比，要棘手一些，当你打断被阻塞的任务时，可能需要清理资源，正因为这一点，在任务的run()方法中间打断，更像是抛出的异常，因此在java线程的这种类型的异常中断中用到异常（这是为什么我们在调用一些使得线程阻塞的方法时总是要捕获异常，以防止线程会在阻塞状态期间被打断之后进行后续资源的清理工作），为了以这种方式终止任务，返回众所周知的良好状态，你必须仔细考虑代码的执行路径，并仔细编写catch子句以争取清除所有事物<br><strong>Thread类包含interrupt()方法，因此你可以终止被阻塞的任务，这个方法将设置线程的中断状态，如果一个线程已经被阻塞，或者试图执行一个阻塞操作，那么设置这个线程的中断状态将抛出InterruptedException</strong>（这里也就明白了，异常并不一定要在阻塞那里被抛出，当已经处于阻塞状态时，中断任务（调用Thread类的interrupt()），会创建异常对象，这些异常对象除了异常信息外，其实虚拟机还初始化了很多关于这个异常的信息，这个异常对象会被包好它的类的异常处理器所捕获到，注意，我们编写的catch语句其实就是在给这个类创建异常处理器而已，剩下的事情编译器会帮我们做），<strong>当抛出异常或者该任务调用Thread.interrupted()时，中断状态将被复位</strong>。正如将会看到的，Thread.interrupted()提供了离开run()循环而不抛出异常的第二种方式<br>为了调用Thread.interrupt()，你必须持有Thread对象，但是新的concurrent类库似乎在避免多Thread对象的直接操作，转而尽量通过Executor来执行所有操作，如果你在Excutor上调用shutdownNow(),那么它将发送一个interrupt()调用给它启动的所有线程，这么做是有意义的，因为当你完成工程中的某一个部分或者整个程序时，通常会希望同时关闭某个特定Executor的所有任务，然而，你有时也希望只中断某个单一任务，如果使用Executor，那么通过调用submit()而不是execute()来启动任务，就可以持有该任务的上下文，summit将返回一个泛型Future&lt;?&gt;,其中有一个为修饰的参数，因此你永远都不会在其上调用get()——持有这个Future的关键是在于你可以在其上调用cancel()，并因此可以使用它来中断某个特定任务，如果你将true传递给cancel()，那么它就会拥有在该线程上调用interrupt()以停止这个线程的权限，因此，cancel()是一种中断由Executor启动的单个线程的方式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.sql.Time;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="comment">//休眠状态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SleepBlocked</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"InterruptedException"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Exiting SleepBlocked.run()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//I/O阻塞</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IOBlocked</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> InputStream in;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IOBlocked</span><span class="params">(InputStream is)</span></span>&#123;in=is;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Waiting for Read():"</span>);</span><br><span class="line">            in.read();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                System.out.println(<span class="string">"Interrupted from blocked I/O"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Exiting IOBlocked.run()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同步阻塞</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SynchronizedBlocked</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;<span class="comment">//never release lock</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SynchronizedBlocked</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;<span class="comment">//匿名线程获得对象锁</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                f();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"trying to call f()"</span>);</span><br><span class="line">        f();</span><br><span class="line">        System.out.println(<span class="string">"Exiting SynchronizedBlocked.run()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interrupting</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Runnable r)</span><span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        Future&lt;?&gt; f=exec.submit(r);</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">"Interrupting"</span>+r.getClass().getName());</span><br><span class="line">        f.cancel(<span class="keyword">true</span>);<span class="comment">//interrupts if running</span></span><br><span class="line">        System.out.println(<span class="string">"Interrupt sent to "</span>+r.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        test(<span class="keyword">new</span> SleepBlocked());</span><br><span class="line">        test(<span class="keyword">new</span> IOBlocked(System.in));</span><br><span class="line">        test(<span class="keyword">new</span> SynchronizedBlocked());</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">"Aborting with System exit(0)"</span>);</span><br><span class="line">        System.exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的每个任务表示了三种不同类型的阻塞，这个程序证明I/O和在synchronized块上的等待是不可中断的，但是浏览代码，可以发现——无论是I/O还是尝试调用synchronzied,都是不需要任何InterruptedException处理器<br>上面的代码有一些注意的，前两个代码很简单，但是为了演示SynchronizedBlocked,我们在任务构造器中创建一个匿名的线程调用f()获得对象锁（这个线程必须区别于为SynchronizedBlocked驱动run()的线程，因为同一个线程可以多次获得某个对象的锁）<br><strong>从输出中可以看到，你能够中断对sleep()的调用（或者任何要求抛出InterruptedException的调用），但是你不能中断正在尝试获得synchronized锁或者试图执行I/O操作的线程</strong>，这一点令人烦恼，特别是在创建执行I/O的任务时，因为这意外这I/O具有锁住你的多线程程序的可能，特别是在基于Web的程序，这更是关乎利害<br>对于这类问题，有一个略显笨拙但确实行之有效的解决方案，即关闭任务在其上发生阻塞的底层资源<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloseResource</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        ServerSocket server=<span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</span><br><span class="line">        InputStream socketInput=<span class="keyword">new</span> Socket(<span class="string">"localhost"</span>,<span class="number">8080</span>).getInputStream();</span><br><span class="line">        exec.execute(<span class="keyword">new</span> IOBlocked(socketInput));</span><br><span class="line">        exec.execute(<span class="keyword">new</span> IOBlocked(System.in));</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">"Shutting down all thread"</span>);</span><br><span class="line">        exec.shutdownNow();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"Closing"</span>+socketInput.getClass().getName());</span><br><span class="line">        socketInput.close();<span class="comment">//Releases blocked thread</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"Colsing"</span>+System.in.getClass().getName());</span><br><span class="line">        System.in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>运行上面程序，可以得知，在shutdownNow()被调用之后已经在两个输入流上调用close()之前的延迟强调的是：一旦底层资源被关闭任务将被解除阻塞</strong><br><strong>幸运的是，java SE5新添加的各种nio类提供了更加人性化的I/O中断，被阻塞的nio通道会自动地相应中断</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousCloseException;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ClosedByInterruptException;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.ServerCloneException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NIOBlocked</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SocketChannel sc;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NIOBlocked</span><span class="params">(SocketChannel sc)</span></span>&#123;<span class="keyword">this</span>.sc=sc;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Writing for read() in "</span>+<span class="keyword">this</span>);</span><br><span class="line">            sc.read(ByteBuffer.allocate(<span class="number">1</span>));</span><br><span class="line">        &#125;<span class="keyword">catch</span>(ClosedByInterruptException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"closedByInterruptException"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (AsynchronousCloseException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"AsynchronousCloseException"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Exiting NIOBlocked.run()"</span>+<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOinterruption</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        ServerSocket server=<span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</span><br><span class="line">        InetSocketAddress isa=<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>,<span class="number">8080</span>);</span><br><span class="line">        SocketChannel sc1=SocketChannel.open(isa);</span><br><span class="line">        SocketChannel sc2=SocketChannel.open(isa);</span><br><span class="line">        Future&lt;?&gt; f=exec.submit(<span class="keyword">new</span> NIOBlocked(sc1));</span><br><span class="line">        exec.execute(<span class="keyword">new</span> NIOBlocked(sc2));</span><br><span class="line">        exec.shutdown();<span class="comment">//无法关闭I/O阻塞的线程</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//produce an interrupt via cancel</span></span><br><span class="line">        f.cancel(<span class="keyword">true</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//release the block by closing the channel</span></span><br><span class="line">        sc2.close();<span class="comment">//你也可以通过关闭底层资源释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="被互斥所阻塞"><a href="#被互斥所阻塞" class="headerlink" title="被互斥所阻塞"></a>被互斥所阻塞</h4><p><strong>就像之前在不可中断的I/O中所观察的那样，无论在任何时候，只要任务以不可中断的方式被阻塞了，那么都有潜在的会锁住程序的可能</strong><br>java SE5并发类库中添加了一个特性，即在ReentrantLock上阻塞的任务具备可以被中断的能力，这与在synchronized方法或者临界区上阻塞的任务完全不同<br>与I/O调用不同，interrupt()可以打断被互斥所阻塞的调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockedMutex</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlockedMutex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();<span class="comment">//总是持有锁不释放</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//this will never be available to a second task</span></span><br><span class="line">            lock.lockInterruptibly();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Interrupted form lock acquisition in f()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blocked2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    BlockedMutex blocked=<span class="keyword">new</span>  BlockedMutex();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"waiting for f() in BlockedMutex"</span>);</span><br><span class="line">        blocked.f();</span><br><span class="line">        System.out.println(<span class="string">"Broken out of blocked call"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interrupting2</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">      Thread t=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Blocked2());</span><br><span class="line">      t.start();</span><br><span class="line">       TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">       System.out.println(<span class="string">"Issuing t.interrupt"</span>);</span><br><span class="line">       t.interrupt();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="检查中断"><a href="#检查中断" class="headerlink" title="检查中断"></a>检查中断</h3><p>注意，当你在线程上调用interrupt()时，中断发生的唯一时刻是在任务要进入到阻塞操作中或或者以及在阻塞操作内部时（如你所见，除了不可中断的I/O或被阻塞的synchronized方法之外，在其余的例外情况下，你无事可做）但是如果根据程序运行的环境，你已经编写了可能会产生这种阻塞调用的代码，那又该怎么办？<strong>如果你只能通过在阻塞调用上抛出异常来退出，那么你就无法总是可以离开run()循环，因此如果你调用interrupt()以停止某个任务，那么在run()循环碰巧没有产生任何阻塞调用的情况下，你的任务将需要第二种方式来退出</strong><br>这种集合是由中断检查来表示的，其状态可以通过调用interrupt()来设置，你可以通过调用interrupted()来检查中断状态，这不仅可以告诉你interrupt()是否调用过，而且还可以清除中断状态，清除中断状态可以确保并发结构不会就某个任务被中断这个问题通知你两次，你可以经由单一的InterruptedException或单一的成功的Thread.interrupted()测试来得到这种通知，如果想要再次检查以了解是否中断，则可以在调用Thread.interrupted()时将结果存储起来<br>下面的示例展示了典型的惯用法，你应该在run()方法中使用它来处理在中断状态被设置时，被阻塞和不被阻塞的各种可能性<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NeedsCleanUp</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NeedsCleanUp</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id=id;</span><br><span class="line">        System.out.println(<span class="string">"NeedsCleanUp"</span>+id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Cleaning up"</span>+id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blocked3</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">double</span> d=<span class="number">0.0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">           <span class="keyword">while</span>(!Thread.interrupted())&#123;</span><br><span class="line">               <span class="comment">//point1</span></span><br><span class="line">             NeedsCleanUp n1=<span class="keyword">new</span> NeedsCleanUp(<span class="number">1</span>);</span><br><span class="line">             <span class="comment">//start try-finally immediately after definition</span></span><br><span class="line">               <span class="comment">//of n1.to guarantee proper cleanup of it</span></span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 System.out.println(<span class="string">"Sleeping"</span>);</span><br><span class="line">                 TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                 <span class="comment">//point2</span></span><br><span class="line">                 NeedsCleanUp n2 = <span class="keyword">new</span> NeedsCleanUp(<span class="number">2</span>);</span><br><span class="line">                 <span class="keyword">try</span> &#123;</span><br><span class="line">                     System.out.println(<span class="string">"Calculating"</span>);</span><br><span class="line">                     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200000</span>; i++) &#123;</span><br><span class="line">                         d = d + (Math.PI + Math.E) / d;</span><br><span class="line">                     &#125;</span><br><span class="line">                     System.out.println(<span class="string">"Finished time-consuming operation"</span>);</span><br><span class="line">                 &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                     n2.cleanUp();</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                 n1.cleanUp();</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;</span><br><span class="line">            System.out.println(<span class="string">"Exiting via while() test"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">           System.out.println(<span class="string">"Exiting via InterruptedException"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptingIdiom</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args.length!=<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"usage java InterruptingIdiom delay-in-ms "</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread t=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Blocked3());</span><br><span class="line">        t.start();</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="keyword">new</span> Integer(args[<span class="number">0</span>]));</span><br><span class="line">        t.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码是个很好的例子，比较晦涩难懂的是太多的嵌套比如，while try-catch try-finally,这些嵌套代码搅在一起就会让人比较头疼，但是如果有技巧的分析，这些代码还是比较简单的，我们先看下run()方法最外层的try-catch，我们之前讲过，一般任务的run()方法都提供了某种循环，这种循环，一般来说，提供了离开循环的方式，一种方式很简单，就是通过条件判断离开循环，在while(！Thread.interrupted())看到，如果在线程从新开始的未知继续执行循环的时候，Thread.interrupted返回为true，即！Thread.interrupted返回为false,条件不满足，则不进入循环内部，继续执行while后接下来的程序，任务结束，另一种是在while执行内部抛出异常被异常处理器捕获，这是可以直接通过异常处理程序使任务结束，所以第一个try-catch和while就能够理解了，我们再来看看里面的两个双层嵌套的try-finally，这些代码表明的意思是，无论怎样都要执行，无论是程序的正常执行还是在try中抛出异常，所以我们的做法是，在需要清理工作的对象创建之后后面紧跟着try-finaly，如程序的执行不抛出异常，那么finally会执行，如果在try块中，因为阻塞发生的中断异常，此时也会得到相应的处理<br>我们通过这种分析方法来看上面的代码，你必须给程序提供一个命令行参数，来表示在它调用interrupt()之前以毫秒为单位的延迟时间，通过使用不同的延迟，你可以确保在不同的地点退出Blocked3.run(),在阻塞的sleep()调用中，或者在非阻塞的数学计算中，你将会看到，如果interrupt()在注释的point2之后（即在非阻塞的操作过程中被）被调用，那么首先循环将结束，然后所有的对象将被销毁，最后循环会经由while()句的顶部退出，但是，如果interrupt()是在point1和point2之间（在while语句之后，但是在阻塞操作sleep()之前或者过程中）被调用，那么这个任务就会在第一次尝试调用阻塞操作之前，经由InterruptedException退出，而你也有了在catch子句执行其他任何清除工作的机会<br><strong>被设计用来相应interrupt()的类必须建立一种策略，来确保它将保持一致的状态，这通常意味着所有需要清理的对象创建操作的后面，都必须紧跟着try-finnaly子句，从而使得无论run()循环如何退出，清理都会发生</strong></p>
<h2 id="线程之间的协作"><a href="#线程之间的协作" class="headerlink" title="线程之间的协作"></a>线程之间的协作</h2><p>当你使用线程来同时运行多个任务时，可以通过使用锁（互斥）来同步两个任务的行为，从而使得一个任务不会去干涉另一个任务的资源，也就是说，如果两个任务交替着步入某项共享资源（通常是内存），你可以使用互斥使得任何时刻只有一个任务可以访问这个资源<br>这个问题以及解决了，下一步是学习如何使任务之间可以协作，以使得多个任务一起工作去，解决某个问题，现在的问题不是彼此之间干涉，而是彼此之间协作，因为在这类问题中，某些部分必须在其他部分被解决之前解决<br>当任务协作是，关键问题是这些任务之间的握手，为了实现这种握手，我们使用了相同的基础特性：互斥，在这种情况下，互斥能确保一个任务可以响应某个信号，这样就可以根除任何可能的竞争条件，<strong>在互斥之上，我们为任务添加了一种途径，可以将自身挂起，直到某些外部条件发生变化 ，表示是时候让这个任务向前开动为止</strong>，这种握手可以通过Object的方法wait()和notify()来安全地实现，，java SE5的并发类库还提供了具有await()和signal()方法的Condition对象，我们将看到产生的各种问题，以及相应的解决方案</p>
<h3 id="wait-和notifyAll"><a href="#wait-和notifyAll" class="headerlink" title="wait()和notifyAll()"></a>wait()和notifyAll()</h3><p>wait()是你可以等待某个条件的改变，而改变这个条件超出了当前方法的控制能力，通常，这种条件将由另一个任务来改变，你肯定不想在你的任务测试这个条件的同时，不断地进行空循环，这被称为“忙等待”，通常是一种不良的CPU调用使用方式，因此wait()会在等待外部时间产生变化的时候将任务挂起，并且只有notify()或者notifyAll()发生时，即表示发生了某些感兴趣的事物，这个任务才会被唤醒并检查所产生的变化，因此，wait()提供了一种在任务之间对活动同步的方式<br><strong>调用sleep()的时候锁并没有被释放，调用yield()也属于这种情况，理解这一点很重要，另一方面，当一个任务在方法里遇到了对wait()的调用的时候，线程的执行将被释放，对象上的锁被释放</strong>因为wait()将释放锁，这就意味着另一个任务可以获得这个锁，因此在该对象（现在是未锁定的）中的其他synchronzed方法可以在wait()期间被调用，这一点直观重要，因为这些其他的方法通常会产生改变，而这种改变正是使得被挂起的任务重新唤醒所感兴趣的变化，<strong>因此，当你调用wait()时，就是在声明：“我已经刚刚做完能做的事情，因此我要在这里等待，但是，我希望其他的synchronized操作在条件合适的情况下能够执行”</strong><br>有两种形式的wait()<br>一种版本接受毫秒数作为参数，含义与与sleep()方法里参数的意思相似，都是指：“在此期间暂停”，但是与sleep()不同的是，对于wait()而已：</p>
<ol>
<li>wait()期间锁是释放的</li>
<li>可以通过notify()，notifyAll()，或者时间到期，从wait()中恢复执行<br>第二种，也是更常用的版本的wait()不接受任何参数，这种wait()将无限等待下去，直到线程的notify()和notifyAll()的消息<br><strong>wait(),notify(),notifyAll()有个比较特使的方面，那就是这些方法都是基类Object的一部分，而不是Thread的一部分</strong>，这看起来有点奇怪，不过这是有道理的，因为这些方法操作的锁也是对象的一部分，所以，你可以把wait()放在任何同步控制方法里，而不用考虑这些类是继承自Thread还是实现了Runnable，实际上，只能在同步控制方法或同步控制块里调用wait()，notify()和notifyAll()（因为不用操作锁，所以sleep()可以在非同步控制方法里调用），如果在非同步控制方法里调用这些方法，程序能通过编译，但运行的时候，将得到IllegalMonitorStateException异常，并伴随着一些含糊的信息，比如“当前线程不是拥有者”    ，消息的意思是：调用wait()，notify()和notifyAll()的任务在调用这些方法之前必须“拥有”（获取）对象的锁<br>可以让另一个对象执行某种操作以维护其自己的锁，要这么做的话，必须首先得到对象的锁，比如，如果向对象x发送notifyAll(),那么就必须在能够取得x的锁的同步控制块中这么做（我猜测在x对象的内部应该有维持一个挂起的线程列表）<br> synchronized(x){获得对象x的锁<pre><code>x.notifyAll();x对象调用notifyAll()
</code></pre> }<br>下面一个仿真的例子，关于汽车打蜡抛光的案例，抛光任务在涂蜡完成之前，是不能执行的，而涂蜡任务在涂另一层蜡之前必须等待抛光任务完成<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> waxOn=<span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span>  <span class="keyword">void</span> <span class="title">waxed</span><span class="params">()</span></span>&#123;<span class="comment">//打蜡</span></span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        waxOn=<span class="keyword">true</span>;<span class="comment">//ready to buff</span></span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">buffed</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        waxOn=<span class="keyword">false</span>;<span class="comment">//ready for another coat of wax</span></span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">waitingForBuffing</span><span class="params">()</span><span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!waxOn)&#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">waitingForWaxing</span><span class="params">()</span><span class="keyword">throws</span>  InterruptedException</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(waxOn)&#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaxOn</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Car car;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WaxOn</span><span class="params">(Car car)</span></span>&#123;<span class="keyword">this</span>.car=car;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!Thread.interrupted())&#123;</span><br><span class="line">                System.out.println(<span class="string">"Wax On!"</span>);</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">                car.waxed();<span class="comment">//改变条件，如果在访问这个对象上方法时被挂起的线程，则唤醒它</span></span><br><span class="line">                car.waitingForBuffing();<span class="comment">//等待条件改变，挂起并在这里释放锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Exiting via interrupt"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"ending wax on task"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaxOff</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Car car;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WaxOff</span><span class="params">(Car car)</span></span>&#123; <span class="keyword">this</span>.car=car;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                car.waitingForWaxing();<span class="comment">//如果条件改变则执行接下来的操作，如果没有，挂起释放锁等待其他线程改变并唤醒我</span></span><br><span class="line">                System.out.println(<span class="string">"wax off"</span>);</span><br><span class="line">                TimeUnit.MICROSECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">                car.buffed();<span class="comment">//任务结束，改变状态唤醒其他挂起的线程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Exiting via interrupt"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Ending wax of task"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaxOnMatic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Car car=<span class="keyword">new</span> Car();</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        exec.execute(<span class="keyword">new</span> WaxOn(car));</span><br><span class="line">        exec.execute(<span class="keyword">new</span> WaxOn(car));</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        exec.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这里，Car有一个单一的布尔属性waxOn,表示涂蜡-抛光处理的状态<br>在waitForWaxing()中将建厂waxOn标志，如果它为false,那么这个任务调用将通过调用wait()而被挂起，这个行为发生在synchronized方法中这一点很重要，因为i在这样的方法中，任务以及获取了锁，当你调用wait()时，<strong>线程被挂起，而锁被释放，锁被释放这一点是本质所在</strong>，因为为了安全地改变对象的状态，其他某个任务就必须能够获得这个锁，其他任务改变状态标志并且唤醒被挂起的任务，为了是该任务从wait()中唤醒，它必须重新获得当它进入wait()时释放的锁，在这个锁变得可用之前，这个任务是不会被唤醒的<br>前面的示例强调你必须用一个检查感兴趣的条件的while循环包围wait()，这很重要，放在while循环中的意思是，当你（任务）被唤醒的时候，我希望你再此进行判断要不要重新进入等待状态<br>因为：//这个我还没想清楚，以后再讨论</p>
<h4 id="错失的信号"><a href="#错失的信号" class="headerlink" title="错失的信号"></a>错失的信号</h4><p>当两个线程使用notify()/wait()或notifyAll()/wait()进行协作的时候，有可能会错过某个信号，假设T1是通知T2的线程，而这连个线都是使用下面（有缺陷的）方式实现的<br>      T1:<br>      synchronized(shareMonitor){<br>         <setup condition="" for="" t2=""><br>         shareMonitor.notify();<br>      }</setup></p>
<pre><code>T2:
while(someCondition){//没有将someCondition同步
    //point1
    synchronized(sharaMonitor){
       shareMonitor.wait();
    }
}
</code></pre><p><setup condition="" for="" t2="">是防止T2调用wait()的一个动作，当然前提是T2还没有调用wait()<br>假设T2对someCondition求值发现其为true,在Point1,线程调度器可能切换到了T1,而T1将执行其设置，然后调用notify(),当T2得以继续执行时，此时对于T2来说，时机已经太晚了，以至于不能意识到这个条件已经发生了变化，因此会盲目地进入wait(),此时notify()将错失，而T2也就无限地等待这个以及发送过的信号，从而产生死锁<br><strong>该问题的解决方法是防止在someCondition变量上产生竞争性</strong>，下面是T2正确的执行方式<br>     synchronized(sharedMonitor){<br>       while(somecondition){<br>            sharedMonitor.wait();<br>       }<br>     }<br>现在,如果T1首先执行，但控制返回T2时，它将发现条件发生了变化，从而不会进入wait()，反过来，如果T2首先执行，那它将进入wait()，并且稍后会由T1唤醒，因此，信号不会丢失</setup></p>
<h3 id="notify-和notifyAll"><a href="#notify-和notifyAll" class="headerlink" title="notify()和notifyAll()"></a>notify()和notifyAll()</h3><p>因为在技术上，可能会有多个任务在单个Car对象上处于wait（）状态，因此调用notifyAll()比只调用notify()更安全<br>使用notify()而不是notifyAll()是一种优化，使用notify()时，在众多等待同一个锁的任务中只有一个会被唤醒，因此如果你希望notify(),就必须保证被唤醒的是恰当的任务，另外为了使用notify()，所有的任务必须等待相同的条件，因为如果你有多个任务等待不同的条件，那么你就不会知道是否唤醒了恰当的任务，如果使用notify()，当条件发生时，必须有一个任务能够从中收益，最后，这些限制对所有可能崔你在的子类都必须总是起作用，如果这些规则中有任何一条不满足，那么你就必须使用notifyAll()而不是notify()<br>有关java的线程机制的讨论中，有一个令人困惑的描述：notifyAll将唤醒“所有正在等待的任务”，这是否意味着在程序中任何地方，任何处于wait()状态中的任务都将被任何对notifyAll()的调用唤醒呢？是不是如此——事实上是，当notifyAll()因某个特定锁而被调用是，值有等待这个锁的任务才会被唤醒<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javafx.concurrent.Task;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Time;</span><br><span class="line"><span class="keyword">import</span> java.util.Timer;</span><br><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blocker</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">waitingCall</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">           <span class="keyword">while</span>(!Thread.interrupted())&#123;</span><br><span class="line">               wait();</span><br><span class="line">               System.out.println(Thread.currentThread()+<span class="string">" "</span>);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            <span class="comment">//Ok to exit this way</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span>  <span class="keyword">void</span> <span class="title">prod</span><span class="params">()</span></span>&#123;notify();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">prodAll</span><span class="params">()</span></span>&#123;notifyAll();&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Blocker blocker=<span class="keyword">new</span> Blocker();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        blocker.waitingCall();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Blocker blocker=<span class="keyword">new</span> Blocker();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        blocker.waitingCall();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotifyVsNotifyAll</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">      ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">          exec.execute(<span class="keyword">new</span> Task1());</span><br><span class="line">      &#125;</span><br><span class="line">      exec.execute(<span class="keyword">new</span> Task2());</span><br><span class="line">      Timer timer=<span class="keyword">new</span> Timer();</span><br><span class="line">      timer.scheduleAtFixedRate(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">          <span class="keyword">boolean</span> prod=<span class="keyword">true</span>;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">if</span>(prod)&#123;</span><br><span class="line">                  System.out.println(<span class="string">"notify()"</span>);</span><br><span class="line">                  Task1.blocker.prod();</span><br><span class="line">                  prod=<span class="keyword">false</span>;</span><br><span class="line">              &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                  System.out.println(<span class="string">"notifyAll()"</span>);</span><br><span class="line">                  Task1.blocker.prodAll();</span><br><span class="line">                  prod=<span class="keyword">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;,<span class="number">400</span>,<span class="number">400</span>);</span><br><span class="line">      TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">      timer.cancel();</span><br><span class="line">      System.out.println(<span class="string">"\n Timer canceled"</span>);</span><br><span class="line">      TimeUnit.MICROSECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">      System.out.println(<span class="string">"Task2.blocker.prodAll"</span>);</span><br><span class="line">      Task2.blocker.prodAll();</span><br><span class="line">      TimeUnit.MICROSECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">      System.out.println(<span class="string">"\nShutting down"</span>);</span><br><span class="line">      exec.shutdownNow();<span class="comment">//interrupt all task</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的例子很简单，Task1和Task2每个都有自己的Blocker对象，因此每个Task1对象都会在Task.blocker上阻塞，而每个Task2都会在Task2.blocker上阻塞,在main()方法中，java.util.Timer对象被设置为每4/10秒交替地Task1.blocker上调用notify()和notifyAll()<br>从输出中可以看到，即使存在，Task2.blocler上阻塞的Task2对象，也没有任何在task1.blocker上的notify()和notifyAll()将其唤醒，与此类似，在main的结尾调用了timer的cancel()，即使计时器被撤销了，前五个任务也依然在运行，并仍旧在它们的阻塞状态，对Task2.blocler.prodAll()的调用所产生的输出不包括任何在Task1.blocker中的锁上等待的任务</p>
<h3 id="生产者与消费者"><a href="#生产者与消费者" class="headerlink" title="生产者与消费者"></a>生产者与消费者</h3><p>考虑饭店的厨师和服务员，厨师做好菜通知服务员，服务员上菜，然后返回继续等待，这是一个线程协作的示例，厨师代表生产者，而服务员代表消费者，两个任务必须在膳食被生产和消费时进行握手，而系统即必须以有序的方式关闭，下面是对这个描述建模的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meal</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> orderNum;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Meal</span><span class="params">(<span class="keyword">int</span> orderNum)</span></span>&#123;<span class="keyword">this</span>.orderNum=orderNum;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">"meal  "</span>+orderNum;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaitPerson</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Restaurant restaurant;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WaitPerson</span><span class="params">(Restaurant r)</span></span>&#123;restaurant=r;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (restaurant.meal == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        wait();<span class="comment">//for the chef to produce a meal</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"waitperson got"</span>+restaurant.meal);</span><br><span class="line">                <span class="keyword">synchronized</span> (restaurant.chef)&#123;通过restaurant.chef调用notifyAll()</span><br><span class="line">                    restaurant.meal=<span class="keyword">null</span>;</span><br><span class="line">                    restaurant.chef.notifyAll();<span class="comment">//ready for another</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"WaitPerson interrupted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chef</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Restaurant restaurant;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chef</span><span class="params">(Restaurant r)</span></span>&#123;restaurant=r;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (restaurant.meal != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        wait();<span class="comment">//for the meal to be taken</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (++count == <span class="number">10</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"out of food closing"</span>);</span><br><span class="line">                    restaurant.exec.shutdownNow();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"order up!"</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (restaurant.waitPerson)&#123;<span class="comment">//唤醒在waitPerson上挂起的任务</span></span><br><span class="line">                    restaurant.meal=<span class="keyword">new</span> Meal(count);</span><br><span class="line">                    restaurant.waitPerson.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"chef interrupted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Restaurant</span> </span>&#123;</span><br><span class="line">    Meal meal;</span><br><span class="line">    ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">    WaitPerson waitPerson=<span class="keyword">new</span> WaitPerson(<span class="keyword">this</span>);</span><br><span class="line">    Chef chef=<span class="keyword">new</span> Chef(<span class="keyword">this</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Restaurant</span><span class="params">()</span></span>&#123;</span><br><span class="line">        exec.execute(chef);</span><br><span class="line">        exec.execute(waitPerson);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Restaurant();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的例子很简单，<strong>Restaurant是两个任务类的焦点</strong>,而不是Meal,Meal只是一个条件标志，也是生成者与消费者之间的产物，在这个简单的例子中，我们知道只有一个任务在WaitPerson的锁上等待，即WaitPerson任务本身，理论上来讲可以调用notify()而不是notifyAll(),但是在更复杂的环境下，多个任务在某个特定对象上等待，因此你不必知道那个任务应该被唤醒，因此，<strong>调用notifyAll()要更安全一点，这样可以唤醒等待这个锁的所有任务，而这个任务都必须决定这个通知是不是与自己相关</strong><br>注意，wait()被包装在一个while()语句中，这个语句在不断地测试正在等待的事物，乍看上去这有点怪——如果在等待一个订单，一旦你被唤醒，这个订单就必定是可获得的，对吗？正如前面注意到的，<strong>问题在并发应用中，某个其他的任务可能会在WaitPerson被唤醒时，会突然插足并拿走订单，唯一安全的方式是使用下面这种wait()的惯用法（当然要在恰当的同步内部，并采取防止错误信号可能性的程序设计）</strong><br>    while(conditionIsNotMe){<br>       wait()<br>    }<br><strong>这样可以保证在你退出等待循环之前，条件将得到满足，并且如果你收到关于某事物的通知，而它与这个条件并无关联（就像在notifyAll()时可能发生的一样），或者在你完全退出等待循环之前，这个条件发生了变化，都可以保证你重返等待状态</strong><br>请注意观察，对notifyAll()的调用必须首先捕获waitPerson上的锁，而在WaitPerson.run()中的对wait(）的调用将会自动释放这个锁，因此这是有可能实现的，<strong>因为调用notifyAll()必然拥有这个锁，所以这可以保证两个试图在同一个对象上调用notifyAll()的任务是不会冲突的</strong><br>注意，在Chef中，在调用shutdownNow()之后，你应该直接从run()返回，并且通常这就是你应该做的，但是，这种方式指向还有一些更有趣的东西，记住，shutdownNow（）将向所有由ExceptionService启动的任务发生interrupt()，但是在Chef()中，任务并没有在获得该interruption之后立即关闭，因为当任务试图进入一个（可中断的）阻塞操作时，这个中断只能抛出InterruptedException，因此，你将看到首先显示了“Order up”，然后当Chef试图调用sleep()时，抛出InterruptionException,如果移除对sleep()的调用，那么这个任务将会回到run()循环的顶部，并由于Thread.Interruted()的测试二退出，同时并不抛出异常</p>
<h4 id="使用显式的Lock和Condition对象"><a href="#使用显式的Lock和Condition对象" class="headerlink" title="使用显式的Lock和Condition对象"></a>使用显式的Lock和Condition对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car2</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition=lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> waxOn=<span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">waxed</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            waxOn=<span class="keyword">true</span>;</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buffed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            waxOn=<span class="keyword">false</span>;</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">waitForWaxing</span><span class="params">()</span><span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(waxOn==<span class="keyword">false</span>)&#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">waitForBuffing</span><span class="params">()</span><span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(waxOn==<span class="keyword">true</span>)&#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaxOn2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Car car;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WaxOn2</span><span class="params">(Car car)</span></span>&#123; <span class="keyword">this</span>.car=car;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"wax on"</span>);</span><br><span class="line">                TimeUnit.MICROSECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">                car.waxed();</span><br><span class="line">                car.waitingForBuffing();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"exiting via Interrupted"</span>);<span class="comment">//两条路径终止任务</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"ending wax on task"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaxOff2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Car car;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WaxOff2</span><span class="params">(Car car)</span></span>&#123;<span class="keyword">this</span>.car=car;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                car.waitingForWaxing();</span><br><span class="line">                System.out.println(<span class="string">"Wax off"</span>);</span><br><span class="line">                TimeUnit.MICROSECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">                car.buffed();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Exiting wax off task"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"ending wax off task"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaxOMatic2</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">       Car car=<span class="keyword">new</span> Car();</span><br><span class="line">       ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">       exec.execute(<span class="keyword">new</span> WaxOn2(car));</span><br><span class="line">       exec.execute(<span class="keyword">new</span> WaxOff2(car));</span><br><span class="line">       TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">       exec.shutdownNow();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="生产者与消费者队列"><a href="#生产者与消费者队列" class="headerlink" title="生产者与消费者队列"></a>生产者与消费者队列</h3><p>wait()和notifyAll()方法以一种非常低级的方式解决六鳌任务互操作的问题，但每次交互时都握手，在许多情况下，你可以瞄向更高的抽象级别，使用同步队列来解决任务协作问题，同步队列在任何时刻都只允许一个任务插入或移除元素，在java.util.concurrent.BlockingQuueue接口中提供了这个队列，这个接口有大量的标准实现，你通常可以使用LinkedBlockingQueue,它是一个无界队列，还可以使用ArrayBlockingQueue,它具有固定的尺寸，因此你可以在它被组设之前，向其中防止有限数量的元素<br>如果消费者任务试图从队列中获取对象，而该队列此时为空，那么这些队列还可以挂起消费者任务，并且当有更多的元素可用时恢复消费者任务，阻塞队列可以解决非常大量的问题，而其方式与wait()和notifyAll()相比，则简单可靠的多<br>下面是一个简单的测试，它将多个LiftOff对象的执行串行化了，消费者是LiftOffRunner，它将每个LiftOff对象从BlockingQueue中推出并直接运行，即，它通过显式地调用run()而使用自己的线程来与运行，而不是为每个任务启动一个新线程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.SynchronousQueue;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LiftOffRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;LiftOff&gt; rockets;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LiftOffRunner</span><span class="params">(BlockingQueue&lt;LiftOff&gt; queue)</span></span>&#123;rockets=queue;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(LiftOff lo)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            rockets.put(lo);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Interrupted during put"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                LiftOff rocket = rockets.take();</span><br><span class="line">                rocket.run();<span class="comment">//use this Thread</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"waking from take()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"exiting LiftOffRunner"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBlockingQueue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getKey</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in)).readLine();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getKey</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(message);</span><br><span class="line">        getKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String msg,BlockingQueue&lt;LiftOff&gt; queue)</span></span>&#123;</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">        LiftOffRunner runner=<span class="keyword">new</span> LiftOffRunner(queue);</span><br><span class="line">        Thread t=<span class="keyword">new</span> Thread(runner);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            runner.add(<span class="keyword">new</span> LiftOff(<span class="number">5</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        getKey(<span class="string">"peress 'enter' ("</span>+msg+<span class="string">")"</span>);</span><br><span class="line">        t.interrupt();</span><br><span class="line">        System.out.println(<span class="string">"finished"</span>+msg+<span class="string">"test"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        test(<span class="string">"LikedBlocking Queue"</span>,<span class="keyword">new</span> LinkedBlockingDeque&lt;LiftOff&gt;());<span class="comment">//unlimited size</span></span><br><span class="line">        test(<span class="string">"ArrayBlockingQueue"</span>,<span class="keyword">new</span> ArrayBlockingQueue&lt;LiftOff&gt;(<span class="number">3</span>));<span class="comment">//fixed size</span></span><br><span class="line">        test(<span class="string">"synchronousQueue"</span>,<span class="keyword">new</span> SynchronousQueue&lt;LiftOff&gt;());<span class="comment">//Size of 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>吐司BlockQueue<br>有一台机器具有三个任务，一个制作吐司，一个给吐司抹黄油，一个在抹过黄油的吐司上涂果酱，下面是这个示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Toast</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Status&#123;DRY,BUTTERED,JAMMED&#125;</span><br><span class="line">    <span class="keyword">private</span> Status status=Status.DRY;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Toast</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;<span class="keyword">this</span>.id=id;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buffer</span><span class="params">()</span></span>&#123;status=Status.BUTTERED;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jam</span><span class="params">()</span></span>&#123;status=Status.JAMMED;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Status <span class="title">getStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Toast"</span>+id+<span class="string">":  "</span>+status;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ToastQueue</span> <span class="keyword">extends</span> <span class="title">LinkedBlockingQueue</span>&lt;<span class="title">Toast</span>&gt;</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Toaster</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ToastQueue toastQueue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Random rand=<span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Toaster</span><span class="params">(ToastQueue queue)</span></span>&#123;toastQueue=queue;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                TimeUnit.MICROSECONDS.sleep(<span class="number">100</span> + rand.nextInt(<span class="number">500</span>));</span><br><span class="line">                Toast t = <span class="keyword">new</span> Toast(count++);</span><br><span class="line">                System.out.println(t);</span><br><span class="line">                toastQueue.put(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Toaster off"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Butterer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ToastQueue dryQueue,butteredQueue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Butterer</span><span class="params">(ToastQueue dry,ToastQueue buttered)</span></span>&#123;</span><br><span class="line">        dryQueue=dry;</span><br><span class="line">        butteredQueue=buttered;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                <span class="comment">//blocked until next piece of toast is available</span></span><br><span class="line">                Toast t = dryQueue.take();</span><br><span class="line">                t.buffer();</span><br><span class="line">                System.out.println(t);</span><br><span class="line">                butteredQueue.add(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Butterer interrupted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Butterer off"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jammer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ToastQueue butteredQueue,finishedQueue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Jammer</span><span class="params">(ToastQueue butter,ToastQueue finished)</span></span>&#123;</span><br><span class="line">        butteredQueue=butter;</span><br><span class="line">        finishedQueue=finished;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                <span class="comment">//blocked until piece of toast is available</span></span><br><span class="line">                Toast t = butteredQueue.take();</span><br><span class="line">                t.jam();</span><br><span class="line">                finishedQueue.put(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"jammer interrupted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"jammer off"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Eater</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ToastQueue finishedQueue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> counter=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Eater</span><span class="params">(ToastQueue finished)</span></span>&#123;</span><br><span class="line">        finishedQueue=finished;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                Toast t = finishedQueue.take();</span><br><span class="line">                <span class="keyword">if</span>(t.getId()!=counter++||t.getStatus()!=Toast.Status.JAMMED)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"&gt;&gt;&gt;&gt;Error:"</span>+t);</span><br><span class="line">                    System.exit(<span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"Chomp! "</span>+t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Eater interrupted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Eater off"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToastOMatic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ToastQueue dryQueue=<span class="keyword">new</span> ToastQueue(),</span><br><span class="line">                   butteredQueue=<span class="keyword">new</span> ToastQueue(),</span><br><span class="line">                   finishedQueue=<span class="keyword">new</span> ToastQueue();</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        exec.execute(<span class="keyword">new</span> Toaster(dryQueue));</span><br><span class="line">        exec.execute(<span class="keyword">new</span> Butterer(dryQueue,butteredQueue));</span><br><span class="line">        exec.execute(<span class="keyword">new</span> Jammer(butteredQueue,finishedQueue));</span><br><span class="line">        exec.execute(<span class="keyword">new</span> Eater(finishedQueue));</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        exec.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，这个示例中没有任何显式的同步（即使用Lock对象或synchronized关键字的同步），因为同步由队列（其内部是同步的）和系统的设计隐式地管理了——每片Toast在任何时刻都只由一个任务在操作，因为队列的阻塞，使得处理过程将被自动挂起和恢复，由BlockingQueue产生的简化十分明显，在使用显式的wait()和notifyAll()时存在的类和类之间的耦合被消除了，因为两个类都只和它的BlockingQueue通信</p>
<h3 id="任务间使用管道进行输入-输出"><a href="#任务间使用管道进行输入-输出" class="headerlink" title="任务间使用管道进行输入/输出"></a>任务间使用管道进行输入/输出</h3><p>通过输入/输出在线程间进行通信通常很有用，提供线程功能的类库以“管道”的形式对线程间的输入/输出提供了支持，它们在java输入/输出类库中的对应物就是PipedWriter类（允许任务向管道写）和PipedReader类（允许不同任务从同一个管道中读取），这个模型可以看成是“生产者-消费者”问题的变体，这里管道就是一个封装好的解决方案，管道基本上是一个阻塞队列，存在于多个引入BlockingQueue之前的java版本中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Toast</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Status&#123;DRY,BUTTERED,JAMMED&#125;</span><br><span class="line">    <span class="keyword">private</span> Status status=Status.DRY;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Toast</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;<span class="keyword">this</span>.id=id;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buffer</span><span class="params">()</span></span>&#123;status=Status.BUTTERED;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jam</span><span class="params">()</span></span>&#123;status=Status.JAMMED;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Status <span class="title">getStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Toast"</span>+id+<span class="string">":  "</span>+status;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ToastQueue</span> <span class="keyword">extends</span> <span class="title">LinkedBlockingQueue</span>&lt;<span class="title">Toast</span>&gt;</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Toaster</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ToastQueue toastQueue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Random rand=<span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Toaster</span><span class="params">(ToastQueue queue)</span></span>&#123;toastQueue=queue;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                TimeUnit.MICROSECONDS.sleep(<span class="number">100</span> + rand.nextInt(<span class="number">500</span>));</span><br><span class="line">                Toast t = <span class="keyword">new</span> Toast(count++);</span><br><span class="line">                System.out.println(t);</span><br><span class="line">                toastQueue.put(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Toaster off"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Butterer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ToastQueue dryQueue,butteredQueue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Butterer</span><span class="params">(ToastQueue dry,ToastQueue buttered)</span></span>&#123;</span><br><span class="line">        dryQueue=dry;</span><br><span class="line">        butteredQueue=buttered;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                <span class="comment">//blocked until next piece of toast is available</span></span><br><span class="line">                Toast t = dryQueue.take();</span><br><span class="line">                t.buffer();</span><br><span class="line">                System.out.println(t);</span><br><span class="line">                butteredQueue.add(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Butterer interrupted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Butterer off"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jammer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ToastQueue butteredQueue,finishedQueue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Jammer</span><span class="params">(ToastQueue butter,ToastQueue finished)</span></span>&#123;</span><br><span class="line">        butteredQueue=butter;</span><br><span class="line">        finishedQueue=finished;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                <span class="comment">//blocked until piece of toast is available</span></span><br><span class="line">                Toast t = butteredQueue.take();</span><br><span class="line">                t.jam();</span><br><span class="line">                finishedQueue.put(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"jammer interrupted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"jammer off"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Eater</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ToastQueue finishedQueue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> counter=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Eater</span><span class="params">(ToastQueue finished)</span></span>&#123;</span><br><span class="line">        finishedQueue=finished;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                Toast t = finishedQueue.take();</span><br><span class="line">                <span class="keyword">if</span>(t.getId()!=counter++||t.getStatus()!=Toast.Status.JAMMED)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"&gt;&gt;&gt;&gt;Error:"</span>+t);</span><br><span class="line">                    System.exit(<span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"Chomp! "</span>+t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Eater interrupted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Eater off"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToastOMatic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ToastQueue dryQueue=<span class="keyword">new</span> ToastQueue(),</span><br><span class="line">                   butteredQueue=<span class="keyword">new</span> ToastQueue(),</span><br><span class="line">                   finishedQueue=<span class="keyword">new</span> ToastQueue();</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        exec.execute(<span class="keyword">new</span> Toaster(dryQueue));</span><br><span class="line">        exec.execute(<span class="keyword">new</span> Butterer(dryQueue,butteredQueue));</span><br><span class="line">        exec.execute(<span class="keyword">new</span> Jammer(butteredQueue,finishedQueue));</span><br><span class="line">        exec.execute(<span class="keyword">new</span> Eater(finishedQueue));</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        exec.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Sender和Receiver代表了需要互相通信两个任务，Sender创建了一个PipedWriter，它是一个单独的对象，但是对于Receiver，PipedReader的建立必须在构造器中与一个PipedWriter相关联<br>在shutdownNow()被调用时，可以看到PipedReader与普通I/I之间最重要的差异——PipedReader是可中断的</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>一个对象可以有synchronized方法或其他形式的加锁机制来防止别的任务在互斥还没释放的时候就访问这个对象，任务可以出现阻塞状态，所以可能出现这样一种状态，一个任务等待另一个任务，而后者又等待别的人任务，这样一直下去，直到这个链条上的任务又等待第一个任务释放锁，这得到了任务之间互相等待的连续循环，没有哪个线程能够继续，这被称为死锁<br>一个可能产生死锁的程序是那些可能看起来工作良好，但是具有潜在的死锁危险，这时死锁可能发生，而事先没有任何征兆<br>我们看一个哲学家就餐的例子，哲学家将花部分时间思考，花部分时间就餐，当它们思考的时候不需要共享任何资源，但是当它们就餐时，将使用有限数量的餐具（筷子）<br>问题引入的难点是：作为有哲学家，它们很穷，所以它们只能买5根筷子（更一般地讲筷子和哲学家的数量相同），它们在桌子周围坐着，每个人中间放一根筷子，<strong>但一个哲学家要就餐的时候，这个哲学家必须同时得到左边和右边的筷子</strong>，如果一个哲学家左边或右边已经有人在使用筷子了，那么这个哲学家就必须等待，直到可得到必需的筷子<br>筷子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chopstick</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> taken=<span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">take</span><span class="params">()</span><span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(taken)&#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        taken=<span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span>  <span class="keyword">void</span> <span class="title">drop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        taken=<span class="keyword">false</span>;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>哲学家<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Philosopher</span> <span class="keyword">implements</span>  <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Chopstick left;</span><br><span class="line">    <span class="keyword">private</span> Chopstick right;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> ponderFactor;</span><br><span class="line">    <span class="keyword">private</span> Random rand=<span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Philosopher</span><span class="params">(Chopstick lefy,Chopstick right,<span class="keyword">int</span> id,<span class="keyword">int</span> ponder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left=left;</span><br><span class="line">        <span class="keyword">this</span>.right=right;</span><br><span class="line">        <span class="keyword">this</span>.id=id;</span><br><span class="line">        ponderFactor=ponder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span><span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ponderFactor==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        TimeUnit.MICROSECONDS.sleep(</span><br><span class="line">                rand.nextInt(ponderFactor*<span class="number">250</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">           <span class="keyword">while</span>(!Thread.interrupted())&#123;</span><br><span class="line">               System.out.println(<span class="keyword">this</span>+<span class="string">" "</span>+<span class="string">"thinking"</span>);</span><br><span class="line">               pause();</span><br><span class="line">               System.out.println(<span class="keyword">this</span>+<span class="string">"grabbing right"</span>);</span><br><span class="line">               right.take();</span><br><span class="line">               System.out.println(<span class="keyword">this</span>+<span class="string">"grabbing left"</span>);</span><br><span class="line">               left.take();</span><br><span class="line">               System.out.println(<span class="keyword">this</span>+<span class="string">" "</span>+<span class="string">"eating"</span>);</span><br><span class="line">               pause();</span><br><span class="line">               right.drop();</span><br><span class="line">               left.drop();</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>+<span class="string">" "</span>+<span class="string">"exiting via interrupt"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Philosopher"</span>+id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>产生死锁的程序<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.text.html.StyleSheet;</span><br><span class="line"><span class="keyword">import</span> java.sql.Time;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockingDiningPhilosophers</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ponder=<span class="number">5</span>;</span><br><span class="line">        <span class="keyword">if</span>(args.length&gt;<span class="number">0</span>)</span><br><span class="line">            ponder=Integer.getInteger(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> size=<span class="number">5</span>;</span><br><span class="line">        <span class="keyword">if</span>(args.length&gt;<span class="number">1</span>)</span><br><span class="line">            size=Integer.getInteger(args[<span class="number">1</span>]);</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        Chopstick[] chopsticks=<span class="keyword">new</span> Chopstick[size];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            chopsticks[i]=<span class="keyword">new</span> Chopstick();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> Philosopher(chopsticks[i],chopsticks[(i+i)/size],i,ponder));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(args.length==<span class="number">3</span>&amp;&amp; args[<span class="number">2</span>]==<span class="string">"timeout"</span>)&#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"print 'enter tp quit'"</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>你会发现如果Philosopher花在思考上的时间非常少，那么当它们想要就餐时，全都会在Chopstick上产生竞争，而死锁也就会更快地发生</strong><br>注意，ChopStick对象不需要内部标识符，它们是由数组chopsticks中的位置标识的，每一个Philospher构造器都会得到一个对左边和右边Chopstick对象的引用，注意下最后一个Philosopher右边的Chopstick是第一个Chopstick<br>如果Philosopher花费大量的时间去思考而不是进餐（使用非0的ponder,或者大量的Philosopher），那么他们请求共享资源（Chopstick）的可能性就会小很多，这样你就会确信该线程不会死锁，尽管它们并非如此<br><strong>要修正死锁的问题，你必须明白，当一下四个条件同时满足时，就会发生死锁</strong></p>
<ol>
<li>互斥条件，任务使用的资源中至少有一个是不能共享的，这里，一根Chopstick一次就只能被一个Philosopher使用</li>
<li>至少有一个任务它必须持有一个资源其正在等待获取一个当前被别的任务持有的资源。也就是说，要发生死锁，Philosopher必须拿着一根Chopstick并且等待另一根</li>
<li>资源不能被任务抢占，任务必须把资源释放当作普通事件。Philosopher们很有礼貌，他们不会从其他Philosopher那里抢筷子</li>
<li>必须有循环等待，这时，一个任务等待其他任务所持有的资源，后者又在等待另一个任务所持有的资源，这样一直下去，直到一个任务在等待第一个任务所持有的资源，使得大家都被锁住</li>
<li>要发生死锁的话，上面四个条件必须全部满足，所以要防止死锁的话，只需破坏其中一个即可，在程序中，防止死锁最容易的方法是破坏第4个条件，有这个条件的原因是，“每个人都拿着右边的筷子，并等待左边的筷子”，所以只需要最后一个Philosopher被初始化为先拿左边的筷子，后拿右边的筷子，就解决了死锁的问题，这只是解决方案之一，也可以破环其他的条件来防止死锁<br>破坏循环等待的解决办法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FixedDiningPhilosophers</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ponder=<span class="number">5</span>;</span><br><span class="line">        <span class="keyword">if</span>(args.length&gt;<span class="number">0</span>)</span><br><span class="line">            ponder=Integer.getInteger(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> size=<span class="number">5</span>;</span><br><span class="line">        <span class="keyword">if</span>(args.length&gt;<span class="number">1</span>)</span><br><span class="line">            size=Integer.getInteger(args[<span class="number">1</span>]);</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        Chopstick[] chopsticks=<span class="keyword">new</span> Chopstick[size];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            chopsticks[i]=<span class="keyword">new</span> Chopstick();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;(size-<span class="number">1</span>))&#123;</span><br><span class="line">                exec.execute(<span class="keyword">new</span> Philosopher(chopsticks[i],chopsticks[(i+<span class="number">1</span>)],i,ponder));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                exec.execute(<span class="keyword">new</span> Philosopher(chopsticks[<span class="number">0</span>],chopsticks[i],i,ponder));<span class="comment">//破环循环等待</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(args.length==<span class="number">3</span>&amp;&amp; args[<span class="number">2</span>]==<span class="string">"timeout"</span>)&#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"print 'enter tp quit'"</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="新类库中构件"><a href="#新类库中构件" class="headerlink" title="新类库中构件"></a>新类库中构件</h2><p>java SE5的java.util.concurent引入了大量设计用来解决并发问题的新类，学习使用它们将有助于编写出更简单而健壮的并发程序</p>
<h3 id="CountDownLatch-锁存器"><a href="#CountDownLatch-锁存器" class="headerlink" title="CountDownLatch(锁存器)"></a>CountDownLatch(锁存器)</h3><p>它被用来同步一个或多个任务，强制它们等待由其他任务执行的一组操作完成<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskPortion</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> counter=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id =counter++;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand =<span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch latch;</span><br><span class="line">    TaskPortion(CountDownLatch latch)&#123;</span><br><span class="line">        <span class="keyword">this</span>.latch=latch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">try</span>&#123;</span><br><span class="line">              doWork();</span><br><span class="line">              latch.countDown();</span><br><span class="line">          &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">          <span class="comment">//acceptable way to exit</span></span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span><span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        TimeUnit.MICROSECONDS.sleep(rand.nextInt(<span class="number">2000</span>));</span><br><span class="line">        System.out.println(<span class="string">"this completed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"%1$-3d"</span>,id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaitingTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> counter=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id=counter++;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch;</span><br><span class="line"></span><br><span class="line">    WaitingTask(CountDownLatch latch)&#123;</span><br><span class="line">        <span class="keyword">this</span>.latch=latch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            latch.await();</span><br><span class="line">            System.out.println(<span class="string">"Latch barrier passed for "</span>+<span class="keyword">this</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>+<span class="string">" interrupted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"WaitingTask %1$-3d"</span>,id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConntDownLatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE=<span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        CountDownLatch latch=<span class="keyword">new</span> CountDownLatch(SIZE);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> WaitingTask(latch));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;SIZE;i++)&#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> TaskPortion(latch));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Launched all tasks"</span>);</span><br><span class="line">        exec.shutdown();<span class="comment">//quit when all tasks complete</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="CyclicBarrier-栅栏"><a href="#CyclicBarrier-栅栏" class="headerlink" title="CyclicBarrier(栅栏)"></a>CyclicBarrier(栅栏)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Horse</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> counter=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id=counter++;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> strides=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand=<span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier barrier;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Horse</span><span class="params">(CyclicBarrier barrier)</span></span>&#123;<span class="keyword">this</span>.barrier=barrier;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getStrides</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> strides;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">               <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                   strides += rand.nextInt(<span class="number">3</span>);<span class="comment">//produces 0.1.2</span></span><br><span class="line">               &#125;</span><br><span class="line">               barrier.await();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">           <span class="comment">//a legitimate way to exit</span></span><br><span class="line">       &#125;<span class="keyword">catch</span>(BrokenBarrierException e)&#123;</span><br><span class="line">           <span class="comment">//this one we want to know about</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Horse"</span>+id+<span class="string">"  "</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">tracks</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuilder s=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;strides;i++)&#123;</span><br><span class="line">            s.append(<span class="string">"*"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        s.append(id);</span><br><span class="line">        <span class="keyword">return</span> s.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HorseRace</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FINSIH_LINE=<span class="number">75</span>;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Horse&gt; horses=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">private</span> CyclicBarrier barrier;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HorseRace</span><span class="params">(<span class="keyword">int</span> nHorse,<span class="keyword">final</span> <span class="keyword">int</span> pause)</span></span>&#123;</span><br><span class="line">        barrier=<span class="keyword">new</span> CyclicBarrier(nHorse, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                StringBuilder s=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;FINSIH_LINE;i++)&#123;</span><br><span class="line">                    s.append(<span class="string">"="</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">                <span class="keyword">for</span>(Horse horse:horses)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(horse.getStrides()&gt;FINSIH_LINE)&#123;</span><br><span class="line">                        System.out.println(<span class="string">"Horse won!"</span>);</span><br><span class="line">                        exec.shutdownNow();</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    TimeUnit.MICROSECONDS.sleep(pause);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"barrier-action sleep interrupted"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nHorse;i++)&#123;</span><br><span class="line">            Horse horse=<span class="keyword">new</span> Horse(barrier);</span><br><span class="line">            horses.add(horse);</span><br><span class="line">            exec.execute(horse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nHorse=<span class="number">7</span>;</span><br><span class="line">        <span class="keyword">int</span> pause=<span class="number">200</span>;</span><br><span class="line">        <span class="keyword">if</span>(args.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> n=<span class="keyword">new</span> Integer(args[<span class="number">0</span>]);</span><br><span class="line">            nHorse=n&gt;<span class="number">0</span>?n:nHorse;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(args.length&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> p=<span class="keyword">new</span> Integer(args[<span class="number">1</span>]);</span><br><span class="line">            pause=p&gt;-<span class="number">1</span>?p:pause;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> HorseRace(nHorse,pause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.jetbrains.annotations.NotNull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.plaf.basic.BasicInternalFrameTitlePane;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DelayedTask</span> <span class="keyword">implements</span>  <span class="title">Runnable</span>,<span class="title">Delayed</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> counter=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id=counter++;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> delta;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> trigger;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> List&lt;DelayedTask&gt; sequueue=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelayedTask</span><span class="params">(<span class="keyword">int</span> delayInMilliseconds)</span></span>&#123;</span><br><span class="line">        delta=delayInMilliseconds;</span><br><span class="line">        trigger=System.nanoTime()+TimeUnit.NANOSECONDS.convert(delta,TimeUnit.NANOSECONDS);</span><br><span class="line">        sequueue.add(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(@NotNull TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unit.convert(trigger-System.nanoTime(),TimeUnit.NANOSECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(@NotNull Delayed o)</span> </span>&#123;</span><br><span class="line">        DelayedTask that=(DelayedTask)o;</span><br><span class="line">        <span class="keyword">if</span>(trigger&lt;that.trigger)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(trigger&gt;that.trigger)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(<span class="keyword">this</span>+<span class="string">"  "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"[%1$-4d]"</span>, delta) +</span><br><span class="line">                <span class="string">"Task"</span>+id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">summary</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"("</span>+id+<span class="string">":"</span>+delta+<span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EndSentinel</span> <span class="keyword">extends</span> <span class="title">DelayedTask</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> ExecutorService exec;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">EndSentinel</span><span class="params">(<span class="keyword">int</span> delay,ExecutorService e)</span></span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(delay);</span><br><span class="line">            exec=e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(DelayedTask pt:sequueue)&#123;</span><br><span class="line">                System.out.println(pt.summary());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="keyword">this</span>+<span class="string">" Calling shutdownNow"</span>);</span><br><span class="line">            exec.shutdownNow();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DelaydedTaskComsumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DelayQueue&lt;DelayedTask&gt; q;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelaydedTaskComsumer</span><span class="params">(DelayQueue&lt;DelayedTask&gt; q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.q=q;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                q.take().run();<span class="comment">//run task with the current thread</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            <span class="comment">//acceptable way to exit</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Finished DelayTaskConsumer"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Random rand=<span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        DelayQueue&lt;DelayedTask&gt; queue=<span class="keyword">new</span> DelayQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">            queue.put(<span class="keyword">new</span> DelayedTask(rand.nextInt(<span class="number">5000</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        queue.add(<span class="keyword">new</span> DelayedTask.EndSentinel(<span class="number">5000</span>,exec));</span><br><span class="line">        exec.execute(<span class="keyword">new</span> DelaydedTaskComsumer(queue));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~</span><br></pre></td></tr></table></figure>
<h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.jetbrains.annotations.NotNull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.PriorityBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrioritizedTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span>,<span class="title">Comparable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Random rand=<span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> counter=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id=counter++;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> priority;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> List&lt;PrioritizedTask&gt; sequeue=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrioritizedTask</span><span class="params">(<span class="keyword">int</span> priority)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.priority=priority;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(@NotNull Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> priority&gt;((PrioritizedTask)arg).priority?<span class="number">1</span>:</span><br><span class="line">                ( priority &gt; ((PrioritizedTask)arg).priority) ? -<span class="number">1</span>:<span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            TimeUnit.MICROSECONDS.sleep(rand.nextInt(<span class="number">250</span>));</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            <span class="comment">//acceptable way to exit</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"[%1$-3d]"</span>,priority)+</span><br><span class="line">                <span class="string">"Task "</span>+id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">summary</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"("</span>+id+<span class="string">":"</span>+priority+<span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EnSentinel</span> <span class="keyword">extends</span>  <span class="title">PrioritizedTask</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> ExecutorService exec;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">EnSentinel</span><span class="params">(ExecutorService e)</span></span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(-<span class="number">1</span>);</span><br><span class="line">            exec=e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(PrioritizedTask pt:sequeue)&#123;</span><br><span class="line">                System.out.println(pt.summary());</span><br><span class="line">                <span class="keyword">if</span>(++count%<span class="number">5</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println(<span class="keyword">this</span>+<span class="string">"Calling shutdownNow"</span>);</span><br><span class="line">            exec.shutdownNow();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrioritizedTaskProducer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Random rand=<span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Runnable&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> ExecutorService exec;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrioritizedTaskProducer</span><span class="params">(Queue&lt;Runnable&gt; q,ExecutorService e)</span></span>&#123;</span><br><span class="line">        queue=q;</span><br><span class="line">        exec=e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">            queue.add(<span class="keyword">new</span> PrioritizedTask(rand.nextInt(<span class="number">10</span>)));</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">                TimeUnit.MICROSECONDS.sleep(<span class="number">250</span>);</span><br><span class="line">                queue.add(<span class="keyword">new</span> PrioritizedTask(<span class="number">10</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">                queue.add(<span class="keyword">new</span> PrioritizedTask(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            <span class="comment">//acceptable way to exit</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"finished PrioritizedTaskProducer"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrioritizedTaskConsumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PriorityBlockingQueue&lt;Runnable&gt; q;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrioritizedTaskConsumer</span><span class="params">(PriorityBlockingQueue&lt;Runnable&gt; q )</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.q=q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!Thread.interrupted())&#123;</span><br><span class="line">                q.take().run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            <span class="comment">//acceptable way to exit</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"finished prioritizedTaskConsumer"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityBlockingQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Random rand=<span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        PriorityBlockingQueue&lt;Runnable&gt; queue=<span class="keyword">new</span> PriorityBlockingQueue&lt;&gt;();</span><br><span class="line">        exec.execute(<span class="keyword">new</span> PrioritizedTaskProducer(queue,exec));</span><br><span class="line">        exec.execute(<span class="keyword">new</span> PrioritizedTaskConsumer(queue));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用ScheduledExecutor"><a href="#使用ScheduledExecutor" class="headerlink" title="使用ScheduledExecutor"></a>使用ScheduledExecutor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreenhouseScheduler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> light=<span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> water=<span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> String thermostat=<span class="string">"Day"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">getThermostat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> thermostat;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setThermostat</span><span class="params">(String value)</span></span>&#123;</span><br><span class="line">        thermostat=value;</span><br><span class="line">    &#125;</span><br><span class="line">    ScheduledExecutorService scheduler=<span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">10</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">(Runnable event,<span class="keyword">long</span> daley)</span></span>&#123;</span><br><span class="line">        scheduler.schedule(event,daley,TimeUnit.MICROSECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">repeat</span><span class="params">(Runnable event,<span class="keyword">long</span> initialDelay,<span class="keyword">int</span> period)</span></span>&#123;</span><br><span class="line">        scheduler.scheduleAtFixedRate(event,initialDelay,period,TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LightOn</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           System.out.println(<span class="string">"Turning on light"</span>);</span><br><span class="line">           light=<span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LightOff</span> <span class="keyword">implements</span>  <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Truning Off lights"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WaterOn</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Turning greenhouse water on"</span>);</span><br><span class="line">            water =<span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WaterOff</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Turning greenhouse water off"</span>);</span><br><span class="line">            water=<span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ThermostatNight</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Thermostat to night setting"</span>);</span><br><span class="line">            setThermostat(<span class="string">"Night"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ThermostatDay</span> <span class="keyword">implements</span>  <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Thermostat to day setting"</span>);</span><br><span class="line">            setThermostat(<span class="string">"Day"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Bell</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Bing!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Terminate</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Terminating"</span>);</span><br><span class="line">            scheduler.shutdownNow();</span><br><span class="line">            <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(DataPoint d:data)&#123;</span><br><span class="line">                        System.out.println(d);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DataPoint</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Calendar time;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> temperature;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> humidity;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DataPoint</span><span class="params">(Calendar d,<span class="keyword">float</span> temp,<span class="keyword">float</span> hum)</span></span>&#123;</span><br><span class="line">            time=d;</span><br><span class="line">            temperature=temp;</span><br><span class="line">            humidity=hum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span>  time.getTime()+</span><br><span class="line">                    String.format(<span class="string">"temperature: %1$.1f humidity: %2$.2f"</span>,</span><br><span class="line">                            temperature,humidity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Calendar lastTime=Calendar.getInstance();</span><br><span class="line">    &#123;lastTime.set(Calendar.MINUTE,<span class="number">30</span>);</span><br><span class="line">     lastTime.set(Calendar.SECOND,<span class="number">00</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> lastTemp=<span class="number">65.0f</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tempDirection=+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> lastHumidity=<span class="number">50.0f</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> humidityDirection=+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> Random rand=<span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    List&lt;DataPoint&gt; data= Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;DataPoint&gt;());</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CollectData</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Collecting data"</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (GreenhouseScheduler.<span class="keyword">this</span>)&#123;</span><br><span class="line">                lastTime.set(Calendar.MINUTE,lastTime.get(Calendar.MINUTE)+<span class="number">30</span>);</span><br><span class="line">                <span class="keyword">if</span>(rand.nextInt(<span class="number">5</span>)==<span class="number">4</span>)</span><br><span class="line">                    tempDirection=-tempDirection;</span><br><span class="line">                lastTemp=lastTemp+</span><br><span class="line">                        tempDirection*(<span class="number">1.0f</span>+rand.nextFloat());</span><br><span class="line">                <span class="keyword">if</span>(rand.nextInt(<span class="number">5</span>)==<span class="number">4</span>)</span><br><span class="line">                    humidityDirection=-humidityDirection;</span><br><span class="line">                lastHumidity=lastHumidity+</span><br><span class="line">                        humidityDirection*rand.nextFloat();</span><br><span class="line">                data.add(<span class="keyword">new</span> DataPoint((Calendar) lastTime.clone(),lastTemp,lastHumidity));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        GreenhouseScheduler gh=<span class="keyword">new</span> GreenhouseScheduler();</span><br><span class="line">        gh.schedule(gh.new Terminate(),<span class="number">5000</span>);</span><br><span class="line">        gh.repeat(gh.new Bell(),<span class="number">0</span>,<span class="number">1000</span>);</span><br><span class="line">        gh.repeat(gh.new ThermostatNight(),<span class="number">0</span>,<span class="number">2000</span>);</span><br><span class="line">        gh.repeat(gh.new LightOn(),<span class="number">0</span>,<span class="number">200</span>);</span><br><span class="line">        gh.repeat(gh.new LightOff(),<span class="number">0</span>,<span class="number">400</span>);</span><br><span class="line">        gh.repeat(gh.new WaterOn(),<span class="number">0</span>,<span class="number">600</span>);</span><br><span class="line">        gh.repeat(gh.new WaterOff(),<span class="number">0</span>,<span class="number">800</span>);</span><br><span class="line">        gh.repeat(gh.new ThermostatDay(),<span class="number">0</span>,<span class="number">1400</span>);</span><br><span class="line">        gh.repeat(gh.new CollectData(),<span class="number">500</span>,<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pool</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; items=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span>[] checkOut;</span><br><span class="line">    <span class="keyword">private</span> Semaphore available;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pool</span><span class="params">(Class&lt;T&gt; classObject,<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size=size;</span><br><span class="line">        checkOut=<span class="keyword">new</span> <span class="keyword">boolean</span>[size];</span><br><span class="line">        available=<span class="keyword">new</span> Semaphore(size,<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                items.add(classObject.newInstance());</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">checkOut</span><span class="params">()</span><span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        available.acquire();</span><br><span class="line">        <span class="keyword">return</span> getItem();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkIn</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(releaseItem(t))&#123;</span><br><span class="line">            available.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> T <span class="title">getItem</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!checkOut[i])&#123;</span><br><span class="line">                checkOut[i]=<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">return</span> items.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">null</span>;<span class="comment">//semaphore prevents reaching here</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">releaseItem</span><span class="params">(T item)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index=items.indexOf(item);</span><br><span class="line">        <span class="keyword">if</span>(index==-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(checkOut[index])&#123;</span><br><span class="line">            checkOut[index]=<span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//wasn't checked out</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fat</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">double</span> d;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> counter=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id=counter++;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Fat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">            d+=(Math.PI+Math.E)/(<span class="keyword">double</span>)i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Fat id:"</span>+id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.StreamSupport;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckoutTask</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> counter=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id=counter++;</span><br><span class="line">    <span class="keyword">private</span> Pool&lt;T&gt; pool;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CheckoutTask</span><span class="params">(Pool&lt;T&gt; pool)</span></span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.pool=pool;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            T item = pool.checkOut();</span><br><span class="line">            System.out.println(<span class="keyword">this</span>+<span class="string">"checked out"</span>+item);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="keyword">this</span>+<span class="string">"checked in"</span>+item);</span><br><span class="line">            pool.checkIn(item);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            <span class="comment">//acceptable way to terminate</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"CheckoutTask "</span>+id+<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaPhoreDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> SIZE=<span class="number">25</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Pool&lt;Fat&gt; pool=<span class="keyword">new</span> Pool&lt;&gt;(Fat.class,SIZE);</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;SIZE;i++)&#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> CheckoutTask&lt;Fat&gt;(pool));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Al CheckoutTask created"</span>);</span><br><span class="line">        List&lt;Fat&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;SIZE;i++)&#123;</span><br><span class="line">            Fat f=pool.checkOut();</span><br><span class="line">            System.out.println(i+<span class="string">": main thread checkout out"</span>);</span><br><span class="line">            f.operation();</span><br><span class="line">            list.add(f);</span><br><span class="line">        &#125;</span><br><span class="line">        Future&lt;?&gt; blocked=exec.submit(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//Semaphore prevents additional checkout</span></span><br><span class="line">                    <span class="comment">//so call is blocked</span></span><br><span class="line">                    pool.checkOut();</span><br><span class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"Checkout() interrupted"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        blocked.cancel(<span class="keyword">true</span>);</span><br><span class="line">        System.out.println(<span class="string">"Checking in objects in"</span>+list);</span><br><span class="line">        <span class="keyword">for</span>(Fat f:list)</span><br><span class="line">            pool.checkIn(f);</span><br><span class="line">        <span class="keyword">for</span>(Fat f:list)</span><br><span class="line">            pool.checkOut();</span><br><span class="line">        exec.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> xyz.egbertday.generics.BasicGenerator;</span><br><span class="line"><span class="keyword">import</span> xyz.egbertday.generics.Generator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExchangeProceducer</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Generator&lt;T&gt; generator;</span><br><span class="line">    <span class="keyword">private</span> Exchanger&lt;List&lt;T&gt;&gt; exchanger;</span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; holder;</span><br><span class="line">    ExchangeProceducer(Exchanger&lt;List&lt;T&gt;&gt; exchg,Generator&lt;T&gt; gen,List&lt;T&gt; holder)&#123;</span><br><span class="line">        exchanger=exchg;</span><br><span class="line">        generator=gen;</span><br><span class="line">        <span class="keyword">this</span>.holder=holder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ExchangeDemo.size; i++) &#123;</span><br><span class="line">                    holder.add(generator.next());</span><br><span class="line">                    holder = exchanger.exchange(holder);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            <span class="comment">//ok to terminate this way</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExchangeConsumer</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Exchanger&lt;List&lt;T&gt;&gt; exchanger;</span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; holder;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> T value;</span><br><span class="line">    ExchangeConsumer(Exchanger&lt;List&lt;T&gt;&gt; exchg,List&lt;T&gt; holder)&#123;</span><br><span class="line">        exchanger=exchg;</span><br><span class="line">        holder=holder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                holder = exchanger.exchange(holder);</span><br><span class="line">                <span class="keyword">for</span>(T x:holder)&#123;</span><br><span class="line">                    value=x;<span class="comment">//fetch out value</span></span><br><span class="line">                    holder.remove(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            <span class="comment">//Ok to terminate this way</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"final value: "</span>+value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangeDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> size=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> delay=<span class="number">5</span>;<span class="comment">//seconds</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args.length&gt;<span class="number">0</span>)</span><br><span class="line">            size=<span class="keyword">new</span> Integer(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span>(args.length&gt;<span class="number">1</span>)</span><br><span class="line">            delay=<span class="keyword">new</span> Integer(args[<span class="number">1</span>]);</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        Exchanger&lt;List&lt;Fat&gt;&gt; xc=<span class="keyword">new</span> Exchanger&lt;&gt;();</span><br><span class="line">        List&lt;Fat&gt;  produceList=<span class="keyword">new</span> CopyOnWriteArrayList&lt;Fat&gt;();</span><br><span class="line">        List&lt;Fat&gt;  cunsumerList=<span class="keyword">new</span> CopyOnWriteArrayList&lt;Fat&gt;();</span><br><span class="line">        exec.execute(<span class="keyword">new</span> ExchangeProceducer&lt;Fat&gt;(xc, BasicGenerator.create(Fat.class),produceList));</span><br><span class="line">        exec.execute(<span class="keyword">new</span> ExchangeConsumer&lt;Fat&gt;(xc,cunsumerList));</span><br><span class="line">        TimeUnit.SECONDS.sleep(delay);</span><br><span class="line">        exec.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="仿真"><a href="#仿真" class="headerlink" title="仿真"></a>仿真</h2><h3 id="银行出纳员仿真"><a href="#银行出纳员仿真" class="headerlink" title="银行出纳员仿真"></a>银行出纳员仿真</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.jetbrains.annotations.NotNull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> serviceTime;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(<span class="keyword">int</span> tm)</span></span>&#123;serviceTime=tm;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getServiceTime</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> serviceTime;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"["</span>+serviceTime+<span class="string">"&#125;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerLine</span> <span class="keyword">extends</span> <span class="title">ArrayBlockingQueue</span>&lt;<span class="title">Customer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomerLine</span><span class="params">(<span class="keyword">int</span> maxLineSize)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(maxLineSize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"[empty]"</span>;</span><br><span class="line">        StringBuilder s=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(Customer c:<span class="keyword">this</span>)&#123;</span><br><span class="line">            s.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerGenerator</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CustomerLine customers;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand=<span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomerGenerator</span><span class="params">(CustomerLine cl)</span></span>&#123;</span><br><span class="line">        customers=cl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                TimeUnit.MICROSECONDS.sleep(rand.nextInt(<span class="number">300</span>));</span><br><span class="line">                customers.put(<span class="keyword">new</span> Customer(rand.nextInt(<span class="number">1000</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"CustomerGenerator interrupted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"CustomerGenerator terminating"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teller</span> <span class="keyword">implements</span>  <span class="title">Runnable</span>,<span class="title">Comparable</span>&lt;<span class="title">Teller</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> counter=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id=counter++;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> customerServed=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> CustomerLine customers;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> servingCustomerLine=<span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Teller</span><span class="params">(CustomerLine cl)</span></span>&#123;</span><br><span class="line">        customers=cl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(@NotNull Teller o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> customerServed&lt;o.customerServed?-<span class="number">1</span>:</span><br><span class="line">                (customerServed==o.customerServed?<span class="number">0</span>:<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                Customer customer = customers.take();</span><br><span class="line">                TimeUnit.MICROSECONDS.sleep(customer.getServiceTime());</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    customerServed++;</span><br><span class="line">                    <span class="keyword">while</span> (!servingCustomerLine) &#123;</span><br><span class="line">                        wait();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>+<span class="string">"interrupted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>+<span class="string">"terminating"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomethingElse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        customerServed=<span class="number">0</span>;</span><br><span class="line">        servingCustomerLine=<span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span>  <span class="keyword">void</span> <span class="title">serverCustomerLine</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> !servingCustomerLine:<span class="string">"alreay serving: "</span>+<span class="keyword">this</span>;</span><br><span class="line">        servingCustomerLine=<span class="keyword">true</span>;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Teller"</span>+id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">shortStrting</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"T"</span>+id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TellerManager</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ExecutorService exec;</span><br><span class="line">    <span class="keyword">private</span> CustomerLine customers;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Teller&gt; workingTellers=</span><br><span class="line">            <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Teller&gt; tellersDoingOtherThings=</span><br><span class="line">            <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> adjustmentPeriod;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand=<span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TellerManager</span><span class="params">(ExecutorService e,CustomerLine customers,<span class="keyword">int</span> adjustmentPeriod)</span></span>&#123;</span><br><span class="line">        exec=e;</span><br><span class="line">        <span class="keyword">this</span>.customers=customers;</span><br><span class="line">        <span class="keyword">this</span>.adjustmentPeriod=adjustmentPeriod;</span><br><span class="line"></span><br><span class="line">        Teller teller=<span class="keyword">new</span> Teller(customers);</span><br><span class="line">        exec.execute(teller);</span><br><span class="line">        workingTellers.add(teller);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                TimeUnit.MICROSECONDS.sleep(adjustmentPeriod);</span><br><span class="line">                adjuctTellerNumber();</span><br><span class="line">                System.out.println(customers + <span class="string">"&#123;"</span>);</span><br><span class="line">                <span class="keyword">for</span> (Teller teller : workingTellers) &#123;</span><br><span class="line">                    System.out.println(teller.shortStrting() + <span class="string">" "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"&#125;"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>+<span class="string">"interrupted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>+<span class="string">"terminating"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adjuctTellerNumber</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(customers.size()/workingTellers.size()&gt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tellersDoingOtherThings.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                Teller teller=tellersDoingOtherThings.remove();</span><br><span class="line">                teller.serverCustomerLine();</span><br><span class="line">                workingTellers.offer(teller);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Teller teller=<span class="keyword">new</span> Teller(customers);</span><br><span class="line">            exec.execute(teller);</span><br><span class="line">            workingTellers.add(teller);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(workingTellers.size()&gt;<span class="number">1</span>&amp;&amp;customers.size()/workingTellers.size()&lt;<span class="number">2</span>)&#123;</span><br><span class="line">              reassignOneTeller();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(customers.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(workingTellers.size()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                reassignOneTeller();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reassignOneTeller</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Teller teller=workingTellers.poll();</span><br><span class="line">        teller.doSomethingElse();</span><br><span class="line">        tellersDoingOtherThings.offer(teller);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"TellerManager"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BankTellerSimulation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Max_LINE_SIZE=<span class="number">50</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ADJUSTMENT_PERIOD=<span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">       ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">       CustomerLine customers=<span class="keyword">new</span> CustomerLine(Max_LINE_SIZE);</span><br><span class="line">       exec.execute(<span class="keyword">new</span> CustomerGenerator(customers));</span><br><span class="line">       exec.execute(<span class="keyword">new</span> TellerManager(exec,customers,ADJUSTMENT_PERIOD));</span><br><span class="line">       <span class="keyword">if</span>(args.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">           TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Integer(args[<span class="number">0</span>]));</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           System.out.println(<span class="string">"Press 'enter' to quit"</span>);</span><br><span class="line">           System.in.read();</span><br><span class="line">       &#125;</span><br><span class="line">       exec.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="饭店仿真"><a href="#饭店仿真" class="headerlink" title="饭店仿真"></a>饭店仿真</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency.restaurant2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> xyz.egbertday.enumerated.Course;</span><br><span class="line"><span class="keyword">import</span> xyz.egbertday.enumerated.Food;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> counter=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id=counter++;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">final</span> Customer customer;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WaitPerson waitPerson;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Food food;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span><span class="params">(Customer c,WaitPerson w, Food food)</span></span>&#123;</span><br><span class="line">        customer=c;</span><br><span class="line">        waitPerson=w;</span><br><span class="line">        <span class="keyword">this</span>.food=food;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">item</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> food;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WaitPerson <span class="title">getWaitPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  waitPerson;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Customer <span class="title">getCustomer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> customer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="string">"Order: "</span>+id+<span class="string">"item: "</span>+food+</span><br><span class="line">                <span class="string">"for:"</span>+customer+<span class="string">"served by:"</span>+waitPerson;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plate</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Order order;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Food food;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Plate</span><span class="params">(Order ord, Food f)</span></span>&#123;</span><br><span class="line">        order=ord;</span><br><span class="line">        food=f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Order <span class="title">getOrder</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> order;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">getFood</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> food;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> food.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> counter=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id=counter++;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WaitPerson waitPerson;</span><br><span class="line">    <span class="keyword">private</span> SynchronousQueue&lt;Plate&gt; plateSetting=<span class="keyword">new</span> SynchronousQueue&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(WaitPerson w)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.waitPerson=w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deliver</span><span class="params">(Plate plate)</span><span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        plateSetting.put(plate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (Course course : Course.values()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Food food = course.randomSelection();</span><br><span class="line">                    waitPerson.placeOrder(<span class="keyword">this</span>, food);</span><br><span class="line">                    System.out.println(<span class="keyword">this</span> + <span class="string">"eating"</span> + plateSetting.take());</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                    System.out.println(<span class="keyword">this</span>+<span class="string">"waiting for "</span>+course+<span class="string">"interrupted"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>+<span class="string">"finished meal.leaving"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaitPerson</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> counter=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id=counter++;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Restaurant restaurant;</span><br><span class="line">    BlockingQueue&lt;Plate&gt; filldedOders=<span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">WaitPerson</span><span class="params">(Restaurant restaurant)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.restaurant=restaurant;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">placeOrder</span><span class="params">(Customer cust,Food food)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            restaurant.orders.put(<span class="keyword">new</span> Order(cust,<span class="keyword">this</span>,food));</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>+<span class="string">" placeOrder interrupted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">               Plate plate = filldedOders.take();</span><br><span class="line">                System.out.println(<span class="keyword">this</span> + <span class="string">"received"</span> + plate +</span><br><span class="line">                        <span class="string">"delivering to "</span> + plate.getOrder().getCustomer());</span><br><span class="line">                plate.getOrder().getCustomer().deliver(plate);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>+<span class="string">" placeOrder interrupt"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>+<span class="string">" off duty"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"waitePerson"</span>+id+<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chef</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> counter=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id=counter++;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Restaurant restaurant;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand=<span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chef</span><span class="params">(Restaurant restaurant)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.restaurant=restaurant;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                Order order = restaurant.orders.take();</span><br><span class="line">                Food requestedItem = order.item();</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(rand.nextInt(<span class="number">500</span>));</span><br><span class="line">                Plate plate = <span class="keyword">new</span> Plate(order, requestedItem);</span><br><span class="line">                order.getWaitPerson().filldedOders.put(plate);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>+<span class="string">"interrupted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>+<span class="string">"off duty"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Chef"</span>+id+<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Restaurant</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;WaitPerson&gt; waitPersons=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Chef&gt;   chefs=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ExecutorService exec;</span><br><span class="line">    <span class="keyword">private</span> Random rand=<span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    BlockingQueue&lt;Order&gt; orders=<span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Restaurant</span><span class="params">(ExecutorService e,<span class="keyword">int</span> nWaitPersons,<span class="keyword">int</span> nChecfs)</span></span>&#123;</span><br><span class="line">        exec=e;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nWaitPersons;i++)&#123;</span><br><span class="line">            WaitPerson waitPerson=<span class="keyword">new</span> WaitPerson(<span class="keyword">this</span>);</span><br><span class="line">            waitPersons.add(waitPerson);</span><br><span class="line">            exec.execute(waitPerson);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nChecfs;i++)&#123;</span><br><span class="line">            Chef chef=<span class="keyword">new</span> Chef(<span class="keyword">this</span>);</span><br><span class="line">            chefs.add(chef);</span><br><span class="line">            exec.execute(chef);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">               WaitPerson wp = waitPersons.get(rand.nextInt(waitPersons.size()));</span><br><span class="line">               Customer c = <span class="keyword">new</span> Customer(wp);</span><br><span class="line">               exec.execute(c);</span><br><span class="line">               TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">           System.out.println(<span class="string">"Restaurant interrupted"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(<span class="string">"Restaurant closing"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestaurantWithQueues</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        Restaurant restaurant = <span class="keyword">new</span> Restaurant(exec, <span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line">        exec.execute(restaurant);</span><br><span class="line">        <span class="keyword">if</span>(args.length&gt;<span class="number">0</span>)</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Integer(args[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Press 'enter' to quit;"</span>);</span><br><span class="line">            System.in.read();</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分发工作"><a href="#分发工作" class="headerlink" title="分发工作"></a>分发工作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency.carbuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span></span><br><span class="line">            engine=<span class="keyword">false</span>,driveTrain=<span class="keyword">false</span>,wheels=<span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;<span class="keyword">this</span>.id=id;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span></span>&#123;id=-<span class="number">1</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> id;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addEngine</span><span class="params">()</span></span>&#123;engine=<span class="keyword">true</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addDriveTrain</span><span class="params">()</span></span>&#123;driveTrain=<span class="keyword">true</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addWheels</span><span class="params">()</span></span>&#123;wheels=<span class="keyword">true</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="string">"Car"</span>+id+<span class="string">"["</span>+<span class="string">"engine:"</span>+engine+<span class="string">" driveTrain:"</span></span><br><span class="line">             +driveTrain+<span class="string">"wheels:"</span>+wheels+<span class="string">"]"</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarQueue</span> <span class="keyword">extends</span> <span class="title">LinkedBlockingQueue</span>&lt;<span class="title">Car</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChassisBuilder</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CarQueue carQueue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> counter=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChassisBuilder</span><span class="params">(CarQueue cars)</span></span>&#123;carQueue=cars;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">                Car car = <span class="keyword">new</span> Car(counter++);</span><br><span class="line">                System.out.println(<span class="string">"ChassicBuilder created"</span> + car);</span><br><span class="line">                carQueue.put(car);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Interrupted:ChassisBuilder"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"ChassisBuilder off"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Assembler</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CarQueue chassisQueue,finishingQueue;</span><br><span class="line">    <span class="keyword">private</span> Car car;</span><br><span class="line">    <span class="keyword">private</span> CyclicBarrier barrier=<span class="keyword">new</span> CyclicBarrier(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">private</span> RobotPool robotPool;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Assembler</span><span class="params">(CarQueue cq,CarQueue fq,RobotPool rp)</span></span>&#123;</span><br><span class="line">        chassisQueue=cq;</span><br><span class="line">        finishingQueue=fq;</span><br><span class="line">        robotPool=rp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">car</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> car;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CyclicBarrier <span class="title">barrier</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> barrier;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                car = chassisQueue.take();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reporter</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CarQueue carQueue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Reporter</span><span class="params">(CarQueue cq)</span></span>&#123;carQueue=cq;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                System.out.println(carQueue.take());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Exiting Reporter via interrupt"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Reporter off"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Robot</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RobotPool robotPool;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Robot</span><span class="params">(RobotPool rp)</span></span>&#123;robotPool=rp;&#125;</span><br><span class="line">    <span class="keyword">protected</span> Assembler assembler;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Robot <span class="title">assignAssembler</span><span class="params">(Assembler assembler)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.assembler=assembler;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> engage=<span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">engage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        engage=<span class="keyword">true</span>;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span>  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">performService</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            powerDown();</span><br><span class="line">            <span class="keyword">while</span>(!Thread.interrupted())&#123;</span><br><span class="line">                performService();</span><br><span class="line">                assembler.barrier().await();</span><br><span class="line">                powerDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">             System.out.println(<span class="string">"Exiting"</span>+<span class="keyword">this</span>+<span class="string">"via interrupted"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(BrokenBarrierException e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>+<span class="string">"off"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">powerDown</span><span class="params">()</span><span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        engage=<span class="keyword">false</span>;</span><br><span class="line">        assembler=<span class="keyword">null</span>;</span><br><span class="line">        robotPool.release(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">while</span>(engage==<span class="keyword">false</span>)&#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EngineRobot</span> <span class="keyword">extends</span> <span class="title">Robot</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EngineRobot</span><span class="params">(RobotPool rp)</span></span>&#123;<span class="keyword">super</span>(rp);&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">performService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>+<span class="string">"installing engine"</span>);</span><br><span class="line">        assembler.car().addEngine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DriveTrainRobot</span> <span class="keyword">extends</span>  <span class="title">Robot</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DriveTrainRobot</span><span class="params">(RobotPool rp)</span></span>&#123;<span class="keyword">super</span>(rp);&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">performService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>+<span class="string">"installing DriveTrain"</span>);</span><br><span class="line">        assembler.car().addDriveTrain();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WheelRobot</span> <span class="keyword">extends</span> <span class="title">Robot</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WheelRobot</span><span class="params">(RobotPool rp)</span></span>&#123;<span class="keyword">super</span>(rp);&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">performService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>+<span class="string">"installing WheelRobot"</span>);</span><br><span class="line">        assembler.car().addWheels();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RobotPool</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Robot&gt; pool=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Robot r)</span></span>&#123;</span><br><span class="line">        pool.add(r);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">hire</span><span class="params">(Class&lt;? extends Robot&gt; robotType,Assembler d)</span><span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Robot r:pool)&#123;</span><br><span class="line">            <span class="keyword">if</span>(r.getClass().equals(robotType))&#123;</span><br><span class="line">                pool.remove(r);</span><br><span class="line">                r.assignAssembler(d);</span><br><span class="line">                r.engage();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        wait();</span><br><span class="line">        hire(robotType,d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(Robot r)</span></span>&#123;add(r);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        CarQueue chassisQueue=<span class="keyword">new</span> CarQueue();</span><br><span class="line">        CarQueue finishingQueue=<span class="keyword">new</span> CarQueue();</span><br><span class="line">        ExecutorService exec=Executors.newCachedThreadPool();</span><br><span class="line">        RobotPool robotPool=<span class="keyword">new</span> RobotPool();</span><br><span class="line">        exec.execute(<span class="keyword">new</span> EngineRobot(robotPool));</span><br><span class="line">        exec.execute(<span class="keyword">new</span> DriveTrainRobot(robotPool));</span><br><span class="line">        exec.execute(<span class="keyword">new</span> WheelRobot(robotPool));</span><br><span class="line">        exec.execute(<span class="keyword">new</span> Assembler(chassisQueue,finishingQueue,robotPool));</span><br><span class="line">        exec.execute(<span class="keyword">new</span> Reporter(finishingQueue));</span><br><span class="line">        exec.execute(<span class="keyword">new</span> ChassisBuilder(chassisQueue));</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">7</span>);</span><br><span class="line">        exec.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h2><h3 id="比较各种互斥技术"><a href="#比较各种互斥技术" class="headerlink" title="比较各种互斥技术"></a>比较各种互斥技术</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.corba.se.impl.orbutil.concurrent.Sync;</span><br><span class="line"><span class="keyword">import</span> com.sun.glass.ui.Size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.SynchronousQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicLong;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Accumulator</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> cycles=<span class="number">50000L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier barrier=<span class="keyword">new</span> CyclicBarrier(N*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> ExecutorService exec= Executors.newFixedThreadPool(N*<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">long</span> duration=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">protected</span> String id=<span class="string">"error"</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> SIZE=<span class="number">100000</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">int</span>[] preLoaded=<span class="keyword">new</span> <span class="keyword">int</span>[SIZE];</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        Random rand=<span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;SIZE;i++)&#123;</span><br><span class="line">            preLoaded[i]=rand.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">accumulate</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Modifier</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">0</span>;i&lt;cycles;i++)&#123;</span><br><span class="line">                accumulate();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                barrier.await();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Reader</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">0</span>;i&lt;cycles;i++)&#123;</span><br><span class="line">               value=read();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                barrier.await();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">timetest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start=System.nanoTime();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> Modifier());</span><br><span class="line">            exec.execute(<span class="keyword">new</span> Reader());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            barrier.await();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">        duration=System.nanoTime()-start;</span><br><span class="line">        System.out.format(<span class="string">"%-22s: %.2f\n"</span>,id,duration);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">report</span><span class="params">(Accumulator acc1,Accumulator acc2)</span></span>&#123;</span><br><span class="line">        System.out.format(<span class="string">"%-22s: %.2f]n"</span>,acc1.id+<span class="string">"/"</span>+acc2.id,</span><br><span class="line">                (<span class="keyword">double</span>)acc1.duration/(<span class="keyword">double</span>)acc2.duration);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicLine</span> <span class="keyword">extends</span> <span class="title">Accumulator</span></span>&#123;</span><br><span class="line">    &#123;id=<span class="string">"basicLine"</span>;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accumulate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        value+=preLoaded[index++];</span><br><span class="line">        <span class="keyword">if</span>(index&gt;=SIZE)</span><br><span class="line">            index=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> <span class="keyword">extends</span> <span class="title">Accumulator</span></span>&#123;</span><br><span class="line">    &#123;id=<span class="string">"synchronized"</span>;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">accumulate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        value+=preLoaded[index++];</span><br><span class="line">        <span class="keyword">if</span>(index&gt;=SIZE)</span><br><span class="line">            index=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> <span class="keyword">extends</span> <span class="title">Accumulator</span></span>&#123;</span><br><span class="line">    &#123;id=<span class="string">"lock"</span>;&#125;</span><br><span class="line">    Lock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accumulate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            value+=preLoaded[index];</span><br><span class="line">            <span class="keyword">if</span>(index&gt;=SIZE)</span><br><span class="line">                index=<span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AtomicTest</span> <span class="keyword">extends</span> <span class="title">Accumulator</span></span>&#123;</span><br><span class="line">    &#123;id=<span class="string">"atomic"</span>;&#125;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger index=<span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> AtomicLong value=<span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accumulate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=index.getAndIncrement();</span><br><span class="line">        value.getAndAdd(preLoaded[i]);</span><br><span class="line">        <span class="keyword">if</span>(++i&gt;=SIZE)</span><br><span class="line">            index.set(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizationComparisons</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> BasicLine basicLine=<span class="keyword">new</span> BasicLine();</span><br><span class="line">    <span class="keyword">static</span> SynchronizedTest synch=<span class="keyword">new</span> SynchronizedTest();</span><br><span class="line">    <span class="keyword">static</span> LockTest lock=<span class="keyword">new</span> LockTest();</span><br><span class="line">    <span class="keyword">static</span> AtomicTest atomic=<span class="keyword">new</span> AtomicTest();</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"================================="</span>);</span><br><span class="line">        System.out.format(<span class="string">"%-12s:%13d\n"</span>,<span class="string">"Cycles"</span>,Accumulator.cycles);</span><br><span class="line">        basicLine.timetest();</span><br><span class="line">        synch.timetest();</span><br><span class="line">        lock.timetest();</span><br><span class="line">        atomic.timetest();</span><br><span class="line">        Accumulator.report(synch,basicLine);</span><br><span class="line">        Accumulator.report(lock,basicLine);</span><br><span class="line">        Accumulator.report(atomic,basicLine);</span><br><span class="line">        Accumulator.report(synch,lock);</span><br><span class="line">        Accumulator.report(synch,atomic);</span><br><span class="line">        Accumulator.report(lock,atomic);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> iterations=<span class="number">5</span>;</span><br><span class="line">        <span class="keyword">if</span>(args.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            iterations=<span class="keyword">new</span> Integer(args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Warmup"</span>);</span><br><span class="line">        basicLine.timetest();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;iterations;i++)&#123;</span><br><span class="line">            test();</span><br><span class="line">            Accumulator.cycles*=<span class="number">2</span>;        </span><br><span class="line">        &#125;</span><br><span class="line">        Accumulator.exec.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码使用的是模版技术，子类使用各种互斥技术实现抽象方法increment()和read(),我们大概的分析一下，在main()中，测试是重复运行的，对于每次重复，循环的数量都会加倍，因此你可以看到当运行次数越来越多时，这些不同的互斥技术在行为方面存在着怎样的差异，对于前几次的迭代执行，synchronized关键字似乎比使用Lock和Atomic要更高效，但是越过一个门槛之后，synchronized似乎变得非常低效，而Locked和Atomic则大体维持着与BasicLine测试之间的比例关系，因此也就变得比synchronized关键字要高效的多<br>记住，上面程序只给出了各种互斥技术之间的差异的趋势，当所使用的线程输了不同，或者程序运行时间更长时，在行为ufangmian肯定存在着明显的变化<br>也就是说，很明显，使用Lock通常会比使用synchronized要高效很多，而且synchronzied开销看起来变化范围太大，而Lock相对比较一致<br>但是这是否意味着你永远不应该使用synchronized关键字呢？我们有两个因素要考虑</p>
<ol>
<li>通常只互斥那些你绝对必须互斥的部分是一个很好的习惯，但是，在实际中，被互斥部分可能要比上面的示例中的那些大很多，因此在这些方法体花费的时间的百分比可能明显大于进入和退出互斥的开销，这样也就湮没了提高互斥技术所带来的好处</li>
<li>其次，在编程中使用synchronized更简单，可读性更强，在团队编程的时候互相之间的交流很重要<br>因此，从以上两个原因得出结论，一般情况下使用synchronized，只有需要性能调优时才替换为Lock对象这种做法<br>Atomic对象比较适合在非常简单的情况下才有用，这种情况通常包括你只有一个要被修改的Atomic对象，并且这个对象独立于其他所有的对象，更安全的做法时：以传统的互斥方法入手，只有在性能方面有明确的要求时再替换为Atomic<h3 id="免锁容器"><a href="#免锁容器" class="headerlink" title="免锁容器"></a>免锁容器</h3>容器是所有编程的基础工具，这其中自然也包括并发编程，出于这样的原因，向Vector和HashTable这类早期容器具有很多synchronized方法，当它们用于非线性的应用程序时，便会导致不可接受的开销，<strong>在java1.2中，新的容器类库是不同步的，并且Collections类提供了各自static方法的同步装饰方法，从而来同步不同类型的容器</strong>，尽管这种开销仍旧是基于synchronized加锁机制的，Java SE5特别添加了新的容器，这些容器使用更灵巧的技术来消除加锁，从而提高线程安全的性能<br>这些免锁容器背后的通用策略是：<strong>对容器的修改可以与读取操作同时发生，只要读取只能看到完成修改的结果即可，修改是在容器数据结构的某个部分的一个单独的副本（有时是整个数据结构的副本）上执行的，并且这个副本在修改的过程中是不可视的，只有当修改完成时，被修改的结构才会自动地与主数据结果进行交换，之后读取者就可以看到这个修改了</strong><br>在CopyOnWriteArrayList中，写入将导致创建整个底层数组的副本，而源数组将保留，使得复制的数组在被修改时，读取操作可以安全地执行，<strong>当修改完成时，一个原子操作将把新的数组转换入</strong>，使得新的读取操作可以看到这个新的修改，CopyOnWriteArrayList的好处之一是当多个迭代器同时遍历和修改这个列表时，不会抛出ConcurrentModificationException，因此你不必编写特殊的代码来防范这种异常<br>CopyOnWriteArraySet将使用CopyOnWriteArrayList来实现其免锁行为<br>CopyOnWriteArrayMap和ConcurrentLinkedQueue使用类似的技术，允许并发的读取和写入，但是容器中只有部分内容而不是整个容器可以被复制和修改，然后，任何修改在完成之前，读取者仍旧不能看到它们，ConcurrentHashMap不会抛出ConcurrentModificationEXception异常<h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4>只要你主要从免锁容器中读取，那么它就会比其synchronized对应物快很多，因为获取和释放锁的开销被省掉了，如果需要向免锁容器中执行少量写入，那么情况也是如此，但是什么算“少量”，这是一个很有意思的问题，下面介绍有关各种不同条件下，这些容器在性能方面差异的大致概念</li>
</ol>
<h4 id="比较各种Map实现"><a href="#比较各种Map实现" class="headerlink" title="比较各种Map实现"></a>比较各种Map实现</h4><h3 id="乐观加锁"><a href="#乐观加锁" class="headerlink" title="乐观加锁"></a>乐观加锁</h3><h3 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h3><h3 id=""><a href="#" class="headerlink" title="#"></a>#</h3><h2 id="活动对象"><a href="#活动对象" class="headerlink" title="活动对象"></a>活动对象</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/27/并发/" data-id="cjnzv2pu4003rcorzpnyz5dqu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-注解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/19/注解/" class="article-date">
  <time datetime="2018-10-19T14:08:07.000Z" itemprop="datePublished">2018-10-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习心得/">学习心得</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/19/注解/">注解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/19/注解/" data-id="cjnzv2pru002zcorz5ktryfn3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-枚举类型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/19/枚举类型/" class="article-date">
  <time datetime="2018-10-19T14:07:39.000Z" itemprop="datePublished">2018-10-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习心得/">学习心得</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/19/枚举类型/">枚举类型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>关键字enum可以将一组具名的值的有限集合创建为一种新的类型，而这些具名的值可以作为常规的程序组件使用，这是一种非常有用的功能</strong></p>
<h2 id="基本的enum特性"><a href="#基本的enum特性" class="headerlink" title="基本的enum特性"></a>基本的enum特性</h2><p>调用values生成一个enum实例的数组，而且该数组中的元素严格保持其在enum中声明时的顺序<br>创建enum时，编译器就为你生成一个相关的类，这个类继承自java.lang.Enum，下面演示了Enum提供的一些功能<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Shrubbery&#123;GROUND,GRAELING,HANGING&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Shrubbery s:Shrubbery.values())&#123;</span><br><span class="line">            System.out.println(s+<span class="string">" ordinal: "</span>+s.ordinal());</span><br><span class="line">            System.out.println(s.compareTo(Shrubbery.GRAELING)+<span class="string">" "</span>);</span><br><span class="line">            System.out.println(s.equals(Shrubbery.GRAELING));</span><br><span class="line">            System.out.println(s==Shrubbery.GRAELING);</span><br><span class="line">            System.out.println(s.getDeclaringClass());</span><br><span class="line">            System.out.println(s.name());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(String s:<span class="string">"HANGING CRAWLING GROUND"</span>.split(<span class="string">" "</span>))&#123;</span><br><span class="line">            Shrubbery shrub=Shrubbery.valueOf(s);</span><br><span class="line">            System.out.println(shrub);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ordinal()方法返回一个int值，这是每个enum实例在声明时的次序，从0开始，编译器自动为你提供equals()和hashCode()，它还实现了Comparable接口。所以它具有compareTo()方法，同时，它还实现了Serializable接口<br>如果在enum实例上调用getDeclaringClass()，我们就知道其所属的enum类<br>name()方法返回enum实例声明时的名字，这与使用toString()方法效果相同。valueOf()是在Enum类中定义的static方法，它根据给定的名字返回相应的enum实例，如果不存在给定名字则会抛出异常</p>
<h3 id="将静态导入用于enum"><a href="#将静态导入用于enum" class="headerlink" title="将静态导入用于enum"></a>将静态导入用于enum</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.enumerated;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Spiciness &#123;</span><br><span class="line">    NOT,MILD,MEDIUM,HOT,FLAMING</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> xyz.egbertday.enumerated;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> xyz.egbertday.enumerated.Spiciness.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Burrito</span> </span>&#123;</span><br><span class="line">    Spiciness degree;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Burrito</span><span class="params">(Spiciness degree)</span></span>&#123;<span class="keyword">this</span>.degree=degree;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">"Burrito is"</span>+degree;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Burrito(NOT));</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Burrito(MEDIUM));</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Burrito(HOT));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">~~~使用<span class="keyword">import</span> <span class="keyword">static</span> 能够将<span class="keyword">enum</span>实例的标识符带入到当前的命名空间，所有无需再使用<span class="keyword">enum</span>类型来修饰<span class="keyword">enum</span>实例，这是一个好方法吗？或者还是显示地修饰<span class="keyword">enum</span>实例更好，这样看代码的复杂程度，哪一种方式都OK</span><br><span class="line">## 向enum中添加新方法 ##</span><br><span class="line">除了不能继承一个<span class="keyword">enum</span>之外，我们基本上可以将<span class="keyword">enum</span>看做是一个常规的类，也就是说，我们可以向<span class="keyword">enum</span>中添加方法，<span class="keyword">enum</span>甚至可以有main()方法</span><br><span class="line">一般来说，我们希望每个枚举实例都能返回对自身的描述，而不仅仅只是默认的toString()实现，这只能返回枚举实例的名字，为此，你可以提供一个构造器，专门负责处理这个额外的信息，然后添加一个方法，返回这个描述的信息，看下面的示例</span><br><span class="line">~~~java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> OzWith &#123;</span><br><span class="line">    WEST(<span class="string">"Miss Gulch aka"</span>),</span><br><span class="line">    NORTH(<span class="string">"Glnda"</span>),</span><br><span class="line">    EAST(<span class="string">"Wicked"</span>),</span><br><span class="line">    SOUTH(<span class="string">"Good by interface"</span>);<span class="comment">//自定义方法时，分号不要忘记</span></span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">OzWith</span><span class="params">(String description)</span></span>&#123;/即使不刻意声明构造器为<span class="keyword">private</span>，它的可访问性也不会发生改变</span><br><span class="line">        <span class="keyword">this</span>.description=description;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  description;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(OzWith oz:OzWith.values())&#123;</span><br><span class="line">            System.out.println(oz+oz.getDescription());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，如果你打算定义自己的方法的时候，那么必须在enum实例序列的最后添加一个分号，同时java要求你必须先定义enum实例，如果在enum实例之前定义的任何方法或属性，那么在编译器就会得到错误信息<br>可以说enum的构造器和方法和普通的类没什么区别，因为除了有少些的限制之外，enum就是一个普通的类，虽然，在这个例子中，我们刻意的将enum的构造器声明为private，但对于它的可访问性并没有什么变化，因为（即使我们不声明为private）,我们只能在enum定义的内部使用其构造器创建enum实例，一旦enum的定义结束，编译器就不允许我们再使用其构造器来创建任何得实例了，可是我们也不能使用public来修饰构造器，直接什么都不写就可以了</p>
<h3 id="覆盖enum的方法"><a href="#覆盖enum的方法" class="headerlink" title="覆盖enum的方法"></a>覆盖enum的方法</h3><p>覆盖enum默认具有的方法和普通的类没什么区别</p>
<h2 id="switch语句中的enume"><a href="#switch语句中的enume" class="headerlink" title="switch语句中的enume"></a>switch语句中的enume</h2><p>在Switch中使用enum，是enum提供的一项非常便利的功能，一般来说，在switch中只能使用整数值，而枚举类型天生就具备整数值的次序，并且可以通过ordinal()方法取得其次序（显然编译器以及帮我们做了类似的工作），因此我们可以在switch语句中使用enum，一般来说，我们必须要使用enum类型来修饰一个enum实例，但在case语句中却不必如此<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Signal&#123;RED,YELLOW,GRREN&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrafficLight</span> </span>&#123;</span><br><span class="line">    Signal signal=Signal.RED;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(Signal signal)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (signal)&#123;</span><br><span class="line">            <span class="keyword">case</span> RED: <span class="keyword">this</span>.signal=Signal.GRREN;</span><br><span class="line">            <span class="keyword">case</span> GRREN:<span class="keyword">this</span>.signal=Signal.YELLOW;</span><br><span class="line">            <span class="keyword">case</span> YELLOW:<span class="keyword">this</span>.signal=Signal.RED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="values的神秘之处"><a href="#values的神秘之处" class="headerlink" title="values的神秘之处"></a>values的神秘之处</h2><p>前面提到，编译器为你创建的enum类都继承自Enum类，然而，如果你研究一下Enum类就会发现，它并没有values()方法，难道存在着“隐匿”的方法，我们利用反射机制编写一个简单的程序<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Explore&#123;HERE,THERE&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reflection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;String&gt; <span class="title">analyze</span><span class="params">(Class&lt;?&gt; enumClass)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"------------analyzing-----"</span>+enumClass+<span class="string">"---------"</span>);</span><br><span class="line">        System.out.println(<span class="string">"interface"</span>);</span><br><span class="line">        <span class="keyword">for</span>(java.lang.reflect.Type t:enumClass.getGenericInterfaces())&#123;</span><br><span class="line">            System.out.println(t);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Base"</span>+enumClass.getSuperclass());</span><br><span class="line">        System.out.println(<span class="string">"methods"</span>);</span><br><span class="line">        Set&lt;String&gt; methods=<span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Method m:enumClass.getMethods())&#123;</span><br><span class="line">           methods.add(m.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(methods);</span><br><span class="line">        <span class="keyword">return</span> methods;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">           Set&lt;String&gt; exploreMethods=analyze(Explore.class);</span><br><span class="line">           Set&lt;String&gt; enumMethods=analyze(Enum.class);</span><br><span class="line">           System.out.println(<span class="string">"Explore.containsAll(Enum)?"</span>+</span><br><span class="line">           exploreMethods.containsAll(enumMethods));</span><br><span class="line">           System.out.println(<span class="string">"Explore.removeAll(Enum):"</span>);</span><br><span class="line">           exploreMethods.removeAll(enumMethods);</span><br><span class="line">           System.out.println(exploreMethods);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行程序结果可知，Enum类没有values()方法，而是编译器在创建enum类时自动添加的一个static方法，还可以看出了，在创建enum类的时候，编译器还为其添加了valueOf()方法，这能令人疑惑，Enum类不是已经有valueOf()方法了吗？不过Enum的valueOf()方法需要两个参数，而这个新增的方法只有一个参数，其方法签名不同，根本就是两个不同的方法，可以javap 反编译看出编译器将enum标记为final类，所有无法继承enum，其中还有static的初始化语句，其实就是初始化enum类型的实例的，其实例的的标识符具名，且被修饰为static final 因此我们也就知道，enum定义的enum实例其实就是enum类型的常量，其依附在enum类型下而已<br>由于values()是编译器插入到enum定义上的static方法，所有向上转型为Enum时，就不能再调用values()方法了（因为Enum没有这个方法），不过Class中有一个getEnumConstants()方法，所有即使Enum接口中没有values()方法，我们依然可以通过Class对象取得所有的enum实例</p>
<h2 id="实现而非继承"><a href="#实现而非继承" class="headerlink" title="实现而非继承"></a>实现而非继承</h2><p>我们已经知道了，所有的enum都继承自java.lang.Enum类，由于java不支持多重继承，所以我们的enum就不能再继承其他的类了</p>
<h2 id="随机选取"><a href="#随机选取" class="headerlink" title="随机选取"></a>随机选取</h2><p>由于接下来的许多示例都需要从enum实例中继续随机选择，我们利用泛型，从而使这个公共更一般化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Enums</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand=<span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Enum&lt;T&gt;&gt; <span class="function">T <span class="title">random</span><span class="params">(Class&lt;T&gt; ec)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> random(ec.getEnumConstants());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">random</span><span class="params">(T[] values)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> values[rand.nextInt(values.length)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="使用接口组织枚举"><a href="#使用接口组织枚举" class="headerlink" title="使用接口组织枚举"></a>使用接口组织枚举</h2><p>方法从enum自称子类有时很令人沮丧，这种需求有时源于我们希望扩展员enum中的元素，有时是因为我们希望使用某个子类将一个enum中的元素进行分组<br>在一个接口的内部，创建实现接口的枚举，以此将元素进行分组，可以达到将枚举元素分组的目的，假设你希望用enum表示不同类别的事物，同时还希望每个enum元素依然是Food类型，就可以这样实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> Apptizer implements Food&#123;SALAD,SOUP,SPRING_ROLLS&#125;</span><br><span class="line">    <span class="keyword">enum</span> MianCourse implements  Food&#123;LASANGE,BURRITO,PAD_THAI,LENTILS&#125;</span><br><span class="line">    <span class="keyword">enum</span> Dessert implements  Food&#123;TIRAMISU,GELATO,FRUIT&#125;</span><br><span class="line">    <span class="keyword">enum</span> Coffee implements Food&#123;BLACK_COFFEE,DECAF_COFFEE,ESPRESSO&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对enum而言，实现接口是其子类化的唯一办法，所以嵌入在Food中的每个enum都实现了Food接口，这样所有的enum实例也都是Food类型的了<br>Food，我们知道接口中除了方法之外的任何成员的是static final的，所有也知道，这些Enum类型是嵌套在Food接口中的，因此，如果你想引用嵌套接口内某个enum类型的实例时，应该这样写 Food.Apptizer.SALAD，或者在使用静态导入之后，写成Apptizer.SALAD<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> xyz.egbertday.enumerated.Food.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeOfFood</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Food food = Apptizer.SALAD;</span><br><span class="line">        food =MainCourse.LASANGE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然而，当你需要与一大堆类型打交道时，接口就不如enum好用了，例如，<strong>如果你想创建一个“枚举的枚举”</strong>，那么就可以创建一个新的enum，然后用其实例包装Food中的每个enum类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Course &#123;</span><br><span class="line">    APPETIZER(Food.Apptizer.class),</span><br><span class="line">    MAINCOUSER(Food.MainCourse.class),</span><br><span class="line">    DESSERT(Food.Dessert.class),</span><br><span class="line">    COFFEE(Food.Coffee.class);</span><br><span class="line">    <span class="keyword">private</span> Food[] values;</span><br><span class="line">    Course(Class&lt;? extends Food&gt; kind)&#123;</span><br><span class="line">        values=kind.getEnumConstants();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">randomSelection</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Enums.random(values);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是通过每个Course实例中随机地选择一个Food，我们便能生成一份菜单<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Meal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(Course course:Course.values())&#123;</span><br><span class="line">                Food food=course.randomSelection();<span class="comment">//重点在这里</span></span><br><span class="line">                System.out.println(food);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"------------------"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另一种组织枚举实例的方式，但其也有其他的一些限制，就是将一个enum嵌套在一个enum内，就像这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SecurityCatagory &#123;</span><br><span class="line">    STOCK(Security.Stock.class),BOND(Security.Bond.class);</span><br><span class="line">    Security[] values;</span><br><span class="line">    SecurityCatagory(Class&lt;? extends Security&gt; kind)&#123;</span><br><span class="line">        values=kind.getEnumConstants();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Security</span></span>&#123;</span><br><span class="line">        <span class="keyword">enum</span> Stock implements  Security&#123;SHORT,LONG,MARGIN&#125;</span><br><span class="line">        <span class="keyword">enum</span> Bond implements  Security&#123;MUNICAPAL,JUNK&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Security <span class="title">randomSelection</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Enums.random(values);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            SecurityCatagory catagory=Enums.random(SecurityCatagory.class);</span><br><span class="line">            System.out.println(catagory+<span class="string">":"</span>+</span><br><span class="line">            catagory.randomSelection());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Security接口的作用就是将其所包含的enum组合成一个公共类型，这一点是有必要的</strong>，然后SecurityCatagory才能将Security中的enum作为其构造器的参数使用，以起到组织的作用</p>
<h2 id="使用EnumSet替代标志"><a href="#使用EnumSet替代标志" class="headerlink" title="使用EnumSet替代标志"></a>使用EnumSet替代标志</h2><p>Set是一种集合，只能向其中添加不重复的对象，<strong>当然，enum也要求其成员都是唯一的，所以enum看起来也具有集合的行为，不过，由于不能从enum中删除或者添加元素，所有它只能算作不太有用的集合</strong>，Java SE5引入了EnumSet，是为了通过enum创建一种替代品，以替代传统的基于int的“位标志”，这种标志可以用来表示某种“开/关”信息，不过，使用这种标志，我们会最终操作的只是一些bit，而不是这些bit想要表达的概念，因此很容易写出令人难以理解的代码<br>EnumSet的设计充分考虑到了速度因素，就其内部而言，它（可能）就是将一个long值作为比特向量，所以EnumSet非常快速高效，使用EnumSet的优点是，它在说明一个二进制位是否存在时，具有更好的表达能力，并且无须担心性能<br>EnumSet中的元素必须来自一个enum，下面的enum表示一座大楼中，警报传感器的安放位置<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> AlarmPoints &#123;</span><br><span class="line">    START1,START2,LOBBY,OFFICE1,OFFICE2,OFFICE3,</span><br><span class="line">    OFFICE4,BATHROOM,UTILITY,KITCHEN</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后我们用EnumSet来跟着警报器的状态<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumSets</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        EnumSet&lt;AlarmPoints&gt; points=EnumSet.noneOf(AlarmPoints.class);<span class="comment">//empty set</span></span><br><span class="line">        points.add(BATHROOM);</span><br><span class="line">        System.out.println(points);</span><br><span class="line">        points.addAll(EnumSet.of(START1,START2,KITCHEN));</span><br><span class="line">        System.out.println(points);</span><br><span class="line">        points=EnumSet.allOf(AlarmPoints.class);</span><br><span class="line">        points.removeAll(EnumSet.of(START1, START2,KITCHEN));</span><br><span class="line">        System.out.println(points);</span><br><span class="line">        points.removeAll(EnumSet.range(OFFICE1,OFFICE4));</span><br><span class="line">        System.out.println(points);</span><br><span class="line">        points=EnumSet.complementOf(points);</span><br><span class="line">        System.out.println(points);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们从上面的这个例子也能看到EnumSet的一些用法，查看EnumSet的有关文档能看到多个of()的重载版本，有接受2-5个参数这样的重载版本，这里也能看到EnumSet对性能的追求<br><strong>EnumSet的基础是long</strong>,一个long值有64位，而一个enum实例只需要一位bit表示其是否存在，也就是说，在不超过一个long值的表达式的情况下，你的EnumSet可以应用与最多不超过64个元素的enum，如果超过了会怎么样？通过代码分析（这里不写），可以得出结论，EnumSet会扩容到多于一个long值<br>我们来分析下EnumSet是什么吧，很简单，EnumSet是一种类型，这种类型可以存储一个long值，这个long值上的bit可以是0或1，0表示相应enum实例不存在,1表示相应的enum实例存在，EnumSet对象间接拥有了enum实例一样，这种通过位来表示相应enum实例是否存在的方式，给了我们增删enum实例（因为Enum类型一旦建立之后，enum示例数组不能再改变了）的一个解决方案，注意，底层的enum实例并没有改变<br>我们知道了EnumSet的底层机制，也就明白了向EnumSet重复调用add()方法放入同一个enum实例将会被忽略，EnumSet的输出顺序决定于enum定义时的顺序</p>
<h2 id="使用EnumMap"><a href="#使用EnumMap" class="headerlink" title="使用EnumMap"></a>使用EnumMap</h2><p><strong>EnumMap是一种特殊的Map，它要求其中的键（key）必须来自一个enum，由于enum本身的限制，所以EnumMap在内部可由数组实现</strong>，因此EnumMap的速度很快，我们可以放心地使用enum实例在EnumMap中进行查找操作，不过我们只能将enum的实例来调用put()方法，其他操作也使用一般的Map差不多<br>下面的例子演示了命令设计模式的用法，一般来说，命令模式首先需要一个只有单一方法的接口，然后该接口实现具有不同的行为的多个子类，接下来程序员就可以构造命令对象，并在需要的时候使用它们了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> xyz.egbertday.enumerated.AlarmPoints.*;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Command</span></span>&#123;<span class="function"><span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumMaps</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        EnumMap&lt;AlarmPoints,Command&gt; em=<span class="keyword">new</span> EnumMap&lt;AlarmPoints, Command&gt;(AlarmPoints.class);</span><br><span class="line">        em.put(KITCHEN,<span class="keyword">new</span> Command()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"kitchen fire!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        em.put(BATHROOM,<span class="keyword">new</span> Command()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Bathroom alert!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;AlarmPoints,Command&gt; entry:em.entrySet())&#123;</span><br><span class="line">            System.out.println(entry.getKey());</span><br><span class="line">            entry.getValue().action();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            em.get(UTILITY).action();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的例子最后的部分说明。enum的每个实例作为一个键，总是存在的，但是，如果你没有为这个键调用put（）方法来存入相应的值的化，其对应的值就是null，与常量相关的方法有个优点就是EnumMap允许程序员改变值对象，而常量相关的方法在编译期就被固定了</p>
<h2 id="常量相关的方法"><a href="#常量相关的方法" class="headerlink" title="常量相关的方法"></a>常量相关的方法</h2><p><strong>java的enum有个非常有趣的特性，即它允许程序员为enum实例编写方法，从而为每个enum实例赋予各自不同的行为，要实现常量相关的方法，你需要为enum定义一个或多个abstract方法，然后为每个enum实例实现该抽象方法</strong><br>下面的例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ConsatantSpecificMethod &#123;</span><br><span class="line">    DATE_TIME&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function">String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> DateFormat.getDateInstance().format(<span class="keyword">new</span> Date());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    CLASSPATH&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function">String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> System.getenv(<span class="string">"CLASSPATH"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    VERSION&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function">String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> System.getProperty(<span class="string">"java.version"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> String <span class="title">getInfo</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(ConsatantSpecificMethod c:ConsatantSpecificMethod.values())&#123;</span><br><span class="line">            System.out.println(c.getInfo());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过相应的enum实例，我们可以调用其上的方法，这通常也被称为表驱动的代码<br>在面向对象的程序设计中，不同的行为与不同的类相关联，而通过常量相关的方法，每个enum实例都可以具备自己独特的方法，这时候说明每个enum实例就像是一个独特的类（实际上就是的，这个类继承自它所在的enum类）在上面的例子中，每个enum实例被当成了其“超类”ConstantSpecificMethod来使用，在调用getInfo()方法时，体现了多态的行为<br>然而，enum实例与类的相似之处也仅限与此了，我们不能真的将enum实例作为一个类型来使用，也就是说你不能这样来使用enum实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> LikeClass&#123;</span><br><span class="line">  WINKEN,BLINKEN</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(LikeClass.WINKEN instance)</span><span class="comment">//错误的</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> f（LikeClass instance）<span class="comment">//正确</span></span></span><br></pre></td></tr></table></figure></p>
<p>我们分析下编译器生成的代码能够知道这是正常的，enum元素实际上都是LikeClass类型的一个static final实例<br>同时由于它们是static实例，无法访问外部类的非static元素或方法，所有对于内部的enum的实例来说，其行为与一般的内部类并不相同（也就是说在enum类型内部定义的enum实例内部类是不能访问其外围类的非static成员的）<br>除了实现abstract方法以外，程序员是否可以覆盖常量相关的方法呢？答案是肯定的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> OverrideConstantSpecific &#123;</span><br><span class="line">    NUT,BOLT,WASHER&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Override Method"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"default behavior"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(OverrideConstantSpecific o:OverrideConstantSpecific.values())&#123;</span><br><span class="line">            o.f();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="使用enum的职责链"><a href="#使用enum的职责链" class="headerlink" title="使用enum的职责链"></a>使用enum的职责链</h3><p>在职责链（Chain of Responsibility）设计模式中，程序员以多种不同的方式来解决一个问题，然后将它们链接在一起，所以，当一个请求到来时，它遍历这个连，直到链中的某个解决方法能够处理该请求<br>通过常量相关的方法，我们很容易可以实现一个简单的职责链<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> xyz.egbertday.enumerated.Mail.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mail</span> </span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> GeneraliDelivery&#123;YES,NO1,NO2,NO3,NO4,NO5&#125;</span><br><span class="line">    <span class="keyword">enum</span> Scannablity&#123;UNSCANNABLE,YES1,YES2,YES3,YES4,YES5&#125;</span><br><span class="line">    <span class="keyword">enum</span> Readablity&#123;ILLEGIBLE,YES1,YES2,YES3,YES4&#125;</span><br><span class="line">    <span class="keyword">enum</span> Address&#123;INCORRECT,OK1,OK2,OK3,OK4,OK5,OK6&#125;</span><br><span class="line">    <span class="keyword">enum</span> ReturnAddress&#123;MISSING,OK1,OK2,OK3,OK4,OK5&#125;</span><br><span class="line">    GeneraliDelivery generaliDelivery;</span><br><span class="line">    Scannablity scannablity;</span><br><span class="line">    Readablity readablity;</span><br><span class="line">    Address address;</span><br><span class="line">    ReturnAddress returnAddress;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span> counter =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> id =counter++;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="string">"Mail"</span>+id; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">details</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> toString()+<span class="keyword">this</span>.generaliDelivery+</span><br><span class="line">                <span class="keyword">this</span>.scannablity+<span class="keyword">this</span>.readablity+</span><br><span class="line">                <span class="keyword">this</span>.address+<span class="keyword">this</span>.address;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Mail <span class="title">randomMail</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Mail mail=<span class="keyword">new</span> Mail();</span><br><span class="line">        mail.generaliDelivery=Enums.random(GeneraliDelivery.class);</span><br><span class="line">        mail.scannablity=Enums.random(Scannablity.class);</span><br><span class="line">        mail.readablity=Enums.random(Readablity.class);</span><br><span class="line">        mail.address=Enums.random(Address.class);</span><br><span class="line">        mail.returnAddress=Enums.random(ReturnAddress.class);</span><br><span class="line">        <span class="keyword">return</span> mail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Iterable&lt;Mail&gt; <span class="title">generator</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Iterable&lt;Mail&gt;()&#123;</span><br><span class="line">            <span class="keyword">int</span> n=count;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Iterator&lt;Mail&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;Mail&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> n--&gt;<span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Mail <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> randomMail();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PostOffice</span> </span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> MailHandler&#123;</span><br><span class="line">        GENERAL_DELIVERY&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">boolean</span> <span class="title">handle</span><span class="params">(Mail mail)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">switch</span>(mail.generaliDelivery)&#123;</span><br><span class="line">                    <span class="keyword">case</span> YES:</span><br><span class="line">                        System.out.println(<span class="string">"Using general delivery for"</span>+mail);</span><br><span class="line">                        <span class="keyword">return</span>  <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">default</span>:<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        MACHINE_SCAN&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">boolean</span> <span class="title">handle</span><span class="params">(Mail mail)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">switch</span> (mail.scannablity)&#123;</span><br><span class="line">                    <span class="keyword">case</span> UNSCANNABLE:<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">switch</span> (mail.address)&#123;</span><br><span class="line">                            <span class="keyword">case</span> INCORRECT:<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">default</span>:</span><br><span class="line">                                System.out.println(<span class="string">"Delivering"</span>+mail+<span class="string">"automaticaly"</span>);</span><br><span class="line">                                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        VISUAL_INSPECTION&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">boolean</span> <span class="title">handle</span><span class="params">(Mail mail)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">switch</span> (mail.readablity)&#123;</span><br><span class="line">                    <span class="keyword">case</span> ILLEGIBLE: <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        System.out.println(<span class="string">"Delivering "</span>+mail+<span class="string">"normally"</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        RETURN_TO_SENDER&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">boolean</span> <span class="title">handle</span><span class="params">(Mail mail)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">switch</span> (mail.returnAddress)&#123;</span><br><span class="line">                    <span class="keyword">case</span> MISSING:<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        System.out.println(<span class="string">"Returning "</span>+mail+<span class="string">" to sender"</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">handle</span><span class="params">(Mail mail)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Mail mail)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(MailHandler handler:MailHandler.values())&#123;</span><br><span class="line">            <span class="keyword">if</span>(handler.handle(mail))&#123;</span><br><span class="line">                <span class="keyword">return</span>;<span class="comment">//当不通过这里返回的时候,表明mail是个dead letter</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"this is a dead letter"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mian</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Mail mail:Mail.generator(<span class="number">10</span>))&#123;</span><br><span class="line">            System.out.println(mail.details());</span><br><span class="line">            handle(mail);</span><br><span class="line">            System.out.println(<span class="string">"*************"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的例子也会简单，随机生成mail对象，使用enum来实现职责链模式具有天生的优势，第一是enum.values()生成的数组是按照声明的顺序排序的，最重要的是每个enum实例都具有不同的行为（常量相关的方法）</p>
<h3 id="使用enum的状态机"><a href="#使用enum的状态机" class="headerlink" title="使用enum的状态机"></a>使用enum的状态机</h3><p>枚举类型非常适合用来创建状态机，一个专题可以具有有限个特定的状态，它通常根据输入，从一个状态转移到另一个状态，不过也可能存在瞬时状态（transient states）,而一旦任务执行结束，状态机就会立刻离开瞬时状态<br>每个状态都具有某些可接受的输入，不同的输入会使状态机从当前状态转移到不同的新状态，由于enum对其实例有严格限制，非常适合用来表现不同状态和输入，一般而言，每个状态都具有一些相关的输出<br>自动售货机是个很好的转态机的例子，首先，我们用一个enum定义各种输入<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> xyz.egbertday.enumerated.Input.*;</span><br><span class="line"><span class="keyword">enum</span> Category&#123;</span><br><span class="line">    MONEY(NICKEL,DIME,QUARTER,DOLLAR),</span><br><span class="line">    ITEM_SELECTION(TOOTHPASTE,CHIPS,SODA,SOAP),</span><br><span class="line">    QUIT_TRANSACTION(ABORT_TRANSACTION),</span><br><span class="line">    SHUT_DOWN(STOP);</span><br><span class="line">    <span class="keyword">private</span> Input[] values;</span><br><span class="line">    Category(Input... types)&#123;</span><br><span class="line">        values=types;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> EnumMap&lt;Input,Category&gt; categories=<span class="keyword">new</span> EnumMap&lt;&gt;(Input.class);</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Category category:Category.values())&#123;</span><br><span class="line">            <span class="keyword">for</span> (Input type:category.values)&#123;</span><br><span class="line">                categories.put(type,category);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Category <span class="title">categorize</span><span class="params">(Input input)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> categories.get(input);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VendingMachine</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> State state=State.RESTING;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> amount=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Input selection=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">enum</span> StateDuration&#123;TRANSIENT&#125;<span class="comment">//tagging enum</span></span><br><span class="line">    <span class="keyword">enum</span> State&#123;</span><br><span class="line">        RESTING&#123;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">(Input input)</span></span>&#123;</span><br><span class="line">                <span class="keyword">switch</span>(Category.categorize(input))&#123;</span><br><span class="line">                    <span class="keyword">case</span> MONEY:</span><br><span class="line">                        amount+=input.amount();</span><br><span class="line">                        state=ADDING_MONEY;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> SHUT_DOWN:</span><br><span class="line">                        state=TERMINAL;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        ADDING_MONEY&#123;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">(Input input)</span></span>&#123;</span><br><span class="line">                <span class="keyword">switch</span> (Category.categorize(input))&#123;</span><br><span class="line">                    <span class="keyword">case</span> MONEY:</span><br><span class="line">                        amount+=input.amount();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> ITEM_SELECTION:</span><br><span class="line">                        selection=input;</span><br><span class="line">                        <span class="keyword">if</span>(amount&lt;selection.amount())&#123;</span><br><span class="line">                            System.out.println(<span class="string">"Insufgficient money for "</span>+selection);</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            state=DISPENSING;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> QUIT_TRANSACTION:</span><br><span class="line">                        state=GIVING_CHANGE;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> SHUT_DOWN:</span><br><span class="line">                        state=TERMINAL;</span><br><span class="line">                     <span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        DISPENSING&#123;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">()</span></span>&#123;</span><br><span class="line">               System.out.println(<span class="string">"here is your "</span>+selection);</span><br><span class="line">               amount-=selection.amount();</span><br><span class="line">               state=GIVING_CHANGE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line">        GIVING_CHANGE&#123;</span><br><span class="line">             <span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                 <span class="keyword">if</span> (amount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                     System.out.println(<span class="string">"your change is:"</span> + amount);</span><br><span class="line">                     amount = <span class="number">0</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">                 state=RESTING;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        TERMINAL&#123;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>&#123;System.out.println(<span class="string">"Halted"</span>);&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> isTransient=<span class="keyword">false</span>;</span><br><span class="line">        State()&#123;&#125;</span><br><span class="line">        State(StateDuration trans)&#123; isTransient=<span class="keyword">true</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">(Input input)</span></span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">""</span> +</span><br><span class="line">                    <span class="string">"only call next() for StateDuration.non-Transient states"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">""</span> +</span><br><span class="line">                    <span class="string">"Only call next() for state Duration.transient states"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>&#123;System.out.println(amount);&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Generator&lt;Input&gt; gen)</span></span>&#123;</span><br><span class="line">         <span class="keyword">while</span>(state!=State.TERMINAL)&#123;</span><br><span class="line">             state.next(gen.next());</span><br><span class="line">             <span class="keyword">while</span>(state.isTransient)&#123;</span><br><span class="line">                 state.next();</span><br><span class="line">             &#125;</span><br><span class="line">             state.output();</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       Generator&lt;Input&gt; gen=<span class="keyword">new</span> RandomInputGenerator();</span><br><span class="line">       <span class="keyword">if</span>(args.length==<span class="number">1</span>)&#123;</span><br><span class="line">           gen=<span class="keyword">new</span> FileInputGenerator(args[<span class="number">0</span>]);</span><br><span class="line">       &#125;</span><br><span class="line">       run(gen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomInputGenerator</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">Input</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Input <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Input.randomSelection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileInputGenerator</span> <span class="keyword">implements</span>  <span class="title">Generator</span>&lt;<span class="title">Input</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Iterator&lt;String&gt; input;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileInputGenerator</span><span class="params">(String fileName)</span></span>&#123;</span><br><span class="line">        input=<span class="keyword">new</span> TextFile(fileName,<span class="string">";"</span>).iterator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Input <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!input.hasNext())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Enum.valueOf(Input.class,input.next().trim());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的售货机例子并不难，耐心看下去，很简单<br>这种设计有一个缺陷，他要求enum State实例访问的VendingMachin属性必须声明为static，这意味着，你只能有一个Vendingmachine实例,不过我们考虑一下实际（嵌入式java）应用，这也许不是什么大问题</p>
<h2 id="多路分发"><a href="#多路分发" class="headerlink" title="多路分发"></a>多路分发</h2><p>当你声明a.plus(b)时，你并不知道a或b的确切类型，那你如何能让它们正确交互呢？<br>你可能从未思考这个问题的答案，Java只支持单路分发，也就是说，如果要执行的操作包含了不止一个类型位置的对象时，那么java的的动态绑定机制只能处理其中一个的类型，这就无法解决我们上面提到的问题，所以你必须自己来判断其他的类型，从而实现自己的动态绑定行为<br>解决上面的办法就是多路分发（在上面那个例子中，只有两个分发，一般称之为两路分发）。<br>多态只能发生在方法调用时，所有，如果想使用两路分发，那么就必须有两个方法调用，第一个方法调用决定第一额未知类型，第二个方法调用第二个位置的类型，要利用多路分发，程序员必须能够为每一个类型提供一个实际的方法调用，如果你要处理两个不同的类型体系，就要为每个类型体现执行一个方法调用，一般而言，程序员需要设定好的某种配置，以便一个方法调用能够引出更多的方法调用，从而能够在这个过程中处理多种类型，为了达到这种效果，我们需要与多个犯法一同工作，因为每个分发都需要一个方法调用<br>下面是个石头剪刀布的游戏<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Outcome&#123;WIN,LOSE,DRAW&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Item</span></span>&#123;</span><br><span class="line">    <span class="function">Outcome <span class="title">compare</span><span class="params">(Item it)</span></span>;</span><br><span class="line">    <span class="function">Outcome <span class="title">eval</span><span class="params">(Paper p)</span></span>;</span><br><span class="line">    <span class="function">Outcome <span class="title">eval</span><span class="params">(Scissor s)</span></span>;</span><br><span class="line">    <span class="function">Outcome <span class="title">eval</span><span class="params">(Rock r)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Paper</span> <span class="keyword">implements</span> <span class="title">Item</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">compare</span><span class="params">(Item it)</span> </span>&#123; <span class="keyword">return</span> it.eval(<span class="keyword">this</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Paper p)</span> </span>&#123; <span class="keyword">return</span> DRAW; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Scissor s)</span> </span>&#123; <span class="keyword">return</span> LOSE; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Rock r)</span> </span>&#123; <span class="keyword">return</span> WIN; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scissor</span>  <span class="keyword">implements</span> <span class="title">Item</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">compare</span><span class="params">(Item it)</span> </span>&#123; <span class="keyword">return</span> it.eval(<span class="keyword">this</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Paper p)</span> </span>&#123; <span class="keyword">return</span> WIN; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Scissor s)</span> </span>&#123; <span class="keyword">return</span> DRAW;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Rock r)</span> </span>&#123; <span class="keyword">return</span> LOSE; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rock</span> <span class="keyword">implements</span> <span class="title">Item</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">compare</span><span class="params">(Item it)</span> </span>&#123; <span class="keyword">return</span> it.eval(<span class="keyword">this</span>); &#125;<span class="comment">//第二次分发</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Paper p)</span> </span>&#123; <span class="keyword">return</span> LOSE; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Scissor s)</span> </span>&#123; <span class="keyword">return</span> WIN ; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Rock r)</span> </span>&#123; <span class="keyword">return</span> DRAW; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoShamBo1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE=<span class="number">20</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand=<span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Item <span class="title">newItem</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (rand.nextInt(<span class="number">3</span>))&#123;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:<span class="keyword">return</span> <span class="keyword">new</span> Paper();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:<span class="keyword">return</span>  <span class="keyword">new</span> Scissor();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:<span class="keyword">return</span> <span class="keyword">new</span> Rock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">macth</span><span class="params">(Item a,Item b)</span></span>&#123;</span><br><span class="line">        System.out.println(</span><br><span class="line">           a+<span class="string">"VS"</span>+b+<span class="string">":"</span>+a.compare(b)<span class="comment">//第一次分发</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;SIZE;i++)&#123;</span><br><span class="line">            macth(newItem(),newItem());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Item是这几种类型的接口，会被用作多路分发，RoShamBo1.match()有两个Item参数，通过调用Item.compare()方法开始两路分发，要判定a的类型，分发机制会在a的实际类型的compara()内部起到分发的作用，compara()方法同eval()来为另一个类型实现第二次分发</strong>，将自身(this)作为参数调用eval()，就能调用重载过的eval()方法，这能够保留第一次分发的类型信息，当第二次分发完成时，你就能够知道两个Item对象的具体类型了<br>要配置好多路分发需要很多的工序，不过要记住，它的好处在于方法调用时的优雅的语法，这就避免了在一个方法中判断多个对象的类型的丑陋代码，你只需要说“嘿，你们两个，我不在会你们是什么类型，请你们自己交流！”</p>
<h3 id="使用enum分发"><a href="#使用enum分发" class="headerlink" title="使用enum分发"></a>使用enum分发</h3><p>我们不能直接将RoShamBo1.java翻译为基于enum的版本，因为enum实例不是类型，我没在RoShamBol通过实现接口来对类型划分可以做到，但是enum不可以，因为每个enum实例都是相应的enum类型啊，它们的类型一致，怎么能实现分发呢？不过我们还有很多方法可以实现多路分发，并从enum中获益<br><strong>一种实现多路分发的方法是使用构造器初始化每个enum实例，并以“一组”结果作为参数，这两者放在一起，形成了类似查询表的结构</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Competitor</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">Outcome <span class="title">compete</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoShamBo</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Competitor&lt;T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">match</span><span class="params">(T a,T b)</span></span>&#123;</span><br><span class="line">        System.out.println(</span><br><span class="line">           a+<span class="string">"vs"</span>+b+a.compete(b)<span class="comment">//第一次分发</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Enum&lt;T&gt; &amp; Competitor&lt;T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">(Class&lt;T&gt; type,<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            match(Enums.random(type),Enums.random(type));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RoShamBo2 implements Competitor&lt;RoShamBo2&gt; &#123;</span><br><span class="line">    PAPER(DRAW,LOSE,WIN),</span><br><span class="line">    SCISSORS(WIN,DRAW,LOSE),</span><br><span class="line">    ROCK(LOSE,WIN,DRAW);</span><br><span class="line">    <span class="keyword">private</span> Outcome vPaper,vScissors,vRock;</span><br><span class="line">    RoShamBo2(Outcome paper,Outcome sciccors,Outcome rock)&#123;</span><br><span class="line">        vPaper=paper;</span><br><span class="line">        vScissors=sciccors;</span><br><span class="line">        vRock=rock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">compete</span><span class="params">(RoShamBo2 roShamBo2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (roShamBo2)&#123;<span class="comment">//使用switch实现第二次分发</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">case</span> PAPER: <span class="keyword">return</span> vPaper;</span><br><span class="line">            <span class="keyword">case</span> SCISSORS:;<span class="keyword">return</span> vScissors;</span><br><span class="line">            <span class="keyword">case</span> ROCK:<span class="keyword">return</span> vRock;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args)</span></span>&#123;</span><br><span class="line">        RoShamBo.play(RoShamBo2.class,<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的例子更加短小，直接，容易理解，注意，这里我们仍然使用了两路分发来判断两个对象的类型，在RoShamBo1两次分发都是通过实际的方法调用实现，而在这个例子中，只有第一次分发是实际的方法调用，第二次分发使用的是switch，不过这样是安全的，因为enum限制了switch语句的选择分支</p>
<h3 id="使用常量相关的方法"><a href="#使用常量相关的方法" class="headerlink" title="使用常量相关的方法"></a>使用常量相关的方法</h3><p><strong>常量相关的方法允许我们为每个enum实例提供方法不同的实现，这使得常量相关的方法似乎是实现多路分发的完美解决方案，不过，通过这种方式，enum实例虽然可以具有不同的行为，但他们仍然不是类型，不能将其作为方法签名中的参数类型来使用，最好的办法是将enum用在switch语句中</strong></p>
<h3 id="使用EnumMap分发"><a href="#使用EnumMap分发" class="headerlink" title="使用EnumMap分发"></a>使用EnumMap分发</h3><p>使用EnumMap能够实现“真正的”两路分发，EnumMap是为Enum专门设计的一种性能非常好的特殊的Map,由于我们的目的是摸索出两种不同未知的类型，<strong>所以可以用EnumMap的EnumMap来实现两路分发</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.EnumMap;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> xyz.egbertday.enumerated.Outcome.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RoShamBo5 implements Competitor&lt;RoShamBo5&gt;&#123;</span><br><span class="line">    PAPER,SCISSORS,ROCK;</span><br><span class="line">    <span class="keyword">static</span> EnumMap&lt;RoShamBo5,EnumMap&lt;RoShamBo5,Outcome&gt;&gt; table=<span class="keyword">new</span> EnumMap&lt;&gt;(RoShamBo5.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(RoShamBo5 it:RoShamBo5.values())&#123;</span><br><span class="line">            table.put(it,<span class="keyword">new</span> EnumMap&lt;RoShamBo5, Outcome&gt;(RoShamBo5.class));</span><br><span class="line">        &#125;</span><br><span class="line">        initRow(PAPER,DRAW,LOSE,WIN);</span><br><span class="line">        initRow(SCISSORS,WIN,DRAW,LOSE);</span><br><span class="line">        initRow(ROCK,LOSE,WIN,DRAW);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initRow</span><span class="params">(RoShamBo5 it,Outcome vPaper,Outcome vScissors,Outcome vRock)</span></span>&#123;</span><br><span class="line">        EnumMap&lt;RoShamBo5,Outcome&gt; row=RoShamBo5.table.get(it);</span><br><span class="line">        row.put(RoShamBo5.PAPER,vPaper);</span><br><span class="line">        row.put(RoShamBo5.SCISSORS,vScissors);</span><br><span class="line">        row.put(RoShamBo5.ROCK,vRock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">compete</span><span class="params">(RoShamBo5 roShamBo5)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> table.get(<span class="keyword">this</span>).get(roShamBo5);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        RoShamBo.play(RoShamBo5.class,<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/19/枚举类型/" data-id="cjnzv2prp002wcorzbxripi7u" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java-I-O系统" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/19/Java-I-O系统/" class="article-date">
  <time datetime="2018-10-19T14:06:30.000Z" itemprop="datePublished">2018-10-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习心得/">学习心得</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/19/Java-I-O系统/">Java I/O系统</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>创建一个好的输入/输出(I/O)系统是一项困难的事情，挑战似乎来自于要涵盖所有的可能性，不仅存在各种I/O源端和想要与之通信的接收器（文件，控制台，网络链接等），而且还需要以各种不同的方式与它们进行通信（顺序，随机缓存，缓冲，二进制，按行，按字等）<br>自从Java 1.0版本以来，java的I/O类库发生了明显改变，在原本面向字节的类中添加了面向字符和基于Unicode的类，在JDK1.4中，添加了nio类（对于“新I/O”来说，这是一个从现在起我们将会使用多年的名称，即使它们在JDK1.4就被引用了）添加进来是为了改善性能和功能， 因此，在充分理解Java I/O系统以便正确运用它们之前，我们需要学习相当数量的类，另外，很有必要理解I/O类型的演化过程</p>
<h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><p>File是一个实用类库工具，它可以帮助我们处理文件目录问题<br>File(文件)类的名字有一定的误导性，我们可能以为它指代的是文件，实际上并非如此，它既能表示一个特定文件的名称，又能代表一个目录下的一组文件的名称，实际上，FilePath（文件路径）这个名称可能更适合它</p>
<h3 id="目录列表器"><a href="#目录列表器" class="headerlink" title="目录列表器"></a>目录列表器</h3><p>假如我们想要查看一个目录列表，可以用两种方式来使用File对象，如果我们调用不带参数的list()方法，便可以获得此File对象包含的全部列表，然而，如果我们想要获得一个受限列表，例如，想要获得所有扩展名为.java的文件，那么我们就要使用到“目录过滤器”，这个类会告诉我们怎样显示符合条件的File对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      String[] fileNames;</span><br><span class="line">      File path=<span class="keyword">new</span> File(<span class="string">"."</span>);</span><br><span class="line">      <span class="keyword">if</span>(args.length==<span class="number">0</span>)&#123;</span><br><span class="line">          fileNames=path.list();</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          fileNames=path.list(<span class="keyword">new</span> DirFilter(args[<span class="number">0</span>]));</span><br><span class="line">      &#125;</span><br><span class="line">        Arrays.sort(fileNames,String.CASE_INSENSITIVE_ORDER);</span><br><span class="line">      <span class="keyword">for</span>(String fileName:fileNames)&#123;</span><br><span class="line">          System.out.println(fileName);</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DirFilter</span> <span class="keyword">implements</span> <span class="title">FilenameFilter</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String regex;</span><br><span class="line">    Pattern pattern=Pattern.compile(regex);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DirFilter</span><span class="params">(String regex)</span></span>&#123;regex=regex;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pattern.matcher(name).matches();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>DirFile这个类存在的唯一原因就是提供accept()方法给List()方法使用，使用list()可回调accept()，进而选择以决定那些文件被包含在列表中，因此，这种结构也常常被称作回调</strong>，更具体的说，这是一个策略模式的例子，因为list()实现了基本功能，而按照FilenamFilter的形式提供这个策略，以便完善list()在提供服务是所需的算法，因为list()接受FilenameFilter对象作为参数，这意味着我们可以 传递实现了FilenameFilter接口的任何类的对象</p>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>这个例子使用匿名内部类进行改写，首先创建一个filter()方法，它会返回一个指向FilenameFilter的引用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirList2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FilenameFilter <span class="title">filter</span><span class="params">(<span class="keyword">final</span> String regex)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FilenameFilter() &#123;</span><br><span class="line">            Pattern pattern=Pattern.compile(regex);</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> pattern.matcher(name).matches();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String[] fileNames;</span><br><span class="line">        File path=<span class="keyword">new</span> File(<span class="string">"."</span>);</span><br><span class="line">        <span class="keyword">if</span>(args.length==<span class="number">0</span>)&#123;</span><br><span class="line">            fileNames=path.list();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            fileNames = path.list(filter(args[<span class="number">0</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意传递给filter的参数必须是final的，这个在匿名内部类是必需的，这样它才能使用来自该类范围之外的对象</strong><br>这个设计有所改进，因为现在FilenameFilter类紧密地和DirFilter2绑定到一起，然而，我们可以进一步修改该方法，定义一个作为list()参数的匿名内部类，这样程序会变得更小<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirList3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span></span>&#123;<span class="comment">//传递给匿名内部类的参数使用final修饰</span></span><br><span class="line">        String[] fileNames;</span><br><span class="line">        File path= <span class="keyword">new</span> File(<span class="string">"."</span>);</span><br><span class="line">        <span class="keyword">if</span>(args.length==<span class="number">0</span>)&#123;</span><br><span class="line">            fileNames=path.list();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            fileNames=path.list(<span class="keyword">new</span> FilenameFilter() &#123;</span><br><span class="line">                Pattern pattern=Pattern.compile(args[<span class="number">0</span>]);</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> pattern.matcher(name).matches();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(String fileName:fileNames)&#123;</span><br><span class="line">            System.out.println(fileName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="目录实用工具"><a href="#目录实用工具" class="headerlink" title="目录实用工具"></a>目录实用工具</h3><p>程序设计中的一项常见的任务就是在文件集上执行操作，这些文件要么在本地目录中，要么遍布于整个目录树中，如果你有一种工具能够为你产生这个文件集，那么它会非常有用，下面的实用工具类就是通过使用list()方法产生由本地目录中的文件构成的File对象数组，或者通过使用walk()方法产生给目录下的由整个目录树中所有的文件构成的List<file>（File文件比对象更有用，因为File对象包含更多信息），下面的这些文件时基于你的正则表达式被选中的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Directory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> File[] local(File dir,<span class="keyword">final</span> String regex)&#123;</span><br><span class="line">        <span class="keyword">return</span> dir.listFiles(<span class="keyword">new</span> FilenameFilter() &#123;</span><br><span class="line">            Pattern pattern=Pattern.compile(regex);</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> pattern.matcher(name).matches();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> File[] local(String path,String regex)&#123;</span><br><span class="line">        <span class="keyword">return</span> local(<span class="keyword">new</span> File(path),regex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeInfo</span> <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">File</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> List&lt;File&gt; files =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">public</span> List&lt;File&gt; dirs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="meta">@NotNull</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Iterator&lt;File&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> files.iterator();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">(TreeInfo other)</span></span>&#123;</span><br><span class="line">            files.addAll(other.files);</span><br><span class="line">            dirs.addAll(other.dirs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"dirs"</span>+PPrint.pformat(dirs)+<span class="string">"\n\nfiles"</span>+PPrint.pformat(files);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeInfo <span class="title">walk</span><span class="params">(File start,String regex)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  recurseDirs(start,regex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeInfo <span class="title">walk</span><span class="params">(String path,String regex)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  recurseDirs(<span class="keyword">new</span> File(path),regex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeInfo <span class="title">walk</span><span class="params">(File start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> recurseDirs(start,<span class="string">".*"</span>);<span class="comment">//Everything</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeInfo <span class="title">walk</span><span class="params">(String startPath)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  recurseDirs(<span class="keyword">new</span> File(startPath),<span class="string">".*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> TreeInfo <span class="title">recurseDirs</span><span class="params">(File startDir,String regex)</span></span>&#123;</span><br><span class="line">        TreeInfo result = <span class="keyword">new</span> TreeInfo();</span><br><span class="line">        <span class="keyword">for</span>(File item:startDir.listFiles())&#123;</span><br><span class="line">            <span class="keyword">if</span>(item.isDirectory())&#123;</span><br><span class="line">                result.dirs.add(item);</span><br><span class="line">                recurseDirs(item,regex);<span class="comment">//递归调用</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(item.getName().matches(regex))&#123;</span><br><span class="line">                    result.files.add(item);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></file></p>
<p>上面的代码实现了收集一个目录数的信息，这里使用listFile()产生File数组，这个方法还可以接收一个目录FilenameFilter，我们得到File数组之后，对File数组遍历判断File是目录还是文件，若是目录则递归执行这个方法<br>我们还可以更进一步，创建一个工具，它可以在目录中穿行，并且根据Stratagy对象来处理这些目录中的文件（这是策略模式的另一个示例）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessFile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(File file)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line">    <span class="keyword">private</span> String ext;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProcessFile</span><span class="params">(Strategy strategy,String ext)</span></span>&#123;</span><br><span class="line">        strategy=strategy;</span><br><span class="line">        ext=ext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(args.length==<span class="number">0</span>)&#123;</span><br><span class="line">               processDirectoryTree(<span class="keyword">new</span> File(<span class="string">"."</span>));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(String arg:args)&#123;</span><br><span class="line">                    File fileArg=<span class="keyword">new</span> File(arg);</span><br><span class="line">                    <span class="keyword">if</span>(fileArg.isDirectory())&#123;</span><br><span class="line">                        processDirectoryTree(fileArg);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">if</span>(!arg.endsWith(<span class="string">"."</span>+ext))&#123;</span><br><span class="line">                            arg+=<span class="string">"."</span>+ext;</span><br><span class="line">                            strategy.process(<span class="keyword">new</span> File(arg).getCanonicalFile());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processDirectoryTree</span><span class="params">(File root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(File file:Directory.walk(root.getAbsolutePath(),<span class="string">".*\\."</span>+ext))&#123;</span><br><span class="line">            strategy.process(file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       <span class="keyword">new</span> ProcessFile(<span class="keyword">new</span> ProcessFile.Strategy()&#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">               System.out.println(file.getName());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,<span class="string">"java"</span>).start(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="目录的检查和创建"><a href="#目录的检查和创建" class="headerlink" title="目录的检查和创建"></a>目录的检查和创建</h3><p>File类不仅仅只是代表存在的文件或目录，也可以用File对象来创建新的目录或尚不存在的整个目录路径，我们还可以查看文件的特性（如大小，最后修改日期，读/写），检查某个File对象代表的是文件还是目录，并可以删除文件，下面的示例展示了File类的一些其他的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fileData</span><span class="params">(File f)</span></span>&#123;</span><br><span class="line">        System.out.println(</span><br><span class="line">                <span class="string">"Absolate path"</span>+f.getAbsolutePath()+</span><br><span class="line">                 <span class="string">"\n Can read:"</span>+f.canRead()+</span><br><span class="line">                 <span class="string">"\n Can write"</span>+f.canWrite()+</span><br><span class="line">                 <span class="string">"\n getName"</span>+f.getName()+</span><br><span class="line">                <span class="string">"\n getPath"</span>+f.getPath()+</span><br><span class="line">                 <span class="string">"\n getParent"</span>+f.getParent()+</span><br><span class="line">                 <span class="string">"\n length"</span>+f.length()+</span><br><span class="line">                 <span class="string">"\n lastModified"</span>+f.lastModified()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args.length&lt;<span class="number">1</span>)</span><br><span class="line">            usage();</span><br><span class="line">        <span class="keyword">if</span> (args[<span class="number">0</span>].equals(<span class="string">"-r"</span>))&#123;</span><br><span class="line">            <span class="keyword">if</span>(args.length!=<span class="number">3</span>)</span><br><span class="line">                usage();</span><br><span class="line">            File old=<span class="keyword">new</span> File(args[<span class="number">1</span>]);</span><br><span class="line">            File rname=<span class="keyword">new</span> File(args[<span class="number">2</span>]);</span><br><span class="line">            old.renameTo(rname);</span><br><span class="line">            fileData(old);</span><br><span class="line">            fileData(rname);</span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">//exit main</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> del=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(args[<span class="number">0</span>].equals(<span class="string">"-d"</span>))&#123;</span><br><span class="line">            count++;</span><br><span class="line">            del=<span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">while</span>(++count &lt; args.length)&#123;</span><br><span class="line">            File f=<span class="keyword">new</span> File(args[count]);</span><br><span class="line">            <span class="keyword">if</span>(f.exists())&#123;</span><br><span class="line">                System.out.println(f+<span class="string">" exsits"</span>);</span><br><span class="line">                <span class="keyword">if</span> (del)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"deleting..."</span>+f);</span><br><span class="line">                    f.delete();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(!del)&#123;</span><br><span class="line">                    f.mkdir();</span><br><span class="line">                    System.out.println(<span class="string">"Create"</span>+f);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            fileData(f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>renameTo()，用来将一个文件重命名（或移动）到由参数所指示的另一个完全不同的新路径（也就是另一个File对象），</p>
<h2 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h2><p><strong>编程语言的I/O类库中经常使用流这个概念，它代表任何又能及产出数据的数据源对象或者有能力接收数据的接收端对象，流屏蔽了实际的I/O设备中处理数据的细节</strong><br>java类库的I/O类分为输入和输出两部分，可以在java的JDK文档里的层次结构中查看到，<strong>通过继承，任何自InputStreanm或Reader派生而来的类都含有名字为read的基本方法</strong>，用于读取单个字节或者字节数组，同样，任何自OutputStream或Writer派生而来的类都包含有名为write()的基本方法，用于写单个字节或者字节数组，但是，我们通常不会用到这些方法，它们之所以存在是因为别的类可以使用它们，以便提供更有用的接口，因此，我们还少使用单一的类来创建流对象，而是通过叠加多个对象来提供期望的功能，这就是装饰器设计模式，java的流类库让人困惑的一点就是：创建单一的结果流却需要创建多个对象<br>按照这些类的功能对它们进行分类，在java1.0中，类库的设计者首先限定与输入有关的所有类都应该从InputStream继承，而与输出有关的类都应该从OutputStream继承</p>
<h3 id="InputStream类型"><a href="#InputStream类型" class="headerlink" title="InputStream类型"></a>InputStream类型</h3><p>InputStream的作用就是用来表示那些从不同数据源产生输入的类，这些数据源包括</p>
<ol>
<li>字节数组</li>
<li>String对象</li>
<li>文件</li>
<li>“管道”</li>
<li>一个由其他种类的流组成的序列，以便我们可以将它们收集合并到一个流内</li>
<li>其他数据源，如Internet连接等</li>
</ol>
<p><strong>每一种数据源都有相应的InputStream</strong>，另外，FilterInputStream也属于一种InputStream，为“装饰器”类提供基类，其中“装饰器”可以把有用的属性和接口与输入流连接在一起<br>|：InputStream类型：|</p>
<table>
<thead>
<tr>
<th></th>
<th>:类:</th>
<th>：功能：</th>
<th>：构造器参数/如何使用：</th>
</tr>
</thead>
<tbody>
<tr>
<td>ByteArrayInputStream</td>
<td>允许将内存的缓冲区当作InputStream使用</td>
<td>缓冲区，字节将从中取出<br>作为一种数据源：将其与FilterInputStrea对象相连以提供有用的接口</td>
</tr>
<tr>
<td>StringInputStream</td>
<td>将String转换成InputStream</td>
<td>字符串，底层实现实际使用StringBuffer<br>作为一种数据源：将其与FilterInputStream对象相连以提供有用的接口</td>
</tr>
<tr>
<td>FileInputStream</td>
<td>用于从文件中读取信息</td>
<td>字符串：表示文件名，文件或FileDescriptor对象<br>作为一种数据源：将其与FilterInputStream对象相连以提供有用的接口</td>
</tr>
<tr>
<td>PipedInputStream</td>
<td>产生用于写入相关PipedInputStream的数据，实现“管道化”概念</td>
<td>PipedOutputStream<br>作为多线程中数据源：将其与FilterInputStream对象相连以提供有用的接口</td>
</tr>
<tr>
<td>SequenceInputStream</td>
<td>将两个或多个InputStream对象转换成单一的InputStream</td>
<td>两个InputStream对象或一个容纳InputStream对象的容器Enumation<br>作为一种数据源，将其与FilterInputStream对象相连以提供有用的接口</td>
</tr>
<tr>
<td>FilterInputStream</td>
<td>抽象类，作为“装饰器”的接口，其中“装饰器”为其他的类提供有用的功能</td>
<td>详情查看实现FilterInputStream的类</td>
</tr>
</tbody>
</table>
<h3 id="OutputStream类型"><a href="#OutputStream类型" class="headerlink" title="OutputStream类型"></a>OutputStream类型</h3><p>该类别决定了输出所要去往的目标：字节数组（但不是String，不过你当然可以用字节数组自己创建），文件或管道<br>另外，FilterOutputStream为“装饰器”类提供了一个基类，“装饰器”类把属性或者有用的接口与输出流连接了起来<br>|：OutputStream类型：|</p>
<table>
<thead>
<tr>
<th></th>
<th>：类：</th>
<th>：功能：</th>
<th>：构造器参数/如何使用：</th>
</tr>
</thead>
<tbody>
<tr>
<td>ByteArrayOutoputStream</td>
<td>在内存中创建缓冲区，所有送往“流”的数据都要放置在此缓冲区内</td>
<td>缓冲区初始化尺寸（可选的）<br>用于指定数据的目的地：将其与FilterOutputStream对象相连以提供有用接口</td>
</tr>
<tr>
<td>FileOutputStream</td>
<td>用于将信息写至文件</td>
<td>字符串，表示文件名，文件或者FileDiscriptor<br>指定数据的目的地：将其与FilterOutputStream对象相连以提供有用接口</td>
</tr>
<tr>
<td>PipeOutputStream</td>
<td>任何写入其中的信息都会自动作为相关PipedInputStream的输出，实现”管道化”概念</td>
<td>PidedInputStream<br>指定用于多线程的数据的目的地：将其与FilterOutStream对象相连以提供有用的接口</td>
</tr>
<tr>
<td>FilterOutputStream</td>
<td>抽象类，作为“装饰器”的接口，其中“装饰器”为其他OutputStream提供有用的功能</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="添加属性和有用的接口"><a href="#添加属性和有用的接口" class="headerlink" title="添加属性和有用的接口"></a>添加属性和有用的接口</h2><p><strong>java的I/O类库需要多种不同功能的组合，这正是装饰器模式的理由所在</strong>，这也正是java I/O类库中存在filter（过滤器）类的原因所在，抽象类filter是所有装饰器类的基类，装饰器必须具有和它所装饰的对象相同的接口，但也可以扩展接口，而这种情况只发生在个别的filter类中<br>装饰器的一个缺点，在编写代码的时候，它给了我们很大的灵活性（因为我们很容易混合和匹配属性），但是它同时也增加了代码的复杂性，Java I/O类库操作不便的原因在于:我们必须创建很多类——“核心”I/O类型加上所有的装饰器，才能得到我们所需要单个I/O对象<br>FilterInputStream和FilterOutputStream是用来提供装饰器类接口以控制特定输入流和输出流的两个类，它们的名字不是很直观，它们是直接子I/O类库中的InputStream和OutPutStream派生而来，这两个类是装饰器的必要条件（以便能为所有正在被修饰的对象提供通用的接口）</p>
<h3 id="通过FilterInputStream和InputStream读取数据"><a href="#通过FilterInputStream和InputStream读取数据" class="headerlink" title="通过FilterInputStream和InputStream读取数据"></a>通过FilterInputStream和InputStream读取数据</h3><p>FilterInputStream类能够完成两件完全不同的事情，其中，DataInputStream允许我们读取不同的基本类型数据以及String对象（所有方法都以“read”开头，例如readByte(),readFloat()等等）搭配相应的DataOutPutStream，我们可以通过数据“流”将基本类型的数据从一个地方迁移到另一个地方<br>其他FilterInputStream类则在内部修改InputStream的行为方式：是否缓冲，是否保留它所读过的行（允许我们查询行数或设置行数），以及是否把单一字符推回输入流等等，最后两个类看起来就像是为了创建一个编译器（它们被添加进来可能是为了对“用java构建编译器”实验提供支持），因此我们在一般的编程不会用到它们<br>|:FilterInputStream:|</p>
<table>
<thead>
<tr>
<th></th>
<th>：类：</th>
<th>：功能：</th>
<th>：构造器参数/如何使用：</th>
</tr>
</thead>
<tbody>
<tr>
<td>DataInputStream</td>
<td>与DataOutputStream搭配使用，因此我们可以按照可移植方式从流读取基本数据类型（int,cahr,long等）</td>
<td>InputStream<br>包含用于读取基本类型数据的全部接口</td>
</tr>
<tr>
<td>BufferInputStream</td>
<td>使用它可以防止每次读取都得进行实际写操作，代表“使用缓冲区”</td>
<td>InputStream<br>本质上不提供接口，只不过是向进程中添加缓冲区所必需的，与接口对象搭配</td>
</tr>
<tr>
<td>LineNubmberInputStream</td>
<td>跟踪输入流中的行为，可调用getLineNumber()和setLineNumber(int)</td>
<td>InputStream<br>仅增加了行号，因此可能要与接口对象搭配使用</td>
</tr>
<tr>
<td>PushbackInputStream</td>
<td>具有“能弹出一个字节的缓冲区”，因此可以将读到的最后一个字符回退</td>
<td>InputStream<br>通常作为编译器的扫描器，之所以包含在内是因为java编译器的需要，我们可能永远不会用到</td>
</tr>
</tbody>
</table>
<h3 id="通过FilterOutputStream和OutputStream写入数据"><a href="#通过FilterOutputStream和OutputStream写入数据" class="headerlink" title="通过FilterOutputStream和OutputStream写入数据"></a>通过FilterOutputStream和OutputStream写入数据</h3><p>与DataInputStream对应的是DateOutPut，它可以将各种基本类型数据以及String对象格式化输出到“流”中，这样以来，任何在机器上的人任何DataInputStream都能读取它们，所有方法都是以“write”开头，例如writeByte().writeFloat()等<br>PrintStream最初的目的便是为了可以以可视化格式打印所有的基本类型以及String对象，这和DataOutputStream不同，后者的目的是将数据元素置入“流”中，使得DataInputStream能够可移植地重构它们<br>PrintStream内有两个重要的方法：print(),println(),对它们进行重载，以便可打印出各种数据类型，print()和println()之间的差异，后者是在操作完毕后添加一个换行符<br>PrintStream可能会有一些问题，因为它们捕捉了所有的IOExceptions（因此，我们必须使用checkError()自行检测错误状态，如果出现错误它返回true），另外，PrintStrea也未完全国际化，不能以平台无关的方式处理换行动作（这些问题在printWriter得到了解决）<br>BuferredOutputStream是一个修改过的OutputStream，它对数据流使用缓冲技术，因此当每次向流写入时，不必每次都进行实际的物理写动作，所以在进行输出时，我们可能更经常的使用它</p>
<p>|:FilterOutputStream:|</p>
<table>
<thead>
<tr>
<th></th>
<th>：类：</th>
<th>：功能：</th>
<th>：构造器参数/如何使用：</th>
</tr>
</thead>
<tbody>
<tr>
<td>DataOutputStream</td>
<td>与DataInputStream搭配使用，因此可以按照可移植方式向流中写入基本类型数据（int char long等）</td>
<td>OutputStream<br></td>
</tr>
</tbody>
</table>
<p>包含用于写入基本类型数据的全部接口<br>PrintStream|用于产生格式化输出，其中DataOutStream处理数据的存储，PrintStream处理显示|OutputStream<br>可以用boolean值指示是否在每次换行时清空缓冲区（可选的）应该是对OutputStream对象的“final”封装，可能会经常使用它<br>BufferedOutputStream|使用它以避免每次发送数据时都要进行实际的写操作，代表“使用缓冲区”可以调用flush()清空缓冲区|OutputStream可以指定缓冲区大小（可选）<br>本质上并不提供接口，只不过是向进程中添加缓冲区所必需的，与接口对象搭配</p>
<h2 id="Reader和Writer"><a href="#Reader和Writer" class="headerlink" title="Reader和Writer"></a>Reader和Writer</h2><p>java1.1对基本的I/O流类型进行了重大的修改，当我们初次看到Reader和Writer类时，可能会认为这两个类时取代InputStream和OutputStream的类，但实际上并不是如此，尽管员I/O类库中的一些类已经被废弃，但是InputStream和OutputStream在以面向字节形式的I/O中仍可以提供极其有价值的功能，Reader和Writer则提供兼容Unicode与面向字符的I/O功能，另外：</p>
<ol>
<li>java1.1向InputStream和OutputStream继承结构中添加了一些新类，所有显然这两个类时不会被取代的</li>
<li>有时我们必须要把来自于“字节”层次结构中的类和“字符”层次结构中的类结合起来使用，为了实现这个目的，就要使用“适配器（adapter）”类：InputStreamReader可以将InputStream转换为Reader，而OutStreamWriter可以把OutputStream转换为Writer<br>设计Reader和Writer继承层次结构主要是为了国际化，老的I/O流继承层次结构仅支持8位字节流，并且不能很好地处理16位的Unicode字符，由于Unicode用于字符国际化（java本身的char也是16位的Unicode），所以添加Reader和Writer继承层次结构是为了在所以的I/O操作中都支持Unicode，另外，新类库的设计使得它的操作比旧类库更快<h3 id="数据的来源和去处"><a href="#数据的来源和去处" class="headerlink" title="数据的来源和去处"></a>数据的来源和去处</h3>几乎所有原始的java I/O流类都有相应的Reader和Writer类来提供天然的Unicode操作<br>然而在某些场合，面向字节的InputStream和OutputStream才是正确的解决方案，特别是，java.util,zip类库就是面向字节的而不是面向字符的，因此，最明智的做法是尽量尝试使用Reader和Writer，一旦程序代码无法编译成功，我们就会发现自己不得不使用面向字节的类型<br>下面展示了两个继承结构中，信息的来源和去处（即数据物理上来自哪里及去向哪里）之间的对应关系</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>来源与去处：java 1.0类</th>
<th>相应的java 1.1类</th>
</tr>
</thead>
<tbody>
<tr>
<td>InputStream</td>
<td>Reader<br>适配器：InputStreamReader</td>
</tr>
<tr>
<td>OutputStream</td>
<td>Writer<br>适配器：OutputStreamWriter</td>
</tr>
<tr>
<td>FileInputStream</td>
<td>FileReader</td>
</tr>
<tr>
<td>FileOutoutStream</td>
<td>FileWriter</td>
</tr>
<tr>
<td>StringBufferInputStream（已废弃）</td>
<td>StringReader</td>
</tr>
<tr>
<td>无相应的类</td>
<td>StringWriter</td>
</tr>
<tr>
<td>ByteArrayInputStream</td>
<td>CharArrayReader</td>
</tr>
<tr>
<td>ByteArrayOutputStream</td>
<td>CharArrayWriter</td>
</tr>
<tr>
<td>PipedInputStream</td>
<td>PipedReader</td>
</tr>
<tr>
<td>PipedOutputStream</td>
<td>PipedWriter</td>
</tr>
</tbody>
</table>
<h3 id="更改流的行为"><a href="#更改流的行为" class="headerlink" title="更改流的行为"></a>更改流的行为</h3><p>对于InputStream和OutPutStream来说，我们会使用FilterInputStream和FilterOutputStream的装饰器子类来“修改”流，以满足特殊需要。Reader和Writer的类继承层次结构继续沿用相同的思想——但是并不完全相同<br>下表，相对于前一个表格来说，左右之间的对应关系的近似程度更加粗略一些，造成这种差别的主要原因是因为类的组织形式的不同，：尽管BufferedOutputStream是FilterOutputStream的子类，但是BufferedEriter并不是FilterWriter的子类（尽管FilterWriter是抽象类，但是它没有任何子类，把它放在这里也只是把它作为一个占位符，或仅仅让我们不会对它所在的地方产生疑惑），然而这些类的接口却十分相似</p>
<table>
<thead>
<tr>
<th></th>
<th>过滤器： java 1.0类</th>
<th>相应的 Java 1.1类</th>
</tr>
</thead>
<tbody>
<tr>
<td>FilterInputStream</td>
<td>FilterReader</td>
</tr>
<tr>
<td>FilterOutputStream</td>
<td>FilterWriter(抽象类，没有子类)</td>
</tr>
<tr>
<td>BufferedInputStream</td>
<td>BufferedRaeder(也有readLine())</td>
</tr>
<tr>
<td>BufferdeOutStream</td>
<td>BufferedWriter</td>
</tr>
<tr>
<td>DataInputStream</td>
<td>使用DateInputStream（除了当需要使用readLIne()时以外，这时应该使用BufferReader）</td>
</tr>
<tr>
<td>PrintStream</td>
<td>PrintWriter</td>
</tr>
<tr>
<td>LineNumberInputStream(已弃用)</td>
<td>LineNumberReader</td>
</tr>
<tr>
<td>StreamTokenizer</td>
<td>StreamTokenizer（使用接受Reader的构造器）</td>
</tr>
<tr>
<td>PushBackInputStream</td>
<td>PushBackReader</td>
</tr>
</tbody>
</table>
<p>有一点很清楚，无论何时使用readLine(),都不应该使用DataInputStream(这会遭到编译器的强烈反对)，而应该使用BufferedReader,除了这一点，DataInputStream仍是I/O的首先成员</p>
<p>为了更容易过渡到使用PrintWriter,它提供了既能接受Writer对象又能接受任何OutputStream对象的构造器，PrintWriter的格式化接口实际上与PrintStream相同<br>在java Se5中添加了PrintWriter构造器，以简化在将输出写入时的文件创建过程<br>有一种PrintWriter构造器还有一个选项，就是“自动执行清空”选项，如果构造器设置此选项，即每个println()执行之后，便会自动清空</p>
<h3 id="未发生变化的类"><a href="#未发生变化的类" class="headerlink" title="未发生变化的类"></a>未发生变化的类</h3><p>有一些类在java1.0和java 1.1之间则未做改变</p>
<h2 id="以下这些java1-0类在java1-1中没有相应类"><a href="#以下这些java1-0类在java1-1中没有相应类" class="headerlink" title="|以下这些java1.0类在java1.1中没有相应类|"></a>|以下这些java1.0类在java1.1中没有相应类|</h2><p>|DataOutStream|<br>|File|<br>RandomAccessFile|<br>SequenceInputStream|</p>
<h2 id="自我独立的类：RandomAccessFile"><a href="#自我独立的类：RandomAccessFile" class="headerlink" title="自我独立的类：RandomAccessFile"></a>自我独立的类：RandomAccessFile</h2><p>RandomAccessFile适用于由大小已知的记录组成的文件，所以我们可以使用seek()将记录从一处转移到另一处，然后读取或者修改记录，文件中记录的大小不一定相同，只要我们能够确定那些记录有多大以及它们在文件中的位置即可<br>RandomAccessFile不是InputStream或者OutputStream继承层次结构的一部分，除了实现DataInput和DateOutput（DataInputStream和DataOutputStream也实现了这两个接口）两个接口之外，他和这两个继承层次没什么关联，它甚至不使用InputStream和OutputStream类中已有的功能，它是完全独立的类，从头开始编写其所有的方法（大多是本地方法）这么做是因为RandomAccessFile拥有和别的I/O类型本质的不同的行为，因为我们可以在文件内向前或者向后移动，在任何情况下，它都是自我独立的，直接从Object继承<br>从本质上来说，RandomAccessFile的工作方式类似于把DataInputStream和DataOutputStream组合起来，还添加了一些地方，例如getFilePointer(),seek(),length()，另外，其构造器还接受第二个参数用来指示我们只是“随即读”（r）还是“既读又写”（rw）</p>
<h2 id="I-O流的典型用法"><a href="#I-O流的典型用法" class="headerlink" title="I/O流的典型用法"></a>I/O流的典型用法</h2><h3 id="缓冲输入文件"><a href="#缓冲输入文件" class="headerlink" title="缓冲输入文件"></a>缓冲输入文件</h3><p>如果想要打开一个文件用于字符输入，可以使用以String或File对象作为文件名的FileInputReader，为了提高速度，我们希望对那个文件可以缓冲，那么我们将所产生的引用传给一个BuffredReader构造器，由于BufferedReader也提供readLine()方法，所以这是我们最终的对象和进行读取的接口，当readLine()返回null的时候，你就达到了文件的结尾<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedInputFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">read</span> <span class="params">(String fileName)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        BufferedReader br=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(fileName));</span><br><span class="line">        String s;</span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>((s=br.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            sb.append(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.out.println(read(<span class="string">"BufferedInputFlie.java"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="从内存输入"><a href="#从内存输入" class="headerlink" title="从内存输入"></a>从内存输入</h3><p>下面的示例，从BufferedInputFile.read()读入的String结果被用来创建一个StringReader，然后调用read()每次读取一个字符，并将它发送到控制台<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryInput</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        StringReader in=<span class="keyword">new</span> StringReader(BufferedInputFile.read(<span class="string">"MemoryInput.java"</span>));</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">        <span class="keyword">while</span>((c=in.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>)c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~</span><br></pre></td></tr></table></figure></p>
<h3 id="格式化的内存输入"><a href="#格式化的内存输入" class="headerlink" title="格式化的内存输入"></a>格式化的内存输入</h3><p>要读取格式化数据，可以使用DataInputStream,它是一个面向字节的I/O类（不是面向字符的），因此我们必须使用InputStream类而不是Reader类，当然我们可以用InputStream以字节的形式读取任何数据（例如一个文件），不过，在这里我们使用的是字符串<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FormattedMemoryInput</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DataInputStream in = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">                    <span class="keyword">new</span> ByteArrayInputStream(</span><br><span class="line">                            BufferedInputFile.read(<span class="string">"FormattedMemoryInput.java"</span>).getBytes()</span><br><span class="line">                    ));</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                System.out.println((<span class="keyword">char</span>)in.readByte());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.err.println(<span class="string">"end of stream"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果我们一次一个字节地读取字符，那么任何字节的值都是合法的结果，因此返回值不能用来检测输入是否结束，相反，我们可以使用available()方法查看还有多少个可供存取的字符，下面这个例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEOF</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        DataInputStream in=<span class="keyword">new</span> DataInputStream(</span><br><span class="line">                <span class="keyword">new</span> ByteArrayInputStream(</span><br><span class="line">                        BufferedInputFile.read(<span class="string">"TestEOF.java"</span>).getBytes()</span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">while</span>(in.available()!=<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>) (in.read()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意，available()的工作方式会随着所读取的媒介类型的不同而有所不同</strong>，字面意思就是在没有阻塞的情况下所能读取的字节数，对于文件，这意味着整个文件，但是对于不同的类型的流，可能就不是这样，所以要谨慎使用<br>我们也可以通过捕获异常来检测输入的末尾，就像前一个例子，但是，使用异常进行流控制，被认为是对异常特性的错误使用</p>
<h3 id="基本的文件输出"><a href="#基本的文件输出" class="headerlink" title="基本的文件输出"></a>基本的文件输出</h3><p>FileWriter可以向文件写入数据，首先，创建一个与指定文件连接的FileWriter，通常我们会使用BufferedWriter将其包装起来用以缓冲输出（尝试移除此包装来感受对性能的影响——缓冲往往能够显著地添加I/O操作的性能），在本例，为了提供格式化机制，它被装饰成了PrintWriter，按照这种方式创建的数据文件可作为普通文本文件读取<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicFileOutput</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String file=<span class="string">"BasicFileOutput.out"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        BufferedReader in=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> StringReader(</span><br><span class="line">                <span class="keyword">new</span> BufferedInputFile().read(<span class="string">"BasicFileOutput.java"</span>)</span><br><span class="line">        ));</span><br><span class="line">        PrintWriter out=<span class="keyword">new</span> PrintWriter(</span><br><span class="line">          <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(file))</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">int</span> linecount=<span class="number">1</span>;</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span>((line=in.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            out.print(linecount++ +<span class="string">":"</span>+line);</span><br><span class="line">        &#125;</span><br><span class="line">        out.close();<span class="comment">//关闭流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个例子中当文本写入文件时，行号就会增加，注意并未使用到LineNumberInputStream，因为这个类没有太大帮助，所以我们没必要使用它<br>一旦读完输入数据流，readLine()就会返回null,<strong>我们可以看到要为out显示调用close()，如果我们不为所有的输出文件调用close()，就会发现缓冲区内容不会被刷新清空，那么它们也就不完整</strong></p>
<h4 id="文本文件输出的快捷方式"><a href="#文本文件输出的快捷方式" class="headerlink" title="文本文件输出的快捷方式"></a>文本文件输出的快捷方式</h4><p><strong>Java Se5在PrintWriter中添加了一个辅助构造器，使得你不必在每次希望创建文本文件并向其中写入时，都要执行后面所有的装饰工作</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PrintWriter out=<span class="keyword">new</span> PrintWriter(String fileName)</span><br></pre></td></tr></table></figure></p>
<p>你仍然使用了缓冲，只是你不必自己去实现，遗憾的是，其他常见的写入任务都没有这样的快捷方式，但是我们可以创建工具类来使得使用流变得更为简单</p>
<h3 id="存储和恢复数据"><a href="#存储和恢复数据" class="headerlink" title="存储和恢复数据"></a>存储和恢复数据</h3><p>PrintWriter可以对数据进行格式化，以便人们的阅读，但是为了输出可供另一个“流”恢复的数据，我们需要用到DataOutputStream写入数据和DataInputStream恢复数据，当然，这些流可以是任何形式，注意DataOutoutStream和DataInputStream是面向字节的，因此要使用InputStream和OutputStream<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StoringAndRecoveringData</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        DataOutputStream out=<span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> BufferedOutputStream(</span><br><span class="line">                <span class="keyword">new</span> FileOutputStream(<span class="string">"Data.txt"</span>)</span><br><span class="line">        ));</span><br><span class="line">        out.writeDouble(<span class="number">3.14159</span>);</span><br><span class="line">        out.writeUTF(<span class="string">"this is a Pi"</span>);</span><br><span class="line">        out.writeDouble(<span class="number">1.41413</span>);</span><br><span class="line">        out.writeUTF(<span class="string">"Square of pi"</span>);</span><br><span class="line">        out.close();</span><br><span class="line">        DataInputStream in=<span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                <span class="keyword">new</span> FileInputStream(<span class="string">"Data.txt"</span>)</span><br><span class="line">        ));</span><br><span class="line">        System.out.println(in.readDouble());</span><br><span class="line">        System.out.println(in.readUTF());</span><br><span class="line">        System.out.println(in.readDouble());</span><br><span class="line">        System.out.println(in.readUTF());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>如果我们使用DataOutputStream写入数据，Java保证我们可以使用DataInputStream准确地读取数据——无论读和写数据的平台多么不同</strong>这是有价值的，人们曾加花费大量的精力处理特定平台的数据问题，只要两个平台上都有Java，这个问题就不会再发生<br>当我们使用DataOutputStream时，写字符串并且让DataInputStream能够恢复它的唯一可靠的做法就是使用UTF-8编码，在上面的示例中是通过writeUTF()和readUTF()实现的，UTF-8是一种多字节格式，其编码长度更加实际使用的字符集会有所变化，UTF-8将ASCII字符编码成单一字节的形式，而非ASCII字符则编码成两个或三个字节，例如汉字字符，另外字符串的长度存储在UTF-8字符串的前两个字节中（所有也就能知道字符串最长能够保存的字符长度了），但是，writeUTF()和readUTF()使用的是适合于Java的变体，因此我们用一个非java的程序取用writeUTF()所写的字符串时，必须编写一些特殊代码才能正确读取字符串<br>有了DataOutputStream的各种write()方法，我们就可以将字符串和其他数据类型混合，并且可以很容易地使用DataInputStream来恢复它<br>但是为了保证所有的读方法都能够正常工作，我们必须知道流中数据所在的位置和类型，因为极有可能将保存的double数据当成char或者其他类型读取，这会产生问题，有两个解决办法</p>
<ol>
<li>为文件中的数据采用固定的格式，这种方式我们就能够确定每个位置上的数据类型是什么了</li>
<li>将数据的信息保存在文件中，以便能够对其进行解析以确定数据的存放位置<br>但是，对象化和XML可能是最容易存储和读取复杂数据结构的方式<h3 id="读写随机访问文件"><a href="#读写随机访问文件" class="headerlink" title="读写随机访问文件"></a>读写随机访问文件</h3>使用RandomAccessFile，类似组合使用了DataInputStream和DataOutStream(因为它实现了相同的接口：DataInput和DataOutput),并且我们还可以看到使用seek()可以在文件中到处移动，并修改文件中的某个值<br>在使用RandomAccessFile时，你必须知道文件的排版，这样才能正确地操作它，RandomAccessFile拥有读取基本类型和UTF-8字符串的各自具体方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingRandomAccessFile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String file=<span class="string">"rtest.txt"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        RandomAccessFile rf=<span class="keyword">new</span> RandomAccessFile(file,<span class="string">"r"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Value"</span>+i+<span class="string">":"</span>+rf.readDouble());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(rf.readUTF());</span><br><span class="line">        rf.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        RandomAccessFile rf=<span class="keyword">new</span> RandomAccessFile(file,<span class="string">"rw"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">            rf.writeDouble(i*<span class="number">1.414</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        rf.writeUTF(<span class="string">"end of the file"</span>);</span><br><span class="line">        rf.close();</span><br><span class="line">        display();</span><br><span class="line">        rf=<span class="keyword">new</span> RandomAccessFile(file,<span class="string">"w"</span>);</span><br><span class="line">        rf.seek(<span class="number">5</span>*<span class="number">8</span>);</span><br><span class="line">        rf.writeDouble(<span class="number">47.00001</span>);</span><br><span class="line">        rf.close();</span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="管道流"><a href="#管道流" class="headerlink" title="管道流"></a>管道流</h3><p>PipedInputStream,PipedOutputStream,PipedReader和PipedWriter管道流，它们的价值主要用于任务之间的通信</p>
<h2 id="文件读写的工具"><a href="#文件读写的工具" class="headerlink" title="文件读写的工具"></a>文件读写的工具</h2><p>一个很常见的程序化任务就是读取文件到内存，修改，然后再写出，Java I/O类库的问题之一就是：它需要编写相当多的代码去执行这些常用的操作——没有任何基本的帮助功能可以为我们做这一切，更糟糕的是，装饰器会使得要记住如何打开文件变成意见相当困难的事，因此，在我们的类库中添加帮助类就显得相当有意义，这样就很容易地为我们完成这些基本任务，Java Se5在PrintWriter中添加了方便的构造器，因此你可以很方便地打来一个文件进行写入操作，但是，还有很多其他的常见操作是你需要反复执行的，这就使得消除与这些任务相关联的重复代码就显得很有意义<br>我们看下面的一个示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextFile</span> <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">read</span><span class="params">(String fileName)</span></span>&#123;</span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BufferedReader br = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                    <span class="keyword">new</span> FileReader(fileName)</span><br><span class="line">            );</span><br><span class="line">           <span class="keyword">try</span>&#123;</span><br><span class="line">               String s;</span><br><span class="line">               <span class="keyword">while</span>((s=br.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                   sb.append(s);</span><br><span class="line">                   sb.append(<span class="string">"\n"</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">               br.close();</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String fileName,String text)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> File(fileName).getAbsoluteFile());</span><br><span class="line">            out.write(text);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TextFile</span><span class="params">(String fileName,String splitter)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(Arrays.asList(read(fileName).split(splitter)));</span><br><span class="line">        <span class="comment">//正则表达式 split()经常产生一个空字符在第一个位置</span></span><br><span class="line">        <span class="keyword">if</span>(get(<span class="number">0</span>)==<span class="string">""</span>)</span><br><span class="line">            remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TextFile</span><span class="params">(String fileName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(fileName,<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">write</span><span class="params">(String fileName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> File(fileName).getAbsoluteFile());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (String item : <span class="keyword">this</span>) &#123;</span><br><span class="line">                    out.print(item);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                out.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	        String file=read(<span class="string">"TextFile.java"</span>);</span><br><span class="line">	        write(<span class="string">"test.txt"</span>,file);</span><br><span class="line">	        TextFile text=<span class="keyword">new</span> TextFile(<span class="string">"test.txt"</span>);</span><br><span class="line">	        text.write(<span class="string">"text2.txt"</span>);</span><br><span class="line">	        TreeSet&lt;String&gt; words=<span class="keyword">new</span> TreeSet&lt;String&gt;(<span class="keyword">new</span> TextFile(<span class="string">"TextFile.java"</span>,<span class="string">"\n"</span>));</span><br><span class="line">	        System.out.println(words.headSet(<span class="string">"a"</span>));</span><br><span class="line">	  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="读取二进制文件"><a href="#读取二进制文件" class="headerlink" title="读取二进制文件"></a>读取二进制文件</h3><p>这个工具与TextFile类似，因为它简化了读取二进制文件的过程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryFile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] read(File file)<span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        BufferedInputStream in=<span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                <span class="keyword">new</span> FileInputStream(file)</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[in.available()];</span><br><span class="line">            in.read(data);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            in.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] read(String file)<span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> read(<span class="keyword">new</span> File(file));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="标准I-O"><a href="#标准I-O" class="headerlink" title="标准I/O"></a>标准I/O</h2><p>标准I/O这个术语参考的是Unix中“程序所使用的单一信息流”这个概念（在window及其他的操作系统中，也有相似形式的实现）程序的所有输入都可以来自于与标准输入，它的所有输出也可以发送到标准输出，以及所有的错误信息都可以发送到标准错误，<strong>标准I/O的意义在于：我们可以很容易地把程序串联起来，一个程序的标准输出可以成为另一个程序的标准输入</strong></p>
<h3 id="从标准输入中读取"><a href="#从标准输入中读取" class="headerlink" title="从标准输入中读取"></a>从标准输入中读取</h3><p>按照标准I/O模型，java提供了System.io,System.out.System.err,其中System.out，System.err已经事先被包装成PrintStream对象，System.in却是一个未经加工的InputStream,这意味尽管可以立即使用System.out和System.err，但是在读取System.in之前必须对其包装<br>通常我们会使用readLine()一次一行地读取输入，为此，我们将System.in包装成BufferedReader,这里需要使用InputStreamReader把System.in转换成Reader（适配器模式），下面的例子会直接回显你输入的每一行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Echo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        InputStreamReader inr=<span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line">        BufferedReader br=<span class="keyword">new</span> BufferedReader(inr);</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span>((s=br.readLine())!=<span class="keyword">null</span> &amp;&amp; s.length()!=<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//ctrl+z终止程序运行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="将System-out转换成PrintWriter"><a href="#将System-out转换成PrintWriter" class="headerlink" title="将System.out转换成PrintWriter"></a>将System.out转换成PrintWriter</h3><p>System.out是一个PrintStrem，而PrintStream是一个OutputStream，而PrintWriter可以接受一个OutputStream作为参数的构造器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeSystemOut</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        PrintWriter out =<span class="keyword">new</span> PrintWriter(System.out,<span class="keyword">true</span>);</span><br><span class="line">        out.println(<span class="string">"hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>重要的是构造器的第二个参数，将其设置成true，以便开启自动清空功能，否则，你可能看不到输出</p>
<h3 id="标准I-O的重定向"><a href="#标准I-O的重定向" class="headerlink" title="标准I/O的重定向"></a>标准I/O的重定向</h3><p><strong>java的System类提供了一些简单的静态方法调用，以允许我们对标准输入，输出，和错误I/O流进行重定向</strong><br>setIn(InputStream)<br>setOut(PrintStream)<br>setErr(printStream)<br>（使用场景之一）如果我们突然开始在显示器上创建大量输出，而这些输出滚动的太快以至于无法阅读时，重定向输出就显得极为有用，对于我们向重复测试某个特定用户的输入序列的命令行程序来说重定向输入就很有价值，下面演示了这个方法的使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Redirecting</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        PrintStream console=System.out;</span><br><span class="line">        BufferedInputStream in=<span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"Redirecting.java"</span>));</span><br><span class="line">        PrintStream out=<span class="keyword">new</span> PrintStream(<span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"test.out"</span>)));</span><br><span class="line">        System.setIn(in);</span><br><span class="line">        System.setOut(out);</span><br><span class="line">        System.setErr(out);</span><br><span class="line">        BufferedReader br= <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));<span class="comment">//这里就是上面的in变量</span></span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span>((s=br.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(s);<span class="comment">//将数据写入标准输出，标准输出已经被重新设置过了</span></span><br><span class="line">        &#125;</span><br><span class="line">        out.close();</span><br><span class="line">        System.setOut(console);<span class="comment">//在将原来的标准输出改回来</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的程序很有意思，首先我们先将原来的标准输出的引用用一个引用保存起来留待后面重新设置回来，System的标准输入输出的set方法可以改变成员原来的流，我们从这里也能看到一些事情，标准输入输出在java类库中的设计主要是为了和操作系统进行交互的（我的理解）</p>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>你经常会需要在java内部执行操作系统上的其他程序，并且要控制这些程序的输入和输出，Java类库提供了执行这些操作的类<br>一项常见的任务是运行程序，并将产生的输出发送到控制台<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OSExcuteException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OSExcuteException</span><span class="params">(String why)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(why);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OSExecute</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">command</span><span class="params">(String command)</span><span class="keyword">throws</span> OSExcuteException</span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> err=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Process process=<span class="keyword">new</span> ProcessBuilder(command.split(<span class="string">" "</span>)).start();</span><br><span class="line">            BufferedReader result=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(process.getOutputStream()));</span><br><span class="line">            String s;</span><br><span class="line">            <span class="keyword">while</span>((s=result.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">            BufferedReader errors=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(process.getErrorStream()));</span><br><span class="line">            <span class="keyword">while</span> ((s=errors.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">                err=<span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!command.startsWith(<span class="string">"CMD /C"</span>))&#123;</span><br><span class="line">                command(<span class="string">"CMD /C"</span>+command);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OSExcuteException(<span class="string">"Errors excuting:"</span>+command);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">~~~为了捕获程序执行时产生的标准输出流，你需要调用getOutputStream()，这是因为InputStream是我们可以从中读取信息的流</span><br><span class="line">~~~java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OsExecuteDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            OSExecute.command(<span class="string">"javap OsExecuteDemo"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="新I-O"><a href="#新I-O" class="headerlink" title="新I/O"></a>新I/O</h2><p>JDK1.4的java.nio.*包中引入了新的java I/O类库，其目的是为了提高速度，实际上，旧的I/O包已经使用nio重新实现过，以便充分利用这种速度提高，因此，即使我们不显式地使用nio编写代码，也能从中收益，速度的提高在文件I/O和网络I/O中都可能发生，我们这里只研究前者<br>速度的提高来自于所使用的结构更接近于操作系统执行I/O的方式，通道和缓冲器，<strong>我们可以把它们想像成一个“煤矿”，通道是一个包含数据（煤层）的矿藏，而缓冲器则是派送到矿藏的卡车</strong>，卡车载满煤炭而归，我们再从卡车上获取煤炭<strong>，也就是说，我们并没有直接和通道交互，我们只和缓冲器交互</strong>，并把缓冲区派送到通道，通道要么从缓冲器获取数据，要么向缓冲器发送数据<br><strong>唯一直接与通道打交道的缓冲区是ByteBuffer</strong>,也就是说，可以存储未加工字节的缓冲器，当我们查询JDK文档中的java.nio.ByteBuffer时，<strong>会发现它是相当基础的类，通过告知分配多少存储空间来创建一个ByteBuffer对象，并且还有一个方法选择集，用于以原始的自己形式或基本数据类型输出和读取数据，但是没有办法输出或读取对象，即使是字符串也不行</strong>，这种处理当然很低级，但是，因为这是大多数操作系统中更有效的映射<br>旧I/O类库中有三个类被修改了，用以产生FileChannel，这三个类便是FileOutputStream，FileInputStrea,RandomAccessFile，注意这些是字节操纵流，与底层的nio一致，Reader和Writer这种字符模式不能用以产生通道，但是java.io.channels,Channels类提供了实用方法，用以在通道中产生Reader和Writer<br>下面的代码演示了使用FileChannel和ByteBuffer的方式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetChannel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BSIZE=<span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        FileChannel fc=<span class="keyword">new</span> FileOutputStream(<span class="string">"data.txt"</span>).getChannel();</span><br><span class="line">        fc.write(ByteBuffer.wrap(<span class="string">"Somen text"</span>.getBytes()));</span><br><span class="line">        fc.close();</span><br><span class="line"></span><br><span class="line">        fc=<span class="keyword">new</span> RandomAccessFile(<span class="string">"data.txt"</span>,<span class="string">"rw"</span>).getChannel();</span><br><span class="line">        fc.position(fc.size());<span class="comment">//move to the end</span></span><br><span class="line">        fc.write(ByteBuffer.wrap(<span class="string">"Some more"</span>.getBytes()));</span><br><span class="line">        fc.close();</span><br><span class="line">        fc=<span class="keyword">new</span> FileInputStream(<span class="string">"data.txt"</span>).getChannel();</span><br><span class="line">        ByteBuffer bf=ByteBuffer.allocate(BSIZE);</span><br><span class="line">        fc.read(bf);</span><br><span class="line">        bf.flip();</span><br><span class="line">        <span class="keyword">while</span>(bf.hasRemaining())&#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>) bf.get());<span class="comment">//从ByteBuffer每次只读取一个字节</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>getChannel()产生一个FileChannel，可以向它传送一个用于读写的ByteBuffer<br>将数据存放于ByteBuffer的方法之一是，使用一种“put”方法直接对它们进行填充，填入一个或多个字节，或基本数据类型的值，不过，也可以向上面的例子中那样使用wrap()方法将已存在的字节数组“包装”到ByteBuffer,但如此，就不在复制底层的数组，而是把它作为所产生的ByteBuffer的存储器，我们称之为数组支持的ByteBuffer<br>allocate()是为ByteBuffer分配空间的，可以使用allocationDirect()以产生一个与操作系统更高耦合的“直接”缓冲器，但是，这种分配开销更大，并且其具体实现也随着操作系统的不同而不同，因此我们可以看看程序实际运行时获得直接缓冲器是否可以使我们在速度上获得优势<br><strong>一旦调用了read()来告知FileChannel向ByteBuffer存储字节，就必须调用缓冲器上的flip(),让缓冲器做好让别人读取字节的准备</strong>，如果我们打算使用缓冲器执行进一步的操作，我们也必须调用clear()来为每一个read()做好准备，下面是这些注意要点的示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelCopy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BSIZE=<span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args.length!=<span class="number">2</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"arguments i:sourcefile,destfile"</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        FileChannel in=<span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]).getChannel(),</span><br><span class="line">                    out=<span class="keyword">new</span> FileOutputStream(args[<span class="number">1</span>]).getChannel();</span><br><span class="line">        ByteBuffer buf=ByteBuffer.allocate(BSIZE);</span><br><span class="line">        <span class="keyword">while</span>(in.read(buf)!=-<span class="number">1</span>)&#123;</span><br><span class="line">            buf.flip();<span class="comment">//prepare for writing</span></span><br><span class="line">            out.write(buf);</span><br><span class="line">            buf.clear();<span class="comment">//prepare to reading</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的代码中可以看到，但FileChannel.read()返回“-1”的时候，表示我们已经达到了输入的末尾，每次read()操作之后，就会将数据输入到缓冲器中，flip()则是准备缓冲器以便它的信息可以由write()提取，write()操作之后，信息仍在缓冲器中，接着clear()操作则对所有的内部指针重新安排，以便缓冲器在另一个read()操作期间能够做好接收数据的准备<br>然而上面的那个程序并不是处理此类操作的理想方式，特殊的方法transferTo()和transferFrom()则允许我们将一个通道和另一个通道直接相连，看下面的简单示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferTo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args.length!=<span class="number">2</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"arguments i:sourcefile,destfile"</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        FileChannel in= <span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]).getChannel(),</span><br><span class="line">                out=<span class="keyword">new</span> FileOutputStream(args[<span class="number">1</span>]).getChannel();</span><br><span class="line">        in.transferTo(<span class="number">0</span>,in.size(),out);</span><br><span class="line">        <span class="comment">//or out.transferFrom(in,0，in.size());</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="转换数据"><a href="#转换数据" class="headerlink" title="转换数据"></a>转换数据</h3><p>回过头来看到GetChannel的程序就会发现，为了输出文件的信息，我们必须每次只读取一个字节的数据，然后将每个Byte类型强制转换成char类型，这种方式太过原始了——我们查看java.nio。CharBuffer这个类，将会发现它有一个toString（）方法时这样定义的“返回一个包含缓冲器中所有字符的字符串”，既然ByteBuffer可以看做是具有asCharBuffer()方法的CharBuffer，那么为什么不用它呢？看下面这个例子，如输出语句的第一行所见，这种方式并不能解决问题<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferToText</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  BSIZE=<span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        FileChannel fc=<span class="keyword">new</span> FileOutputStream(<span class="string">"data2.text"</span>).getChannel();</span><br><span class="line">        fc.write(ByteBuffer.wrap(<span class="string">"some text"</span>.getBytes()));</span><br><span class="line">        fc.close();</span><br><span class="line">        fc=<span class="keyword">new</span> FileInputStream(<span class="string">"data2.text"</span>).getChannel();</span><br><span class="line">        ByteBuffer buff=ByteBuffer.allocate(BSIZE);</span><br><span class="line">        fc.read(buff);</span><br><span class="line">        buff.flip();</span><br><span class="line">        <span class="comment">//doesn't work</span></span><br><span class="line">        System.out.println(buff.asCharBuffer());</span><br><span class="line">        <span class="comment">//decode using this.system default charset</span></span><br><span class="line">        buff.rewind();<span class="comment">//</span></span><br><span class="line">        String encoding=System.getProperty(<span class="string">"file.encoding"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Decoded using"</span>+encoding+ Charset.forName(encoding).decode(buff));</span><br><span class="line">        <span class="comment">//or wo could encode with something that will print</span></span><br><span class="line">        fc=<span class="keyword">new</span> FileOutputStream(<span class="string">"data2.text"</span>).getChannel();</span><br><span class="line">        fc.write(ByteBuffer.wrap(<span class="string">"Some text"</span>.getBytes(<span class="string">"UTF-16BE"</span>)));</span><br><span class="line">        fc.close();</span><br><span class="line">        <span class="comment">//now try read again</span></span><br><span class="line">        fc=<span class="keyword">new</span> FileInputStream(<span class="string">"data2.text"</span>).getChannel();</span><br><span class="line">        buff.clear();</span><br><span class="line">        fc.read(buff);</span><br><span class="line">        buff.flip();</span><br><span class="line">        System.out.println(buff.asCharBuffer());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ues a CharBuffer  to write through</span></span><br><span class="line">        fc=<span class="keyword">new</span> FileOutputStream(<span class="string">"data2.text"</span>).getChannel();</span><br><span class="line">        buff=ByteBuffer.allocate(<span class="number">24</span>);<span class="comment">//more than needed</span></span><br><span class="line">        buff.asCharBuffer().put(<span class="string">"some text"</span>);</span><br><span class="line">        fc.write(buff);</span><br><span class="line">        fc.close();</span><br><span class="line">        <span class="comment">//read an display</span></span><br><span class="line">        fc=<span class="keyword">new</span> FileInputStream(<span class="string">"data.text"</span>).getChannel();</span><br><span class="line">        buff.clear();</span><br><span class="line">        fc.read(buff);</span><br><span class="line">        buff.flip();</span><br><span class="line">        System.out.println(buff.asCharBuffer());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>缓冲器容纳的是普通的字节，为了把它们转换成字符，我们要么在输入它们的时候对其进行编码（这样，它们的输出才具有意义），要么在将其从缓冲器输出时对它们进行解码，可以使用java.nio.charset.Charset类实现这些功能，该类提供了把数据编码成各种不同类型的字符集的工具<br>如果我们想要对缓冲器调用rewind()方法（调用这个方法是为了返回数据开始的地方），接着使用平台的默认字符集对数据进行decode()，那么作为结果的CharBuffer可以很好地输出打印到控制台，可以使用System.getProperty(“file.encoding”)发现默认字符集，它会产生代表字符集名称的字符串，把该字符串传送给Charset.forName()用以产生Charset对象，可以用它对字符串进行解码<br>另一个选择是在读该文件的时候，使用能够产生可打印的输出的字符集进行encode()，正如在BufferToText.java中看到的那样，这里，UTF-16BE可以把文本写进文件中，当读取时，我们只需把它转换成CharBuffer，就会产生所期望的文本、<br>最后，让我们看看若是通过CharBuffer向ByteBugffer写入，会发生什么情况，注意我们为ByteBuffer分配了24个字节，既然一个字符需要两个字节，那么一个ByteBuffer足可以容纳12个字符，，但是“some text”只要9个字符，剩余的内容为零的字节仍然由它的tString()所产生的CharBuffer的表示中<br>这样来理解，当我们将数据转换为Byte数组的时候，我们实际上是将这些字符串通过系统默认的方式来进行解码的，当然我们再拿到这些数据的时候，也要以相应的字符集来解码才能得到正确的结果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AvailableCharSets</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SortedMap&lt;String,Charset&gt; charSets=Charset.availableCharsets();</span><br><span class="line">        Iterator&lt;String&gt; it=charSets.keySet().iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            String csName=it.next();</span><br><span class="line">            System.out.print(csName);</span><br><span class="line">            Iterator aliases=charSets.get(csName).aliases().iterator();</span><br><span class="line">            <span class="keyword">if</span>(aliases.hasNext())&#123;</span><br><span class="line">                System.out.print(<span class="string">":"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(aliases.hasNext())&#123;</span><br><span class="line">                System.out.print(aliases.next());<span class="comment">//在这里也说明了迭代器的指针只有在next()方法调用之后才会发生变化</span></span><br><span class="line">                <span class="keyword">if</span>(aliases.hasNext())&#123;</span><br><span class="line">                    System.out.print(<span class="string">", "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码输出的就是java支持的字符集有哪些，关键的代码是Charset.availableCharsets()方法，返回一个Map&lt;String,Charset&gt;关联数组;</p>
<h3 id="获取基本类型"><a href="#获取基本类型" class="headerlink" title="获取基本类型"></a>获取基本类型</h3><p>虽然ByteBuffer只能保存字节类型的数据，但是它具有可以从其所容纳的字节中产生出不同的基本类型值的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BSIZE=<span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ByteBuffer bb=ByteBuffer.allocate(BSIZE);</span><br><span class="line">        <span class="comment">//allocation automatically zeroes the ByteBuffer;</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i++&lt;bb.limit())&#123;</span><br><span class="line">            <span class="keyword">if</span>(bb.get()!=<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.print(<span class="string">"nozero"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">"i="</span>+i);</span><br><span class="line">        bb.rewind();</span><br><span class="line">        <span class="comment">//store and read char array</span></span><br><span class="line">        bb.asCharBuffer().put(<span class="string">"howdy"</span>);</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="keyword">while</span>((c= bb.getChar())!=<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.print(c+<span class="string">"  "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        bb.rewind();</span><br><span class="line">        <span class="comment">//store and read a short</span></span><br><span class="line">        bb.asShortBuffer().put((<span class="keyword">short</span>)<span class="number">41411</span>);</span><br><span class="line">        System.out.print(bb.getShort());</span><br><span class="line">        bb.rewind();</span><br><span class="line">        <span class="comment">//store and read a int;</span></span><br><span class="line">        bb.asIntBuffer().put(<span class="number">193972342</span>);</span><br><span class="line">        System.out.print(bb.getInt());</span><br><span class="line">        <span class="comment">//.......................</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在分配一个ByteBuffer之后，可以通过检测它的值来查看缓冲器的分配方式是否将其内容自动清零——它确实是这样做了<br><strong>向缓冲器插入基本类型数据的最简单的方法是：利用asCharBuffer()，asShortBuffer()等获得该缓冲器的一个视图</strong>，然后利用试图的put()方法，取出数据是调用相应的get()方法即可</p>
<h3 id="视图缓冲器"><a href="#视图缓冲器" class="headerlink" title="视图缓冲器"></a>视图缓冲器</h3><p><strong>视图缓冲器（view buffer）可以让我们通过某个特定的基本数据类型的视窗查看其底层的ByteBuffer,ByteBuffer依然是实际存储数据的地方</strong>，对视图的修改都会映射成为对ByteBuffer中数据的修改，这使得我们可以很方便地向ByteBuffer插入数据，试图还允许我们从ByteBuffer一次一个地（与ByteBuffer所支持的方法相同）或者成批地（放入数组中）读取基本类型值，下面这个例子，通过IntBuffer操作ByteBuffer中的int型视图<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntBufferDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BSIZE=<span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ByteBuffer bb= ByteBuffer.allocate(BSIZE);</span><br><span class="line">        IntBuffer ib=bb.asIntBuffer();</span><br><span class="line">        ib.put(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">11</span>,<span class="number">42</span>,<span class="number">33</span>,<span class="number">45</span>,<span class="number">25</span>,<span class="number">24</span>,<span class="number">4354</span>,<span class="number">34</span>&#125;);</span><br><span class="line">        <span class="comment">//absolute location read and write</span></span><br><span class="line">        System.out.print(ib.get(<span class="number">3</span>));</span><br><span class="line">        ib.put(<span class="number">3</span>,<span class="number">1811</span>);</span><br><span class="line">        ib.flip();</span><br><span class="line">        <span class="keyword">while</span>(ib.hasRemaining())&#123;</span><br><span class="line">            <span class="keyword">int</span> i=ib.get();</span><br><span class="line">            System.out.print(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一旦底层的ByteBuffer通过视图缓冲器填满了整数或者其他的基本类型时，就可以直接被写到通道中了，正像从通道中读取那样容易，然后使用视图缓冲器可以把任何数据都转换成某一特定的基本类型，下面的例子，通过在同一个ByteBuffer上建立不同的视图缓冲器，将同一字节序列翻译成了short,int,float和double类型的数据<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewBuffer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ByteBuffer bb= ByteBuffer.wrap(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="string">'a'</span>&#125;);</span><br><span class="line">        bb.rewind();</span><br><span class="line">        System.out.print(<span class="string">"Byte buffer"</span>);</span><br><span class="line">        <span class="keyword">while</span>(bb.hasRemaining())&#123;</span><br><span class="line">            System.out.print(bb.position()+<span class="string">"-&gt;"</span>+bb.get());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        CharBuffer cb=((ByteBuffer)(bb.rewind())).asCharBuffer();</span><br><span class="line">        System.out.print(<span class="string">"Char Buffer"</span>);</span><br><span class="line">        <span class="keyword">while</span>(cb.hasRemaining())&#123;</span><br><span class="line">            System.out.print(cb.position()+<span class="string">"-&gt;"</span>+cb.get());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//...................</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>###$ 字节存放次序 ####<br>不同的机器可能会使得不同的字节排序方法来存储数据，“big endian”(高位优先)将最重要的字节存放在地址最低的存储单元，而“little endian”（低位优先），则是将最重要的字节放在地址最高的存储器单元，当存储量大于1个字节的时候，就要考虑字节的顺序问题了，ByteBuffer是以高位优先的形式存储数据的，并且数据在网上传送时也常常使用高位优先的形式，我们也可以使用ByteOrder.GIG_ENDISN或ByteOrder.LITTLE_EBDIAN的order()方法改变ByteBuffer的字节排序方式</p>
<h3 id="用缓冲器操纵数据"><a href="#用缓冲器操纵数据" class="headerlink" title="用缓冲器操纵数据"></a>用缓冲器操纵数据</h3><p>我们怎么把字节数组写到文件中去的呢？我们可以使用ByteBuffer.warp()方法将数组包装起来，然后用getChannel方法在fileOutputStream上打开一个通道，接着将来自于ByteBuffer的数据写到FileChannel中<br>注意，<strong>ByteBuffer是将数据移进移出的唯一方式</strong>，并且我们只能创建一个独立的基本类型缓冲器，或者使用“as”方法从ByteBuffer中获得，也就是说，我们不能把基本类型的缓冲器转换为ByteBuffer，然而，由于我们可以经由视图缓冲器将基本类型数据移进移出ByteBuffer，所以这也不是什么真正的限制了</p>
<h3 id="缓冲器的细节"><a href="#缓冲器的细节" class="headerlink" title="缓冲器的细节"></a>缓冲器的细节</h3><p>**Buffer由数据和可以高效地访问及操纵这些数据的四个索引组成，这四个索引是：mark(标记)，position（位置），limit（界限）和capacity（容量），下面是用于设置和复位索引以及查询它们值的方法</p>
<table>
<thead>
<tr>
<th></th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>capacity()</td>
<td>返回缓冲区容量</td>
</tr>
<tr>
<td>clear()</td>
<td>清空缓冲区，将position设为0，limit设置为容量，我们可以调用此方法复写缓冲区</td>
</tr>
<tr>
<td>flip()</td>
<td>将limit设置诶position，position设置为0，此方法用于准备从缓冲区读写已经写入的数据</td>
</tr>
<tr>
<td>limit()</td>
<td>返回limit的值</td>
</tr>
<tr>
<td>limit(int lim)</td>
<td>设置limit的值</td>
</tr>
<tr>
<td>mark()</td>
<td>将mark设置为position</td>
</tr>
<tr>
<td>position()</td>
<td>返回position的值</td>
</tr>
<tr>
<td>position(int pos)</td>
<td>设置position</td>
</tr>
<tr>
<td>ramaining()</td>
<td>返回（limit-position）</td>
</tr>
<tr>
<td>hasRemaining()</td>
<td>若有介于position和limit之间的元素，则返回true</td>
</tr>
</tbody>
</table>
<p>在缓冲器中插入和提取数据的方法会更新这些索引，用于反映所发生的变化<br>下面的示例用了一个很简单的算法（交换相邻字符），以对CharBuffer中的字符进行编码(scramble)和译码(unscramble)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingBuffers</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">symmetricScramble</span><span class="params">(CharBuffer buff)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(buff.hasRemaining())&#123;</span><br><span class="line">            <span class="keyword">char</span> c1=buff.get();</span><br><span class="line">            <span class="keyword">char</span> c2=buff.get();</span><br><span class="line">            buff.reset();</span><br><span class="line">            buff.put(c2).put(c1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] data=<span class="string">"UsingBuffers"</span>.toCharArray();</span><br><span class="line">        ByteBuffer bb=ByteBuffer.allocate(data.length*<span class="number">2</span>);</span><br><span class="line">        CharBuffer cb=bb.asCharBuffer();</span><br><span class="line">        cb.put(data);</span><br><span class="line">        System.out.print(cb.rewind());</span><br><span class="line">        symmetricScramble(cb);</span><br><span class="line">        System.out.print(cb.rewind());</span><br><span class="line">        symmetricScramble(cb);</span><br><span class="line">        System.out.print(cb.rewind());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果了解到Buffer类（ByteBuffer,CharBuffer等）的内存及索引控制机制，那么对于Buffer类的读写问题变的很简单，首先当我们创建Buffer类时，pos指针为0，lim指针和cap指针指向最后一个元素，<strong>进行相对的get()和put()方法调用是，pos指针会发生变化，注意，如果调用绝对的get()和put()方法pos指针不会发生变化</strong>，当我们开始循环迭代的时候，mar指针会记下当前的pos指针所在的位置，这个mar本来就是作为标记存在的，<strong>当调用reset()方法的时候，pos将会改变为mar的值</strong>，还有一点需要注意的是，<strong>如果打印缓冲器，只能打印limit和position之间的内容，因此如果要显示缓冲器的全部内容，必须使用rewind()把position设置成缓冲器开始位置</strong></p>
<h3 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h3><p>内存映射文件允许我们创建和修改那些因为太大而不能放入内存的文件，有了内存映射文件，我们就可以假定整个文件都放在了内存中，而且可以完全把它当作非常大的数组来访问，这种方法极大地简化了用于修改文件的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LargeMeppedFiles</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> length=<span class="number">0x8FFFFFF</span>;<span class="comment">//128M</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        MappedByteBuffer out=<span class="keyword">new</span> RandomAccessFile(<span class="string">"test.dat"</span>,<span class="string">"rw"</span>).getChannel().map(</span><br><span class="line">                FileChannel.MapMode.READ_WRITE,<span class="number">0</span>,length</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            out.put((<span class="keyword">byte</span>)<span class="string">'x'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Finished writing"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=length/<span class="number">2</span>;i&lt;length/<span class="number">2</span>+<span class="number">6</span>;i++)&#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>)out.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们通过通道调用map()产生MappedByteBuffer,这是一种特殊类型的直接缓冲器，<strong>注意，我们必须指定映射文件最初的位置和映射区域的长度，这意味着我们可以映射某个大文件的较小部分</strong><br>MppedByteBuffer由ByteBuffer继承而来，因此它具有ByteBuffer的所有方法，这里我们仅仅展示了简单的get()和set()方法，但是我们同样可以是asCharBuffer()等这样的方法</p>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>尽管“旧”的I/O流在用nio实现后性能有所提高，但是“映射文件访问”往往可以更加显著地加快速度<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MappedIO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> numofInts=<span class="number">4000000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> numofubuffInts=<span class="number">2000000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Tester</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Tester</span><span class="params">(String name)</span></span>&#123;name=name;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(name+<span class="string">":"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> start=System.nanoTime();</span><br><span class="line">                test();</span><br><span class="line">                <span class="keyword">long</span> end=System.nanoTime();</span><br><span class="line">                System.out.format(<span class="string">"%.2f\n"</span>,(end-start)/<span class="number">1.0e9</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span><span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//测试组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Tester[] tests=&#123;</span><br><span class="line">      <span class="keyword">new</span> Tester(<span class="string">"Stream Write"</span>)&#123;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">              DataOutputStream dos=<span class="keyword">new</span> DataOutputStream(</span><br><span class="line">                <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(</span><br><span class="line">                        <span class="keyword">new</span> File(<span class="string">"temp.tmp"</span>)</span><br><span class="line">                ))</span><br><span class="line">              );</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; ,</span><br><span class="line">      <span class="keyword">new</span> Tester(<span class="string">"Mapped write"</span>)&#123;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">              FileChannel fc=<span class="keyword">new</span> RandomAccessFile(<span class="string">"temp.tmp"</span>,<span class="string">"rw"</span>).getChannel();</span><br><span class="line">              IntBuffer buff=fc.map(FileChannel.MapMode.READ_WRITE,<span class="number">0</span>,numofInts).asIntBuffer();</span><br><span class="line">              <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numofInts;i++)&#123;</span><br><span class="line">                  buff.put(i);</span><br><span class="line">              &#125;</span><br><span class="line">              fc.close();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; ,</span><br><span class="line">      <span class="keyword">new</span> Tester(<span class="string">"Stream read"</span>)&#123;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">              DataInputStream in=<span class="keyword">new</span> DataInputStream(</span><br><span class="line">                      <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                              <span class="keyword">new</span> FileInputStream(<span class="string">"temp.tmp"</span>)));</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numofInts;i++)&#123;</span><br><span class="line">              in.readInt();</span><br><span class="line">          &#125;</span><br><span class="line">          in.close();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">new</span> Tester(<span class="string">"Mapped read"</span>)&#123;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">              FileChannel fc=<span class="keyword">new</span> FileInputStream(<span class="string">"temp.tmp"</span>).getChannel();</span><br><span class="line">              IntBuffer buff=fc.map(FileChannel.MapMode.READ_ONLY,<span class="number">0</span>,fc.size()).asIntBuffer();</span><br><span class="line">              <span class="keyword">while</span>(buff.hasRemaining())&#123;</span><br><span class="line">                  buff.get();</span><br><span class="line">              &#125;</span><br><span class="line">              fc.close();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">new</span> Tester(<span class="string">"Stream Read/Write"</span>)&#123;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">             RandomAccessFile raf=<span class="keyword">new</span> RandomAccessFile(<span class="string">"temp.tmp"</span>,<span class="string">"rw"</span>);</span><br><span class="line">             raf.writeInt(<span class="number">1</span>);</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numofubuffInts;i++)&#123;</span><br><span class="line">                 raf.seek(raf.length()-<span class="number">4</span>);</span><br><span class="line">                 raf.writeInt(raf.readInt());</span><br><span class="line">             &#125;</span><br><span class="line">             raf.close();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">new</span> Tester(<span class="string">"Mapped Read/write"</span>)&#123;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">              FileChannel fc=<span class="keyword">new</span> RandomAccessFile(<span class="string">"temp.tmp"</span>,<span class="string">"rw"</span>).getChannel();</span><br><span class="line">              IntBuffer buff=fc.map(FileChannel.MapMode.READ_WRITE,<span class="number">0</span>,fc.size()).asIntBuffer();</span><br><span class="line">              <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numofubuffInts;i++)&#123;</span><br><span class="line">                  buff.put(buff.get(i-<span class="number">1</span>));</span><br><span class="line">              &#125;</span><br><span class="line">              fc.close();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Tester tester:tests)&#123;</span><br><span class="line">            tester.runTest();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行上述代码结果会发现“映射写”似乎要使用FileOutputSream。但是映射文件的所有输出使用RandomAccessFile性能更好<br>我们一般建议使用映射进行文件的读写性能更好，即使建立这样的代码代价会稍大</p>
<h3 id="文件加锁"><a href="#文件加锁" class="headerlink" title="文件加锁"></a>文件加锁</h3><p><strong>文件加锁机制，它允许我们同步访问作为共享资源的文件</strong>，不过，竞争同一文件的两个线程可能在不同的java虚拟机上，或者一个是java进程，另一个是操作系统的其他本地进程，<strong>文件锁对其他的操作系统进程是可见的，因为java的文件加锁直接映射到了本地操作系统的加锁工具</strong><br>下面是一个关于文件加锁的简单例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileLocking</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        FileOutputStream fos=<span class="keyword">new</span> FileOutputStream(<span class="string">"file.txt"</span>);</span><br><span class="line">        FileLock fl=fos.getChannel().tryLock();</span><br><span class="line">        <span class="keyword">if</span>(fl!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"locked file"</span>);</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">            fl.release();</span><br><span class="line">            System.out.println(<span class="string">"Release Lock"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过对FileChannel调用tryLock()或lock()，就可以获得整个文件的FileLock（SocketChannel,DatagramChannel和ServerSocketChannel不需要加锁，因为它们是从单进程实体继承而来，我们通常不再两个进程之间共享网络socket）<br>tryLock()是非阻塞的，它设法获取锁，但是如果不能获得（当其他一些进程以及持有相同的锁，并且不共享时），它将直接返回<br>lock()是阻塞式的，它要阻塞进程直至获得锁可以获得<br>也可以使用下面的方法对文件的一部分上锁<br>    tryLock(long position,long size,boolean shared)<br>或<br>    lock(long position,long size,boolean shared)<br>其中的加锁区域有size-position决定，第三个参数指定是否是共享锁<br>无参数的加锁方式将根据文件的尺寸的变化而变化，但是具有固定尺寸的锁不随文件尺寸的变化而变化，也就是说，如果你获得了某一区域上的锁，当文件增大超出position+size时，那么超出的部分不会被锁定，无参数的加锁是对整个文件加锁，即使文件增大也是如此<br>对独占锁或者共享锁的支持必须由底层的操作系统提供，如果操作系统不支持共享锁并为每一请求都创建一个锁，那么它就会使用独占锁，锁的类型（独占或者共享）可以通过FileLock.isShared()进行查询</p>
<h4 id="对映射文件的部分加锁"><a href="#对映射文件的部分加锁" class="headerlink" title="对映射文件的部分加锁"></a>对映射文件的部分加锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockingMappedFiles</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LENGTH=<span class="number">0x8FFFFFF</span>;<span class="comment">//128M</span></span><br><span class="line">    <span class="keyword">static</span> FileChannel fc;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        fc=<span class="keyword">new</span> RandomAccessFile(<span class="string">"text.dat"</span>,<span class="string">"rw"</span>).getChannel();</span><br><span class="line">        MappedByteBuffer out=fc.map(FileChannel.MapMode.READ_WRITE,<span class="number">0</span>,LENGTH);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;LENGTH;i++)&#123;</span><br><span class="line">            out.put((<span class="keyword">byte</span>) <span class="string">'x'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> LockAndModify(out,<span class="number">0</span>,LENGTH/<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">new</span> LockAndModify(out, LENGTH/<span class="number">2</span>,LENGTH/<span class="number">2</span>+LENGTH/<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LockAndModify</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> ByteBuffer buff;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> start,end;</span><br><span class="line">        LockAndModify(ByteBuffer buff,<span class="keyword">int</span> start,<span class="keyword">int</span> end)&#123;</span><br><span class="line">            <span class="keyword">this</span>.buff=buff;</span><br><span class="line">            <span class="keyword">this</span>.start=start;</span><br><span class="line">            buff.limit(end);</span><br><span class="line">            buff.position(start);</span><br><span class="line">            <span class="keyword">this</span>.buff=buff.slice();</span><br><span class="line">            start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                FileLock fl = fc.lock(start, end, <span class="keyword">false</span>);</span><br><span class="line">                System.out.println(<span class="string">"locked"</span>+start+<span class="string">"to"</span>+end);</span><br><span class="line">                <span class="keyword">while</span>(buff.position()&lt;buff.limit()-<span class="number">1</span>)&#123;</span><br><span class="line">                    buff.put((<span class="keyword">byte</span>)(buff.get()+<span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                fl.release();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><p>java I/O类型支持读写压缩格式的数据流，你可以使用它们对其他I/O类进行封装，以提供压缩功能<br>这些类都不是从Reader和Writer类派生而来，而是属于InputStream和OtputStream继承层次结构的一部分，这样做是因为压缩类库是按字节方式而不是字符方式处理的，不过有时我们可能需要被迫要混合使用着两种类型的数据流（注意我们可以使用InputStreamReader和OutputStreamWriter在两种类型之间方便地进行转换）</p>
<table>
<thead>
<tr>
<th></th>
<th>压缩类</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>CheckedInputStream</td>
<td>getCheckSum()为任何InputStream产生效验和（不仅是解压缩）</td>
</tr>
<tr>
<td>CheckedOutputStream</td>
<td>getCheckSum()为任何OutputStream产生效验和（不仅是压缩）</td>
</tr>
<tr>
<td>DeflaterOutputStream</td>
<td>压缩类的基类</td>
</tr>
<tr>
<td>ZipOutputStream</td>
<td>一个DeflaterOutputStream，用于将数据压缩成Zip文件格式</td>
</tr>
<tr>
<td>GZIPOutputStream</td>
<td>一个DeflaterOutputStream，用于将数据压缩成GZip文件格式</td>
</tr>
<tr>
<td>InflaterInputStream</td>
<td>解压缩类的基类</td>
</tr>
<tr>
<td>ZipInputStream</td>
<td>一个InflaterInputStream，用于解压缩Zip文件格式的数据</td>
</tr>
<tr>
<td>GZIPInputStream</td>
<td>一个InflaterInputStream，用于解压缩GZip文件格式的数据</td>
</tr>
</tbody>
</table>
<h3 id="用GZIP进行简单压缩"><a href="#用GZIP进行简单压缩" class="headerlink" title="用GZIP进行简单压缩"></a>用GZIP进行简单压缩</h3><p>GZIP接口非常简单，如果我们只想对单个数据流（而不是一系列互异数据）进行压缩，那么它可能是比较合适的选择，下面是对单个文件进行压缩的例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GZIPCompress</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args.length==<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(</span><br><span class="line">                    <span class="string">"usage:\nGIZPcompress file\n"</span>+</span><br><span class="line">                     <span class="string">"\tUses GZIP compression to compress"</span>+</span><br><span class="line">                     <span class="string">"the file to test.gz"</span></span><br><span class="line">            );</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        BufferedReader in=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"args[0]"</span>));</span><br><span class="line">        BufferedOutputStream out=<span class="keyword">new</span> BufferedOutputStream(</span><br><span class="line">                <span class="keyword">new</span> GZIPOutputStream(</span><br><span class="line">                        <span class="keyword">new</span> FileOutputStream(<span class="string">"test.gz"</span>)</span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">        <span class="keyword">while</span>((c=in.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            out.write(c);</span><br><span class="line">        &#125;</span><br><span class="line">        in.close();</span><br><span class="line">        out.close();</span><br><span class="line">        System.out.println(<span class="string">"reading file"</span>);</span><br><span class="line"></span><br><span class="line">        BufferedReader in2=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(</span><br><span class="line">                <span class="keyword">new</span> GZIPInputStream(</span><br><span class="line">                        <span class="keyword">new</span> FileInputStream(<span class="string">"test.gz"</span>))));</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span>((s=in2.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>压缩类的使用非常直观，直接将输出流封装成GZIPOutputStream或ZIPOutputStream，并将输入流封装成GZIPInputStream或ZIPINputStream即可，其他的操作就是通常的I/O读写</p>
<h3 id="用Zip进行多文件保存"><a href="#用Zip进行多文件保存" class="headerlink" title="用Zip进行多文件保存"></a>用Zip进行多文件保存</h3><p>支持Zip格式的Java库更加全面，利用该库可以方便地保存多个文件，它甚至有一个独立的类，使得读取Zip文件更加方便，这个类库使用标准Zip格式，所有能与当前那些可通过因特网下载的压缩工具很好地协作，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZIpCompress</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        FileOutputStream f =<span class="keyword">new</span> FileOutputStream(<span class="string">"test.zip"</span>);</span><br><span class="line">        CheckedOutputStream csum=<span class="keyword">new</span> CheckedOutputStream(f,<span class="keyword">new</span> Adler32());</span><br><span class="line">        ZipOutputStream zos=<span class="keyword">new</span> ZipOutputStream(csum);</span><br><span class="line">        BufferedOutputStream out=<span class="keyword">new</span> BufferedOutputStream(zos);</span><br><span class="line">        zos.setComment(<span class="string">"A test of java Zipping"</span>);</span><br><span class="line">        <span class="keyword">for</span>(String arg:args)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Writing file"</span>+arg);</span><br><span class="line">            BufferedReader in=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(arg));</span><br><span class="line">            zos.putNextEntry(<span class="keyword">new</span> ZipEntry(arg));</span><br><span class="line">            <span class="keyword">int</span> c;</span><br><span class="line">            <span class="keyword">while</span>((c=in.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">                out.write(c);</span><br><span class="line">            &#125;</span><br><span class="line">            in.close();</span><br><span class="line">            out.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        out.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Checksum"</span>+csum.getChecksum().getValue());</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"Reading file"</span>);</span><br><span class="line">        FileInputStream fi=<span class="keyword">new</span> FileInputStream(<span class="string">"text.zip"</span>);</span><br><span class="line">        CheckedInputStream csum1=<span class="keyword">new</span> CheckedInputStream(fi,<span class="keyword">new</span> Adler32());</span><br><span class="line">        ZipInputStream in2=<span class="keyword">new</span> ZipInputStream(csum1);</span><br><span class="line">        BufferedInputStream bis=<span class="keyword">new</span> BufferedInputStream(in2);</span><br><span class="line">        ZipEntry ze;</span><br><span class="line">        <span class="keyword">while</span>((ze=in2.getNextEntry())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           System.out.println(<span class="string">"Reading file"</span>+ze);</span><br><span class="line">           <span class="keyword">int</span> x;</span><br><span class="line">           <span class="keyword">while</span>((x=bis.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">               System.out.println(x);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(args.length==<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Checksum"</span>+csum1.getChecksum().getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        bis.close();</span><br><span class="line">        ZipFile zf=<span class="keyword">new</span> ZipFile(<span class="string">"test.zip"</span>);</span><br><span class="line">        Enumeration e=zf.entries();</span><br><span class="line">        <span class="keyword">while</span>(e.hasMoreElements())&#123;</span><br><span class="line">            ZipEntry ze2=(ZipEntry) e.nextElement();</span><br><span class="line">            System.out.println(<span class="string">"File"</span>+ze2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码有几个注意的地方，使用Checksum类来计算和校验文件的校验和的方法，共有两种Checksum类型，Adler32(更快)和CRC32(慢一些，但更准确)<br>对于每个呀加人压缩档案的文件，必须调用PutNextEntry()，并将其传递给一个ZipEntry对象,ZipEntry对象包含一个功能很广泛的接口，允许你获取和设置Zip文件内该特定项上所有可利用的数据，包括：名字，压缩的和未压缩的文件大小，日期，CRC校验和，额外字段数据，注解，压缩方法以及它是否是一个目录入口等等，然后尽管Zip格式提供了设置密码的方式，但是java的Zip类库不提供这些方法的支持<br>为了能够解压缩文件，ZipInputStream提供了getNextEntry()方法返回下一个ZipEntry（如果存在的话），解压缩文件有个更简便的方法，使用ZipFile对象读取文件，该对象有一个entries()方法用来向ZipEntries返回一个Enumeration<br>为了读取校验和，必须拥有对与之相关联的Checksum的访问权限，在这里保留了CheckedOutputStream和CheckedInputStream对象的引用，但是，也可以值保留一个执行Checksum对象的引用<br>Zip流中有个令人困惑的方法setComment()，我们可以在写文件时写注释，但没有任何方法恢复ZipInpuStream内的注释，似乎只能通过ZipEntry才能以逐条方式完全支持注释的获取</p>
<h3 id="java档案文件"><a href="#java档案文件" class="headerlink" title="java档案文件"></a>java档案文件</h3><p>Zip格式也被应用于JAR(java ARchive java文档文件)文件格式中在，这种文件格式就像Zip一样，可以将一组文件压缩到单一压缩文件中<br>jar文件是跨平台的，jar文件非常有用，一次请求可以获取多个文件，因为压缩的原因使得传输时间也变得更短，而且还可以在每个条目上添加数字签名<br><strong>一个jar文件由一组压缩文件构成，同时还有一张描述所有文件的“文件清单”</strong>（可以自行创建文件清单，也可以由jar程序自动生成），在jdk文档中可以找到与Jar文件清单更多的资料<br>我们看下在命令行中如何使用jar程序</p>
<p>jar [options] destination [manifest] inputfile(s)<br>其中option只是一个字母集合（不必输入任何“-”或者其他任何标识符），以下是这些选项字符在Unix和Linux系统中的tar文件也具有相同的意义<br>|选项|功能说明|<br>——-|——–<br>c|创建一个新的或空的压缩文档<br>f|列出目录表<br>x|解压所有文件<br>x file|解压该文件<br>f|意指：“我打算指定一个文件名”，如果没有用这个选项，jar假设所有的输入都来自于标准输入<br>或者在创建一个文件时，输出对象也假设为标准输出<br>m|表示第一个参数将是用户自建的清单文件的名字<br>v|产生详细输出，描述jar所做的工作<br>O|只存储文件，不压缩文件（用来创建一个可放在类路径的Jar文档）<br>M|不自动创建文件清单</p>
<p>如果压缩到Jar文件的众多文件中包含多个子目录，那么该子目录会自动被添加到Jar文件中，且包括该子目录的所有子目录，路径信息也会被保留</p>
<h2 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h2><p>当你创建对象的时候，只要你需要，它就一致存在，但是在程序终止时，无论如何它都不会继续存在，尽管这么做是有意义的，但是仍然在某些情况下，如果对象能够在程序不运行的情况下继续存在并保存其信息，那就非常有用，当下次程序运行时，该对象被重建并拥有信息与上次运行它时的信息是相同的（当然，我们可以通过将信息写入文件或数据库达到同样的目的）<br>java的对象序列化将那些实现了Serializabel接口的对象转换成一个字节序列，并能够在以后将这个字节序列完全恢复为原来的对象，这一过程甚至可以通过网络进行，这意味着序列化能够自动弥补不同操作系统之间的差异，也就是说，可以在运行window系统的计算机上创建对象，将其序列化，通过网络将它发送给一台运行Unix系统的计算机，然后在那里准确地重新组装，而却不必担心数据在不同的机器上表示会不同<br>对象的序列化很有趣，因为利用它可以实现轻量级持久性，“持久性”意味着一个对象的生命周期不取决与程序是否正在执行，通过将一个持久化对象写入磁盘，然后在重新调用程序是恢复该对象，就能实现持久化的效果<br>对象必须在程序中显式地序列化（seialize）和反序列化还原（deserialize）（更严格的持久化机制，例如Hibernate或者MyBatis）<br>对象的序列化概念加入到语言中是为了支持两种主要特性<br>一是java的远程方法调用（Remote method invocation RMI）<strong>它使存活在其他计算机上的对象使用起来就像是存活于本机上一样，当向远程对象发送消息时，需要通过对象序列化来传输参数和返回值</strong><br>再者，对java Beans设计来说，对象的序列化也是必需，使用一个Bean时，一般情况下是在设计阶段对它的状态信息进行配置，这种状态信息必须保存下来，并在程序启动时进行后期恢复，这种具体工作也是由对象序列化完成的<br>只要对象实现类Serializable标记接口，对象的序列化就很简单，查看API可以看到标准类库中很多对象都实现了这个接口<br>如何序列化一个对象？<br>首先要创建某种OutpuStream，将其封在在ObjectOutputStream对象中，这时调用writeObject()即可将对象序列化，并将其发送给OutputStream（对象序列化是基于字节的，因要使用InputStream和OutputStream继承层次结构）将一个序列还原为一个对象，和往常一样，需要将InputStream封装到一个ObjectInputStream内，调用readObject()方法，获得一个指向根类Object的引用，所以必须向下转型才能设置它们<br>对象序列化特别“聪明”的地方是它不仅保存了对象的“全景图”，而且能追踪对象内所包含的所有引用，并保存那些对象，接着又能对对象内的每个这样的引用进行追踪，依此类推，这种情况被称为“对象网”<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Data</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n=n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> Integer.toString(n);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worm</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand= <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="keyword">private</span>  Data[] datas=<span class="keyword">new</span> Data[]&#123;</span><br><span class="line">           <span class="keyword">new</span> Data(rand.nextInt()),</span><br><span class="line">           <span class="keyword">new</span> Data(rand.nextInt()),</span><br><span class="line">           <span class="keyword">new</span> Data(rand.nextInt())</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">private</span> Worm next;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> c;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Worm</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">char</span> x)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"constructor:"</span>+i);</span><br><span class="line">        c=x;</span><br><span class="line">        <span class="keyword">if</span>(--i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">           next=<span class="keyword">new</span> Worm(i,(<span class="keyword">char</span>)(x+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Worm</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Default constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuilder result=<span class="keyword">new</span> StringBuilder(<span class="string">":"</span>);</span><br><span class="line">        result.append(c);</span><br><span class="line">        result.append(<span class="string">"("</span>);</span><br><span class="line">        <span class="keyword">for</span>(Data data:datas)&#123;</span><br><span class="line">            result.append(data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            result.append(next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException,ClassNotFoundException</span>&#123;</span><br><span class="line">        Worm w=<span class="keyword">new</span> Worm(<span class="number">6</span>,<span class="string">'a'</span>);</span><br><span class="line">        System.out.println(<span class="string">"w="</span>+w);</span><br><span class="line">        ObjectOutputStream out=<span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"worm.out"</span>));</span><br><span class="line">        out.writeObject(<span class="string">"Worm strorage\n"</span>);</span><br><span class="line">        out.writeObject(w);</span><br><span class="line">        out.close();</span><br><span class="line">        ObjectInputStream in=<span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span>  FileInputStream(<span class="string">"worm.out"</span>));</span><br><span class="line">        String s=(String) in.readObject();</span><br><span class="line">        Worm w2=(Worm)in.readObject();</span><br><span class="line">        System.out.println(s+<span class="string">"w2+"</span>+w2);</span><br><span class="line">        ByteArrayOutputStream bout=<span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream out2=<span class="keyword">new</span> ObjectOutputStream(bout);</span><br><span class="line">        out2.writeObject(<span class="string">"Worm storage\n"</span>);</span><br><span class="line">        out2.writeObject(w);</span><br><span class="line">        out.flush();</span><br><span class="line">        ObjectInputStream in2=<span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">                <span class="keyword">new</span> ByteArrayInputStream(bout.toByteArray()));</span><br><span class="line">        s=(String)in2.readObject();</span><br><span class="line">        Worm w3=(Worm)in2.readObject();</span><br><span class="line">        System.out.println(s+<span class="string">"w="</span>+w3);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行此程序可以看到，被还原的对象确实包含了原对象的所有链接（对象内的所有对象引用数组即下潜到最后一个对象（可以称为对象网或对象树））<br>对象的还原过程没有调用任何构造器，整个对象都是通过从InputStream中取得数据恢复而来的</p>
<h3 id="寻找类"><a href="#寻找类" class="headerlink" title="寻找类"></a>寻找类</h3><p>将一个对象从它的序列化状态中恢复出来，有那些工作是必须的呢？假如我们将一个对象序列化，并通过网络将其作为文件传送给另一台计算机，那么，另一台计算机上的程序可以只利用该文件内容来还原这个对象吗？答案是no<br>原因也很容易理解，对象的序列化数据中一点会有保留其类型的信息，所有在进行反序列化的时候吗，输出流一定会去获取这个对象序列化的类型信息，当知道了对象的类型之后，虚拟机将会在本地寻找其.class文件加载该Class,如果已经加载或能够在类路径下找到（找到之后加载），接下来的反序列化将会很容易的进行，但是如果找不到，就会抛出ClassNotFoundException异常，所有如果进行可靠的反序列化一定要在类路径下能找到该对象的字节码文件</p>
<h3 id="序列化的控制"><a href="#序列化的控制" class="headerlink" title="序列化的控制"></a>序列化的控制</h3><p>序列化可以进行更加细粒度的控制，例如，出于安全的考虑，你不希望对象的某一部分被序列化，或者一个对象被还原以后，某个子对象需要重新创建，从而不比将该子对象序列化<br>Externalizable接口——代替实现Serializable接口——来对序列化过程进行控制，这个Externalizable接口继承了Sericalizbale接口，同时也添加了两个方法，writeExternal()和readExternal()方法，这两个方法会在序列化和反序列化还原的过程中被自动调用以便执行一些特殊操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blip1</span> <span class="keyword">implements</span> <span class="title">Externalizable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Blip1</span><span class="params">()</span></span>&#123;<span class="comment">//构造器不是public</span></span><br><span class="line">        System.out.println(<span class="string">"Blip1 Constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Blip1.writeExternal"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Blip1.readExternal"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blip2</span> <span class="keyword">implements</span> <span class="title">Externalizable</span></span>&#123;</span><br><span class="line">    Blip2()&#123;</span><br><span class="line">        System.out.println(<span class="string">"Blip2 Constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Blip2 writeExrternal"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Blip2.readExternal"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Blips</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException,ClassNotFoundException</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"constructing Objeects:"</span>);</span><br><span class="line">        Blip1 b1=<span class="keyword">new</span> Blip1();</span><br><span class="line">        Blip2 b2=<span class="keyword">new</span> Blip2();</span><br><span class="line"></span><br><span class="line">        ObjectOutputStream out=<span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">                <span class="keyword">new</span> FileOutputStream(<span class="string">"Bilps.out"</span>));</span><br><span class="line">        System.out.println(<span class="string">"saving Objects"</span>);</span><br><span class="line">        out.writeObject(b1);</span><br><span class="line">        out.writeObject(b2);</span><br><span class="line">        out.close();</span><br><span class="line"></span><br><span class="line">        ObjectInputStream in=<span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">                <span class="keyword">new</span> FileInputStream(<span class="string">"Blips.out"</span>));</span><br><span class="line">        System.out.println(<span class="string">"recovering b1"</span>);</span><br><span class="line">        b1=(Blip1)in.readObject();</span><br><span class="line">        <span class="comment">//System.out.println("recovering b2");</span></span><br><span class="line">        <span class="comment">//b2=(Blip2)in.readObject();//因为Blip2的构造器不是公共的所以在恢复对象时会发发生异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的例子很简单，Blip1和Blip2都实现了Externalizable接口，并通过ObjectOutputStream和ObjectInputStream读写<br>关于Externalizable接口有一些需要注意的地方，当我们通过readObject恢复对象的时候，与Sericalizabel最大的不同是，对于Serializable对象，对象是完全以它的存储的二进制为基础来构造的，而不调用构造器，而对于一个EXternalizable对象，所有默认的构造器都会被调用（包括在字段定义是的初始化），然后才调用readExternalizabel(),必须注意一点的是——所有默认的构造器都会被调用，才能使Externalizable对象产生正确的行为，<br>看看上面的代码，Blip2和Blip1最大的不同是Blip2的构造器不是public的，因此在readObject()方法时，因为要调用Blip2的构造器，所以对于ObjectOutStream是没有访问权的，这里也能猜到，对对象构造器访问的代码一定会在readObject()方法的内部被调用了，这也能说明为什么Blips和Blip2同包，访问Blip2的构造器也会抛出异常，因为访问者是ObjectOutputStream而不是Blips，所以要想正确的被反序列（当然要反序列化，不然为什么要对对象进行序列化呢？ 哈哈）实现Externalizable接口的类的构造器一定要是public“公共的”<br>关于实现了Externalizable接口的对象是如何实现的序列化的，看看下面的一个示例就很清楚了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Blip3</span> <span class="keyword">implements</span> <span class="title">Externalizable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">private</span> String s;<span class="comment">//no Initialization</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Blip3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Blip3 constructor"</span>);</span><br><span class="line">        <span class="comment">//s,i not initialized</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Blip3</span><span class="params">(String x,<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Blip3(String x,int a)"</span>);</span><br><span class="line">        s=x;</span><br><span class="line">        i=a;</span><br><span class="line">        <span class="comment">//s &amp; i only  initialized in non-default constructor</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> s+i;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Blip3.writeExternal"</span>);</span><br><span class="line">        out.writeObject(s);</span><br><span class="line">        out.writeObject(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Blip3.readExternal"</span>);</span><br><span class="line">        s=(String) in.readObject();</span><br><span class="line">        i=(Integer)in.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException,ClassNotFoundException</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Constructing Objects:"</span>);</span><br><span class="line">        Blip3 b3=<span class="keyword">new</span> Blip3(<span class="string">"A String"</span>,<span class="number">47</span>);</span><br><span class="line">        System.out.println(b3);</span><br><span class="line">        ObjectOutputStream out=<span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">                <span class="keyword">new</span> FileOutputStream(<span class="string">"Blip3.out"</span>));</span><br><span class="line">        System.out.println(<span class="string">"Saving Objects"</span>);</span><br><span class="line">        out.writeObject(b3);</span><br><span class="line">        out.close();</span><br><span class="line">        ObjectInputStream in=<span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">                <span class="keyword">new</span> FileInputStream(<span class="string">"Blip3.out"</span>));</span><br><span class="line">        System.out.println(<span class="string">"recovering Objects"</span>);</span><br><span class="line">        b3=(Blip3) in.readObject();</span><br><span class="line">        System.out.println(b3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的示例中我们能够看到，实现了Externalizable接口的对象是如何实现序列化和反序列化的，当我们调用writeObject()方法的时候，ObjectOutputStream记录了对象的类型信息，之后调用writeExternal()方法，在writeExternal，我们可以任意的将关于对象的属性信息记录在ObjectOutputStream中（也就是说对象信息的保存可以个性化定制），这样关于这个对象的所有应该知道的信息，我们都保存了下来，当我们调用readObjetc()方法进行反序列化的时候，首先查看这个对象的类型信息，加载—&gt;调用默认构造器（创建实例对象）—&gt;调用readExternal（对象的属性进行初始化）<br>从这里我们也可以看出使用Externalizabel接口和Serializable接口的序列化和反序列化机制是不同的</p>
<h3 id="transient-瞬时-关键字"><a href="#transient-瞬时-关键字" class="headerlink" title="transient(瞬时)关键字"></a>transient(瞬时)关键字</h3><p>当我们对序列化进行控制时，可能某个特定子对象不想让java的序列化机制自动保存与恢复，如果子对象表示的是我们不希望将其序列化的敏感信息，即使对象中的这些信息是private属性，一经序列化处理，人们就可以通过读取文件或者拦截网络传输的方式来访问它<br>有一种办法可以防止对象的敏感信息部分被序列化，就是将类实现问Extrenalizable,如前面所示，这样一来，（没有任何东西可以自动序列化），并且可以在writeExternal()内部只对所需部分进行显式地初始化<br>然而，如果我们正在操作的是一个Serializable对象，那么所有序列化操作都会自动进行，为了能够予以控制，可以用transient“瞬时”关键字逐个字段地关闭序列化，它的意思是：“不用麻烦你保存或恢复数据——我自己会处理”，其实transients关键字的特性实现只是给了编译器或者虚拟机一个提示，由虚拟机来去实现忽略子对象的序列化而已<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Login</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Date date=<span class="keyword">new</span> Date();</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String password;<span class="comment">//添加了关键字transient</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Login</span><span class="params">(String name,String pwd)</span></span>&#123;</span><br><span class="line">        username=name;</span><br><span class="line">        password=pwd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"login info:\n"</span>+<span class="string">"username:"</span>+username+<span class="string">"\n"</span>+</span><br><span class="line">                <span class="string">"date:"</span>+date+<span class="string">"\n"</span>+</span><br><span class="line">                <span class="string">"password:"</span>+password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException,ClassNotFoundException,InterruptedException</span>&#123;</span><br><span class="line">        Login a=<span class="keyword">new</span> Login(<span class="string">"Hulk"</span>,<span class="string">"myliitepony"</span>);</span><br><span class="line">        System.out.println(<span class="string">"login a="</span>+a);</span><br><span class="line">        ObjectOutputStream out=<span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">                <span class="keyword">new</span> FileOutputStream(<span class="string">"login.out"</span>));</span><br><span class="line">        out.writeObject(a);</span><br><span class="line">        out.close();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        ObjectInputStream in=<span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">                <span class="keyword">new</span> FileInputStream(<span class="string">"login.out"</span>));</span><br><span class="line">        a=(Login) in.readObject();</span><br><span class="line">        System.out.println(<span class="string">"recovering Object at"</span>+<span class="keyword">new</span> Date());</span><br><span class="line">        System.out.println(<span class="string">"login a="</span>+a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>简单例子，password由关键字transient修饰</p>
<h3 id="Externalizable的替代方案"><a href="#Externalizable的替代方案" class="headerlink" title="Externalizable的替代方案"></a>Externalizable的替代方案</h3><p>如果不是坚持要使用Externalizable的话，那么还有一种方法，我们可以实现Serialzable接口，然后添加（注意是“添加”而非“覆盖”或“实现”）名为writeObject()和ReadObject()的方法，这样一旦对象被序列化或者反序列化还原，就会自动地分别调用这两个方法，也是就是说，只要提供了这两个方法，就会使用它们而不是默认的序列化机制<br><strong>这些方法必须要有正确的方法签名</strong><br>    private void writeObject(ObjectOutpuStream stream)<br>    private void readObject(ObjectInputStream stream)<br>上面的这些方法很令人疑惑，首先这些方法被声明为private，也就是说这些方法是有这个类的其他成员来调用的，但是实际上我们并没有从这个类的其他方法中调用它们，而是ObjectOutputStream和ObjectInoutStream的writeObject()和readObject()方法调用了你的对象的writeObject（）和readObject()方法，但是为什么ObjectOuputStream和ObjectInputStream能够访问你类中的private()方法的？我们只能假设这正是序列化神奇的地方（真想骂人啊）<br>所以我个人不推荐这种方式，因为：</p>
<ol>
<li>这种方式违背了访问控制权限机制，</li>
<li>你添加的WriteObject和readObject()方法必须要有正确的方法前面并且是private的（我们无法保证不会犯错，而且错误产生时我们也是毫无察觉的，编译器并不会提醒我们），</li>
<li>实现Externalizable接口就可以完全达到这个目的了，我们为何要选择这种方式来控制序列化呢？<h3 id="使用“持久性”"><a href="#使用“持久性”" class="headerlink" title="使用“持久性”"></a>使用“持久性”</h3>一个比较诱人的使用序列化技术的想法是：存储程序的一些状态，以便我们随后可以很容易地将程序恢复到当前状态，但是我们能够这样做之前，必须回答几个问题<br>如果我们将两个对象——他们都具有指向第三个对象的引用——进行序列化，会发生什么？当我们从它们的序列化状态恢复这两个对象时，第三个对象会只出现一次吗？<br>如果我们将这两个对象序列化成独立的文件，然后在代码的不同部分对它们进行反序列化还原，又会怎样呢？<br>下面这个例子说明这些问题<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> <span class="keyword">implements</span>  <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> House perferenceHouse;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name,House h)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.perferenceHouse=h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name+<span class="string">"["</span>+<span class="keyword">super</span>.toString()+<span class="string">"],"</span>+perferenceHouse+<span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException,ClassNotFoundException</span>&#123;</span><br><span class="line">        House house=<span class="keyword">new</span> House();</span><br><span class="line">        List&lt;Animal&gt; animals=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        animals.add(<span class="keyword">new</span> Animal(<span class="string">"Boson the dog"</span>,house));</span><br><span class="line">        animals.add(<span class="keyword">new</span> Animal(<span class="string">"Ralph  the hamster"</span>,house));</span><br><span class="line">        animals.add(<span class="keyword">new</span> Animal(<span class="string">"Molly the cat"</span>,house));</span><br><span class="line">        System.out.println(<span class="string">"animals:"</span>+animals);</span><br><span class="line"></span><br><span class="line">        ByteArrayOutputStream buf1=<span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream out1 =<span class="keyword">new</span> ObjectOutputStream(buf1);</span><br><span class="line">        out1.writeObject(animals);</span><br><span class="line">        out1.writeObject(animals);<span class="comment">//write a 2nd set</span></span><br><span class="line"></span><br><span class="line">        ByteArrayOutputStream buf2=<span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream out2=<span class="keyword">new</span> ObjectOutputStream(buf2);</span><br><span class="line">        out2.writeObject(animals);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//now get them back</span></span><br><span class="line">        ObjectInputStream in1=<span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">                <span class="keyword">new</span> ByteArrayInputStream(buf1.toByteArray()));</span><br><span class="line">        ObjectInputStream in2=<span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">                <span class="keyword">new</span> ByteArrayInputStream(buf2.toByteArray()));</span><br><span class="line">        List animals1=(List) in1.readObject(),</span><br><span class="line">             animals2=(List) in1.readObject(),</span><br><span class="line">             animals3=(List) in2.readObject();</span><br><span class="line">        System.out.print(</span><br><span class="line">                <span class="string">"animals1:"</span>+animals1+<span class="string">"\n"</span>+</span><br><span class="line">                <span class="string">"animals2:"</span>+animals2+<span class="string">"\n"</span>+</span><br><span class="line">                 <span class="string">"animals3:"</span>+animals3);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>运行上面的程序我们能够得出这样的结论，当我们在同一个流中写入两个对象时，当取出时，这两个恢复的对象将会指向同样的引用，也就是说对象链接是一样的，但是当我们将对象保存在不同的流时，恢复对象时，这两个对象的对象树保存在不同的内存地址中，两个对象之间没有任何关联<br>（我猜测，在序列化对象时，可能会将对象的内存地址的信息也保存下来，比如对象的引用中就有关于对象内存地址的信息，待序列化对象的引用同样也会有内存地址的信息，因此在反序列化时，会查看序列化中保存的对象内存地址以判断待反序列化对象与其他序列化对象之间的关系，当反序列化之后会进行正确的链接，这就能说明了animals1和animal2的toString返回的信息完全一样（指向同样的内存地址，包括子对象也是如此））<br><strong>如果我们想要保存系统状态，最安全的做法是将其作为“原子”操作进行序列化</strong>，如果我们序列化了某些东西，再去其他的一些工作，再来序列化更多的东西，如此等等，那么将无法安全地保存系统状态，取而代之的是，将构成系统状态的所有对象都置入单一容器内，并在一个操作中将该容器直接写出，然后同样只需一次方法调用，既可以将其恢复（原因是，当我们分步进行序列化的期间，你所保存的对象状态可能已经发生了变化，序列化保存的信息已经“过时了”）</p>
<h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><p><strong>对象序列化的一个重要的限制就是它只是java的解决方案</strong>只有java程序才能反序列化这种对象，一种更具有操作性的解决方案是将数据转换为xml格式，这可以使其被各种各样的平台和语言使用<br>你可以使用java的标准类库中的javax.xml.*，也可以使用开源的XOM类库，使用方法很简单，就是为对象建立一个文档对象模型（Document）这里是通过节点层次结构来表示对象的信息的，然后将其写入输出流即可，这里不讲</p>
<h2 id="Preferences"><a href="#Preferences" class="headerlink" title="Preferences"></a>Preferences</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreferencesDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Preferences prefs= Preferences.userNodeForPackage(PreferencesDemo.class);</span><br><span class="line">        prefs.put(<span class="string">"location"</span>,<span class="string">"oz"</span>);</span><br><span class="line">        prefs.put(<span class="string">"Footwear"</span>,<span class="string">"Ruby Slippers"</span>);</span><br><span class="line">        prefs.putInt(<span class="string">"Companions"</span>,<span class="number">4</span>);</span><br><span class="line">        prefs.putBoolean(<span class="string">"Ara there witches"</span>,<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">int</span> usageCount=prefs.getInt(<span class="string">"usageCount"</span>,<span class="number">0</span>);</span><br><span class="line">        usageCount++;</span><br><span class="line">        prefs.putInt(<span class="string">"UsageCount"</span>,usageCount);</span><br><span class="line">        <span class="keyword">for</span>(String key:prefs.keys())&#123;</span><br><span class="line">            System.out.println(key+<span class="string">":"</span>+prefs.get(key,<span class="keyword">null</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//you musy always provide a default value</span></span><br><span class="line">        System.out.println(<span class="string">"how many companions does Derothy havs?"</span></span><br><span class="line">        + prefs.getInt(<span class="string">"Companions"</span>,<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/19/Java-I-O系统/" data-id="cjnzv2psx003hcorzm29tvxfl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-容器深入研究" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/19/容器深入研究/" class="article-date">
  <time datetime="2018-10-19T14:05:34.000Z" itemprop="datePublished">2018-10-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习心得/">学习心得</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/19/容器深入研究/">容器深入研究</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="完整的容器分类法"><a href="#完整的容器分类法" class="headerlink" title="完整的容器分类法"></a>完整的容器分类法</h2><h2 id="填充容器"><a href="#填充容器" class="headerlink" title="填充容器"></a>填充容器</h2><p>虽然容器打印问题解决了，容器的填充仍然像Arrays一样面临着同样的问题，就像Arrays一样，相应的Collections类也有一些实用的static方法，其中包括fill(),与Arrays一样，此fill()方法也是只复制同一个对象引用来填充整个容器，并且只对List对象有用，但是所产生的列表可以传递给构造器或addAll()方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringAddress</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String s;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringAddress</span><span class="params">(String s)</span></span>&#123;s=s;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">super</span>.toString()+s;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FillingLists</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;StringAddress&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Collections.nCopies(<span class="number">4</span>, <span class="keyword">new</span> StringAddress(<span class="string">"Hello"</span>)));</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        Collections.fill(list,<span class="keyword">new</span> StringAddress(<span class="string">"world"</span>));</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">~~~上面这个例子展示了用对单个对象的引用来填充Collection的方式，第一种是使用Collections.nCopies()创建传递给构造器的List，这里填充的是ArrayList</span><br><span class="line">StringAddress的toString()调用了它的基类Object的toString()方法，这个方法返回的是该类的名字，后面紧跟着该对象的散列码的十六进制表示（通过hashCode()产生的），从输出中你可以看到所有引用都是指向的同一个对象，这在第二个方法被调用之后也是同样如此，fill()方法的作用有限，因为它只能替换已经在List中存在的元素，而不能添加新的元素</span><br><span class="line">### 一种Generator解决方案 ###</span><br><span class="line">**事实上，所有的Collection子类型都有一个接收另一个Collection对象的构造器，用所接收的Collection对象中的元素来填充新的容器**，为了更好地创建测试数据，我们需要做的是创建接受Generator和quantity数值并将它们当作参数的类</span><br><span class="line">**这个类使用Generator在容器中放置所需要的对象，然后所产生的容器可以传递给任何Collection的构造器**，这个构造器会把其中的数据复制到自身中，addAll()方法是所有Collection子类型的一部分，它也可以用来组装现有的Collection</span><br><span class="line">**泛型便利方法可以减少在使用类时所必需的类型检查**</span><br><span class="line">CollectionData是适配器设计模式的一个实例，它将Generator适配到Collection的构造器上</span><br><span class="line">~~~java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionData</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CollectionData</span><span class="params">(Generator&lt;T&gt; gen,<span class="keyword">int</span> quantity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;quantity;i++) &#123;</span><br><span class="line">           add(gen.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">CollectionData&lt;T&gt; <span class="title">list</span><span class="params">(Generator&lt;T&gt; gen,<span class="keyword">int</span> quantity)</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span>  <span class="keyword">new</span> CollectionData&lt;&gt;(gen,quantity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Map生成器"><a href="#Map生成器" class="headerlink" title="Map生成器"></a>Map生成器</h3><p>我们可以对Map使用相同的方法，但是这需要一个Pair类，因为为了组装Map,每次调用Generator的next()方法都必须产生一个对象对（一个键和一个值）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> K k;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V v;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(K k,V v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.k=k;</span><br><span class="line">        <span class="keyword">this</span>.v=v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>适配器现在可以使用不同的Generator，Iterator和常量值的组合来填充Map初始化对象了,你可以使用单一的Generator&lt;pair&lt;K,V&gt;&gt;,两个分离的Generator，一个Generator和一个常量值，一个Iterable和一个Generator，随你的心情定制<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapData</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapData</span><span class="params">(Generator&lt;Pair&lt;K,V&gt;&gt; gen,<span class="keyword">int</span> qantity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;qantity;i++) &#123;</span><br><span class="line">            put(gen.next().k, gen.next().v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapData</span><span class="params">(Generator&lt;K&gt; genK,Generator&lt;V&gt; genV,<span class="keyword">int</span> quantity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;quantity;i++)&#123;</span><br><span class="line">           put(genK.next(),genV.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapData</span><span class="params">(Generator&lt;K&gt; genK,V value,<span class="keyword">int</span> quantity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;quantity;i++)&#123;</span><br><span class="line">            put(genK.next(),value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapData</span><span class="params">(Iterable&lt;Pair&lt;K,V&gt;&gt; it,<span class="keyword">int</span> quantity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Pair&lt;K,V&gt; pair:it)&#123;</span><br><span class="line">            put(pair.k,pair.v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapData</span><span class="params">(Iterable&lt;K&gt; itK,Generator&lt;V&gt; genV)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(K key:itK)&#123;</span><br><span class="line">            put(key,genV.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="function">MapData&lt;K,V&gt; <span class="title">map</span><span class="params">(Generator&lt;Pair&lt;K,V&gt;&gt; gen,<span class="keyword">int</span> quantity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MapData&lt;&gt;(gen,quantity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="function">MapData&lt;K,V&gt; <span class="title">map</span><span class="params">(Generator&lt;K&gt; genK,Generator&lt;V&gt; genV,<span class="keyword">int</span> quantity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> MapData&lt;&gt;(genK,genV,quantity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="使用Abstrcat类"><a href="#使用Abstrcat类" class="headerlink" title="使用Abstrcat类"></a>使用Abstrcat类</h3><p>对于产生用于容器的测试数据问题，另一种解决方式是创建定制的Collection和Map实现，每个java.util容器都有其自己的Abstract类,它们提供了该容器的部分实现，因此你必须做的只是去实现那些产生想要容器所需的方法，如果所产生的容器是只读的，就像它通常用的测试数据那样，那么你需要提供的方法数量将减到最少<br>尽管在在比例中不是特别需要，但下面的的剞劂方案还是提供了一个机会来演示另一种设计模式：享元。你可以在普通的解决方案中需要过多的对象，后者产生普通对象太占空间时使用享元，享元使得对象的一部分可以被具体化，因此，与对象中的所有事物都包含在对象内部不同，我们可以在更加高效的外部表中查找对象的一部分或者整体（或者同某些其他节省空间的计算来产生对象的一部分或整体）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Countries</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String[][] DATA=&#123;</span><br><span class="line">            &#123;<span class="string">"ANGDAL"</span>,<span class="string">"Luanda"</span>&#125;,&#123;<span class="string">"NIID"</span>,<span class="string">"asdasd"</span>&#125;,&#123;<span class="string">"sdasdasd"</span>,<span class="string">"asdasdasd"</span>&#125;,</span><br><span class="line">            &#123;<span class="string">"asdasdasd"</span>,<span class="string">"adsdfasda"</span>&#125;,&#123;<span class="string">"GUPOOAD"</span>,<span class="string">"sdfsdf"</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyWeightMap</span> <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">String</span>,<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//创建一个嵌套的内部类Entry以提供EntrySet使用</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">String</span>,<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> index;</span><br><span class="line">            Entry(<span class="keyword">int</span> index)&#123;<span class="keyword">this</span>.index=index;&#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> DATA[index][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> DATA[index][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">setValue</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> DATA[index][<span class="number">0</span>].equals(o);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> DATA[index][<span class="number">0</span>].hashCode();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">String</span>,<span class="title">String</span>&gt;&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">            EntrySet(<span class="keyword">int</span> size)&#123;</span><br><span class="line">                <span class="keyword">if</span>(size&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">this</span>.size=<span class="number">0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(size&gt;DATA.length)&#123;</span><br><span class="line">                     <span class="keyword">this</span>.size=DATA.length;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">this</span>.size=size;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Iter</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">String</span>,<span class="title">String</span>&gt;&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">private</span> Entry entry=<span class="keyword">new</span> Entry(-<span class="number">1</span>);</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> entry.index&lt;size-<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> Map.<span class="function">Entry&lt;String, String&gt; <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    entry.index++;</span><br><span class="line">                    <span class="keyword">return</span> entry;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Iter();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Set&lt;Map.Entry&lt;String,String&gt;&gt; entries=<span class="keyword">new</span> EntrySet(DATA.length);</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet() &#123;</span><br><span class="line">            <span class="keyword">return</span> entries;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Map&lt;String,String&gt; <span class="title">select</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FlyWeightMap()&#123;</span><br><span class="line">            <span class="keyword">public</span> Set&lt;Map.Entry&lt;String,String&gt;&gt; entrySet()&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> EntrySet(size);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;String,String&gt; map=<span class="keyword">new</span> FlyWeightMap();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String,String&gt; <span class="title">map</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String,String&gt; <span class="title">capitals</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> select(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> List&lt;String&gt; names=<span class="keyword">new</span> ArrayList&lt;String&gt;(map.keySet());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">names</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> names;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">names</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;String&gt;(select(size).keySet());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>二维数组String DATA是public的，因此可以在其他地方使用，FlyweightMap必须实现entrySet()方法，它需要定制的Set实现和定制的Map.Entry类，这里正是享元的部分，每个Map.Entry对象只存储了它的索引，而不是实际的值和键，当你调用getKey()和getValue()得时候它们会使用该索引来返回恰当的DATA元素，，EntrySet可以确保它的size不会大于DATA<br>你可以在EntrySet.Iterator中看到享元的其他部分实现，与为DATA中的每个数据对都创建Map.Entry对象不同，每个迭代器只有一个Map.Entry,<strong>Entry对象被用作数据的视窗</strong>，它只包含在静态字符串数组的引用，<strong>你每次调用迭代器的next()方法时，Entry中的index都会递增，使其指向下一个元素对，然后从next()返回该Iterator所持有的单一的Entry对象</strong></p>
<h2 id="Collection的功能方法"><a href="#Collection的功能方法" class="headerlink" title="Collection的功能方法"></a>Collection的功能方法</h2><p>下面列出了可以通过Collection执行的所有操作（不包括从Object继承的方法），因此，它们也是可通过Set和List执行的所有方法（List有额外的功能），Map不是继承自Collection的</p>
<table>
<thead>
<tr>
<th></th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean add(T)</td>
<td>确保容器持有具有泛型类型T的参数，如果没有将此参数添加进容器，则返回false（这是“可选”的方法）</td>
</tr>
<tr>
<td>boolean addAll(Collection<t>)</t></td>
<td>添加参数中的所有元素，只要添加了任意元素就返回true（可选的）</td>
</tr>
<tr>
<td>void clear()</td>
<td>移除容器中的所有元素（可选）</td>
</tr>
<tr>
<td>boolean contains(T)</td>
<td>如果容器已经持有具有泛型类型T此参数，则返回true</td>
</tr>
<tr>
<td>Boolean containsAll(Collection<t>)</t></td>
<td>如果容器持有此参数中的所有元素，则返回true</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>容器中没有元素返回true</td>
</tr>
<tr>
<td>Iterator<t> iterator()</t></td>
<td>返回一个Iterator<t>,可以遍历容器中的元素</t></td>
</tr>
<tr>
<td>Boolean remove(Object)</td>
<td>如果参数在容器内，则移除该元素的一个实例，如果做了移除动作，则返回true（可选）</td>
</tr>
<tr>
<td>Boolean removeAll(Collection&lt;?&gt;)</td>
<td>移除参数中的所有元素，只要有移除动作发生就返回true（可选）</td>
</tr>
<tr>
<td>Boolean retainAll(Collection&lt;?&gt;)</td>
<td>只保存参数中的元素（应用集合论的“交集”概念），只要Collection发生了改变就返回true(可选)</td>
</tr>
<tr>
<td>int size()</td>
<td>返回容器中保存的元素个数</td>
</tr>
<tr>
<td>Object[] toArray()</td>
<td>返回一个数组，该数组包含容器中的所有元素</td>
</tr>
<tr>
<td><t> T[] toArray(T[] a)</t></td>
<td>返回一个数组，该数组包含容器中的所有元素，返回结果的运行是类型与，参数数组类型相同，而不是单纯的Object</td>
</tr>
</tbody>
</table>
<p>注意上面的方法不包括随机访问所选择元素的get()方法，因为Collection包括了Set，而Set是自己维护内部顺序的（这使得随机访问变得没有意义），因此，如果想检查Collection的元素，就必须使用迭代器</p>
<h2 id="可选操作"><a href="#可选操作" class="headerlink" title="可选操作"></a>可选操作</h2><p>什么是可选操作？就是接口声明的，但是实现类并不一定支持其实现的方法就是可选操作<br>执行各种不同的添加和移除的方法在Collection接口中都是可选操作，这意味着实现类并不一定选需要为这些方法提供功能定义（记住是不一定需要提供功能定义，但是必须提供实现，因为实现接口中声明的方法一定要有实现，实现可以什么都不做，也可以直接抛出一个UnsupportedException异常）<br>这是一种很不寻常的接口定义方式，<strong>接口是面向对象设计中的契约</strong>，它声明了“无论你选择任何实现该接口，我保证你可以向该接口发送这些消息”，但是可选操作违反了这个基本原则，它声明调用某些方法将不会执行任何有意义的行为，相反，它会抛出异常，这看起来好像是编译期的类型安全好像被抛弃了，因为编译期的类型检查就是为了运行期程序的正常执行<br>但是事情并不那么糟糕，如果一个操作是可选的，编译器仍然后要求你只能调用该接口中的方法，这样动态语言不同，<strong>动态语言可以在任何对象上调用任何方法，并且可以在运行时发现某个特定方法是否可以工作</strong>，另外将Collection当作参数接受的大部分方法只会从该Collection中读取，而Collection的读取都是不可选的<br><strong>为什么你会讲方法定义为可选的呢？那是因为这样做可以防止在设计中出现接口爆炸的情况</strong>，容器类型的其他设计看起来总是在描述每个主题的各种变体，而最终患上了令人困惑的接口过剩症，<strong>这种方式可以实现java容器类库的一个重要目标：容器应该是易学易用的（我们假定这样的一种情形，如果我们的Collection方法只声明了较少的方法，那么当我们需要具有某个特性的容器类时，我们必须在类库中添加具有这些特性的接口，这就造成了接口膨胀，而且当我们进行客户端编程的时候，要时刻区分那些容器类都实现了那些接口，这时我们不能仅仅将其向上转型为Collection类型了，因为Collection类型中仅有少量的方法可调用），未获支持的操作是一种特例，可以延迟到需要时才出现，但是，这种方式能够工作</strong><br>而且这种设计留下了一个后门，如果你想要创建新的Collection，但是没有为Collection接口中的所有方法都提供有意义的支持，那么它仍旧适合现有的类库<br>未获支持的异常只有在运行时才能探测到，因此它们表示动态类型检查<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Unsupported</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String msg,List&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">        Collection&lt;String&gt; c=list;</span><br><span class="line">        Collection&lt;String&gt; subList=list.subList(<span class="number">1</span>,<span class="number">8</span>);</span><br><span class="line">        Collection&lt;String&gt; c2=<span class="keyword">new</span> ArrayList&lt;&gt;(subList);</span><br><span class="line">        <span class="keyword">try</span>&#123; c.retainAll(subList); &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"retain"</span>+e); &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">try</span>&#123; c.remove(subList); &#125;<span class="keyword">catch</span>(Exception e)&#123; </span><br><span class="line">            System.out.println(<span class="string">"remove"</span>+e); &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">try</span>&#123; c.clear(); &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"clear"</span>+e); &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span>&#123; c.add(<span class="string">"x"</span>); &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"add"</span>+e); &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">try</span>&#123; c.addAll(c2); &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"addAll"</span>+e); &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">try</span>&#123; list.set(<span class="number">0</span>,<span class="string">"x"</span>); &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"List.set"</span>+e); &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list= Arrays.asList(<span class="string">"A B C D E F G H I "</span>.split(<span class="string">" "</span>));</span><br><span class="line">        test(<span class="string">"modifiable"</span>,<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">        test(<span class="string">"asList"</span>,list);</span><br><span class="line">        test(<span class="string">"unmodifiableList"</span>, Collections.unmodifiableList(<span class="keyword">new</span> ArrayList&lt;&gt;(list))); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最常见的未获支持的操作，都来源于背后由固定尺寸的数据结构支持的容器<br>我们看上面的一个例子。Arrays.asList()返回的容器对象就是以传入的数组对象为其底层的数据结构为基础提供容器的功能，因为我们知道，数组尺寸大小固定，所以对这个容器进行的增删都是未获支持的（容器的增删操作定义了执行这些操作时，容器的size必须改变，因为数组的length不可修改，所有，这样的容器自然不能进行增删操作了，不然就违反了容器原则）<br>但是我们将一个Arrays.asList（）返回的容器作为构造器的参数传递给ArrayList时，却发现了此时可以对这个容器进行增删操作了，这是因为，这样的方式会产生新的尺寸可调的底层数据结构。Collections类的“不可修改” 的方法将容器包装到了一个代理，只要进行任何试图修改容器的操作，这个代理都会产生一个UssupportedOperationException异常<br>最后一个方法set()比较有意思，对于Arrays.asList()返回的容器可以调用的，因为这个操作并不会改变尺寸，只是修改了某个位置元素而已，而对于Collections.unmodifiableLis()返回的容器只读，任何的写操作都不支持<br>最后，如果你要编写一个接受Collection类型的方法，其文档应该指定那些可选操作必须实现</p>
<h2 id="List的功能方法"><a href="#List的功能方法" class="headerlink" title="List的功能方法"></a>List的功能方法</h2><p>List继承了Collection接口，又添加了本身的一些接口方法，因此每一个实现了List接口的List容器实现都可以调用这些方法，这些方法可以查看api，见名知义，另外要注意的一个实现类LinkedList这个实现类不仅实现了List接口，还实现了其他的接口，所有具有普通List所不具有的特性和方法，如addFrist(),addLast(),removeFrist()等…,具体api请参见Queue接口</p>
<h2 id="Set和存储顺序"><a href="#Set和存储顺序" class="headerlink" title="Set和存储顺序"></a>Set和存储顺序</h2><table>
<thead>
<tr>
<th></th>
<th>接口或Set容器实现类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Set(interface)</td>
<td>放在Set中的每一个元素都必须是唯一的，因为Set不保存重复元素，加入Set的元素必须定义equals()方法以确保对象的唯一性，set与Collection有完全一样的接口，<strong>Set接口不保证维护元素的次序</strong></td>
</tr>
<tr>
<td>HashSet*</td>
<td>为快速查找设计的Set，存入HashSet的元素必须定义hashCode()</td>
</tr>
<tr>
<td>TreeSet</td>
<td>保持次序的Set，底层为树结构，使用它可以从Set中提取有序的方法，元素必须实现Comparable接口</td>
</tr>
<tr>
<td>LinkedHashSet</td>
<td>具有HashSet的查询速度，其内部使用链表维护元素的顺序（插入顺序），于是在使用迭代器遍历Set时，结果会按元素插入的次序显示，也必须定义hashCode()</td>
</tr>
</tbody>
</table>
<p>在HashSet上打星号，表示如无特殊的要求，这个应该是我们的首选<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SetType</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SetType</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;i=n;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o <span class="keyword">instanceof</span> SetType &amp;&amp; (i==((SetType) o).i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="string">"SetType"</span>+i; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashType</span> <span class="keyword">extends</span> <span class="title">SetType</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashType</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;<span class="keyword">super</span>(n);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hasCode</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeType</span> <span class="keyword">extends</span> <span class="title">SetType</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">TreeType</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeType</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;<span class="keyword">super</span>(n);&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(@NotNull TreeType o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (o.i&lt;i)? -<span class="number">1</span>:((o.i==<span class="number">0</span>)? <span class="number">0</span>:<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypesForSets</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Set&lt;T&gt; <span class="title">fillSet</span><span class="params">(Set&lt;T&gt; set,Class&lt;T&gt;  type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                set.add(type.getConstructor(<span class="keyword">int</span>.class).newInstance(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> set;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(Set&lt;T&gt; set,Class&lt;T&gt; type)</span></span>&#123;</span><br><span class="line">        fillSet(set,type);</span><br><span class="line">        fillSet(set,type);</span><br><span class="line">        fillSet(set,type);</span><br><span class="line">        System.out.println(set);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        test(<span class="keyword">new</span> HashSet&lt;HashType&gt;(),HashType.class);</span><br><span class="line">        test(<span class="keyword">new</span> LinkedHashSet&lt;HashType&gt;(),HashType.class);</span><br><span class="line">        test(<span class="keyword">new</span> TreeSet&lt;TreeType&gt;(),TreeType.class);</span><br><span class="line"></span><br><span class="line">        test(<span class="keyword">new</span> HashSet&lt;SetType&gt;(),SetType.class);</span><br><span class="line">        test(<span class="keyword">new</span> HashSet&lt;TreeType&gt;(),TreeType.class);</span><br><span class="line">        test(<span class="keyword">new</span> LinkedHashSet&lt;TreeType&gt;(),TreeType.class);</span><br><span class="line">        test(<span class="keyword">new</span> LinkedHashSet&lt;SetType&gt;(),SetType.class);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test(<span class="keyword">new</span> TreeSet&lt;HashType&gt;(), HashType.class);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            test(<span class="keyword">new</span> TreeSet&lt;SetType&gt;(),SetType.class);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果我们尝试着将没有恰当地支持必需的操作的类型用于需要这些方法的Set，那么将会有大麻烦，对于没有定义hashCode()的SetType或SetType,如果将它们放置到任何散列实现中都会产生重复值，这样就违背了Set的基本契约，这是相当烦人的，更烦人的是不会有任何的运行时错误，这是因为默认的hashCode()是合法的，即使它不正确<br>如果我们尝试着将没有实现Comparable的对象添加进TreeSet中，这会在运行期抛出异常，因为TreeSet的方法在内部会检测对象是否实现了Comparable</p>
<h3 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h3><p>SortedSet接口的唯一实现TreeSet,这个接口提供了一些附加的功能</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>comparator()</td>
<td>返回Comparator，或者返回null,表示以自然方式排序</td>
</tr>
<tr>
<td>T first()</td>
<td>返回容器的第一个元素</td>
</tr>
<tr>
<td>T last()</td>
<td>返回容器的最后一个元素</td>
</tr>
<tr>
<td>SortedSet<t> subSet(T fromElement,T toElement)</t></td>
<td>生成此Set的子集，范围从fromElement(包含)到toElement(不包含)</td>
</tr>
<tr>
<td>SortedSet<t>  headSet(T toElement)</t></td>
<td>由小于ToElement的元素组成的子集</td>
</tr>
<tr>
<td>SortedSet<t> tailSet(T fromElement</t></td>
<td>由大于或等于fromElement的元素组成的子集</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sorted</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SortedSet&lt;String&gt; set=<span class="keyword">new</span> TreeSet&lt;String&gt;();</span><br><span class="line">        Collections.addAll(set,<span class="string">"one two three"</span>.split(<span class="string">" "</span>));</span><br><span class="line">        System.out.println(set);</span><br><span class="line">        String low=set.first();</span><br><span class="line">        String high=set.last();</span><br><span class="line">        Iterator&lt;String&gt; it=set.iterator();</span><br><span class="line">        SortedSet&lt;String&gt; toFromSubSet=set.subSet(low,high);</span><br><span class="line">        SortedSet&lt;String&gt; headSubSet=set.headSet(high);</span><br><span class="line">        SortedSet&lt;String&gt; tailSubSet=set.tailSet(low);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>除了并发应用，Queue在java SE5中只有两个实现是LinkedList和PriorityQueue,它们的差异在于排序行为而不是性能<br>下面是涉及Queue实现的大部分操作的基本示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueBehavior</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count =<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(Queue&lt;T&gt; queue, Generator&lt;T&gt; gen)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">            queue.offer(gen.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(queue.peek()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(queue.remove()+<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Gen</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">        String[] s=<span class="string">"one two three four five six "</span>.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> s[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        test(<span class="keyword">new</span> LinkedList&lt;String&gt;(),<span class="keyword">new</span> Gen());</span><br><span class="line">        test(<span class="keyword">new</span> PriorityQueue&lt;String&gt;(),<span class="keyword">new</span> Gen());</span><br><span class="line">        test(<span class="keyword">new</span> ArrayBlockingQueue&lt;String&gt;(count),<span class="keyword">new</span> Gen());</span><br><span class="line">        test(<span class="keyword">new</span> LinkedBlockingQueue&lt;String&gt;(count),<span class="keyword">new</span> Gen());</span><br><span class="line">        test(<span class="keyword">new</span> ConcurrentLinkedQueue&lt;String&gt;(),<span class="keyword">new</span> Gen());</span><br><span class="line">        test(<span class="keyword">new</span> PriorityBlockingQueue&lt;String&gt;(),<span class="keyword">new</span> Gen());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h3><p>优先队列就是从一端插入，从另一端取出，而取出的顺序是按优先级的，所以元素要实现Comparable，我们看下一个简单的toDo列表的问题<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToDolist</span> <span class="keyword">extends</span> <span class="title">PriorityQueue</span>&lt;<span class="title">ToDolist</span>.<span class="title">ToDoItem</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ToDoItem</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ToDoItem</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">char</span> primary;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> secondary;</span><br><span class="line">        <span class="keyword">private</span> String item；</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ToDoItem</span><span class="params">(String item,<span class="keyword">char</span> primary,<span class="keyword">int</span> secondary)</span></span>&#123;</span><br><span class="line">            primary=primary;</span><br><span class="line">            secondary=secondary;</span><br><span class="line">            item=item;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(@NotNull ToDolist.ToDoItem o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(primary&gt;o.primary)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(primary==o.primary)&#123;</span><br><span class="line">                <span class="keyword">if</span>(secondary&gt;o.secondary)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(secondary==o.secondary)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String td,<span class="keyword">char</span> pri,<span class="keyword">int</span> sec)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.add(<span class="keyword">new</span> ToDoItem(td,pri,sec));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ToDolist toDolist=<span class="keyword">new</span> ToDolist();</span><br><span class="line">        toDolist.add(<span class="string">"Empty"</span>,<span class="string">'C'</span>,<span class="number">4</span>);</span><br><span class="line">        toDolist.add(<span class="string">"Feed Dog"</span>,<span class="string">'A'</span>,<span class="number">2</span>);</span><br><span class="line">        toDolist.add(<span class="string">"Empty"</span>,<span class="string">'B'</span>,<span class="number">7</span>);</span><br><span class="line">        toDolist.add(<span class="string">"Empty"</span>,<span class="string">'C'</span>,<span class="number">3</span>);</span><br><span class="line">        toDolist.add(<span class="string">"Empty"</span>,<span class="string">'A'</span>,<span class="number">1</span>);</span><br><span class="line">        toDolist.add(<span class="string">"Empty"</span>,<span class="string">'B'</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(!toDolist.isEmpty())&#123;</span><br><span class="line">            System.out.println(toDolist.remove());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h3><p><strong>双端队列就像是一个队列，但是你可以在任何一端添加或移除元素，在LinkedList中包含了双端队列的方法，但在java标准类库没有任何显式的用于双向队列的接口</strong>，因此你无法将一个LinkedList向上转型到Deque这样的接口（没有这样的接口），但是，你可以使用组合来创建一个Deque，并直接从LinkedList中暴露相关的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Deque</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;T&gt; deque=<span class="keyword">new</span> LinkedList&lt;T&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFrist</span><span class="params">(T item)</span></span>&#123;deque.addFirst(item);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(T item)</span></span>&#123;deque.addLast(item);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFrits</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> deque.getFirst();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span></span>&#123;<span class="keyword">return</span>  deque.getLast();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">removeFrist</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> deque.removeFirst();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">removeLast</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> deque.removeLast();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> deque.size();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> deque.toString();&#125;</span><br><span class="line">    <span class="comment">//other method</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实双端队列在程序中使用的并不是很多，因为我们也很少有需求需要在两端放入元素并取出它们</p>
<h2 id="理解Map"><a href="#理解Map" class="headerlink" title="理解Map"></a>理解Map</h2><p>映射表（关联数组）的基本思想是它维护键值关联，因此你可以使用键来查找值，标准的java类库包含了Map的几种基本实现。包括HashMap,TreeMap,LinedHashMap,WeakHashMap,ConcurretHashMap,IdentityHashMap,它们都有同样的基本接口Map，但是行为特性各不相同，这表现在效率，键值对的保存及呈现次序，对象的保存周期，映射表如何在多线程程序中工作和如何判定“键”等价性的策略等方面<br>我们先观察关联数组是如何创建的，下面是一个极其简单的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AssociativeArray</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[][] pairs;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">AssociativeArray</span><span class="params">(<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        pairs=<span class="keyword">new</span> Object[length][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key,V value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;=pairs.length)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException();</span><br><span class="line">        &#125;</span><br><span class="line">       pairs[index++]=<span class="keyword">new</span> Object[]&#123;key,value&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pairs[i][<span class="number">0</span>].equals(key))&#123;</span><br><span class="line">                <span class="keyword">return</span> (V)pairs[i][<span class="number">0</span>];</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuilder stb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line">            stb.append(pairs[i][<span class="number">0</span>]);</span><br><span class="line">            stb.append(<span class="string">":"</span>);</span><br><span class="line">            stb.append(pairs[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的例子是个很简单的Map实现，主要实现了put()和get(),而且是以Object数组为底层数据结构，并且不可自动调整尺寸的，这个例子看看就好</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>性能是映射表中的一个重要问题，当在get()中使用线性搜索时，执行速度会相当地慢，而这正是HashMap提高速度的地方，HashMap使用了特殊的值称作散列码，来取代对键的缓慢搜索，散列码是相对唯一的，，它通过对象的某些信息进行转换而成的，hashCode()是根类Object的方法，因此所有java对象都能产生散列码，HashMap就是使用对象的hashCode()进行快速搜索的，此方法能够显著提高速度<br>我们看下Map的各种实现</p>
<table>
<thead>
<tr>
<th>实现类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>HashMap</td>
<td>Map是基于散列表的实现（它取代了MaoTable）插入和查询“键值对”的开销是固定的，可以通过构造器设置容量和负载因子，以调整性能</td>
</tr>
<tr>
<td>LinkdHashMap</td>
<td>类似与HashMap，但是迭代遍历它时，取得“键值对”的顺序是其插入次序，或者是最近最少使用（LRU）的次序，只是比HashMap慢一点，而在迭代访问时反而更快，因为它使用链表维护内部次序</td>
</tr>
<tr>
<td>TreeMap</td>
<td>基于红黑树的实现，查看“键”或“键值对”时，它们会被排序（次序又Comparable或Comparator决定），TreeMap的特点在于，所得到的结果是经过排序的，TreeMap是唯一的带有SubMap()方法的Map，它可以返回一个子树</td>
</tr>
<tr>
<td>weakHashMap</td>
<td>弱键（weak key）映射，允许释放映射所指向的对象，这是为了解决某类特殊问题而设计的，如果映射之外没有引用指向某个“键”，则此“键”可以被垃圾回收器回收</td>
</tr>
<tr>
<td>ConcurrentHashMap</td>
<td>一种线程安全的Map，它不涉及同步加锁，我们将在“并发”中讨论它</td>
</tr>
<tr>
<td>IdentityHashMap</td>
<td>使用==代替equals()对“键”进行比较的散列映射，专为解决特殊问题而设计的</td>
</tr>
</tbody>
</table>
<p>对Map中使用的键的要求和对Set中的元素要求是一样的，任何键都要具有equals()方法，如果键被用于散列Map，则对象要有恰当的hashCode(),如果键被用于TreeMap，则它必须要实现Comparable<br>下面是Map接口的可用操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Maps</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printKeys</span><span class="params">(Map&lt;Integer,String&gt; map)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Size="</span>+map.size());</span><br><span class="line">        System.out.println(<span class="string">"Keys"</span>+map.keySet());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Map&lt;Integer,String&gt; map)</span></span>&#123;</span><br><span class="line">        System.out.println(map.getClass().getSimpleName());</span><br><span class="line">        map.putAll(<span class="keyword">new</span> CountringMapData(<span class="number">25</span>));</span><br><span class="line">        printKeys(map);</span><br><span class="line">        System.out.println(<span class="string">"values:"</span>+map.values());</span><br><span class="line">        System.out.println(map.containsKey(<span class="number">11</span>));</span><br><span class="line">        System.out.println(map.get(<span class="number">11</span>));</span><br><span class="line">        System.out.println(map.containsValue(<span class="string">"F0"</span>));</span><br><span class="line">        Iterator&lt;Integer&gt; keyIt=map.keySet().iterator();</span><br><span class="line">        Integer key=keyIt.next();</span><br><span class="line">        map.remove(key);</span><br><span class="line">        printKeys(map);</span><br><span class="line">        map.clear();</span><br><span class="line">        System.out.println(map.isEmpty());</span><br><span class="line">        map.putAll(<span class="keyword">new</span> CountringMapData(<span class="number">25</span>));</span><br><span class="line">        map.keySet().removeAll(map.keySet());</span><br><span class="line">        System.out.println(map.isEmpty());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="SortedMap"><a href="#SortedMap" class="headerlink" title="SortedMap"></a>SortedMap</h3><p>使用SortedMap(TreeMap是现阶段的唯一实现)，可用确保键处于排序状态，这使得它具有额外的功能，这些功能都是由SortedMap的接口提供的<br>Comparator comparator()返回当前Map使用的Comparator，或者返回null<br>T firstKey()返回Map中的第一个元素<br>T lastKey()返回Map中的最后一个元素<br>SortedMap subMap(fromKey,toKey)，SortedMap headMap(toKey) SortedMap tailMap(fromKey) 生成此Map的一个子集</p>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>为了提高速度，LinkedHashSet散列了所有元素，但是在遍历键值对时，却又以元素的插入顺序返回键值对，此外，可以构造器中设定LinkedhashMap，使之采用基于访问最近最少量（LRU）算法，于是没有被访问过的（可被看做需要删除的）元素就会出现在队列的前面，对于需要定期清理元素以节省空间的程序来说，此功能使得程序很容易得以实现，下面的例子演示了LinkedHashMap的这两个特点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMapDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        LinkedHashMap&lt;Integer,String&gt; linkedMap=<span class="keyword">new</span> LinkedHashMap&lt;&gt;(<span class="keyword">new</span> CountringMapData(<span class="number">25</span>));</span><br><span class="line">        System.out.println(linkedMap);</span><br><span class="line">        <span class="comment">//least-recent-used-order</span></span><br><span class="line">        linkedMap=<span class="keyword">new</span> LinkedHashMap&lt;&gt;(<span class="number">16</span>,<span class="number">0.75f</span>,<span class="keyword">true</span>);</span><br><span class="line">        linkedMap.putAll(<span class="keyword">new</span> CountringMapData(<span class="number">25</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">            linkedMap.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(linkedMap);</span><br><span class="line">        linkedMap.get(<span class="number">0</span>);</span><br><span class="line">        System.out.println(linkedMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的例子可以看出，可通过设定容器的容量和负载因子来调整容器的性能和行为</p>
<h2 id="散列和散列码"><a href="#散列和散列码" class="headerlink" title="散列和散列码"></a>散列和散列码</h2><p>使用标准类型的类当作HashMap的键来使用，是很好用的，因为这些类库在设计时，已经重新实现了一个比较恰当的hashCode()和equals()方法，但是如果自己创建的类，就有可能忘记在其中放置必需的方法，这通常会引起很大的错误<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Groundhog</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Groundhog</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;number=number;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">"GroundHog#"</span>+number;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Prediction</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand=<span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">shadow</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> rand.nextDouble()&gt;<span class="number">0.5</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(shadow())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Six more weeks of winter"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Early Spring"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDetecter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Groundhog&gt; <span class="function"><span class="keyword">void</span> <span class="title">detectSpring</span> <span class="params">(Class&lt;T&gt; type)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Constructor&lt;T&gt; ghog=type.getConstructor(<span class="keyword">int</span>.class);</span><br><span class="line">        Map&lt;Groundhog,Prediction&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            map.put(ghog.newInstance(i),<span class="keyword">new</span> Prediction());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        Groundhog gh=<span class="keyword">new</span> Groundhog(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">"looking up prediction for "</span> +gh);</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(gh))&#123;</span><br><span class="line">            System.out.println(map.get(gh));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"not found"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		            detectSpring(Groundhog.class);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的示例很简单，创建一个Map容器，将Groundhog(土拨鼠)与Prediction（天气预报）关联起来，可是这个示例是不工作的，当我们创建一个土拨鼠new Groundhog(3)时，是无法找到这个键的，根本原因是Groundhog继承了Object的hashCode()方法，而它默认是使用的对象的地址计算散列码，因此由Groundhog(3)生成的一个实例的散列码和第二个生成的实例的散列码并不相同，记住一点的是散列码的作用是查找（快速定位）<br>因此你可能会认为只要编写恰当的hashCode()就可以了，但是它仍然无法正常运行，除非你同时覆盖equals()方法，它也是Object的一部分，HashMap使用equals()判断当前的键是否与表中存在的键相同，继承自Object的equals()默认以对象的地址为判断依据<br>正确的equals()方法必须满足下列5个条件</p>
<ol>
<li>自反性：对于任意的x x.equals(x)一定返回true</li>
<li>对称性：任意的x,y 如果x.equals(y)返回true，则y.equals(x)一定返回true;</li>
<li>传递性：任意的x,y,z, x,equals(y) y.equals(z),则x.equals(z)</li>
<li>一致性：任意的x,y 如果对象中用于等价比较的信息没有改变，那么无论调用x.equals()多少次，返回的结果应该保持一致</li>
<li>对于任何不是null的x x.equals(null)返回false</li>
</ol>
<p>再次强调，默认的Object.equals()比较的是对象地址，因此，如果要将自己的类作为HashMap的键，一定要同时覆盖hashCode()和equals()</p>
<h3 id="理解hashCode"><a href="#理解hashCode" class="headerlink" title="理解hashCode()"></a>理解hashCode()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MapEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> K k;</span><br><span class="line">    <span class="keyword">private</span> V v;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapEntry</span><span class="params">(K key,V value)</span></span>&#123;</span><br><span class="line">        k=key;</span><br><span class="line">        v=value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v=value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShowMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;K&gt; listK=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;V&gt; listV=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key,V value)</span></span>&#123;</span><br><span class="line">        V oldValue=get(key);</span><br><span class="line">        <span class="keyword">if</span>(!listK.contains(key))&#123;</span><br><span class="line">            listK.add(key);</span><br><span class="line">            listV.add(value);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            listV.set(listK.indexOf(key),value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span></span>&#123;<span class="comment">//key is type Object not K</span></span><br><span class="line">        <span class="keyword">if</span>(!listK.contains(key))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> listV.get(listK.indexOf(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">        Set&lt;Map.Entry&lt;K, V&gt;&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Iterator&lt;K&gt; itk = listK.iterator();</span><br><span class="line">        Iterator&lt;V&gt; itV = listV.iterator();</span><br><span class="line">        <span class="keyword">while</span> (itk.hasNext()) &#123;</span><br><span class="line">            set.add(<span class="keyword">new</span> MapEntry&lt;K,V&gt;(itk.next(), itV.next()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> set;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">         SlowMap&lt;String,String&gt; m=<span class="keyword">new</span> SlowMap&lt;&gt;();</span><br><span class="line">         m.putAll(Countries.capitals(<span class="number">15</span>));</span><br><span class="line">         System.out.println(m);</span><br><span class="line">         System.out.println(m.entrySet());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面一个例子，最值得注意的问题，我觉得在定义get(Object o)方法的时候，我们期望的是get(K key)但是在这里是不可以的，提示说both motehed have same erasure,这是我感到疑惑的地方，我们知道在同一个类中，方法签名相同是不被允许的，但是这里通过在子类定义与基类中涉及泛型的方法签名相同的方法也是不被允许的，即使它们都被擦除为Object也不可以，这是为什么？<br>上面这个Map的实现并不好，因为<strong>entrySet()方法的调用创建了副本，这样就使得方法调用的效率变低，Map.Entry最好的实现应该是作为窗口通过它我们可以获得键和值，而且我们还应该可以通过这个视图修改底层数据，这些是副本做不到的</strong></p>
<h3 id="为速度而散列"><a href="#为速度而散列" class="headerlink" title="为速度而散列"></a>为速度而散列</h3><p>上面的例子，效率低的另一个原因是，我们搜索键的时候，使用的是线性查询，这种查询方式非常缓慢<br>散列的价值在于速度，散列使得查询得以快速进行，<strong>由于瓶颈在于查询速度，因此解决方案之一就是保持键的排序状态，然后使用Collection.binarySearch()进行查询</strong><br><strong>散列更进一步，它将键保存在某处，以便能够很快找到，存储一组元素最快的数据结构是数组，所以用它来保存键的信息，请留言，这里说的是键的信息，而不是键本身</strong>，这样有一个问题就是，数组尺寸固定的问题，如果我们希望在Map中保存数量不确定的值，这种问题能解决吗？<br>答案就是：数组不保存键本身，因为一旦保存的是键对象本身的话，那么这个数组位置上能保持的元素也只有一个了，其实很好解决，我们通过键对象获得一个数值，这个数值就是散列码，这个散列码表示数组的下标，通过下标将键值对存在这个数组下标位置上的一个容器，那么问题就解决了，任意数量的元素都能存储在Map中，即使hashCode()冲突也能够在数组索引位置上的容器对象上添加新的元素，解决hashCode冲突问题，<br>总结一下，查询一个值的过程是，计算键的hashCode，通过散列码查询数组，找到相应数组位置上的LinkedList，遍历LinkedList使用equals()判断该取LinkedList中存储的哪个元素，这种Map实现的方式使得每次查询只在少量的数据上进行遍历，效率得到提高</p>
<h3 id="覆盖hashCode"><a href="#覆盖hashCode" class="headerlink" title="覆盖hashCode()"></a>覆盖hashCode()</h3><p>如果要使得HashMap的执行效率更佳，那在我们向容器当作添加元素的时候，应该使得元素落在容器的槽位更加均衡才好，桶位下标的产生我们没有办法控制，因为这与HashMap对象的容量有关，而容量的改变与容器的充满程度和负载因子有关，hashCode生成的值经过计算才会生成桶位下标<br>设计hashCode的一个最重要的一个因素是，无论何时，对同一个对象调用hashCode()都应该生成相同的值<br>此外，也不应该使hashCode（）依赖于唯一性的对象信息，比如this，这也是我们在创建一个新类时，总会忽略的可怕问题，使得即使对象的信息描述完全相同，Map却依然将其视为不同的对象<br>基于对象的内容生成散列码是正确的选择<br>另外一个重要的影响因素，好的hashCode()应该产生分布均匀的散列码，否则，HashMap中的某些桶位负载过重，效率也不会更好<br>有一些建议，可以参考网上的资料</p>
<h2 id="选择接口的不同实现"><a href="#选择接口的不同实现" class="headerlink" title="选择接口的不同实现"></a>选择接口的不同实现</h2><p>尽管实际上只有四种容器：List，Set,Map和Queue，但是每种接口都有不止一个版本的实现，如果需要某种接口的功能，如何选择使用哪个实现？<br>容器之间的区别通常归结为由什么在背后“支持”它们，也就是说，所使用的接口是由什么样的数据结构实现的，<br>例如，ArrayList和LinkedList都实现了List接口，ArrayList底层是由数组支持，而LinkedList是由双向链表实现</p>
<h3 id="对List的选择"><a href="#对List的选择" class="headerlink" title="对List的选择"></a>对List的选择</h3><p>随机访问：ArrayList的随机访问要比LinkedList的随机访问要快，因为ArrayList是基于数组实现的，所以随机查找时，可以直接定位到一个对象的位置，而且随机访问速度不太会受到容器尺寸的影响，但是LinkedList的随机访问并不好，因为它是基于链表实现的，随机访问时要通过链表中的对象线性的查找对象的内存地址，所有性能很差，而且会随着尺寸的增大代价变得更加高昂<br>插入和删除，因为Arraylist的底层数组支持的原因，当向ArrayList插入一个元素时，必须创建空间并将它的所有引用先后移动，这种修改内存数据的行为，非常的耗时，但是ArrayList就比较简单，只需要连接两边的元素即可，这种方式的代价是固定的，不会随着尺寸的改变而改变</p>
<h3 id="对Set的选择"><a href="#对Set的选择" class="headerlink" title="对Set的选择"></a>对Set的选择</h3><p>HashSet的性能基本上总是比TreeSet好，特别是在添加和查询元素时，而这两个操作也是总重要的操作，TreeSet存在的唯一原因是它可以维持元素的排序状态，只有当需要一个排好序的Set时，才应该用TreeSet，TreeSet的迭代要比HashSet快、</p>
<h3 id="对Map选择"><a href="#对Map选择" class="headerlink" title="对Map选择"></a>对Map选择</h3><p>HashMap是我们平时应该默认使用的Map，TreeMap和TreeSet一样，是一种创建有序列表的方式，填充完TreeaMap之后，调用keySet()方法获得一个有序列表，LinkedHashSet在插入时比HashMap要慢一点，因为它在维持散列结果的同时也要维持插入顺序，正是由于这个原因，它的迭代速度也更快一些</p>
<h4 id="HashMap的性能因子"><a href="#HashMap的性能因子" class="headerlink" title="HashMap的性能因子"></a>HashMap的性能因子</h4><p>容量：桶位<br>初始容量：表在创建时所拥有的桶位数，HashMap和HashSet都具有允许你指定初始容量的构造器<br>尺寸：表当前存储的项数<br>负载因子：（尺寸/容量）空表的负载因子是0，半满表是0.5,依次类推，负载因子小的表产生冲突的可能性较小，但是会浪费较多的内存空间，也会使得频繁的扩容（这种是典型的空间换时间），HashMap和HashSet都允许你指定初始的负载因子，当达到该负载因子的水平的时候，容器自动增加其容量（桶位），实现的方式是使容量大致加倍，并重新将现有对象分布到新的桶位上（再散列）（HashMap的默认负载因子是0.75）</p>
<h2 id="实用方法"><a href="#实用方法" class="headerlink" title="实用方法"></a>实用方法</h2><p>Java中有大量的容器的卓越的使用方法，它们被称为java.util.Collections的静态方法，常用的方法总结如下</p>
<table>
<thead>
<tr>
<th></th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>checkedCollection(Collection<t> Class<t> type)<br>checkedList(List<t> Class<t> type)<br>checkedSet(Set<t> Class<t> type)<br>checkedMap(Map&lt;K,V&gt;,Class<k> kType,Class<v> vType)</v></k></t></t></t></t></t></t></td>
<td>产生Collection或者Collection子类型动态类型安全的容器，在不可能使用静态检查版本的时使用这些方法</td>
</tr>
<tr>
<td>max(Collection)<br>mix(Collection)</td>
<td>返回参数Collection中最大或最小的元素，采用Comparator比较</td>
</tr>
<tr>
<td>indexOfSubList(List source,List target)</td>
<td>返回target在source中第一次出现的位置，或者找不到返回-1</td>
</tr>
<tr>
<td>lastIndexOfSubList(List source,List target)</td>
<td>返回target在source中最后一次出现的位置，或者找不到返回-1</td>
</tr>
<tr>
<td>replaceAll(List<t>,T oldVal,T newVal)</t></td>
<td>使用newVal替换所有的oldVal</td>
</tr>
<tr>
<td>reverse(List)</td>
<td>逆转所有元素的顺序</td>
</tr>
<tr>
<td>reverseOrder()<br>reverseOrder&lt;Comparator<t>&gt;</t></td>
<td>返回一个Comparator，第二个版本返回一个反序的比较器</td>
</tr>
<tr>
<td>rotate(List,int distance)</td>
<td>所有的元素向后移动distance个位置，后面的元素循环移到前面</td>
</tr>
<tr>
<td>suffle(List)<br>suffle(List,Random)</td>
<td>随机改变元素的顺序</td>
</tr>
<tr>
<td>sort(List)<br> sort&lt;List<t>,Comparator&lt;? super T&gt;&gt;</t></td>
<td>使用List<t>中的自然排序，第二个方法使用比较器的排序</t></td>
</tr>
<tr>
<td>copy(List&lt;? extends T&gt; dist,List&lt;? super T&gt; src)</td>
<td>将src中的元素复制到dist</td>
</tr>
<tr>
<td>swap(List,int i,int j)</td>
<td>交换元素的位置</td>
</tr>
<tr>
<td>fill（List&lt;? super T&gt;,T x）</td>
<td>用对象x替换所有元素</td>
</tr>
<tr>
<td>nCopies(int n,T x)</td>
<td>返回大小为n的List<t>,此List不可改变，其中的引用都指向x</t></td>
</tr>
<tr>
<td>disjoint(Collection,Collection)</td>
<td>当两个集合中没有相同的元素时，返回true</td>
</tr>
<tr>
<td>ferquency(Collection,Object x)</td>
<td>返回Collection中等于x的元素个数</td>
</tr>
<tr>
<td>unmodifiedCollection(Collection)<br>unmodifiedList(List)<br>unmodifiedSet(Set)<br>unmodifiedMap(Map)</td>
<td>生成只读容器</td>
</tr>
<tr>
<td>concurrentCollection(Collection)<br>concurrentList(List)<br>concurrentSet(Set)<br>concurentMap(Map)</td>
<td>生成线程安全的容器</td>
</tr>
</tbody>
</table>
<h2 id="持有引用"><a href="#持有引用" class="headerlink" title="持有引用"></a>持有引用</h2><p>java.lang.ref类库包含了一组类，这些类为垃圾回收器提供了更大的灵活性，当存在可能耗尽内存的大对象时，这次类显得特别有用，有三个继承自抽线类Reference的类，SoftReferenc ,WeakRefrence,PhantomReference,当垃圾回收器正在考察的对象只能通过某个Reference对象才“可获得的”时候，上述这些类给垃圾回收器提供了不同级别的间接指示<br>对象是可获得的（reachable）是值对象能在程序的某处能够找到，不可获得对象，程序不能再访问它们，对这些对象的回收是安全的<br>如果想继续持有某个对象的引用，希望以后还能访问它们，但是也希望能够允许垃圾回收器在内存不足的时候释放它们，这时就可使用Reference对象<br>以Reference对象作为你和普通引用之间的媒介（代理），另外，一定不能有普通的引用指向这个对象，这样就能达到上述的目的，<strong>普通的引用指没有经过Reference对象包装过的引用</strong>，如果垃圾回收器发现某个对象通过引用是可达的，该对象就不会被释放<br>SoftRefenece，WeakReference，PhantomReference由强到弱排列，对应不同级别的“可获得性”，SoftReference用以实现内存敏感的高速缓存，weakReference是为了实现“规范映射”而设计的，，它不妨碍垃圾回收映射的“键”（或“值”），“规范映射”中对象的实例可以在程序的多处被同时使用，以节省内存空间，PhantomReference用于调度回收器的清理工作，它比Java终止机制更灵活<br>使用SoftReference和WeakReferenc时，可以选择是否将它们放入ReferenceQueue(用作垃圾回收前的清理工作的工具)，而PhantomReference只能依赖于ReferenceQueue<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VeryBig</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE=<span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span>[] la =<span class="keyword">new</span> <span class="keyword">long</span>[SIZE];</span><br><span class="line">    <span class="keyword">private</span> String ident;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VeryBig</span><span class="params">(String s)</span></span>&#123;ident=s;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123; <span class="keyword">return</span>  ident; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Finalizing"</span>+ident );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">References</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReferenceQueue&lt;VeryBig&gt; rf=<span class="keyword">new</span> ReferenceQueue();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Reference&lt;? extends VeryBig&gt; inq=rf.poll();</span><br><span class="line">        <span class="keyword">if</span>(inq!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"In Queue"</span>+inq.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size=<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(args.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            size=<span class="keyword">new</span> Integer(args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LinkedList&lt;SoftReference&lt;VeryBig&gt;&gt; sa=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            sa.add(<span class="keyword">new</span> SoftReference&lt;VeryBig&gt;(<span class="keyword">new</span> VeryBig(<span class="string">"Soft"</span>+i),rf));</span><br><span class="line">            System.out.println(<span class="string">"Just created"</span>+sa.getLast());</span><br><span class="line">            checkQueue();</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedList&lt;WeakReference&lt;VeryBig&gt;&gt; wa=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            wa.add(<span class="keyword">new</span> WeakReference&lt;VeryBig&gt;(<span class="keyword">new</span> VeryBig(<span class="string">"Weak"</span>+i),rf));</span><br><span class="line">            System.out.println(<span class="string">"Just created"</span>+wa.getLast());</span><br><span class="line">            checkQueue();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        SoftReference&lt;VeryBig&gt; s=<span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> VeryBig(<span class="string">"Soft"</span>));</span><br><span class="line">        WeakReference&lt;VeryBig&gt; w=<span class="keyword">new</span> WeakReference&lt;&gt;(<span class="keyword">new</span> VeryBig(<span class="string">"weak"</span>));</span><br><span class="line">        </span><br><span class="line">        System.gc();</span><br><span class="line">        </span><br><span class="line">        LinkedList&lt;PhantomReference&lt;VeryBig&gt;&gt; pa=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            pa.add(<span class="keyword">new</span> PhantomReference&lt;VeryBig&gt;(<span class="keyword">new</span> VeryBig(<span class="string">"Phantom"</span>+i),rf));</span><br><span class="line">            System.out.println(<span class="string">"Just created"</span>+pa.getLast());</span><br><span class="line">            checkQueue();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h3><p>容器类中有一种特殊的Map，即WeakHashMap,它被用来保存WeakReference，它使得规范映射更易于使用，在这种映射中，每个值只保存一份实例以节省存储空间，当程序需要那个“值”的时候，便在映射中查询现有的对象，然后使用它（而不是重新再创建），映射可将值作为其初始化的一部分，不过通常是在需要的时候才生成“值”<br>这是一种节省空间的技术，因为WeakHashMap允许垃圾回收器自动清理键和值，所以它显得十分便利，对于向WeakHashMap添加键和值的操作，则没有什么特殊的要求，映射会自动使用WeakReference包装它们，允许清理元素的触发条件是，不再需要此键，如下所示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Element</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String ident;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Element</span><span class="params">(String id)</span></span>&#123;ident=id;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span>  ident;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> ident.hashCode();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o <span class="keyword">instanceof</span>  Element &amp;&amp; ident==((Element)o).ident;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fianlzie</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Finalizing"</span>+getClass().getSimpleName()+ident);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Element</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Key</span><span class="params">(String id)</span></span>&#123;<span class="keyword">super</span>(id);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Value</span> <span class="keyword">extends</span>  <span class="title">Element</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Value</span><span class="params">(String id)</span></span>&#123;<span class="keyword">super</span>(id);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CanonicalMapping</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size=<span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">if</span>(args.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            size=<span class="keyword">new</span> Integer(args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        Key[]  keys=<span class="keyword">new</span> Key[size];</span><br><span class="line">        WeakHashMap&lt;Key,Value&gt; wm=<span class="keyword">new</span> WeakHashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">           Key k=<span class="keyword">new</span> Key(Integer.toString(i));</span><br><span class="line">           Value v=<span class="keyword">new</span> Value(Integer.toString(i));</span><br><span class="line">           <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">               keys[i]=k;<span class="comment">//save as "real"  reference</span></span><br><span class="line">           &#125;</span><br><span class="line">           wm.put(k,v);</span><br><span class="line">        &#125;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/19/容器深入研究/" data-id="cjnzv2pqz002hcorzedmampfa" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-数组" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/19/数组/" class="article-date">
  <time datetime="2018-10-18T17:15:45.000Z" itemprop="datePublished">2018-10-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习心得/">学习心得</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/19/数组/">数组</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="数组为什么特殊"><a href="#数组为什么特殊" class="headerlink" title="数组为什么特殊"></a>数组为什么特殊</h2><p>java中有大量的方式可以持有对象，那么，到底是什么使数组变的与众不同？<br><strong>数组与其他种类容器之间的主要区别有三个方面：效率，类型和保存基本类型的能力</strong><br>效率：数组是一种效率最高的存储和随机访问对象引用序列的方式，数组就是一个线性序列，这使得元素访问非常快速，但是为了这种速度所付出的代价就是数组对象的大小被固定，这是一种典型的以空间换时间的取舍，数组的创建使得数组对象本身的存储空间被固定下来，因此，数组不能扩容，但是带来的好处确实，我们随机访问一个元素时非常快，因为虚拟机很容易就能定位到元素的内存地址<br>类型：在泛型之前，其他的容器类在处理对象时，都将它们视为没有具体类型，也就是说，它们将这些对象都当作Java中所有类的根类处理，这种做法在泛型之前是没有问题的，因为我们不应该将一个容器类指定为只能保存特定类型，如果如此的话，我们要创建大量的容器类，还有我们没有预见的容器类，这是不可能的，也是不现实的，因此将所有对象视为Object是合理的，但是这样的处理方式使得我们没有办法在编译期保证类型的正确性，只有在从容器中取出对象时才可能发现插入类型的不正确，泛型容器的出现，使得我们能够将类型检查放在编译期，从而解决了这个问题，数组对象本身对象的结构性天然的使得它具有只能持有类型正确对象的特性，也就是可以实现编译期的类型检查<br>持有基本类型：容器没有办法持有基本类型，这也很容易理解，因为一般基本类型对象的创建是在栈中，除非基本类型作为对象的属性存储在对象的内存空间内，容器类和数组存储结构最大的不同是在于，容器持有的对象并不在容器对象的内存空间中，它必须通过容器对象保存的元素的引用来访问元素对象，这些元素对象必须要被存储在堆中，所有造成了，容器不能持有（管理）基本类型，如果容器要想具有持有基本类型的能力必须通过包装器这种方式，而数组不同，数组的元素就存储在数组内存空间之中，这种特性很容易使得数组具有持有基本类型的能力<br>因为泛型和自动包箱和拆箱的出现，容器可以很容易的持有基本类型了，数组仅存的优点就是效率，可是使用数值又会受到太多的限制，所以一般情况下我们会选择使用容器而不是数组</p>
<h2 id="数组是第一级对象"><a href="#数组是第一级对象" class="headerlink" title="数组是第一级对象"></a>数组是第一级对象</h2><p>无论使用哪种类型的数组，数组标识符其实只是一个引用，指向堆中创建的一个真实对象，这个（数组）对象用以保存指向其他对象的引用（这里指的是引用数组），如果是基本类型数组，数组对象保存的是基本类型的值<br>只读成员length是数组对象的一部分（事实上，这是唯一yield可以访问的字段或方法），表示此数组对象可以存储多少元素，“[]”语法是访问数组对象元素的唯一方式<br>创建数组方式：</p>
<ol>
<li>作为数组初始化语法的一部分隐式创建，如 <code>String[] strs={&quot;hello&quot;,&quot;world&quot;}</code></li>
<li>使用new关键字显式地创建，如 <code>String[] strs = new String[2]</code>或者<code>String strs=new String[]{&quot;hello&quot;,&quot;world&quot;}</code></li>
</ol>
<p>有几个需要注意的地方：</p>
<ol>
<li>length只表示数组能够容纳多少个元素，也就是说length是数组大小（主要是用来做下标检查，并且不可变），而不是实际保存的元素的个数</li>
<li>数组创建时就已经完成了初始化，未被显式赋值的引用被初始化为null,基本类型被初始化为“零值<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><strong>创建多维数组很方便，对于基本类型的多维数组，可以通过使用花括号将每个向量分隔开</strong>，实际上多维数组中是通过每一维数组保存下一维数组对象的引用实现的<br>数组中的每个向量可以具有任意长度（这被称为粗糙数组）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RaggedArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        Random rand=new Random(<span class="number">47</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span>[][][] a=<span class="keyword">new</span> <span class="keyword">int</span>[rand.nextInt(<span class="number">7</span>)][][];<span class="comment">//创建数组时，第一维下标必须要被初始化，</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            a[i]=a[rand.nextInt(<span class="number">5</span>)];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;a[i].length;j++)&#123;</span><br><span class="line">                a[i][j]=<span class="keyword">new</span> <span class="keyword">int</span>[rand.nextInt(<span class="number">5</span>)];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.deepToString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="数组与泛型"><a href="#数组与泛型" class="headerlink" title="数组与泛型"></a>数组与泛型</h2><p>通常数组和泛型不能很好地结合，你不能实例化具有参数化类型的数组<br>    Peel<banana>[] peels=new Peel<banana>[10]//illegal<br><strong>擦除会移除参数类型信息，而数组必须知道它们所持有的确切类型，以强制保证类型安全</strong><br>但是，你可以参数化数组本身的类型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassParameter</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> T[] f(T[] arg)&#123; <span class="keyword">return</span>  arg;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodParameter</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] f(T[] arg)&#123;<span class="keyword">return</span> arg;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParameterizedArrayType</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Integer[] ints=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        Double[] doubles=&#123;<span class="number">1.1</span>,<span class="number">2.2</span>,<span class="number">3.3</span>,<span class="number">4.4</span>,<span class="number">5.5</span>&#125;;</span><br><span class="line">        Integer[] ints2=<span class="keyword">new</span> ClassParameter&lt;Integer&gt;().f(ints);</span><br><span class="line">        Double[] doubles2=<span class="keyword">new</span> ClassParameter&lt;Double&gt;().f(doubles);</span><br><span class="line">        Integer[] ints3=MethodParameter.f(ints);</span><br><span class="line">        Double[] doubles3=MethodParameter.f(doubles);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></banana></banana></p>
<p>注意，使用参数化方法而不使用参数化类的方便之处：你不必为需要应用的每种不同的类型都使用一个参数去实例化这个类，并且你可以将其定义为静态，当然，你不能总是选择使用参数方法而不是参数化类，但它应该成为首选<br>上面的例子证明了，不能创建泛型数组的这一说法并不准确，诚然，编译器确实不让你实例化泛型数组，但是，它允许你创建对这种数组的引用，例如<br>    List<string> list<br>这条语句可以顺利地通过编译器而不报任何错误，而且，尽管你不能创建实际的持有泛型的数组对象，但是你可以创建非泛型的数组，然后将其转型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayOfGenerics</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt;[] ls;</span><br><span class="line">        List[] la=<span class="keyword">new</span> List[<span class="number">10</span>];</span><br><span class="line">        ls=(List&lt;String&gt;[])la;<span class="comment">//"unchecked" warning</span></span><br><span class="line">        ls[<span class="number">0</span>]=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="comment">//ls[1]=new ArrayList&lt;Integer&gt;();compile-error checking produces an error</span></span><br><span class="line">        Object[] objects=ls;</span><br><span class="line">        <span class="comment">//compiles and runs without complaint</span></span><br><span class="line">        objects[<span class="number">1</span>]=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//howerve if your needs are straightforward it is</span></span><br><span class="line">        <span class="comment">//possible to create an array of generics,albeit("虽然")</span></span><br><span class="line">        <span class="comment">//with an "unchecked" warning</span></span><br><span class="line">        List&lt;BerylliumSphere&gt;[] spheres=(List&lt;BerylliumSphere&gt;[]) <span class="keyword">new</span> List[<span class="number">10</span>];</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;spheres.length;i++)&#123;</span><br><span class="line">				   spheres[i]=<span class="keyword">new</span> ArrayList&lt;BerylliumSphere&gt;();</span><br><span class="line">				&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></string></p>
<p>一旦拥有了对List<string>[]的引用，你就会看到你将得到某些编译器检查<br><strong>数组是协变类型的</strong>，因此向数组中添加元素，可以是数组声明类型的子类，这样在取出数组时，得到的是引用声明的类型，记住，<strong>引用类型主要是给编译器提供类型信息</strong><br>如果你知道将来不会向上转型，并且需求也相对简单，那么你仍旧可以创建泛型数组，它可以提供基本的编译期类型检查，但是，<strong>事实上，泛型容器总是比泛型数据更好的选择</strong><br>一般而言你会发现泛型在类或者方法的边界很有效，而在类或方法的内部，擦除通常会是泛型变得不适用，例如你不能创建泛型数组，如<code>new T[]</code>是错误的，因为数组的创建一定要确切的类型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayOfGenericType</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T[] array;<span class="comment">//is ok</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayOfGenericType</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="comment">//array=new T[size];  不可以创建泛型数组</span></span><br><span class="line">        <span class="comment">//所有对象的引用在堆中所占据的内存空间大小是一样的，所以我们先创建一个Object</span></span><br><span class="line">        <span class="comment">//的数组，给定size，数组在堆中分配的内存空间确定下来，我们将这个创建的数组</span></span><br><span class="line">        <span class="comment">//使用（T[]）进行转型，需要记住的这只是给了编译器一个转型提示，实际底层数组对象</span></span><br><span class="line">        <span class="comment">//头部保存的对象类型信息任何没有改变，它记录了自己保存的是Object类型的数据，</span></span><br><span class="line">        <span class="comment">//但是数组的引用类型指示了当向这个数组插入对象时进行类型检查需要的信息，以及在运行时</span></span><br><span class="line">        <span class="comment">//从数组中取出数据进行动态的类型转换</span></span><br><span class="line">        array=(T[])<span class="keyword">new</span> Object[size];<span class="comment">//unchecked warning </span></span><br><span class="line">        <span class="comment">//public &lt;U&gt; U[] makeArray()&#123; return; new U[10]&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></string></p>
<p>擦出再次成为了障碍——本例试图创建的类型以及被擦除了，因而是类型未知的数组，注意，你可以创建Obeject数组，然后将其转型，但是，如果没有@DSupressWarnings注解，你将在编译期得到一个“不受检查”的警告消息，因为这个组没有真正持有或动态检查类型T,也就是说，如果我创建了一个String[]，java在编译器和运行期都会强制我只能将String对象置于改数组中，如果创建的是Object数组，那么我可以将除基本类型之外的任何对象置于该数组</p>
<h2 id="创建测试数据"><a href="#创建测试数据" class="headerlink" title="创建测试数据"></a>创建测试数据</h2><p>通常，在实验数组和程序时，能够很方便地生成填充了测试数据的数组，将会很有帮助，我们来看看如何利用工具将数值和对象填充进数组</p>
<h3 id="Arrays-fill"><a href="#Arrays-fill" class="headerlink" title="Arrays.fill()"></a>Arrays.fill()</h3><p>java的标准类库Arrays有一个作用很有限的fill()方法，只能用一个填充各个位置，<strong>而针对对象而言，就是复制同一个引用来填充</strong>，可以填充整个数组，也可以填充数组的某个区域，但是由于只能使用单一的数值来调用Arrays.fill()，因此这个方法并没什么用</p>
<h3 id="数据生成器"><a href="#数据生成器" class="headerlink" title="数据生成器"></a>数据生成器</h3><p>为了灵活的方式创建更有趣的数组，我们使用Gererator的概念，如果某个工具使用了Generator,那么你就可以通过选择Generator的类型来创建任何类型的数据（这是策略模式的一个实例——每个不同的Generator都表示一个不同的策略）<br>首先创建这些包装器类嵌套在CountingGenerator类中，注意这里的包装器类只是为了区别各种生成器取和java类库包装器相同的名字而已，它们是在CountingGenerator中，且在不同的命名空间下，所以不是同一类型，这点注意，实现Generator<t>接口的next方法就可以了，如下，省写<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountingGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Boolean</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">java</span>.<span class="title">lang</span>.<span class="title">Boolean</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> value=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">public</span> java.lang.<span class="function">Boolean <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> !value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Byte</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">java</span>.<span class="title">lang</span>.<span class="title">Byte</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">byte</span> value=<span class="number">0</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> java.lang.<span class="function">Byte <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">char</span>[] chars=<span class="string">"abcdefghijklmnopqrstuvwlyz"</span>.toCharArray();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Character</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">java</span>.<span class="title">lang</span>.<span class="title">Character</span>&gt;</span>&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">public</span> java.lang.<span class="function">Character <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> chars[(index++)%chars.length];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span>  <span class="title">Generator</span>&lt;<span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> length=<span class="number">7</span>;</span><br><span class="line">        Generator&lt;java.lang.Character&gt; generator=<span class="keyword">new</span> Character();</span><br><span class="line">        <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">char</span>[] chars=<span class="keyword">new</span> <span class="keyword">char</span>[length];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">                chars[i]=generator.next();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Arrays.toString(chars);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></p>
<p>这些生成器大多都是这样的，实现generator接口的next()方法只是具体的实现不同而已</p>
<h3 id="从Generator中创建数组"><a href="#从Generator中创建数组" class="headerlink" title="从Generator中创建数组 ###"></a>从Generator中创建数组 ###</h3><p>为了接收Generator并产生数组，我们需要两个转换工具，一个工具使用任意的Generator来产生Object子类型的数组，为了处理基本类型，第二个工具接收任意基本类型的包装器类型数组，并产生相应的基本类型数组<br>我们看下第一个工具的两种选择，第一个使用重载的array方法，该方法接受一个已有的数组，并使用某个Generator填充它，而第二个版本接受一个Class对象（类型标记）,一个Generator和所需的元素数量，然后创建一个新数组，并使用所接收的Generator来填充它，注意这个工具只能阐释Object子类型的数组，而不能产生基本类型数组<br>因为泛型不能用于基本类型，而我们确实需要一个生成器来填充基本类型数组，很简单，先使用生成器生成包装器类型数组，然后通过一个转换器生成基本类型数组，所以我们要创建一个转换器类，里面有重载的转换方法接受不同类型的包装器数组，然后在方法内部创建基本类型数组，依次取出包装器数组的数据赋值即可，很简单，不写了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/19/数组/" data-id="cjnzv2prk002tcorzjj3hze4p" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-泛型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/14/泛型/" class="article-date">
  <time datetime="2018-10-14T11:22:59.000Z" itemprop="datePublished">2018-10-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习心得/">学习心得</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/14/泛型/">泛型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一般的类和方法，只能使用具体的类型，要么是基本类型，那么是自定义的类，如果要编写可以应用与多种类型的代码，这种刻板的限制对代码的束缚就会很大<br>在面向对象语言中，动态算是一种泛化机制，你可以将方法的掺水设为基类，那么该方法就可以接受从这个基类中导出的任何类作为参数，这样的方法也更加通用些，可以应用的地方也更多些，但是考虑到除了final类不能被扩展，其他任何类都可以被扩展，所以这种灵活性大多时候也会有一些性能损耗<br>有时候，拘泥于单继承体系，也会使程序受限太多，如果方法的参数是一个接口，而不是一个类，这种限制就放松了很多，因为任何事实现了该接口的类都能满足该方法，这也包括了暂时还不存在的类，这给了客户端程序员一种选择，他可以选择实现一个接口来满足类或方法的<br>可是有时候，即使使用接口，对程序的约束也还是太强了，因为一旦指明了接口，它就要求你的代码必须使用特定的接口，而我们希望达到的目的是编写更通用的代码，要使代码能够用于“某种不具体的类型”而不是具体的接口或类<br>java SE5的重大变化之一，就是泛型的概念，泛型实现了参数化类型的概念，使代码可以应用于多种类型，“泛型”这个术语的意思就是：“适用于多种类型”，<strong>泛型在编程语言出现时，其最初的目的是希望类或方法能够具备更广泛的表达能力</strong>，如何做到这一点的呢？正是实现通过解耦类和方法与所使用的类型之间的解耦，扫后你将会看到，java中的泛型并没有那么高的追求<br>在学习了java的泛型之后，泛型确实是一个很好的补充，在你创建<strong>参数化类型</strong>的一个实例时，编译器会为你负责转型操作，并确保类型的正确性，这是一个进步<br>但是java中的泛型还没有能够做到像C++那样实现了纯粹的泛型，你不要对java的泛型期望太高，在java中使用一个别人已经建好的泛型类型很容易，但是如果自己创建一个泛型实例，就会遇到很多令人吃惊的事情  </p>
<h2 id="与C-d的比较"><a href="#与C-d的比较" class="headerlink" title="与C++d的比较"></a>与C++d的比较</h2><p>java的设计灵感来自于C++,那么先了解C++的泛型机制对理解java泛型有些帮助，了解C++魔板的某些方面，有助于你理解泛型的基础，你可以了解java泛型的局限是什么，已经为什么会有这些限制，最终的目的是帮助理解，java泛型的边界在哪里，理解了边界所在，你才会知道某个技术不能做什么，你才能更好地做到所能做的  </p>
<h2 id="简单泛化"><a href="#简单泛化" class="headerlink" title="简单泛化"></a>简单泛化</h2><p>许多的原因促使了泛型的出现，而最引人注目的一个原因，就是为了创造容器类，我们先来看下一个只能持有单一对象的类，当然这个对象可以明确指定其持有对象的类型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Automobile</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Automobile automobile;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">(Automobile automobile)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.automobile = automobile;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Automobile <span class="title">getAutomobile</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  automobile;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面自定义的容器类Holder，指定了只能存储Automobile这种类型的对象，这个类的可重用性就不怎么样，难道我们要为每一种类型都要创建一个像这样的容器类吗？当然不<br>在java SE5之前我们可以让一个类直接持有Object类型的对象，实际上，我们是使用了关于基类的编程，这要这个类能够应用于这个基类，那么基类的导出类也适用于这个代码，因为导出类本质上也是基类类型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder2</span><span class="params">(Object obj)</span></span>&#123;<span class="keyword">this</span>.obj=obj;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObj</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> obj;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Holder2 holder2=<span class="keyword">new</span> Holder2(<span class="keyword">new</span> Automobile());</span><br><span class="line">        Automobile automobile=(Automobile) holder2.getObj();</span><br><span class="line">        <span class="comment">//特别是这段代码，虽然getObj()返回的实际类型是Automolie类型，我们还是可以做转型操作，编译器才会发现类型转换失败</span></span><br><span class="line">        String s=(String) holder2.getObj();</span><br><span class="line">        holder2.setObj(<span class="string">"Not a Automoblie"</span>);</span><br><span class="line">        String str=(String) holder2.getObj();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~~~在有些情况下，我们确实希望容器具有能持有不同类型的能力，但是，通常情况下，我们希望使用容器来存储一种特定的类型，泛型的主要目的之一就是用来指定容器要持有什么类型的对象，而且由编译器来保证类型的正确性  </span><br><span class="line">因此，与其使用Object，我们更喜欢暂时不指定类型，而是稍后再决定具体使用什么类型，要达到这个目的，需要使用**类型参数**，用尖括号括住，放在类名后面，然后在什么这个类的时候，再用实际的类型替换此类型参数  </span><br><span class="line">~~~java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder3</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder3</span><span class="params">(T a)</span></span>&#123;<span class="keyword">this</span>.a=a;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T a)</span></span>&#123;<span class="keyword">this</span>.a=a;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> a;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Holder3&lt;Automobile&gt; h3=<span class="keyword">new</span> Holder3&lt;&gt;(<span class="keyword">new</span> Automobile());</span><br><span class="line">        Automobile automobile=h3.get();</span><br><span class="line">        <span class="comment">//h3.set(1);</span></span><br><span class="line">        <span class="comment">//h3.set("not a Automoblie");</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当你创建h3对象时，必须指明想要持有什么类型的对象，将其置于尖括号内，然后你就只能在Hold3中存入该类型（或者子类，多态和泛型不冲突，明确指定了泛型类型，那么这个类型的子类型也是该类型，基类与导出类的关系）<br>这就是java泛型的核心概念：告诉编译器想要什么什么类型，然后编译器处理一切   </p>
<h3 id="一个元祖类库"><a href="#一个元祖类库" class="headerlink" title="一个元祖类库"></a>一个元祖类库</h3><p>仅一次方法调用就返回多个对象，我们经常需要这个功能，可是return只能返回一个对象，因此解决办法就是创建一个对象，用它来持有想要返回的多个对象<br>难道我们每次都要创建这样的一个类，指定它能够保存的类型，所有每次需要保存不同类型的元组时，都要创建保存不同类型的类吗？<br>有了泛型，我们不需要这样做，这样一个类保存两种类型的对象，这个类在创建时才指定它需要用到的类型，同时我们在编译期就能确保类型安全<br>这个概念被称为“元组” ，它是将一组对象直接打包存储于其他的一个单一对象，这个容器对象允许读取其中元素，但是不允许向其中存放新的对象，这和对象就被称为<strong>数据传送对象或者信使 </strong><br>通常，元组可以具有任意长度，同时，元组中的对象可以是任意不同的类型，不过我们希望能够为每一个对象指明类型，并且从容器中读取出来时，能够得到正确的类型，看下下面的二维元组，它能够持有两个对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoTuple</span>&lt;<span class="title">A</span>,<span class="title">B</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> A first;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> B second;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TwoTuple</span><span class="params">(A a,B b)</span></span>&#123;</span><br><span class="line">        first=a;</span><br><span class="line">        second=b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">"("</span>+first+second+<span class="string">")"</span>;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>仔细看上面的代码，我们或许会疑惑，上面的代码违反了java编程的安全性原则，first和second应该被声明为private，然后提供getFirst()和getSecond()子类的访问方法才对，让我们看下这个例子的安全性，客户端程序可以读取fisrt和second，然后随心所欲的使用它们，但是，它们却无法赋值给first和second，因为final声明为你提供了相同的安全性，而且这种格式更简洁明了<br>还有另外一个设计考虑，你确实希望客户端程序员改变first或second所引用的对象，如果是这样的话，就强制程序员另外创建一个新的TwoTuple对象<br>我们可以利用继承机制实现长度更长的元组，下面的例子可以看到，增加类型参数是件很简单的事情<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeTuple</span>&lt;<span class="title">A</span>,<span class="title">B</span>,<span class="title">C</span>&gt; <span class="keyword">extends</span> <span class="title">TwoTuple</span>&lt;<span class="title">A</span>,<span class="title">B</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> C third;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreeTuple</span><span class="params">(A a,B b,C c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(a,b);</span><br><span class="line">        third=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">super</span>.toString()+third;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到下面的代码也可以编译通过，这两个代码定义的泛型的导出类是一样的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeTuple</span>&lt;<span class="title">D</span>,<span class="title">E</span>,<span class="title">C</span>&gt; <span class="keyword">extends</span> <span class="title">TwoTuple</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> C third;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreeTuple</span><span class="params">(D a,E b,C c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(a,b);</span><br><span class="line">        third=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">super</span>.toString()+third;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这表明了继承一个泛型类是，基类不一定要添加&lt;A,B&gt;这样的参数类型，导出类添加参数类型即可，实际上我们在定义导出类的泛型类型，而且参数类型只是一个占位符，名称无所谓，只要能够与内部的代码对应就好<br>元组代码测试<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TupleTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TwoTuple&lt;String,Integer&gt; <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span>  <span class="keyword">new</span> TwoTuple&lt;&gt;(<span class="string">"hi"</span>,<span class="number">46</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreeTuple&lt;Automobile,String,Integer&gt; <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span>  <span class="keyword">new</span> ThreeTuple&lt;&gt;(<span class="keyword">new</span> Automobile(),<span class="string">"hi"</span>,<span class="number">46</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      TwoTuple&lt;String,Integer&gt; ttsi=f();</span><br><span class="line">      System.out.print(ttsi);</span><br><span class="line">      ttsi.first=<span class="string">"can't change"</span></span><br><span class="line">      System.out.print(g());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="一个堆栈类"><a href="#一个堆栈类" class="headerlink" title="一个堆栈类"></a>一个堆栈类</h3><p>传统的下推堆栈，在之前的例子，我们是用一个LinkList实现的，LinkedListb本身具备了创建堆栈所需的所有方法<br>现在我们不用LinkedList，来实现自己的内部链式存储机制<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.generics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedStack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">U</span>&gt;</span>&#123;</span><br><span class="line">        U item;</span><br><span class="line">        Node&lt;U&gt; next;</span><br><span class="line">        Node()&#123;</span><br><span class="line">            item=<span class="keyword">null</span>;</span><br><span class="line">            next=<span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node(U item,Node&lt;U&gt; next)&#123;</span><br><span class="line">            <span class="keyword">this</span>.item=item;</span><br><span class="line">            <span class="keyword">this</span>.next=next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> item==<span class="keyword">null</span> &amp;&amp; next==<span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; top =<span class="keyword">new</span> Node&lt;T&gt;();<span class="comment">//哨兵</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T item)</span></span>&#123;</span><br><span class="line">        top=<span class="keyword">new</span> Node&lt;T&gt;(item,top);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        T result = top.item;</span><br><span class="line">        <span class="keyword">if</span>(!top.end())&#123;</span><br><span class="line">            top=top.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        LinkedStack&lt;String&gt; list=<span class="keyword">new</span> LinkedStack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String s:<span class="string">"Phasers on stun!"</span>.split(<span class="string">" "</span>))&#123;</span><br><span class="line">            list.push(s);</span><br><span class="line">        &#125;</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span>((s=list.pop())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到内部类Node也是一个泛型，它拥有自己的参数类型</p>
<h3 id="RandomList"><a href="#RandomList" class="headerlink" title="RandomList"></a>RandomList</h3><p>作为另一个例子，假设我们需要一个特定类型对象的列表，每次调用其上的select()方法时，它可以随机地选取一个元素，如果我们希望以此构建一个可以应用与各种类型的对象的工具，就需要泛型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;T&gt; storage=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Random random=<span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T item)</span></span>&#123;storage.add(item);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">select</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> storage.get(random.nextInt());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        RandomList&lt;String&gt; rs=<span class="keyword">new</span> RandomList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String s:<span class="string">"the queue broken brown fox"</span>.split(<span class="string">" "</span>))&#123;</span><br><span class="line">            rs.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            System.out.println(rs.select());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>泛型也可以应用于接口，例如生成器，这是一种专门负责创建对象的类，实际上，这是工厂方法设计模式的一种应用，不过，当使用生成器创建新的对象时，它不需要任何参数，而工厂方法需要参数，也就是说，生成器无需额外的信息就知道如何创建对象，<br>一般而言，一个生成器只定义一个方法，该方法用于产生新的对象，在这里就是next()方法<br><code>public interface Generator&lt;T&gt; {
    T next();
}</code><br>首先我们先创建一个Coffee类及其子类，我们将创建一个生成咖啡的生成器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id =counter++;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName()+id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Latte</span> <span class="keyword">extends</span> <span class="title">Coffee</span></span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mocha</span> <span class="keyword">extends</span>  <span class="title">Coffee</span></span>&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cappuccino</span> <span class="keyword">extends</span> <span class="title">Coffee</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Americano</span> <span class="keyword">extends</span> <span class="title">Coffee</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>在创建一个实现了生成器泛型接口和迭代器的coffee生成器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoffeeGenerator</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">Coffee</span>&gt;,<span class="title">Iterable</span>&lt;<span class="title">Coffee</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class[] types=&#123;Latte.class,Cappuccino.class,Americano.class,Mocha.class&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random random=<span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CoffeeGenerator</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CoffeeGenerator</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;size=a;&#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CoffeeIterator</span> <span class="keyword">implements</span>  <span class="title">Iterator</span>&lt;<span class="title">Coffee</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> counter=<span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> counter&gt;<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Coffee <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            counter--;</span><br><span class="line">            <span class="keyword">return</span> CoffeeGenerator.<span class="keyword">this</span>.next();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Coffee&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CoffeeIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Coffee <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Coffee) types[random.nextInt(types.length)].newInstance();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        CoffeeGenerator gen=<span class="keyword">new</span> CoffeeGenerator();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.out.println(gen.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们再来看下实现Generator泛型接口的另一个实现 Fibonacci数列<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fibonacci</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">next</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> fib(count++); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> fib(n-<span class="number">2</span>)+fib(n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们还想要更近一步，编写一个实现了Itearable的Fibonacci生成器，我们的第一个选择是重写这个类，可是我们并不是总能拥有代码的控制权，并且除非必要，我们也不愿重写代码，我们还有另一种选择，那就是创建一个适配器（adapter）来实现所需要的接口，有很多方法可以实现适配器模式，我们先来看看第一种吧，通过继承实现适配<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FibonacciAdapter</span> <span class="keyword">extends</span> <span class="title">Fibonacci</span> <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FibonacciAdapter</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;<span class="keyword">this</span>.n=n;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Integer&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;Integer&gt;()&#123;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> n&gt;<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                n--;</span><br><span class="line">                <span class="keyword">return</span> FibonacciAdapter.<span class="keyword">this</span>.next();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Integer i:<span class="keyword">new</span> FibonacciAdapter(<span class="number">10</span>))&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>泛型可以应用到整个类上，但同样的也可在类中包含参数化方法，这个方法所在的类可以是泛型类，也可以不是，也就是说，是否用于泛型方法，与其所在的类是否是泛型没有关系<br>一个基本的指导原则是：无论何时，只要你能做到，你就应该尽量使用泛型方法，也就是说，如果使用泛型方法可以取代将整个类泛型话，那么就应该值使用泛型方法，因为它可以使事情更清除明白，<strong>另外，对于一个static的方法而言，无法访问类的类型参数，所以，如果static方法需要使用泛型能力的话，就必须称为泛型方法</strong><br><strong>要定义泛型方法，只需要将泛型参数列表置于返回值之前</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericMothed</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">        System.out.println(x.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        GenericMothed gm=<span class="keyword">new</span> GenericMothed();</span><br><span class="line">        gm.f(<span class="string">""</span>);</span><br><span class="line">        gm.f(<span class="number">1</span>);</span><br><span class="line">        gm.f(<span class="number">1.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的GenericMothed类不是泛型类，尽管这个类和其内部的方法可以被同时参数化，<strong>在使用泛型类时，必须在创建对象的时候指定类型参数的值，而使用泛型方法的时候，通常不必指明参数类，因为编译器会为我们找出具体的类型，这被称为类型参数推断（type argument inference）</strong></p>
<h3 id="杠杆利用类型参数推断"><a href="#杠杆利用类型参数推断" class="headerlink" title="杠杆利用类型参数推断"></a>杠杆利用类型参数推断</h3><p>以前我们在使用泛型的时候，总是会抱怨需要向程序中添加更多的代码，现在编译器可以使得我们能够省略到对泛型参数列表的重复了，我们看下之前我们的代码的例子<br>    Map&lt;Person,List&lt;? extends Pet&gt;&gt; map=new HashMap&lt;Person,List&lt;? extends Pet&gt;&gt;();<br>现在可以这样写<br>    Map&lt;Person,List&lt;? extends Pet&gt;&gt; map=new HashMap&lt;&gt;();<br>参数类型推断也可以用在泛型方法中  下面的例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">New</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="function">Map&lt;K,V&gt; <span class="title">map</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HashMap&lt;K,V&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">list</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Map&lt;String,Integer&gt; map=New.map();</span><br><span class="line">        List&lt;String&gt; list=New.list();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>类型参数推断避免了重复的泛型参数列表<br>类型参数推断只对赋值有效，其他时候并不起作用，如果将一个泛型方法调用的结果作为参数，传递给另一个方法，这时编译器并不会执行类型推断，在这种情况下，编译器认为，调用泛型方法后，其返回值被赋给列哦一个Object类型的变量，<br>    f(New.map())//does not compile<br>应该这样说，编译器之所以能够进行类型推断的一个基本的条件是，编译器能够获得泛型参数的信息，将泛型方法的返回值直接赋给一个泛型类引用，可以通过这个泛型类引用的类型参数推断出泛型方法的泛型参数，但是如果将泛型方法的返回值直接传递给一个方法，编译器得不到指导  </p>
<h3 id="显示的类型说明"><a href="#显示的类型说明" class="headerlink" title="显示的类型说明"></a>显示的类型说明</h3><p>在泛型方法中，可以显式地指明类型，不过这种语法比较少见，<strong>要显示地指明类型，必须在点操作符与方法名之间插入尖括号，然后把类型置于尖括号内如果是在定义该方法的类的内部，必须在点操作符之前使用this关键字，如果是使用static的方法，必须在点操作符之前加上类名</strong><br>    f(New.&lt;String,Integer&gt;map());</p>
<h3 id="可变参数列表与泛型方法"><a href="#可变参数列表与泛型方法" class="headerlink" title="可变参数列表与泛型方法"></a>可变参数列表与泛型方法</h3><p>泛型和可变参数列表能够很好地共存<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericVarargs</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">makeList</span><span class="params">(T... args)</span></span>&#123;</span><br><span class="line">        List&lt;T&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(T item:args)&#123;</span><br><span class="line">            list.add(item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; ls=makeList(<span class="string">"A"</span>);</span><br><span class="line">        System.out.println(ls);</span><br><span class="line">        ls=makeList(<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>);</span><br><span class="line">        ls=makeList(<span class="string">"ABCDRFGHIJKMLNOPQRST"</span>.split(<span class="string">""</span>));</span><br><span class="line">        System.out.println(ls);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="用于Generator的泛型方法"><a href="#用于Generator的泛型方法" class="headerlink" title="用于Generator的泛型方法"></a>用于Generator的泛型方法</h3><p>下面的程序为任何类构造一个Generator，只要该类有没默认的构造器，并且构造器可访问<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicGenerator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; type;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BasicGenerator</span><span class="params">(Class&lt;T&gt; type)</span></span>&#123;</span><br><span class="line">        type=type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> type.newInstance();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Generator&lt;T&gt; <span class="title">create</span><span class="params">(Class&lt;T&gt; type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> BasicGenerator&lt;&gt;( type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面我们创建一个具有默认构造器的类，来测试上面的泛型生成器（generator<t>）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id=count++;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CounterObject</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">id</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> id;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">"CounterObject"</span>+id;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicGenertorDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Generator&lt;CounterObject&gt; gen=BasicGenerator.create(CounterObject.class);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            gen.next();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="一个Set实用工具"><a href="#一个Set实用工具" class="headerlink" title="一个Set实用工具"></a>一个Set实用工具</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sets</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Set&lt;T&gt; <span class="title">union</span><span class="params">(Set&lt;T&gt; a,Set&lt;T&gt; b)</span> </span>&#123;</span><br><span class="line">        Set&lt;T&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;(a);</span><br><span class="line">        result.addAll(b);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Set&lt;T&gt; <span class="title">intersection</span><span class="params">(Set&lt;T&gt; a,Set&lt;T&gt; b)</span></span>&#123;</span><br><span class="line">        Set&lt;T&gt; result =<span class="keyword">new</span> HashSet&lt;&gt;(a);</span><br><span class="line">        result.retainAll(b);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Set&lt;T&gt; <span class="title">different</span><span class="params">(Set&lt;T&gt; superSet,Set&lt;T&gt; subSet)</span></span>&#123;</span><br><span class="line">        Set&lt;T&gt; result=<span class="keyword">new</span> HashSet&lt;&gt;(superSet);</span><br><span class="line">        result.removeAll(subSet);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Set&lt;T&gt; <span class="title">complement</span><span class="params">(Set&lt;T&gt; a,Set&lt;T&gt; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> different(union(a,b),intersection(a,b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>泛型还可以应用于内部类和匿名内部类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id =counter++;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Customer</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">"Customer"</span>+id;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Generator&lt;Customer&gt; <span class="title">generator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Generator&lt;Customer&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Customer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Customer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teller</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id=counter++;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Teller</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">"Teller"</span>+id;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Generator&lt;Teller&gt; <span class="title">create</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Generator&lt;Teller&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Teller <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Teller();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="构建复杂模型"><a href="#构建复杂模型" class="headerlink" title="构建复杂模型"></a>构建复杂模型</h2><p>泛型的一个重要好处就是能够简单而安全地创建复杂的模型，例如我们很容易地创建元组列表这样的结构<br>    class TupleList&lt;A,B,C,D&gt; extends List&lt;FourTuple&lt;A,B,C,D&gt;&gt;{}<br>下面这个示例，展示了使用泛型来创建复杂模型是多么简单，即使每个类都作为一个构建块创建，但是其整个还是包含很多部分，在这个例子中，构建一个零售商，它包含走廊，货架和商品<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Product</span><span class="params">(<span class="keyword">int</span> IDNumber,String descr,<span class="keyword">double</span> price)</span></span>&#123;</span><br><span class="line">        id= IDNumber;</span><br><span class="line">        description=descr;</span><br><span class="line">        price=price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id+<span class="string">":"</span>+description+price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">priceChange</span><span class="params">(<span class="keyword">double</span> price)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price=price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Generator&lt;Product&gt; generator=<span class="keyword">new</span> Generator&lt;Product&gt;() &#123;</span><br><span class="line">        <span class="keyword">private</span> Random rand=<span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Product <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Product(rand.nextInt(<span class="number">1000</span>),<span class="string">"Test"</span>,Math.round(rand.nextDouble()*<span class="number">1000</span>)+<span class="number">0.99</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shelf</span> <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">Product</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Shelf</span><span class="params">(<span class="keyword">int</span> nProduct)</span></span>&#123;</span><br><span class="line">        Generators.fill(<span class="keyword">this</span>,Product.generator,nProduct);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Aisle</span> <span class="keyword">extends</span>  <span class="title">ArrayList</span>&lt;<span class="title">Shelf</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Aisle</span><span class="params">(<span class="keyword">int</span> nShives,<span class="keyword">int</span> nProduct)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nShives;i++)&#123;</span><br><span class="line">            add(<span class="keyword">new</span> Shelf(nProduct));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Checkoutstand</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Office</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Store</span> <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">Aisle</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Checkoutstand&gt; checkoutstands= <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Office&gt; offices=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Store</span><span class="params">(<span class="keyword">int</span> nAisles,<span class="keyword">int</span> nShives,<span class="keyword">int</span> nProduct)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nAisles;i++)&#123;</span><br><span class="line">            add(<span class="keyword">new</span> Aisle(nShives,nProduct));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuilder stb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(Aisle aisle:<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(Shelf shelf:aisle)&#123;</span><br><span class="line">                <span class="keyword">for</span>(Product product:shelf)&#123;</span><br><span class="line">                    stb.append(product.toString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="擦除的神秘之处"><a href="#擦除的神秘之处" class="headerlink" title="擦除的神秘之处"></a>擦除的神秘之处</h2><p>当开始真正研究泛型的时候，会发现大量的东西初看起来是没有任何意义的，例如，尽管可以声明ArrayList.class。但是不能声明ArrayList<integer>.class 再看下面的例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErasedTypeEquivalence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Class c1=<span class="keyword">new</span> ArrayList&lt;String&gt;().getClass();</span><br><span class="line">        Class c2=<span class="keyword">new</span> ArrayList&lt;Integer&gt;().getClass();</span><br><span class="line">        System.out.println(c1==c2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></integer></p>
<p>ArrayList<string>与ArrayList<integer>很容易被认为是不同的类型，不同的类型在行为上肯定不同，比如尝试将一个Integer放入一个ArrayLIst<string>中，但是上面的程序确实认为它们是相同的<br>我们再来看一个例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Frob</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quark</span>&lt;<span class="title">Q</span>&gt;</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LostInformation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Map&lt;String,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Quark&lt;Frob&gt; quark=<span class="keyword">new</span> Quark&lt;&gt;();</span><br><span class="line">        System.out.println(Arrays.toString(list.getClass().getTypeParameters()));</span><br><span class="line">        System.out.println(Arrays.toString(map.getClass().getTypeParameters()));</span><br><span class="line">        System.out.println(Arrays.toString(quark.getClass().getTypeParameters()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*output</span></span><br><span class="line"><span class="comment">[E]</span></span><br><span class="line"><span class="comment">[K,V]</span></span><br><span class="line"><span class="comment">[Q]</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></string></integer></string></p>
<p>根据JDK文档的描述，<strong><code>Class.getTypeParameters()</code>将“返回一个TypeVariable对象数组”,表示有泛型声明所声明的类型参数…</strong>，这就好像是在暗示你可能发现参数类型的信息，但是，正是正如我们所看到的，我们发现的只是作为参数占位符的标识符，这并非是有用的信息<br>我的理解是，如果在我们第一次创建泛型类的对象的时候，传递给它的构造器一个参数类型，在这个类加载生成Class对象里能够保存这个参数类型的信息就好了，可是我们看到，事实并不是这样<br>因此，残酷的现实是：<br><strong>在泛型代码内部，无法获得任何关于泛型参数类型的信息</strong><br>你可以知道诸如类型参数标记和泛型类型边界这类的信息——你却无法知道用来创建某个特定实例的实际的类型参数<br>java泛型是使用擦除来实现的，这意味着当你在使用泛型时，任何具体的类型信息都被擦除了</p>
<h3 id="C-的方式"><a href="#C-的方式" class="headerlink" title="C++的方式"></a>C++的方式</h3><p>下面是使用模板的C++示例<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Manipulate</span>&#123;</span></span><br><span class="line"> T obj;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Manipulate(T x)&#123;obj=x;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">mainpulate</span><span class="params">()</span></span>&#123;obj.f();&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasF</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"HasF::f()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  HasF hf;</span><br><span class="line">  manipulate&lt;HasF&gt; manipulate(hf)；</span><br><span class="line">  manipulate.manipulate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*output</span></span><br><span class="line"><span class="comment">HasF::f()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<p>Manipulate类存储了一个类型T的对象，有意思的地方是manipulate()方法，它在obj上调用f(),它怎么知道f()方法时为类型参数T而存在的呢？当你实例化一个模板时，C++编译器将会进行检查，因此在Manipulate<hasf>被实例化的那一刻，它看到HasF拥有一个f()方法，否则，就会得到一个编译器错误，这样类型安全就会得到保障<br>我们可以将上面的代码用java的方式重写一次，可是这会出现问题，因此擦除的原因，代码内部并不清楚参数类型是什么？我们就没办法去编写类似obj.f()这样的代码<br>为了能够调用f()，我们必须帮助泛型类，给定泛型类的边界，以表示编译器只能接受遵循这个边界的类型，有可以保证给泛型关于参数类型的信息，<br>在这里我们重用extends这个关键字<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manipulate</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">HasF</span>&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> T obj;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Manipulate</span><span class="params">(T x)</span></span>&#123;obj=x;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">manipulate</span><span class="params">()</span></span>&#123;obj.f();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></hasf></p>
<p>边界<t extends="" hasf=""> 声明T必须具有类型HasF或者从HasF导出的类，如果情况确实如此，就可以安全地使用obj.f()了<br>我们说泛型参数将擦除到它的第一个边界（它可能会有多个边界），我们还提到了类型参数的擦除，编译器实际上会把类型参数替换为它的擦除，就像上面的例子一样，T擦除到了HasF，就好像在类的声明中用HasF替换了T一样<br>我们有看到了，在上面的一个提过了泛型的例子好像并没有贡献什么好处，只需要很容易地自己去执行擦除，就可以创建没有泛型的类，而且代码也比较泛化，看下一个我们主动执行擦除的例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manipulate</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> HasF obj;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Manipulate</span><span class="params">(HasF x)</span></span>&#123;obj=x;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">manipulate</span><span class="params">()</span></span>&#123;obj.f();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></p>
<p>这给来哦我们很重要的启示，<strong>只有当你希望使用的类型参数比某个具体类型（以及它所有的子类类型）更加“泛化”的时——也就是说，当你希望代码能够跨越多个类工作时，使用泛型才有所帮助</strong><br><strong>但是</strong>，我们也不要认为<t extends="" hasf="">形式的任何东西都是有缺陷的，例如，如果某个类有一个返回T的方法，那么泛型就会非常有用，因为在使用这个泛型类的时候，泛型参数给了编译器提示，编译器很容易会将T转换为我们使用泛型时指定的参数类型，可以帮助我们很轻松的解决返回值的转型问题  </t></p>
<h3 id="迁移兼容性"><a href="#迁移兼容性" class="headerlink" title="迁移兼容性"></a>迁移兼容性</h3><p>为了减少潜在的关于擦除的混淆，你必须清楚地认识到这不是一个语言特性，它是java的泛型实现的一种折中，因为泛型不是java语言出现时就有的组成部分，所以这种折中是必须的，虽然它会让你很痛苦<br>擦除减少了泛型的泛化性，泛型在java中仍然有用，但是不如它们本来设想的那么有用，而原因就是擦除<br>在基于擦除的实现中，泛型类型被当作第二类类型处理，即不能在某些重要的上下文环境中使用的类型，<strong>泛型类型只有在静态类型检查期间才出现，在此之后，程序中的所有泛型类型都被擦除，替换为它们的非泛型上界</strong>，例如List<t>这样的类型注解将被擦除为List,而普通的类型变量在未指定边界的情况下将被擦除为Object<br><strong>擦除的核心动机是它使得泛化的客户端可以用非泛化的类库来使用，反之亦然，这经常被称为“迁移兼容性”</strong> 在现实中，即使程序员只编写泛型代码，他们也必须处理在Java SE5之前编写的非泛化类库，这些类库饿作者可能从没想过要泛化它们的代码，或者可能刚刚接触泛型<br><strong>因此java泛化不仅必须支持向后兼容性，即现有的代码和类文件仍旧合法 </strong>（这句话的意思是，在泛化之前出现的类库，那些代码并没有考虑使用泛化的情况，如果我们为了使用泛化，那么就无法使用之前以及创建好的而且很成熟的类库了，为了增加泛化特性，就要抛弃以往已经被实践所验证的代码库，即使是对现有代码库进行修改这样代价也太大了）</t></p>
<h3 id="擦除的问题"><a href="#擦除的问题" class="headerlink" title="擦除的问题"></a>擦除的问题</h3><p>因此，擦除主要的正当理由是从非泛化代码到泛化代码的转变过程，以及在不随意破坏现有类库的情况下，将泛型融入到java语言，擦除使得现有的非泛型客户端代码能够在不改变的情况下继续使用，直至客户端准备好用泛型重写这些代码，这是一个崇高的动机，因为它不会破坏所有现有的代码<br>擦除的代价是显著的，<strong>泛型不能被显式地被引用至运行时类型的操作之中</strong>，例如转型，instanceOf操作和new表达式，因为所有有关参数的类型信息都丢失了，无论何时，<strong>当你在编写泛型代码的时候，必须时刻提醒自己，你只是看起来好像拥有有关参数的类型信息而已</strong><br>    Foo<cat> foo=new Foo<cat>();<br>class Foo中代码应该知道现在工作于Cat之上，而泛型语法也在强烈地暗示，在整个类的各个地方，类型都在被替换，<strong>但是事实并非如此</strong>，无论何时，当你编写这个代码的时，时刻提醒自己“不，它只是个Object”<br>另外，擦除和迁移兼容性意味着，使用泛型并不是强制的，尽管你可能希望这样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericBasic</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T element;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  T <span class="title">getElement</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> element;&#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setElement</span><span class="params">(T x)</span></span>&#123;element=x;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived1</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">GenericBasic</span>&lt;<span class="title">T</span>&gt;</span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived2</span> <span class="keyword">extends</span> <span class="title">GenericBasic</span></span>&#123;&#125; <span class="comment">//no Warning没有警告</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErasuereAndInheritance</span> </span>&#123;</span><br><span class="line">    Derived2 d2=<span class="keyword">new</span> Derived2();</span><br><span class="line">    Object obj=d2.getElement();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//d2.set(obj) //warning here  在这里警告</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></cat></cat></p>
<h3 id="边界处的动作"><a href="#边界处的动作" class="headerlink" title="边界处的动作"></a>边界处的动作</h3><p>正因为有了擦除，泛型最令人困惑的方面源于这样一个事实，即可以表示没有任何意义的事物 ，例如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayMaker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; type;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayMaker</span><span class="params">(Class&lt;T&gt; type)</span></span>&#123;type=type;&#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    T[] create(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">return</span> (T[])Array.newInstance(type,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ArrayMaker&lt;String&gt; stringMaker=<span class="keyword">new</span> ArrayMaker&lt;&gt;(String.class);</span><br><span class="line">        String[] stringArray=stringMaker.create(<span class="number">10</span>);</span><br><span class="line">        System.out.println(Arrays.toString(stringArray));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[null,null,null,null,null,null,null,null,null,null]</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
<p>即使type被存储为Class<t>,**擦除也意味着它将被存储为Class,没有任何参数，因此，当你使用它的时候，例如在创建数组时，Array.newInstance()实际上并未拥有kind所蕴含的类型信息，因此它不会产生具体的结果，所以必须转型，这将产生一条令你无法满意的警告<br>注意，对于在泛型中创建数组，使用Array.newInstance()是推荐的方式<br>如果我们要创建一个容器而不是一个数组，情况就有些不同了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListMaker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">create</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//指定了参数类型，实际上就是给了编译器的一个指示，以使得编译期的静态类型检查和转型代码的插入</span></span><br><span class="line">        ListMaker&lt;String&gt; listMaker=<span class="keyword">new</span> ListMaker&lt;T&gt;();</span><br><span class="line">        List&lt;String&gt; list=listMaker.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></p>
<p>编译器不会给出任何警告，尽管我们知道在create()内部的new ArrayList<t>的T被移除了——在运行时，这个类的内部没有任何<t>,因此看起来毫无意义，但是如果你遵从这种思路，并将这个表达式改为new ArrayList()编译器就会给出警告<br>是否真的毫无意义呢？如果返回list之前，将某些对象放入其中，就像下面这样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilledListMaker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">create</span><span class="params">(T item,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        List&lt;T&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            list.add(item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        FilledListMaker&lt;String&gt; fl=<span class="keyword">new</span> FilledListMaker&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; list=fl.create(<span class="string">"hello"</span>,<span class="number">4</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></t></p>
<p><strong>即使，编译器无法知道有关create()中的T信息，但是它仍旧可以在编译期确保你放置到result中的对象具有T类型，使其合适ArrayList<t>,因此，即使擦除在方法或者类内部移除了有关实际类型的信息，编译器仍旧可以确保在方法或类中使用的类型的内部一致性</t></strong><br><strong>因为擦除在方法体中移除了类型信息，所以在运行时的问题就是边界，即对象进入和离开方法的地点，这些正是编译器在编译期执行类型检查并插入转型代码的地点</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObj</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> obj;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">(Object obj)</span></span>&#123;obj=obj;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以使用javap-c SimpleHolder反编译这个代码<br>我们再来看下下面的代码，除了类名和添加了类型参数之外，和上面的代码几乎完全一样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericHolder</span> &lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  T <span class="title">getObj</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> obj;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">(T x)</span></span>&#123;obj=x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        GenericHolder&lt;String&gt; gen =<span class="keyword">new</span> GenericHolder&lt;&gt;();</span><br><span class="line">        gen.setObj(<span class="string">"hello"</span>);</span><br><span class="line">        String str=gen.getObj();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们再来反编译上面的代码，可以看出，转型是在调用get()的时候接受检查的，从get()返回之后的转型消失，但是我们还知道传递给set()的值在编译期接收检查<br>从上面的例子，我们可以得出这样的结论，在使用泛型类的时候，指定参数类型信息，其实是给编译器一个指示，通过添加的参数类型信息，编译器在编译过程中，会主动进行类型检查和添加转型代码，但是在运行期，参数类型信息被擦除<br>所以在泛型中的所有动作都发生在边界处——对传递进来的值进行额外的编译期类型检查，并插入对传递出去的值的转型，这有助于我们澄清对擦除的混淆，记住，<strong>边界是发生动作的地方</strong></p>
<h2 id="擦除的补偿"><a href="#擦除的补偿" class="headerlink" title="擦除的补偿"></a>擦除的补偿</h2><p><strong>擦除丢失了在泛型代码中执行某些操作的能力，任何运行是需要知道确切类型信息的操作都无法工作</strong> 如下例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Erased</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE=<span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Object args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args <span class="keyword">instanceof</span> T)&#123;&#125;<span class="comment">//error</span></span><br><span class="line">        <span class="keyword">new</span> T();<span class="comment">//error</span></span><br><span class="line">        T[] array=<span class="keyword">new</span> T[SIZE];<span class="comment">//error</span></span><br><span class="line">        T[] array=(T) <span class="keyword">new</span> Object[SIZE];<span class="comment">//unckecked warning</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>偶尔可以绕开这些问题，<strong>但是有时必须通过引入类型标签来对擦除进行补偿，这意味着你需要显式地传递你的类型的Class对象，以便你可以在类型表达式中使用它</strong><br>如前面的例子中使用instanceof的尝试失败了，因为其类型信息已经被擦除了，如果引入类型标签，就可以转而使用动态的isInstance();<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassTypeCapture</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; type;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassTypeCapture</span><span class="params">(Class&lt;T&gt; type)</span></span>&#123;type=type;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">f</span><span class="params">(Object arg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  type.isInstance(arg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ClassTypeCapture&lt;String&gt; ct=<span class="keyword">new</span> ClassTypeCapture&lt;&gt;(String.class);</span><br><span class="line">        <span class="keyword">boolean</span> b=ct.f(<span class="string">"hello"</span>);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译器将确保类型标签可以匹配任何泛型参数</p>
<h3 id="创建类型实例"><a href="#创建类型实例" class="headerlink" title="创建类型实例"></a>创建类型实例</h3><p><strong>在Erased.java中创建一个new T()的尝试将无法实现，部分原因是因为擦除，而另一部分原因是因为编译器不能验证T具有默认（无参）构造器</strong><br>在C++中，这种操作是很自然且直观的因为它在编译期受到检查<br>java中的解决办法是传递一个工厂对象，并用它来创建新的实例，最便利的工厂对象就是Class对象，因此如果使用类型标签，那么你就可以使用new Instance（）来创建这个类型的新对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassAsFactory</span> &lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T x;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassAsFactory</span><span class="params">(Class&lt;T&gt; type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            x = type.newInstance();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstantiateGenericType</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ClassAsFactory&lt;Employee&gt; fe=<span class="keyword">new</span> ClassAsFactory&lt;&gt;(Employee.class);</span><br><span class="line">        System.out.println(<span class="string">"ClassAsFactory&lt;Employee&gt; succeeded"</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ClassAsFactory&lt;Integer&gt; ci=<span class="keyword">new</span> ClassAsFactory&lt;&gt;(Integer.class);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"ClassAsFactory&lt;Integer&gt; failed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这可以编译，但是会因为ClassAsFactory<integer>而失败，因为Integer没有默认构造器，因为这个错误不是在编译器捕获的，所以这种方式使用泛型创建对象并不太好，我们没有尽最大的努力将错误隔绝在编译期，<br>Sun建议使用显式的工厂，并限制其类型，使得只能接受实现了这个工厂的类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">FactoryI</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo2</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T x;</span><br><span class="line">    <span class="keyword">public</span> &lt;F extends FactoryI&lt;T&gt;&gt; Foo2(F factory)&#123;<span class="comment">//这里是重点，确保传递的参数必须是那些可向上转型为FactoryI的的类型</span></span><br><span class="line">        x=factory.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntegerFactory</span> <span class="keyword">implements</span> <span class="title">FactoryI</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;  <span class="comment">//这些类都实现料Factory接口，使得对象的创建得到了保证</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span>  Integer <span class="title">create</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> Integer(<span class="number">0</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">FactoryI</span>&lt;<span class="title">Widget</span>&gt;</span>&#123;  <span class="comment">//Widget.Factory也是实现了FcatoryI的接口</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Widget <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Widget();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryConstraint</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Foo2&lt;Integer&gt;(<span class="keyword">new</span> IntegerFactory());</span><br><span class="line">        <span class="keyword">new</span> Foo2&lt;Widget&gt;(<span class="keyword">new</span> Widget.Factory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></integer></p>
<p>注意，这确实是传递Class<t>的一种变体，两种方式都传递了工厂对象，Class<t>碰巧是内建的工厂对象，而上面的方式创建了一个显式的工厂对象，但是你却获得了编译器检查<br>另一种方式是模板方法设计模式，在这个示例中，get是模板方法，而create()是在子类中定义的，用来产生子类类型的对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericWithCreate</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> T element;</span><br><span class="line">    GenericWithCreate()&#123;</span><br><span class="line">        element=create();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> T <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Creator</span> <span class="keyword">extends</span> <span class="title">GenericWithCreate</span>&lt;<span class="title">X</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">X <span class="title">create</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> X();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(element.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreatorGeneric</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Creator creator= <span class="keyword">new</span> Creator();<span class="comment">//在创建导出类对象的时候,element就得到了初始化，</span></span><br><span class="line">        creator.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></t></p>
<h3 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h3><p>Erased.java看到，不能创建泛型数组，一般的解决办法是在任何想要创建泛型数组的地方都使用ArrayList<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListOfGeneric</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; array=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T item)</span></span>&#123;</span><br><span class="line">        array.add(item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> array.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是有时你仍然想要创建泛型类型的数组，<br>数组将会跟着它们的实际类型，而这个类型是在数组被创建时确定的，因此，即使gia已经被转型为Generic<integer>[],但是这个信息只存在与编译器，在运行时，它仍然是Object数组，而这将会引起问题，成功创建泛型数组的唯一方式就是创建一个被擦除类型的新数组，然后对其转型<br>因为有了擦除，数组在运行时类型就只能是Object[],如果我们立即将其转型为T[]，那么在编译器该数组的实际类型就会丢失，而编译器可能会错过某些潜在的错误检查，正因这样，最好是在集合内部使用Object[]，然后当你使用数组元素时，添加一个对T的转型，让我们看下面这个例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericArray2</span> &lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] array;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericArray2</span><span class="params">(<span class="keyword">int</span> sz)</span></span>&#123;</span><br><span class="line">        array=<span class="keyword">new</span> Object[sz];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> index,T item)</span></span>&#123;</span><br><span class="line">        array[index]=item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"Unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;<span class="keyword">return</span> (T)array[index];&#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"Unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> T[] rep()&#123;</span><br><span class="line">        <span class="keyword">return</span> (T[])array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        GenericArray2&lt;Integer&gt; gia=<span class="keyword">new</span> GenericArray2&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            gia.put(i,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.out.println(gia.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Integer[] ia=gia.rep();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></integer></p>
<p>初看起来没什么太多变化，只是转型挪了地方，如果没有@SuppressWranings注解，你依然会得到unchecked警告，但是，现在的内部表示是Object而不是T[],<strong>当get()被调用的时，它将对象转型为T,这实际上是正确的类型，因此也是安全的，然而，如果你调用rep()，它还是尝试着将Object数组转型为T[],这仍旧不正确的，将在编译器生成警告，在运行时产生异常，因此，没有任何方式可以推翻底层的数组类型，它只能是Object[],</strong>在内部将array当作Object[]而不是T[]处理的优势是，我们不太可能忘记这个数组的运行时类型，从而意外地引入缺陷（尽管大多数也可能是所有这类缺陷都可以在运行时快速地探测到）<br>对于新代码，应该传递一个类型标记，在这种情况下，GenericArray看起来应该像下面这样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericArrayWithToken</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"Unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericArrayWithToken</span><span class="params">(Class&lt;T&gt; type,<span class="keyword">int</span> sz)</span></span>&#123;</span><br><span class="line">        array=(T[]) Array.newInstance(type,sz);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> index,T item)</span></span>&#123;</span><br><span class="line">        array[index]=item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T[] rep()&#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        GenericArrayWithToken&lt;Integer&gt; gia=<span class="keyword">new</span> GenericArrayWithToken&lt;&gt;(Integer.class,<span class="number">10</span>);</span><br><span class="line">        Integer[] ia=gia.rep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意，Class<t>被传递到构造器，以便从擦除中恢复，使得我们可创建需要的实际类型的数组</t></strong>，由此，也可以看出，rep()返回的数组被Integer[]捕获在运行期也没有问题，因为数组底层是type类型的元素，数组的创建也是以type为元素类型创建的，所以没有任何问题，所有从这里也可以看出来，数组类型和数组元素类型是不相同的两个概念</p>
<h2 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h2><p><strong>边界使得你可以在用于泛型的参数类型上设置限制条件，尽管这样使得你可以强制规定泛型可以应用的类型，但是潜在的一个更重要的效果是你可以按照自己的边界类型调用方法</strong><br><strong>因为擦除移除了类型信息，所有，可以用无界泛型参数调用的方法只是那些可以用Object调用的方法，但是，如果能够将这个参数限制为某个参数子集，那么你就可以用这些类型子集来调用方法，为了执行这种限制，java重用了extends关键字</strong>，对你来说有一点很重要，即要理解extends关键字在泛型边界上下文环境中和在普通情况下所具有的意义是完全不同的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">HasColor</span></span>&#123;</span><br><span class="line">    <span class="function">Color <span class="title">getColor</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Colored</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">HasColor</span>&gt;</span>&#123;</span><br><span class="line">    T item;</span><br><span class="line">    Colored(T item)&#123; item=item;&#125;</span><br><span class="line">    <span class="function">T <span class="title">getItem</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item;&#125;</span><br><span class="line">    <span class="function">Color <span class="title">getColor</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item.getColor();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dimnension</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x,y,z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColoredDimension</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Dimnension</span> &amp; <span class="title">HasColor</span>&gt;</span>&#123;</span><br><span class="line">    T item;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ColoredDimension</span><span class="params">(T item)</span></span>&#123;</span><br><span class="line">        item=item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">getItem</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item;&#125;</span><br><span class="line">    <span class="function">Color <span class="title">getColor</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item.getColor() ;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item.x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span></span>&#123;<span class="keyword">return</span>  item.y;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getZ</span><span class="params">()</span></span>&#123;<span class="keyword">return</span>  item.z;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Weight</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">weight</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solid</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Dimnension</span> &amp; <span class="title">HasColor</span> &amp; <span class="title">Weight</span>&gt;</span>&#123;</span><br><span class="line">    T item;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solid</span><span class="params">(T item)</span></span>&#123;</span><br><span class="line">        item=item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">getItem</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item;&#125;</span><br><span class="line">    <span class="function">Color <span class="title">getColor</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item.getColor();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item.x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">weight</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item.weight();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bounded</span> <span class="keyword">extends</span> <span class="title">Dimnension</span> <span class="keyword">implements</span> <span class="title">HasColor</span>,<span class="title">Weight</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Color <span class="title">getColor</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">weight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicBounds</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Solid&lt;Bounded&gt; solid=<span class="keyword">new</span> Solid&lt;&gt;(<span class="keyword">new</span> Bounded());</span><br><span class="line">        solid.getColor();</span><br><span class="line">        solid.weight();</span><br><span class="line">        solid.getX();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面是一个很简单的一个例子，我们创建里一个泛型类，这个泛型类能够接受的类型必须是 <code>extends Diamension &amp; HasColor &amp; Weight</code>的，这种对参数类型进行限定的方式，因为编译器的静态类型检查，我们可以很安全的使用这些基类或接口的方法<br>下面例子，看看如何在继承的每个层次上添加边界限制<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HoldItem</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    T item;</span><br><span class="line">    HoldItem(T item)&#123;</span><br><span class="line">        item=item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Colored2</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">HasColor</span>&gt; <span class="keyword">extends</span> <span class="title">HoldItem</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    Colored2(T item)&#123;<span class="keyword">super</span>(item);&#125;</span><br><span class="line">    <span class="function">Color <span class="title">getColor</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item.getColor();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColoredDimension2</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Dimnension</span> &amp; <span class="title">HasColor</span>&gt; <span class="keyword">extends</span> <span class="title">Colored</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">      ColoredDimension2(T item)&#123;<span class="keyword">super</span>(item);&#125;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item.x;&#125;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span></span>&#123;<span class="keyword">return</span>  item.y;&#125;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getZ</span><span class="params">()</span></span>&#123;<span class="keyword">return</span>  item.z;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solid2</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Dimnension</span> &amp; <span class="title">HasColor</span> &amp; <span class="title">Weight</span>&gt; <span class="keyword">extends</span> <span class="title">ColoredDimension2</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    Solid2(T item)&#123;<span class="keyword">super</span>(item);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">weight</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item.weight();&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritBounds</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Solid2&lt;Bounded&gt; solid2=<span class="keyword">new</span> Solid2&lt;&gt;(<span class="keyword">new</span> Bounded());</span><br><span class="line">        solid2.getColor();</span><br><span class="line">        solid2.getX();</span><br><span class="line">        solid2.weight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>HoldItem持有一个对象，因此这种行为被继承到了Color2中，它也要求其参数与HasColor一致，</strong>或者说参数类型要与HoldItem的参数限定的保存一致，这样才能继承基类那些涉及到限定参数类型的方法</p>
<h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><p>我们首先先看一下数组的一种特殊行为，可以向导出类型的数组赋予基类型的数据引用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CovariantArrays</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Fruit[] fruits=<span class="keyword">new</span> Apple[<span class="number">10</span>];</span><br><span class="line">        fruits[<span class="number">0</span>] = <span class="keyword">new</span> Apple();</span><br><span class="line">        fruits[<span class="number">1</span>] = <span class="keyword">new</span> Jonathan();</span><br><span class="line">        <span class="comment">//runtime type is Apple[],not Fruit[] or Orange[]</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            fruits[<span class="number">0</span>]=<span class="keyword">new</span> Fruit();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123; System.out.println(e);&#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            fruits[<span class="number">0</span>]=<span class="keyword">new</span> Orange();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;System.out.println(e);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>main()第一行创建了一个Apple数组，并将其赋值给一个Fruit数组引用，这是有意义的，因为Apple也是一种Fruit，因此Apple数组应该也是Fruit数组<br><strong>但是，如果实际的数组类型是Apple[],你应该只能往里面放Apple或者Apple的子类型，这在编译器和运行期都可以工作</strong>，但是请注意，编译器允许你将Fruit放置到这个数组，这对于编译器是有意义的，因为它有一个Fruit引用——它有什么理由拒绝将Fruit对象或者任何从Fruit继承出来的对象呢放置到这个数组中呢？因此，编译期，这是允许的，但是，运行时的数组机制知道它处理的是Apple[],因此会向数组中放置异构类型是抛出异常<br>我的理解是这样的，数组和其他的对象是不同的，数组对象中的元素所在的内存空间就在数组对象的内存空间呢，当数组对象创建完成后数组的内存空间，所保存的元素的类型信息就已经定下来了，不能改变，那么这也保证了数组不能保存异构类型的元素<br>实际上，向上转型不适合用在这里，你真正做的是将一个数组赋值给另一个数组，数组行为应当是它可以持有其他对象，这里只是因为我们能够向上转型而已，所有很明显，数组对象可以保留有关它们包含的对象类型的规则，就好像数组对它们持有的对象是有意识的，因此在编译器检查和运行时检查之间，你不能滥用它们<br>对数组的这种滥用并不那么可怕，因为在运行时可以发现你已经插入了不正确的类型，<strong>但是泛型的主要目标之一就是将这种错误检测移到编译期</strong>，因此当我们试图使用泛型容器来替代数组时，会发生什么？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//compile error</span></span><br><span class="line">List&lt;Fruit&gt; fruit=<span class="keyword">new</span> ArrayList&lt;Apple&gt;()</span><br></pre></td></tr></table></figure></p>
<p>尽管你在第一次阅读这段代码时会认为：“不能讲一个Apple容器赋值给一个Fruit容器”，别忘了，<strong>泛型不仅和容器相关正确的说法是：“不能把一个涉及Apple的泛型赋给一个设计Fruit的泛型</strong>”，如果就像在数组中的情况一样，编译器对代码的了解足够多，可以确定所涉及的容器，那么它可能留有一些余地，但是它不知道任何有关这方面的信息，因此它拒绝向上转型，<strong>实际上，这里也不是向上转型—</strong>—Apple的List不是Fruit的List，Apple的List将持有Apple和Apple的子类型，而Fruit的List将持有任何类型的Fruit,诚然，这包括Apple，一个Apple的List，它仍然是Fruit的List，Apple的List在类型上不等价于Fruit的List,即使Apple是一种Fruit类型，我们还记得运行时类型信息讲过的<code>Class&lt;Number&gt; Nclass=Integer.class</code>会引发编译错误也是这个原因<br><strong>真正的问题是我们在谈容器的类型，而不是容器持有的类型</strong>，与数组不同，泛型没没有内建的协变类型，这是因为数组在语言上是完全定义的，因为可以内建了编译期和运行时的检查，但是，<strong>在使用泛型时，编译器和运行时系统都不知道你想用类型做些什么，以及应该采用什么样的规则</strong><br>但是有时你想要在两个类型之间建立某种类型的向上转型关系，这正是通配符所允许的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericAndCovariance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;? extends Fruit&gt; fruit=<span class="keyword">new</span> ArrayList&lt;Apple&gt;();</span><br><span class="line">        <span class="comment">//fruit.add(new Apple())编译错误</span></span><br><span class="line">        <span class="comment">//fruit.add(new Fruit());</span></span><br><span class="line">        <span class="comment">//fruit.add(new Object());</span></span><br><span class="line">        fruit.add(<span class="keyword">null</span>);<span class="comment">//legal but uninstersting</span></span><br><span class="line">        <span class="comment">// we know that it returns at least Fruit;</span></span><br><span class="line">        Fruit f = fruit.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>fruit类型现在是List&lt;? extends Fruit&gt;,你可以将其读作“具有任何从Fruit继承的类型的列表”，<strong>但是实际上， 并不意味着这个List将持有任何类型的Fruit</strong>，<strong>通配符引用的是明确的类型</strong>，<strong>因此它意味着“某种fruit引用没有指定的具体类型</strong>”，因此这个被赋值的List必须持有诸如Fruit或Apple这样的某种指定类型，但是为了向上转型为fruit，这个类型是什么并没有人关心<br>如果唯一的限制是这个List要持有某种具体的Fruit或Fruit的子类型，但是你实际上并不关系它是什么，那么你能用这样的List做什么呢？如果不知道List持有什么类型，那么你怎样才能安全地向其中添加对象呢？你不能，除非编译器而不是运行时系统可以阻止这种操作的发生（也就是说只有编译器阻止向其中添加对象，你添加对象的行为才是安全的，这也是为什么我们不能向List&lt;? extends Fruit&gt;这种类型的对象添加对象的原因，一切都是为了类型安全，我们无法容忍在添加之后，运行时才发现问题的这种情况的发生）<br>你可能认为，事情变得有点走极端了，因为现在你甚至不能向刚刚声明过将持有Apple对象的List中放置一个Apple对象了，是的，编译器并不知道这一点，List&lt;? extends Fruit&gt;可以合法地指向一个List<orange>,一旦指向这种类型的向上转型，你就会丢失掉向其中传递任何对象的能力，甚至Object也不行<br>一方面，如果你调用一个返回Fruit的方法，则是安全的，因为你知道在这个List中的任何对象都至少具有Fruit类型，因此编译器允许这么做 </orange></p>
<h3 id="编译器有多聪明"><a href="#编译器有多聪明" class="headerlink" title="编译器有多聪明"></a>编译器有多聪明</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompileIntelligence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;? extends Fruit&gt; fruits=<span class="keyword">new</span> ArrayList&lt;Apple&gt;();</span><br><span class="line">        Apple a=(Apple)fruits.get(<span class="number">0</span>);</span><br><span class="line">        fruits.contains(<span class="keyword">new</span> Apple());<span class="comment">//argument is "Object"</span></span><br><span class="line">        fruits.indexOf(<span class="keyword">new</span> Apple()); <span class="comment">//argument is "Object"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以看到，对contains()和indexOf()的调用，这两个方法都接受Apple对象作为参数，而这些调用都可以正常执行，这是否意味着编译器实际上将检查代码，以查看是否有某个特定的方法修改了它的对象？<br>通过查看ArrayList文档，我们发现，编译器并没有那么充满，尽管add()方法接受一个具有泛型参数类型的参数，但是contains()和indexOf()将接受一个Object类型的参数，因此当你指向一个ArrayList&lt;? extends Fruit&gt;时，add()的参数就变成了“？extends Fruit”(我在编辑add()方法的时候，确实IDE会提醒这个方法的参数是“？ extends Fruit”，这里的意思是：这个方法接受Fruit类型及其子类型的参数，从这个描述中看，编译器也不确定，接受的是哪个确切的类型，因为编译器对参数类型的信息了解的并不多，为了类型安全（编译期的静态类型检查），编译器拒绝接受任何类型的参数)<br>在使用contains()和indexOf()时，参数类型是Object，因此不涉及任何通配符，而编译器也将允许这个调用，这意味这个将由泛型类的设计来决定哪些调用是“安全”的，并使用Object类型作为其参数类型，<strong>为了在类型中使用了通配符的情况下禁止这类调用，我们需要在参数列表中使用类型参数</strong><br>我们来做个总结，当我们使用类似&lt;? extends Fruit&gt;这样的类型参数时，泛型类中那些在方法列表中不涉及类型参数的方法可以正常调用，而在参数列表中使用了类型参数的方法将会被编译器禁止调用<br>看下面是一个很简单的例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T item;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">(T item)</span></span>&#123;</span><br><span class="line">        item=item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T item)</span></span>&#123;item=item;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.equals(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Holder&lt;Apple&gt; apple=<span class="keyword">new</span> Holder&lt;&gt;(<span class="keyword">new</span> Apple);</span><br><span class="line">        Apple d=apple.get();</span><br><span class="line">        apple.set(<span class="keyword">new</span> Apple());</span><br><span class="line">        Holder&lt;? extends Fruit&gt; fruit=apple;</span><br><span class="line">        Fruit p=fruit.get();</span><br><span class="line">        d=(Apple) fruit.get();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Orange o = (Orange) fruit.get();<span class="comment">//可以，但是运行时类型转换异常</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//fruit.set(new Orange()); 参数列表中涉及到类型参数的方法不能调用</span></span><br><span class="line">        <span class="comment">//fruit.set(new Apple());</span></span><br><span class="line">        System.out.println(fruit.equals(d));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="逆变"><a href="#逆变" class="headerlink" title="逆变"></a>逆变</h3><p><strong>还可以走另外一条路，即使用超类型通配符，这里，可以声明通配符是由某个特定类的任意基类来界定，方法是指定&lt;? super MyClass&gt;，甚至或者使用类型参数&lt;? extends T&gt;</strong>（尽管你不能对泛型参数给出一个超类型边界，即不能声明<t super="" myclass="">）,<strong>这使得你可以安全地传递一个类型对象到泛型类型中</strong> 看下面一个例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperTypeWildcards</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeTo</span><span class="params">(List&lt;? <span class="keyword">super</span> Apple&gt; apples)</span></span>&#123;</span><br><span class="line">        apples.add(<span class="keyword">new</span> Apple());</span><br><span class="line">        apples.add(<span class="keyword">new</span> Jonathan());</span><br><span class="line">        <span class="comment">//apples.add(new Fruit()); //error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></p>
<p>从这例子看出&lt;? super Apple&gt;表明参数类型被指定为Apple的基类，因此泛型类的那些方法的参数列表就变为&lt;? super Apple&gt;，方法接受的类型是Apple的基类，Apple是下界，这样向这些方法传递Apple及其子类型是安全的，（Apple的基类都能接受，Apple及Apple的子类型更是不在话下）</p>
<p>因此你可能根据如何能够向一个泛型类型“写入”(传递给一个方法)，以及如何能够从一个泛型类型中“读取”（从一个方法中返回），来这手思考子类型边界&lt;? extends MyClass&gt;和超类型边界(&lt;? super MyClass&gt;)<br>超类型边界放松了在可以向方法传递参数上所作的限制<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericWriting</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">writeExact</span><span class="params">(List&lt;T&gt; list,T item)</span></span>&#123;</span><br><span class="line">        list.add(item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">writeWithSuperWildcard</span><span class="params">(List&lt;? <span class="keyword">super</span> T&gt; list,T item)</span></span>&#123;</span><br><span class="line">        list.add(item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> List&lt;Apple&gt; apples= <span class="keyword">new</span> ArrayList&lt;Apple&gt;();</span><br><span class="line">    <span class="keyword">static</span> List&lt;Fruit&gt; fruit =<span class="keyword">new</span> ArrayList&lt;Fruit&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        writeExact(apples,<span class="keyword">new</span> Apple());</span><br><span class="line">        writeExact(fruit,<span class="keyword">new</span> Apple());<span class="comment">//为什么，没有编译错误？</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        writeWithSuperWildcard(apples,<span class="keyword">new</span> Apple());</span><br><span class="line">        writeWithSuperWildcard(fruit,<span class="keyword">new</span> Apple());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        f1();</span><br><span class="line">        f2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在《编程思想》中，writeExact(fruit，new Apple())中指明这种方式有编译错误，found Fruit required Apple,但是为什么，我在编译器中没有发现任何编译错误的提示呢？难道是java之后的版本支持了向List<fruit>类型的引用，传递Apple?<br>回来再研究这个问题<br>下面的例子，作为对协变和通配符的一个复习<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericReading</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">readExact</span><span class="params">(List&lt;T&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> List&lt;Apple&gt; apples=Arrays.asList(<span class="keyword">new</span> Apple());</span><br><span class="line">    <span class="keyword">static</span> List&lt;Fruit&gt; fruits=Arrays.asList(<span class="keyword">new</span> Fruit());</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">     Apple a=readExact(apples);</span><br><span class="line">     Fruit f=readExact(fruits);</span><br><span class="line">     f=readExact(apples);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Reader</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">        <span class="function">T <span class="title">readExact</span><span class="params">(List&lt;T&gt; list)</span></span>&#123; <span class="keyword">return</span> list.get(<span class="number">0</span>);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Reader&lt;Fruit&gt; fruitReader=<span class="keyword">new</span> Reader&lt;&gt;();</span><br><span class="line">        Fruit f=fruitReader.readExact(fruits);</span><br><span class="line">        <span class="comment">//error raedFruit(List&lt;Fruit&gt;) cannot be applied to (Lisy&lt;Apple&gt;)</span></span><br><span class="line">        <span class="comment">//Fruit a=fruitReader.readExact(apples);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CovariantReader</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function">T <span class="title">readCovariant</span><span class="params">(List&lt;? extends T&gt; list)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        CovariantReader&lt;Fruit&gt; convariantRead=<span class="keyword">new</span> CovariantReader&lt;&gt;();</span><br><span class="line">        Fruit f=convariantRead.readCovariant(apples);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        f1();f2();f3()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></fruit></p>
<p>第1个方法readExact()使用了精确类型，因此如果使用了这个没有任何通配符的精确类型，就可以向List中写入和读取这个精确类型，另外，对于返回值，静态的泛型方法readExact()可以有效地“适应”每个方法调用，并能从List<apple>中返回一个Apple，从List<fruit>，返回一个Fruit,就像f1()看到的那样，因此，如果可以摆脱静态泛型方法，那么当只是读取时，就不需要协变类型了<br>但是，如果有个泛型类，那么当你创建这个类的实例时，要为这个类确定参数，就像在f2()中看到的那样，fruitReader实例可以从List<fruit>中读取一个Fruit，因为这就是它的确切类型，但是List<apple>还应该产生一个Fruit对象，而fruitReader不允许这么做<br>为了修正这个问题。CovariantReader.readCovariant()方法将接受List&lt;? extends T&gt;,因此，从这个列表读取一个T是安全的（你知道在这个列表中的所有对象至少是一个T，并且可能是从T导出的某种对象），在f3()中，你可以看到现在可以从List<apple><br>中读取Fruit了</apple></apple></fruit></fruit></apple></p>
<h3 id="无界通配符"><a href="#无界通配符" class="headerlink" title="无界通配符"></a>无界通配符</h3><p>无界通配符&lt;?&gt;看起来意味着“任何事物”，因此使用无界通配符好像等价于使用原生类型，事实上，编译器初看起来是支持这种判断的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnboundWildcards1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> List list1;</span><br><span class="line">    <span class="keyword">static</span> List&lt;?&gt; list2;</span><br><span class="line">    <span class="keyword">static</span> List&lt;? extends Object&gt; list3;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign1</span><span class="params">(List list)</span></span>&#123;</span><br><span class="line">        list1=list;</span><br><span class="line">        list2=list;</span><br><span class="line">        <span class="comment">//list3=list; warning:unchecked coversion</span></span><br><span class="line">        <span class="comment">//found List,Required: List&lt;? extends Object&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign2</span><span class="params">(List&lt;?&gt; list)</span></span>&#123;</span><br><span class="line">        list1=list;</span><br><span class="line">        list2=list;</span><br><span class="line">        list3=list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign3</span><span class="params">(List&lt;? extends Object&gt; list)</span></span>&#123;</span><br><span class="line">        list1=list;</span><br><span class="line">        list2=list;</span><br><span class="line">        list3=list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assign1(<span class="keyword">new</span> ArrayList());</span><br><span class="line">        assign2(<span class="keyword">new</span> ArrayList());</span><br><span class="line">        <span class="comment">//assign3(new ArrayList()); warning unchecked conversion found ArrayList Required:list&lt;? extends Object&gt;</span></span><br><span class="line">        assign1(<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">        assign2(<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">        assign3(<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">        List&lt;?&gt; wildList=<span class="keyword">new</span> ArrayList();</span><br><span class="line">        wildList=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        assign1(wildList);</span><br><span class="line">        assign2(wildList);</span><br><span class="line">        assign3(wildList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有很多情况都和你在这里看到的情况类似，即编译器很少关心使用的原生类型还是&lt;?&gt;。在这种情况中，&lt;?&gt;可以被认为是一种装饰，但是它仍旧是有价值的，<strong>因为实际上，它是在声明：我想要java的泛型来编写这段代码，我在这里并不是要用原生类型，但是在当前这种情况下，泛型参数可以持有任何类型</strong><br>下面一个示例展示了无界通配符的一个重要应用，<strong>当你在处理多个泛型参数时，有时允许一个参数可以是任何类型，因此为其他参数确定某种特定类型的这种能力很重要</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Unboundwildcards2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Map map1；</span><br><span class="line">    <span class="keyword">static</span> Map&lt;?,?&gt; map2;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;String,?&gt; map3;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign1</span><span class="params">(Map map)</span></span>&#123;</span><br><span class="line">        map1=map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign2</span><span class="params">(Map&lt;?,?&gt; map)</span></span>&#123;map2=map;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign3</span><span class="params">(Map&lt;String,?&gt; map)</span></span>&#123;map3=map;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        assign1(<span class="keyword">new</span> HashMap());</span><br><span class="line">        assign2(<span class="keyword">new</span> HashMap());</span><br><span class="line">        <span class="comment">//assign3(new HashMap());//warning</span></span><br><span class="line">        assign1(<span class="keyword">new</span> HashMap&lt;String,Integer&gt;());</span><br><span class="line">        assign2(<span class="keyword">new</span> HashMap&lt;String,Integer&gt;());</span><br><span class="line">        assign3(<span class="keyword">new</span> HashMap&lt;String,Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是，当你拥有的是全部的无界通配符时，就像在Map&lt;?,?&gt;中看到的那样，编译器看起来即无法将其与原生Map区分开了，另外，UnboundWildcard1.java展示了编译器处理List&lt;?&gt;和List&lt;? extends Object&gt;时是不同的<br>令人困惑的是，编译器并非总是关注像List&lt;?&gt;和List之间的这种差异，因此它们看起来就像是相同的事物，因为，事实上，由于泛型参数将擦除到它的第一边界，因此List&lt;?&gt;看起来等价于List<object>，而实际上也是List<object>——除非这些语句都不为真，List世家上表示“持有任何Object类型的原生List”，而List&lt;?&gt;表示“具有某种特定类型的非元素List,只是我们不知道那种类型是什么”<br>编译器何时才会关注原生类型和涉及无界通配符的类型之间的差异呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wildcards</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rawArgs</span><span class="params">(Holder holder,Object args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//holder.set(args);//warning unchecked call to set(T) as a member of the raw Holder</span></span><br><span class="line">       <span class="comment">// holder.set(new Wildcards());//simple warning</span></span><br><span class="line">        Object obj=holder.get();</span><br><span class="line">        <span class="comment">//can't do this; don't have any T</span></span><br><span class="line">        <span class="comment">//T t=holder.get();</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unboundedArgs</span><span class="params">(Holder&lt;?&gt; holder,Object args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//holder.set(args);error注意这里是直接错误而不是警告</span></span><br><span class="line">        <span class="comment">//set(captre of ?) in Holder&lt;capture of ?&gt;</span></span><br><span class="line">        <span class="comment">//can't do this; don't have any T</span></span><br><span class="line">        <span class="comment">//T t=holder.get();</span></span><br><span class="line">        <span class="comment">//ok but type information has been lost</span></span><br><span class="line">        Object obj=holder.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">exact1</span><span class="params">(Holder&lt;T&gt; holder)</span></span>&#123;</span><br><span class="line">        T t= holder.get();</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">exact2</span><span class="params">(Holder&lt;T&gt; holder,T args)</span></span>&#123;</span><br><span class="line">        holder.set(args);</span><br><span class="line">        T t = holder.get();</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">wildSubType</span><span class="params">(Holder&lt;? extends T&gt; holder,T args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//holder.set(args); error</span></span><br><span class="line">        T t= holder.get();</span><br><span class="line">        <span class="keyword">return</span>  t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">wildSupType</span><span class="params">(Holder&lt;? <span class="keyword">super</span> T&gt; holder,T args)</span></span>&#123;</span><br><span class="line">        holder.set(args);</span><br><span class="line">        <span class="comment">//T t=holder.get();error</span></span><br><span class="line">        Object obj=holder.get();<span class="comment">//but type information has been lost</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Holder raw =<span class="keyword">new</span> Holder&lt;Long&gt;();</span><br><span class="line">        <span class="comment">//or</span></span><br><span class="line">        raw=<span class="keyword">new</span> Holder();</span><br><span class="line">        Holder&lt;Long&gt; qualified=<span class="keyword">new</span> Holder&lt;&gt;();</span><br><span class="line">        Holder&lt;?&gt; unbounded=<span class="keyword">new</span> Holder&lt;Long&gt;();</span><br><span class="line">        Holder&lt;? extends Long&gt; bounded=<span class="keyword">new</span> Holder&lt;Long&gt;();</span><br><span class="line">        Long lng=<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">        rawArgs(raw,lng);</span><br><span class="line">        rawArgs(qualified,lng);</span><br><span class="line">        rawArgs(unbounded,lng);</span><br><span class="line">        rawArgs(bounded,lng);</span><br><span class="line"></span><br><span class="line">        unboundedArgs(raw,lng);</span><br><span class="line">        unboundedArgs(qualified,lng);</span><br><span class="line">        unboundedArgs(unbounded,lng);</span><br><span class="line">        unboundedArgs(bounded,lng);</span><br><span class="line"></span><br><span class="line">        Object r1=exact1(raw);<span class="comment">//warnning</span></span><br><span class="line">        Long r2 =exact1(qualified);</span><br><span class="line">        Object r3=exact1(unbounded);<span class="comment">//Must return Object</span></span><br><span class="line">        Long r4=exact1(bounded);</span><br><span class="line"></span><br><span class="line">        Long r5=exact2(raw,lng)<span class="comment">//warning</span></span><br><span class="line">        Long r6 =exact2(qualified,lng);</span><br><span class="line">        <span class="comment">//Long r7 = exact2(unbounded,lng);//Error</span></span><br><span class="line">        <span class="comment">//Long r8=exact2(bounded,lng);//error</span></span><br><span class="line">        <span class="comment">//exact2(Holder&lt;T&gt;,T) cannot be applied</span></span><br><span class="line">        <span class="comment">//to (Holder&lt;capture of ? extends Long&gt;,Long)</span></span><br><span class="line"></span><br><span class="line">        Long r9=wildSubType(raw,lng);<span class="comment">//warnings</span></span><br><span class="line">        <span class="comment">//unchecked conversion form Holder to Holder&lt;? extends Long&gt;</span></span><br><span class="line">        <span class="comment">//unchecked method invocation:</span></span><br><span class="line">        <span class="comment">//wildSubType(Holder&lt;? extends T&gt;,T) is applied to (Holder,Long)</span></span><br><span class="line"></span><br><span class="line">        Long r10=wildSubType(qualified,lng);</span><br><span class="line">        <span class="comment">//ok but can only return Object</span></span><br><span class="line">        Object r11=wildSubType(unbounded,lng);</span><br><span class="line">        Long r12=wildSubType(bounded,lng);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//wildSubType(raw,lng);warnnings</span></span><br><span class="line">        <span class="comment">//unchecked conversion from Holder to Holder&lt;? super Long&gt;</span></span><br><span class="line">        <span class="comment">//nchecked method invocation;</span></span><br><span class="line">        <span class="comment">//wildSupType(Holder&lt;? super T&gt;,T) is applied to (Holder,Long)</span></span><br><span class="line"></span><br><span class="line">        wildSupType(qualified,lng);</span><br><span class="line">        <span class="comment">//wildSupType(unbounded,lng);//error</span></span><br><span class="line">        <span class="comment">//wildSuType(Holder&lt;? super T&gt;,T) cannot be applied to (Holder&lt;Capture of ?&gt;,Long)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//wildSupType(bounded,lng);error</span></span><br><span class="line">        <span class="comment">//wildSpType(Holder&lt;? super T&gt;,T)cannot be applied to (Holder&lt;capture of ? extends Long&gt;,Long )</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></object></object></p>
<p>在rawArgs()中，编译器知道Holder是一个泛型类型，因此即使它在这里表示成一个原生类型，编译器仍然知道向set()传递一个Obeject是不安全的，由于它是原生类型，你可以将任何类型的对象传递给set()，而这个对象将被向上转型为Object，因此无论何时，<strong>只要使用了原生类型，都会放弃编译器检查</strong>，对get()的调用说明了相同的问题，没有任何T类型的睇相，因此结果只能是一个Object<br>人们很自然会开始考虑原生类型Holder和Holder&lt;?&gt;是大致相同的事物，但是unboundArg()强调了它们的不同——它揭示了相同的问题，但是它将这些问题作为错误而不是警告报告，<strong>因为原生Holder将持有任何类型的组合，而Holder&lt;?&gt;将持有具有某种具体类型的同构集合，因此不能只是向其中传递Object</strong><br>在exact1()和exact2()中，你可以看到使用了确切的泛型类型——没有任何通配符，你将看到，exact2和exact1()有不同的限制，因为它有额外的参数<br>在wildSubType()中，在Holder类型上的限制被放松为包括持有任何扩展子T的对象的Holder，这还是意味着如果T是Fruit，那么Holder可以是Holder<apple>,这是合法的，为了防止将Orange()放置到Holder<apple>中，对set()的调用（或者任何接受这个类型参数的方法的调用）都是不允许的，但是，你仍旧知道任何来自Holder&lt;? extends Fruit&gt;的对象至少都是Fruit的，因此get()(任何参数列表不涉及类型参数的方法)的调用都是允许的<br>wildSupType()展示了超类型通配符，因此set()可以接受T,因为任何可以工作于基类的对象都可以多态地作用于导出类（这里就是T），但是尝试着调用get()是没用的，因此由Holder持有的类型可以是任何超类型，因此唯一安全的类型即使Object,但是这样具体的类型信息就会丢失<br>这个例子还展示了对于unbounded()中使用无界通配符能够做什么不能做什么所做出的限制，对于迁移兼容性，rawArgs()将接受所有Holder的不同变体，而不会产生警告，unboundedArgs()方法也可以接受相同的所有类型，尽管如前所示，它在方法体内部处理这些类型的方式并不相同<br><strong>如果向接受“确切”泛型类型（没有通配符）的方法产地一个原生Holder引用，就会得到一个警告，因为确切的参数期望得到在原生类型中并不存在的信息</strong>如果向exact1()传递一个无界引用，就不会有任何可以确定返回类型的类型信息<br>可以看到，exact2()具有更多的限制，因为它希望精确地得到一个Holder<t>，已经一个具有T类型的参数，正因如此，它将产生错误或者警告，除非提供确切的参数，有时，这样做很好，但是如果它过于受限，那么就可以使用通配符，这取决与是否想要从泛型参数中返回类型确定返回值（就像在wildSubType中看到的那样），或者是否想要向泛型参数传递类型确定的参数（就像在wildSupType()中看到的那样）<br>因此使用确切类型来替代通配符的好处是，可以用泛型参数来做更多事，但是使用通配符使得你必须接受范围更宽的参数化类型作为参数，因此，必须逐个情况地权衡利弊，找到更适合你的方法</t></apple></apple></p>
<h3 id="捕获转换"><a href="#捕获转换" class="headerlink" title="捕获转换"></a>捕获转换</h3><p><strong>有一种情况特别需要使用&lt;?&gt;而不是原生类型，如果像一个使用&lt;?&gt;的方法传递原生类型，那么对与编译器来说，可能会推断出实际的参数类型，使得这个方法可以回转并调用另一个使用这个确切类型的方法</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CaptureConversion</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(Holder&lt;T&gt; holdedr)</span></span>&#123;</span><br><span class="line">        T t=holdedr.get();</span><br><span class="line">        System.out.println(t.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">(Holder&lt;?&gt; holder)</span></span>&#123;</span><br><span class="line">        f1(holder);<span class="comment">//call with capture type</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Holder raw = <span class="keyword">new</span> Holder&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//f1(raw);//warnings</span></span><br><span class="line">        f2(raw);<span class="comment">//no warning</span></span><br><span class="line">        Holder rawBasic=<span class="keyword">new</span> Holder();</span><br><span class="line">        rawBasic.set(<span class="keyword">new</span> Object());<span class="comment">//warning</span></span><br><span class="line">        f2(rawBasic);<span class="comment">//no warning</span></span><br><span class="line">        Holder&lt;?&gt; wildcarded=<span class="keyword">new</span> Holder&lt;Double&gt;();</span><br><span class="line">        f2(wildcarded);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output</span></span><br><span class="line"><span class="comment">Integer</span></span><br><span class="line"><span class="comment">Object</span></span><br><span class="line"><span class="comment">Double</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
<p>f1()的参数类型都是确切的，没有通配符或边界，在f2()中，Holder参数是一个无界通配符，因此它看起来是未知的，但是，在f2()中，f1()被调用，而f1()需要一个已知参数，<strong>这里发生的是，参数类型在调用f2()的过程中被捕获，因此它可以在对f1()的调用中被使用</strong><br>你可能想知道，这项技术是否可以用于写入，但是这要求要在床底Holder&lt;?&gt;同时传递以恶搞具体类型，捕获站好只有在这样的情况下才能工作：即在方法内部，你需要使用确切的类型  </p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="任何基本类型都不能作为类型参数"><a href="#任何基本类型都不能作为类型参数" class="headerlink" title="任何基本类型都不能作为类型参数"></a>任何基本类型都不能作为类型参数</h3><h3 id="实现参数化接口"><a href="#实现参数化接口" class="headerlink" title="实现参数化接口"></a>实现参数化接口</h3><p>一个类不能实现一个泛型接口的两种变体，由于擦除的影响，这两个变体会成为相同的接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Payable</span>&lt;<span class="title">T</span>&gt;</span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Payable</span>&lt;<span class="title">Employee</span>&gt;</span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hourly</span> <span class="keyword">extends</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Payable</span>&lt;<span class="title">Hourly</span>&gt;</span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>Hourly不能编译成功，因为擦除会将Payable<eployee>和Payable<hourly>简化成相同的类Payable</hourly></eployee></p>
<h3 id="转型和警告"><a href="#转型和警告" class="headerlink" title="转型和警告"></a>转型和警告</h3><p>使用带有泛型参数的转型或instanceof不会产生任何效果，下面的容器在内部将各个值存储为Object，并在获取这些值时，再将它们转型回T<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FixedSizeStack</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Object[] storage;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FixedSizeStack</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">       storage=<span class="keyword">new</span> Object[size]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T item)</span></span>&#123;storage[index++]=item;&#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> (T)storage[index--];&#125;<span class="comment">//重点在这一行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericCast</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE=<span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        FixedSizeStack&lt;String&gt; strings=<span class="keyword">new</span> FixedSizeStack&lt;&gt;(SIZE);</span><br><span class="line">        <span class="keyword">for</span>(String str:<span class="string">"A B C D E F G H I J"</span>.split(<span class="string">" "</span>))&#123;</span><br><span class="line">            strings.push(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;SIZE;i++)&#123;</span><br><span class="line">            String s=strings.pop();</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果没有@SuppressWranings注解，编译将会产生“unchecked cast”警告,<strong>由于擦除的影响，编译器无法知道这个转型是否是安全的，并且pop()方法实际上没有执行任何转型，这是因为，T被擦除到它的第一个边界，默认情况下是Object，因此pop()实际上只是将Object转型为Object</strong><br><strong>有时，泛型没有消除对转型的需要，就会产生编译器警告，而这个警告是不恰当的，例如</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NeedCasting</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]));</span><br><span class="line">        List&lt;Widget&gt; shape=(List&lt;Widget&gt;)in.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>readObject()无法知道它正在读取的是什么，因此它返回的是必须转型的对象，但是当注释点@SuppressWranings注解，并编译这个程序的时，就会出现下面的警告<br>Note:NeedCasting,java uses unchecked or unsafe operations<br>Note:Recompile with —Xlint:unchecked for detail<br>如果遵循这条指示，使用—Xlint：unchecked来重新编译<br>NeedCasting.java:12: warning:[unckecked] unchecked cast<br>found :java.lang.Object<br>required: java.util.List<widget><br>   List<shape> shapes=(List<widget>)in.readObject();<br>你会被强制要求转型，但是又被告知不应该转型，为了解决这个问题，必须使用在java SE5中引入的新的转型形式，既通过泛型类来转型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NeedCasting</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]));</span><br><span class="line">        <span class="comment">//List&lt;Widget&gt; lw1=List&lt;Widget&gt;.class.cast(in.readObject());</span></span><br><span class="line">        List&lt;Widget&gt; lw2=List.class.cast(in.readObject());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></widget></shape></widget></p>
<p>这里是相当奇怪的</p>
<h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>下面的程序是不能编译的，即使编译它是一种合理的尝试<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseList</span>&lt;<span class="title">W</span>,<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(List&lt;T&gt; v)</span></span>&#123;&#125;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(List&lt;W&gt; v)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于擦除的影响，重载方法将产生相同的类型签名</p>
<h3 id="基类劫持了接口"><a href="#基类劫持了接口" class="headerlink" title="基类劫持了接口"></a>基类劫持了接口</h3><p>假设你有一个Pet类，它可以与其他的Pet类对象进行比较（实现了Comparable接口）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparablePet</span>  <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ComparablePet</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(@NotNull ComparablePet o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对可以与ComparablePet的子类比较的类型进行窄化是有意义的，例如，一个Cat对象就只能与其他Cat对象进行比较<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">ComparablePet</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Cat</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(@NotNull Cat o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>遗憾的是上面代码错误，一旦为Comparable确定了ComparablePet参数，那么其他任何实现类都不能与ComparablePet之外的任何对象比较<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hamster</span> <span class="keyword">extends</span> <span class="title">ComparablePet</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ComparablePet</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(ComparablePet args)</span></span>&#123;<span class="keyword">return</span>  <span class="number">1</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Hasmter说明再次实现ComparablePet中的接口是可能的，只要它们精确地相同，包括参数类型在内</p>
<h2 id="自限定的类型"><a href="#自限定的类型" class="headerlink" title="自限定的类型"></a>自限定的类型</h2><p>在java中，经常出现一个令人费解的惯用法<br>class SelfBound&lt;T extends SelfBound<t>&gt;<br>这就像是两面镜子彼此看着对方产生的炫目感，是一种无限循环，SelfBound接受泛型参数T，而T由一个边界类限定，这个边界就是拥有T作为参数的ShefBound</t></p>
<h3 id="古怪的循环泛型"><a href="#古怪的循环泛型" class="headerlink" title="古怪的循环泛型"></a>古怪的循环泛型</h3><p>我们先从简单的版本入手<br><strong>不能直接继承一个泛型参数，但是，可以继承在其自己的定义中使用这个泛型参数的类</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericType</span>&lt;<span class="title">T</span>&gt;</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuriouslyRecurringGeneric</span> <span class="keyword">extends</span> <span class="title">GenericType</span>&lt;<span class="title">CuriouslyRecurringGeneric</span>&gt;</span>&#123; &#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的例子可以称为“古怪的循环”，<strong>“古怪的循环”是指类相当古怪地出现在自己的基类中这一事实</strong><br>为了理解其含义，努力地大声说“<strong>我正在创建一个新类吗，这个类继承子一个泛型类型，这个泛型类型的接受我的类的名字作为其参数</strong>”，当给出导出类的名字时，<strong>这个泛型基类能够实现什么呢？好吧，java中的泛型关乎参数和返回类型，因此它能够产生使用导出类作为参数和返回类型的积累，它还能将导出类用作其域类型，甚至那些将其擦除为Object的类型</strong><br>下面是一个普通的泛型类,它的方法将接受和产生具有参数类型的对象，还有一个方法将在其存储的域上执行操作（尽管只在这个域上执行Object操作）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicHolder</span> &lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T item;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setItem</span><span class="params">(T item)</span></span>&#123;item=item;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getItem</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(item.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面这个示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubType</span> <span class="keyword">extends</span> <span class="title">BasicHolder</span>&lt;<span class="title">SubType</span>&gt;</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CRWithBasicHolder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">      SubType subType1=<span class="keyword">new</span> SubType();</span><br><span class="line">      SubType subType2=<span class="keyword">new</span> SubType();</span><br><span class="line">      subType1.setItem(subType2);</span><br><span class="line">      SubType subType3=subType1.getItem();</span><br><span class="line">      subType1.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>新类SubType接受的参数和返回的值具有SubType类型而不仅仅是基类Basicholder的类型，这就是CRG(古怪的循环)的本质，<strong>基类用导出类替代其参数</strong>，<strong>这意味着泛型基类变成了一种其所有导出类的公共功能的模版，但是这些功能对于其所有参数和返回值，将使用导出类型，也就是说，在产生的类中将使用确切类型而不是其基类型</strong>，因此，在SubType中，传递给set()的参数和从get()返回的类型都是确切的SubType</p>
<h3 id="自限定"><a href="#自限定" class="headerlink" title="自限定"></a>自限定</h3><p>BasicHolder可以使用任何类型作为其泛型参数，就像下面看到的那样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Other</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicOther</span> <span class="keyword">extends</span> <span class="title">BasicHolder</span>&lt;<span class="title">Other</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        BasicOther b=<span class="keyword">new</span> BasicOther();</span><br><span class="line">        b.setItem(<span class="keyword">new</span> Other());</span><br><span class="line">        Other o=b.getItem();</span><br><span class="line">        b.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>自限定将采取额外的步骤，强制泛型当作其自己的边界参数来使用</strong><br>观察所产生的类可以如何使用以及不可以如何使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelfBounded</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&gt;</span>&#123;</span><br><span class="line">    T element;</span><br><span class="line">    <span class="function">SelfBounded&lt;T&gt; <span class="title">set</span><span class="params">(T arg)</span></span>&#123;</span><br><span class="line">        element=arg;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">A</span>&gt;</span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">A</span>&gt;</span>&#123;&#125;<span class="comment">//also ok</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">C</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">C <span class="title">setAndGet</span><span class="params">(C arg)</span></span>&#123;</span><br><span class="line">        set(arg);</span><br><span class="line">        <span class="keyword">return</span> get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//class E extends SelfBounded&lt;D&gt;&#123;&#125;can't do this</span></span><br><span class="line"><span class="comment">//compile error : Type parameter D is not within its bound</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//also you can do this ,so you can't force the idiom</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelfBounding</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        A a =<span class="keyword">new</span> A();</span><br><span class="line">        a.set(<span class="keyword">new</span> A());</span><br><span class="line">        a=a.set(<span class="keyword">new</span> A()).get();</span><br><span class="line">        a=a.get();</span><br><span class="line"></span><br><span class="line">        C c=<span class="keyword">new</span> C();</span><br><span class="line">        c=c.setAndGet(<span class="keyword">new</span> C());</span><br><span class="line"></span><br><span class="line">        B b=<span class="keyword">new</span> B();</span><br><span class="line">        b.set(<span class="keyword">new</span> A());</span><br><span class="line">        A ba=b.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>自限定所做的，就是要求在继承关系中，像下面这样使用这个类</strong><br>    class A extends SelfBounded<a>{}<br><strong>这会强制要求将正在定义的类当作参数传递给基类</strong><br>从基类的类型参数的表达式也能看的出来</a></p>
<p>&lt;T extends SelfBounded<t>&gt; T表示类型参数，这个参数的类型是其自身类型的导出类<br>自限定的参数有何意义呢？它可以保证类型参数必须与正在被定义的类相同<br>正如你从B类的定义所看到的，还可以从另一个SelfBounded参数的SelfBounded中导出，尽管A类看到的用法是最主要的用法<br>对定义E的尝试说明不能使用不是SelfBounded的类型参数<br>遗憾的是，F可以编译，不会有任何警告，这是比较奇怪的吗？这也说明了自限定惯用法不是可强制执行的，如果它确实很重要，可以要求一个外部工具来确保不会使用原生类型来替代参数化类型<br>注意，可以移除自限定这个限制，这样所有的类仍旧可以编译的，但是E也因此可编译成功<br>其实自限定类型的目的就是限定导出类在继承基类的时候，必须将参数类型替换为导出类（只要是基类的导出类都可以，一般我们惯用的是新建的这个导出类自身来替代参数类型而已，一次泛型类的自限定对于继承自它的类来说，没什么一样，自限定最大的功效就是强制而已）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A2</span> <span class="keyword">extends</span> <span class="title">NotSelfBounded</span>&lt;<span class="title">A</span>&gt;</span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span> <span class="keyword">extends</span> <span class="title">NotSelfBounded</span>&lt;<span class="title">A2</span>&gt;</span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C2</span> <span class="keyword">extends</span> <span class="title">NotSelfBounded</span>&lt;<span class="title">C2</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">C2 <span class="title">getAndSet</span><span class="params">(C2 arg)</span></span>&#123; set(arg);<span class="keyword">return</span> get(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E2</span> <span class="keyword">extends</span> <span class="title">NotSelfBounded</span>&lt;<span class="title">D2</span>&gt;</span>&#123;&#125;<span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotSelfBounded</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T element;</span><br><span class="line">    <span class="function">NotSelfBounded&lt;T&gt; <span class="title">set</span><span class="params">(T arg)</span></span>&#123;</span><br><span class="line">        element=arg;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> element;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></p>
<p>这里E2能够编译，即使D2不在NotSelfBounded继承关系中，因此得出结论：<strong>自限定限制只能强制作用于继承关系</strong>。<br>自限定也可以用在泛型方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelfBoundedMethods</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T extends SelfBounded&lt;T&gt;&gt; <span class="function">T <span class="title">f</span><span class="params">(T arg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arg.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        A a=f(<span class="keyword">new</span> A());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="参数协变"><a href="#参数协变" class="headerlink" title="参数协变"></a>参数协变</h3><p>自限定类型的价值是它可以产生协变参数类型——方法参数类型会随着子类而变化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">OrdinaryGetter</span></span>&#123;</span><br><span class="line">    <span class="function">Base <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">DerivedGetter</span> <span class="keyword">extends</span> <span class="title">OrdinaryGetter</span></span>&#123;</span><br><span class="line">    <span class="function">Derived <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CovariantReturnType</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(DerivedGetter d)</span></span>&#123;</span><br><span class="line">        Derived d2=d.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>DerivedGetter中的get()方法覆盖了OrderinaryGetter中的get()方法，并返回一个从OrderinaryGetter.get()返回类型中导出的类型，尽管这是很合理的，导出类方法应该能够返回比它覆盖的基类方法更具体的类型，但是这在java之前的版本中是不合法的<br>自限定泛型实际上将产生确切的导出类型作为其返回值，就像在get()中看到的那样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GenericGetter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">GenericGetter</span>&lt;<span class="title">T</span>&gt;&gt;</span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Getter</span> <span class="keyword">extends</span> <span class="title">GenericGetter</span>&lt;<span class="title">Getter</span>&gt;</span>&#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsAndGetter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(Getter g)</span></span>&#123;</span><br><span class="line">        Getter result=g.get();</span><br><span class="line">        GenericGetter gg=g.get();<span class="comment">//also the base type</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在非泛代码中，参数类型不能随子类型发生变化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrdinarySetter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Base base)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"OrdinarySetter.set(Base)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedSetter</span> <span class="keyword">extends</span> <span class="title">OrdinarySetter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Derived derived)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"DerivedSetter.set(Derived)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderinaryArguments</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Base base=<span class="keyword">new</span> Base();</span><br><span class="line">        Derived derived=<span class="keyword">new</span> Derived();</span><br><span class="line">        DerivedSetter ds=<span class="keyword">new</span> DerivedSetter();</span><br><span class="line">        ds.set(derived);</span><br><span class="line">        ds.set(base);<span class="comment">//这是重载，不是覆盖，overloade，not overridden</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">DerivedSetter.set(Derived)</span></span><br><span class="line"><span class="comment">OrdinarySetter,set(Base)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
<p>set(Derived)和set(Base)都是合法的，因此DerivdeSetter.set(Derived)方法没有覆盖OrdinarySetter.set(Base)方法，而是重载了它，基类版本的代码依然是可用的<br>但是，在使用自限定类型时，在导出类中只有一个方法，并且这个方法接受导出类而不是基类型为参数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SelfBoundSetter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SelfBoundSetter</span>&lt;<span class="title">T</span>&gt;&gt;</span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">set</span><span class="params">(T arg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Setter</span> <span class="keyword">extends</span> <span class="title">SelfBoundSetter</span>&lt;<span class="title">Setter</span>&gt;</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelfBoundingAndConvariantArguments</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testA</span><span class="params">(Setter s1,Setter s2,SelfBoundSetter sb3)</span></span>&#123;</span><br><span class="line">        s1.set(s2);</span><br><span class="line">        <span class="comment">//s1.set(sb3);  set(Setter) in SelfBoundSetter&lt;Setter&gt;</span></span><br><span class="line">        <span class="comment">//cannot be applied to SelfBoundSetter</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>上面这个例子可以看出，编译器不能识别将基类当作参数传递给setter()的尝试，因为没有任何方法具有这样的签名</strong><br>如果不使用自限定类型，普通的继承机制就会介入，而你将能够重载，就像在非泛型的情况下一样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericSetter</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(T arg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"GenericSetter.set(Base)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedGs</span> <span class="keyword">extends</span> <span class="title">GenericSetter</span>&lt;<span class="title">Base</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Derived derived)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"DerivedGs.set(Derived)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlainGenericInheritance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Base base=<span class="keyword">new</span> Base();</span><br><span class="line">        Derived derived=<span class="keyword">new</span> Derived();</span><br><span class="line">        DerivedGs derivedGs=<span class="keyword">new</span> DerivedGs();</span><br><span class="line">        derivedGs.set(base);</span><br><span class="line">        derivedGs.set(derived);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">GenericSetter.set(Base)</span></span><br><span class="line"><span class="comment">DerivedGs.set(Derived)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
<h2 id="动态类型安全"><a href="#动态类型安全" class="headerlink" title="动态类型安全"></a>动态类型安全</h2><p>因为可以向java SE5之前的代码传递容器，所以旧式代码仍旧有可能破坏你的容器（这句话的意思，向你的容器插入不正确的类型）,java SE5的java.util.Collections中有一组便利的工具，可以解决在这种情况下的类型检查问题，它们是，静态方法checkedCollection(),checkedList(),checkedMap(),checkedSet(),checkedSortedMap()和checkedSortedSet(),这些方法每一个都将会希望动态检查的容器作为第一第一个参数接受，并将你希望强制要求的类型作为第二个参数接受<br>受检查的容器，在你试图插入类型不正确的对象时抛出ClassCastException，这与泛型之前的（原生）容器形成对比，对于后者来说，当你将对象从容器中取出的时候，才会通知你出现了问题，而且你也不知道问题是什么时候造成的，受检查的容器与其不同，当向这个容器插入不良对象的时候我们就立刻知道问题发生了<br>用受检查的容器来看看“将猫插入狗列表中”这个问题，这里oldStyleMethod代表遗留代码，因为它接受原生容器List，而@SuppressWarnings注解对这些遗留代码是必需的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pet</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span>  <span class="title">Pet</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span>  <span class="title">Pet</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckedList</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">oldStyleMethod</span><span class="params">(List probablyDogs)</span></span>&#123;</span><br><span class="line">        probablyDogs.add(<span class="keyword">new</span> Cat());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;Dog&gt; dogs1=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        oldStyleMethod(dogs1);<span class="comment">//Quietyly accepts a Cat//不会抛出异常 也不会警告，因为遗留代码使用了原生类型作为参数</span></span><br><span class="line">        List&lt;Dog&gt; dogs2= Collections.checkedList(<span class="keyword">new</span> ArrayList&lt;Dog&gt;(),Dog.class);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oldStyleMethod(dogs2);<span class="comment">//抛出异常</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//derived Type work fine</span></span><br><span class="line">        List&lt;Pet&gt;  pets=Collections.checkedList(<span class="keyword">new</span> ArrayList&lt;Pet&gt;(),Pet.class);</span><br><span class="line">        pets.add(<span class="keyword">new</span> Dog());</span><br><span class="line">        pets.add(<span class="keyword">new</span> Cat());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行这个程序，会发现向dog1插入Cat没有任何问题，如果问题出现也只会在以后从容器中取出时才会发现，因为遗留代码使用了原生类型而不是泛型类型，向dog2插入一个Cat会立马抛出异常</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>由于擦除的影响，将泛型应用于异常是非常受限的。catch语句不能捕获泛型类型的异常，因为在编译期和运行期都必须知道异常的确切类型，泛型类也不呢个直接或间接继承自Throwable(这将进一步阻止你去定义一个不能捕获的泛型异常)<br>但是，类型参数可能会在一个方法的throws子句中用到，这使得你可以编写随检查型异常的类型而发生变化的泛型代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Processor</span>&lt;<span class="title">T</span>,<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Exception</span>&gt;</span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;T&gt; resultCollector)</span><span class="keyword">throws</span> E</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProcessRuuner</span>&lt;<span class="title">T</span>,<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Exception</span>&gt; <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">Processor</span>&lt;<span class="title">T</span>,<span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">processAll</span><span class="params">()</span><span class="keyword">throws</span> E</span>&#123;</span><br><span class="line">        List&lt;T&gt; resultCollector=<span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Processor&lt;T,E&gt; p:<span class="keyword">this</span>)&#123;</span><br><span class="line">            p.process(resultCollector); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  resultCollector;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Failure1</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Processor1</span> <span class="keyword">implements</span> <span class="title">Processor</span>&lt;<span class="title">String</span>,<span class="title">Failure1</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;String&gt; resultCollector)</span> <span class="keyword">throws</span> Failure1 </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count--&gt;<span class="number">1</span>)</span><br><span class="line">            resultCollector.add(<span class="string">"hep!"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            resultCollector.add(<span class="string">"Ho!"</span>);</span><br><span class="line">        <span class="keyword">if</span>(count&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Failure1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Failuer2</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Processor2</span> <span class="keyword">implements</span>  <span class="title">Processor</span>&lt;<span class="title">Integer</span>,<span class="title">Failuer2</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;Integer&gt; resultCollector)</span> <span class="keyword">throws</span> Failuer2 </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count-- == <span class="number">0</span>)</span><br><span class="line">            resultCollector.add(<span class="number">11</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            resultCollector.add(<span class="number">47</span>);</span><br><span class="line">        <span class="keyword">if</span>(count&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Failuer2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowGenericException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ProcessRuuner&lt;String,Failure1&gt; runner1=<span class="keyword">new</span> ProcessRuuner&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            runner1.add(<span class="keyword">new</span> Processor1());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(runner1.processAll());</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Failure1 e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ProcessRuuner&lt;Integer,Failuer2&gt; runner2 = <span class="keyword">new</span> ProcessRuuner&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            runner2.add(<span class="keyword">new</span> Processor2());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(runner2.processAll());</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Failuer2 e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码是很简单的，虽然看起来很长，说明了异常也可以参数化</p>
<h2 id="混型"><a href="#混型" class="headerlink" title="混型"></a>混型</h2><p>混型（混合的类型，使得这个类型可以混合多个类的能力）随着时间的推移好像拥有无数的含义，<strong>但是其最基本的概念是混合多个类型的能力，以产生一个可以表示混型中所有类型的类</strong>，这往往是你最后的手段，它使得组装多个类型变得简单易行</p>
<h3 id="C-中的混型"><a href="#C-中的混型" class="headerlink" title="C++中的混型"></a>C++中的混型</h3><p>代码不写了，C++中，使用多重继承的最大理由，就是为了使用混型，但是对于混型来说，更有趣，更优雅的方式是使用参数化类型，因为混型就是继承子其类型参数的类，在C++中，可以很容易的创建混型，因为C++能够记住模版参数的类型</p>
<h3 id="与接口混合"><a href="#与接口混合" class="headerlink" title="与接口混合"></a>与接口混合</h3><p>在java中，最常见的解决方案就是使用接口来产生混型的效果,类似这样的吧<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">C</span></span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span></span>;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">C</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mix</span> <span class="keyword">extends</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">B</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="使用装饰器模式"><a href="#使用装饰器模式" class="headerlink" title="使用装饰器模式"></a>使用装饰器模式</h3><p>当你观察混型的使用方式时，你会发现混型概念好像与装饰器模式关系很近，装饰器常用于满足各种可能的组合，而直接子类化会产生过多的类，因此是不实际的<br><strong>装饰器模式使用了分层对象来动态透明地向单个对象添加责任，装饰器是指包装在最初的对象周围的所有对象都具有的基本接口</strong>，某些事物是可装饰的，可以通过是其他类包装在这个可装饰对象的四周，来将功能分层，这使得对装饰器的使用是透明的——无论对象是否被装饰，你都拥有一个可以向对象发送的公共接口集，装饰器也可以添加新的方法，但是正如你所见的，这将是受限的<br><strong>装饰器是使用组合和形式化结构（可装饰物/装饰器层次结构）来实现的</strong>，而混型是基于继承的，因此可以将基于参数化类型的混型当作是一种泛型装饰器机制，这种机制不需要装饰器设计模式的继承结构<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Processor</span>&lt;<span class="title">T</span>,<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Exception</span>&gt;</span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;T&gt; resultCollector)</span><span class="keyword">throws</span> E</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProcessRuuner</span>&lt;<span class="title">T</span>,<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Exception</span>&gt; <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">Processor</span>&lt;<span class="title">T</span>,<span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">processAll</span><span class="params">()</span><span class="keyword">throws</span> E</span>&#123;</span><br><span class="line">        List&lt;T&gt; resultCollector=<span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Processor&lt;T,E&gt; p:<span class="keyword">this</span>)&#123;</span><br><span class="line">            p.process(resultCollector); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  resultCollector;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Failure1</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Processor1</span> <span class="keyword">implements</span> <span class="title">Processor</span>&lt;<span class="title">String</span>,<span class="title">Failure1</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;String&gt; resultCollector)</span> <span class="keyword">throws</span> Failure1 </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count--&gt;<span class="number">1</span>)</span><br><span class="line">            resultCollector.add(<span class="string">"hep!"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            resultCollector.add(<span class="string">"Ho!"</span>);</span><br><span class="line">        <span class="keyword">if</span>(count&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Failure1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Failuer2</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Processor2</span> <span class="keyword">implements</span>  <span class="title">Processor</span>&lt;<span class="title">Integer</span>,<span class="title">Failuer2</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;Integer&gt; resultCollector)</span> <span class="keyword">throws</span> Failuer2 </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count-- == <span class="number">0</span>)</span><br><span class="line">            resultCollector.add(<span class="number">11</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            resultCollector.add(<span class="number">47</span>);</span><br><span class="line">        <span class="keyword">if</span>(count&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Failuer2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowGenericException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ProcessRuuner&lt;String,Failure1&gt; runner1=<span class="keyword">new</span> ProcessRuuner&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            runner1.add(<span class="keyword">new</span> Processor1());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(runner1.processAll());</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Failure1 e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ProcessRuuner&lt;Integer,Failuer2&gt; runner2 = <span class="keyword">new</span> ProcessRuuner&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            runner2.add(<span class="keyword">new</span> Processor2());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(runner2.processAll());</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Failuer2 e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>产生自泛型的类包含所有感兴趣的方法，<strong>但是由使用装饰器所产生的对象类型是最后被装饰的类型，也就是说，尽管可以添加多个层，但是最后一层才是实际的类型，因此只有最后一层的方法时可视的</strong>，而混型的类型是所有被混合到一起的类型，因此对于装饰器来说，其明显的缺陷就是它只能有效地工作于装饰器中的一层（最后一层），而混型方法显然会更自然一些，因此，装饰器只是对由混型提出的问题的一种局限的解决方案</p>
<h3 id="与动态代理混合"><a href="#与动态代理混合" class="headerlink" title="与动态代理混合"></a>与动态代理混合</h3><p><strong>可以使用动态代理来创建一种比装饰器更贴近混型模型的机制，通过使用动态代理，所产生的类的动态类型将会是已经混入的组合类型</strong><br>由于动态代理的限制，每个被混入的类都必须是某个接口的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MixinProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">    Map&lt;String,Object&gt; delegatesByMethod;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mixin</span><span class="params">(TwoTuple&lt;Object,Class&lt;?&gt;&gt;... pairs)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(TwoTuple&lt;Object,Class&lt;?&gt;&gt; pair:pairs)&#123;</span><br><span class="line">          <span class="keyword">for</span>(Method method:pair.second.getMethods())&#123;</span><br><span class="line">              String methodName=method.getName();</span><br><span class="line">              <span class="comment">//the first inferface in the map</span></span><br><span class="line">              <span class="comment">//implements the method</span></span><br><span class="line">              <span class="keyword">if</span>(!delegatesByMethod.containsKey(methodName))&#123;</span><br><span class="line">                  delegatesByMethod.put(methodName,pair.first);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        String methodName=method.getName();</span><br><span class="line">        Object delegate=delegatesByMethod.get(methodName);</span><br><span class="line">        <span class="keyword">return</span> method.invoke(delegate,args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newInstance</span><span class="params">(TwoTuple... pairs)</span></span>&#123;</span><br><span class="line">        Class[] interfaces=<span class="keyword">new</span> Class[pairs.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pairs.length;i++)&#123;</span><br><span class="line">            interfaces[i]=(Class) pairs[i].second</span><br><span class="line">        &#125;</span><br><span class="line">        ClassLoader c1=pairs[<span class="number">0</span>].first.getClass().getClassLoader();</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(c1,interfaces,<span class="keyword">new</span> MixinProxy(pairs));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyMixin</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Object mixin=MixinProxy.newInstance(</span><br><span class="line">                tuple(<span class="keyword">new</span> BasicImp(),Basic.class),tuple(<span class="keyword">new</span> TimeStampedImp(),TimeStamped.class),</span><br><span class="line">                tuple(<span class="keyword">new</span> SerialNumberedImp(),SerialNumbered.class));</span><br><span class="line">        Basic b=(Basic)mixin;<span class="comment">//重点在这里</span></span><br><span class="line">        TimeStamped t=(TimeStamped)mixin;</span><br><span class="line">        SerialNumbered s=(SerialNumbered)mixin;</span><br><span class="line">        b.set(<span class="string">"Hello"</span>);</span><br><span class="line">        b.get();</span><br><span class="line">        t.getStamp();<span class="comment">//重点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为只有动态类型而不是静态类型才包含所有的混入类型，因此这种方式依然不如C++的方式好，因为可以在具有这些类型的对象上调用方法之前，你必须被强制要求向下转型到恰当的类型，但是，它明显更接近于真正的混型</p>
<h2 id="潜在类型机制"><a href="#潜在类型机制" class="headerlink" title="潜在类型机制"></a>潜在类型机制</h2><p>泛型的理想就是能够编写尽可能泛化代码，为了实现这一点，我们需要各种途径来放松带我们代码将要作用的类型所做的限制，同时不丢失静态类型检查的好处，然后，我们就可以编写出无需修改就可以应用于更多情况的代码，即更加“泛化”的代码<br>java泛型看起来是向这一方向迈进了一步，但你编写或使用只是持有对象的泛型时，这些代码可以引用于任何类型，后者，换个角度，“持有器”泛型能够声明：“我不关心你是什么类型”，如果代码不关心它将要作用的类型，那么这种代码就可以真正地被用在任何地方，并因此而相当地泛化<br>还是正如你所看到的那样，<strong>当要在泛型类型上执行操作（即调用Object方法之外的操作）时，就会产生问题，因为擦除要求指定可能会用到的泛型参数的边界，以安全地调用代码中的泛型对象上的具体方法，这是对“泛化”概念 的一种很明显地限制，因为限制了你的泛型类型，使它们继承自特定的类，或者实现特定的接口，在某些情况下，你最终可能会使用普通类或普通接口，因为限定边界的泛型可能会和指定类和接口没有任何区别</strong><br>某些编程语言提供了一种解决方案称为潜在类型机制或结构化参数机制，而更古怪的术语称为“鸭子类型机制”，鸭子理论非常有名，如果“它走起来像鸭子，叫起来像鸭子，那你你就可以将它当作鸭子看待”<br>泛型代码典型地将在泛型类型上调用少量的代码，而且潜在类型机制的语言只要求实现某个方法的子集，而不是某个特定的接口，从而方式了这种限制（并且产生了更加泛化的代码），正由于此，<strong>潜在类型机制使得你可以横跨多个类继承结构，调用不属于某个公共接口的方法，因此，实际上一段代码可以声明：“我不关心你是什么类型，只要你可以speck()和sit()即可</strong>”由于不要求具体类型，因此代码更加泛化<br>潜在类型机制是一种代码组织和复用机制，有了它编写出的代码相对没有它编写出的代码，能够更容易复用，代码组织和复用是所有计算机编程的基本手段，编写一次，多次使用，并在一个位置上保存代码，因为我并未被要求去命名我的代码要操作于其上的确切接口<br><strong>两种支持潜在类型机制的语言实例是Python和C++，Python是动态类型语言（实际上所有的类型检查都发生在运行时），而C++是静态类型语言（类型检查发生在编译期），因此潜在类型机制不要求静态类型还是动态类型检查</strong><br>我们下Python和C++的代码吧，即使你没有学过这两门语言，你也能理解下面代码的概念</p>
<h2 id="对缺乏潜在类型安全机制的补偿"><a href="#对缺乏潜在类型安全机制的补偿" class="headerlink" title="对缺乏潜在类型安全机制的补偿"></a>对缺乏潜在类型安全机制的补偿</h2><p>尽管java不支持潜在类型机制，但是这并不意味着有界泛型代码不能在不同的类型层次结构之间应用，也就是说，我们仍旧可以创建真正的泛型代码，但是这需要付出一些额外的努力</p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>下面的profrom就是用了潜在类型机制<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mime</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walkAgainstTheWind</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span></span>&#123;System.out.println(<span class="string">"pretending to sit"</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushInvisibleWalls</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">"Mime"</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartDog</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;System.out.println(<span class="string">"Woof"</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span></span>&#123;System.out.println(<span class="string">"Sitting"</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reproduct</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommunicateReflectively</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">perform</span><span class="params">(Object specker)</span></span>&#123;</span><br><span class="line">        Class&lt;?&gt; spkr=specker.getClass();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Method m = spkr.getMethod(<span class="string">"speak"</span>);</span><br><span class="line">                m.invoke(specker);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                System.out.println(specker + <span class="string">" cannot speak"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Method m = spkr.getMethod(<span class="string">"sit"</span>);</span><br><span class="line">                m.invoke(specker);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                System.out.println(specker + <span class="string">"cannot sit"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(specker.toString(),e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LatentReflection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        CommunicateReflectively.perform(<span class="keyword">new</span> Mime());</span><br><span class="line">        CommunicateReflectively.perform(<span class="keyword">new</span> SmartDog());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的例子，类完全啊彼此分离的，没有任何公共基类（除了Object）或接口,通过反射，CommunicateReflectively.perform()能够动态地确定所需要的方法是否可用并调用它们，它甚至能够处理Mime只具有一个必须的方法这一事实，并能够部分实现其目标</p>
<h3 id="将一个方法应用于序列"><a href="#将一个方法应用于序列" class="headerlink" title="将一个方法应用于序列"></a>将一个方法应用于序列</h3><p><strong>反射提供了一些有趣的可能性，但是它将所有的类型检查都转移到了运行时，因此在许多情况下并不是我们所希望的，如果能够实现编译器类型检查，这通常更符合要求</strong>，但是有可能实现编译器类型检查和潜在类型机制吗？<br>我们看一个说明这个问题的示例，假设想要创建一个apply()方法，它能够将任何方法应用于谋而序列的所有对象，这是接口看起来并不适合的情况，因为你想要将任何方法应用到一个对象集合，而接口对于描述“任何方法”存在过多的限制，任何用java来实现这个需求呢？<br>最初，我们可以用反射来解决这个问题，由于有JavaSE5的可变参数，这种方法被证明是优雅的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apply</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T ,S extends Iterable&lt;? extends T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(S seq, Method f, Object... args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (T t : seq) &#123;</span><br><span class="line">                f.invoke(t, args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">()</span></span>&#123;System.out.println(<span class="keyword">this</span>+<span class="string">"rotate"</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reSize</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;System.out.println(<span class="keyword">this</span>+<span class="string">"resize"</span>+size);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilledList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">FilledList</span><span class="params">(Class&lt;? extends T&gt; type,<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">              add(type.newInstance());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplyTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        List&lt;Shape&gt;  shapes=<span class="keyword">new</span> FilledList&lt;&gt;(Shape.class,<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            shapes.add(<span class="keyword">new</span> Shape());</span><br><span class="line">        &#125;</span><br><span class="line">        Apply.apply(shapes, Shape.class.getMethod(<span class="string">"rotate()"</span>));</span><br><span class="line">        Apply.apply(shapes,Shape.class.getMethod(<span class="string">"reSize"</span>, <span class="keyword">int</span>.class),<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Square&gt; squares=<span class="keyword">new</span> FilledList&lt;&gt;(Square.class,<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            squares.add(<span class="keyword">new</span> Square());</span><br><span class="line">        &#125;</span><br><span class="line">        Apply.apply(squares,Square.class.getMethod(<span class="string">"retate"</span>));</span><br><span class="line">        Apply.apply(squares,Square.class.getMethod(<span class="string">"reSize"</span>, <span class="keyword">int</span>.class),<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        Apply.apply(<span class="keyword">new</span> FilledList&lt;Shape&gt;(Shape.class,<span class="number">10</span>),Shape.class.getMethod(<span class="string">"retate"</span>));</span><br><span class="line">        Apply.apply(<span class="keyword">new</span> FilledList&lt;Shape&gt;(Square.class,<span class="number">10</span>),Square.class.getMethod(<span class="string">"retate"</span>));</span><br><span class="line">        SimpleQueue&lt;Shape&gt; shapeQ=<span class="keyword">new</span> SimpleQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            shapeQ.add(<span class="keyword">new</span> Shape());</span><br><span class="line">            shapeQ.add(<span class="keyword">new</span> Square());</span><br><span class="line">        &#125;</span><br><span class="line">        Apply.apply(shapeQ,Shape.class.getMethod(<span class="string">"retate"</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们运气很好，因为碰巧在Java中内建了一个由Java容器类库使用的Iterable接口，因此，apply()方法可以接受任何实现了Iterable接口的事物，实际上，它还接受其他任何事物，只要能够使得这些事物是Iterable的就可以了<br>注意，我们必须要使用边界和通配符，以便是Apply和FilledList在所需要的情况下都可以使用，<br><strong>FilledList表示有些进退两难的情况，为了使用某种类型，它必须要有默认的构造器，但是java没有任何方式可以在编译器断言这件事，因此变成了一个运行时问题，确保编译器检查的有个常见的建议是定义一个工厂接口</strong>，它有一个可以生产对象的方法，然后FilledList接受这个接口而不是这个类型标记的“原生工厂（Class对象）”，<strong>但是，大部分的类都是在不了解你的接口的情况下创建的，因此也就没有实现这个接口</strong>，稍后，我们展示一种使用适配器的解决办法<br>使用类型标记是一种合理的折中，错误在运行时报告，所有你要有把握，这些错误将在开发过程的早期出现<br>注意，使用类型标记是java文献推荐的技术，但是也有很多人强烈推荐使用工厂方法让错误在编译器就被发现<br>尽管java解决方案被证明很优雅，但是我们必须知道使用反射（尽管反射在最近的版本中以及明显的改善）可能比非反射的实现要慢一些，因为大多数动作都是在运行时发生的，但是这不应该成为你使用这个解决方案的脚本，至少可以将其作为一种马上就能想到的解决方案  </p>
<h3 id="当你并未碰巧拥有正确的接口时"><a href="#当你并未碰巧拥有正确的接口时" class="headerlink" title="当你并未碰巧拥有正确的接口时"></a>当你并未碰巧拥有正确的接口时</h3><p>我们看到上面的例子，Iterable接口是内建，我们很容易创建容器并使用它，但是如果不存在刚好适合你的需求的接口呢？<br>看下面一个例子，让我们泛化FilledList中的思想，创建一个参数化的方法fill(),它接受一个序列<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fill</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(Collection&lt;T&gt; collection, Class&lt;? extends T&gt; type, <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                collection.add(type.newInstance());</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Contract</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id =counter++;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getSimpleName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TitleTransfer</span> <span class="keyword">extends</span> <span class="title">Contract</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FillTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       List&lt;Contract&gt; contracts=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       Fill.fill(contracts,Contract.class,<span class="number">3</span>);</span><br><span class="line">       Fill.fill(contracts,TitleTransfer.class,<span class="number">2</span>);</span><br><span class="line">       <span class="keyword">for</span>(Contract c:contracts)&#123;</span><br><span class="line">           System.out.println(c);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//don't work fill()is not generic enough;</span></span><br><span class="line">       <span class="comment">//SimpleQueue&lt;Contract&gt; simpleQueue=new SimpleQueue&lt;&gt;();</span></span><br><span class="line">       <span class="comment">//Fill.fill(simpleQueue,Contract.class,3);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们使用java编写代码时，会陷入问题之中，因为没有任何像前面实例的Iterable接口那样的“Addable”便利接口，因此你不能说：“可以在任何事物上调用add()”,而必须说：“可以在Collection的子类型上调用add()”,这样产生的代码就不是特别泛化，因为它必须被限制为只能工作于Collection的实现，如果我试图使用没有实现Collection的类，那么我的泛化代码将不能工作<br>上面的情况中，因为java设计着（可以理解地）没有预见对“Addable()”接口的需要，所有我们被现在在Collection的继承层次结构之内，即便SimpleQueue有个add()方法，它也不能工作，因此这样的代码不是特别泛化，有了潜在类型机制，情况就会不同了</p>
<h3 id="用适配器仿真潜在类型机制"><a href="#用适配器仿真潜在类型机制" class="headerlink" title="用适配器仿真潜在类型机制"></a>用适配器仿真潜在类型机制</h3><p>java泛型并不是没有潜在类型机制，而我们需要使用潜在类型机制这样的东西去编写能够跨类边界应用的代码（也就是“泛化”代码），存在某种方式可以绕过这项限制吗？<br>潜在类型机制将在这里实现什么？它意味着你可以编写代码声明：“我不关心我在这里使用的类型，只要它们具有这些方法即可”，<strong>实际上，潜在类型机制创建了一个包含所需方法的隐式接口</strong>，因此它遵循这样的规则，如果我们手工编写了所需的接口（因为java并没有为我们做这些事），那么它就应该能够解决问题<br><strong>从我们拥有的接口中编写代码来产生我们需要的接口，这就是适配器设计模式的一个典型示例</strong>，我们可以使用适配器来适配已有的接口，以产生想要的接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Addable</span>&lt;<span class="title">T</span>&gt;</span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(T item)</span></span>;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fill2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(Addable&lt;T&gt; addable,Class&lt;? extends T&gt; type,<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                addable.add(type.newInstance());</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载的fill()的类型参数Generator&lt;T&gt; 确保了编译期的类型安全，所以将错误阻止在编译期，在运行时不会抛出</span></span><br><span class="line">    <span class="comment">//任何错误，这种方式比使用类型标记更安全</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(Addable&lt;T&gt; addable,Generator&lt;T&gt; generator,<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            addable.add(generator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//to adapter a base Type,you must use composition</span></span><br><span class="line"><span class="comment">//make any Collection Addable using composition</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddableCollectionAdapter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Addable</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Collection&lt;T&gt; c;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AddableCollectionAdapter</span><span class="params">(Collection&lt;T&gt; c)</span></span>&#123; c=c;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T item)</span></span>&#123; c.add(item); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//a Helper to capture the type automatically</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Addable&lt;T&gt; <span class="title">collectionAdapetr</span><span class="params">(Collection&lt;T&gt; c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AddableCollectionAdapter&lt;T&gt;(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//to adapt a specific type,you can use inheritance</span></span><br><span class="line"><span class="comment">//make a SimpleQueue Addable using inheritance</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddableSimpleQueue</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">SimpleQueue</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Addable</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T item)</span></span>&#123; <span class="keyword">super</span>.add(item);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fill2Test</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       List&lt;Coffee&gt; coffees=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       Fill2.fill(<span class="keyword">new</span> AddableCollectionAdapter&lt;&gt;(coffees),Coffee.class,<span class="number">3</span>);</span><br><span class="line">       Fill2.fill(Adapter.collectionAdapetr(coffees),Coffee.class,<span class="number">3</span>);</span><br><span class="line">       Fill2.fill(Adapter.collectionAdapetr(coffees),Latte.class,<span class="number">3</span>);</span><br><span class="line">       <span class="keyword">for</span>(Coffee coffee:coffees)&#123;</span><br><span class="line">           System.out.println(coffee);</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(<span class="string">"-------------------------------------------------------"</span>);</span><br><span class="line">       AddableSimpleQueue&lt;Coffee&gt; coffeeQueue=<span class="keyword">new</span> AddableSimpleQueue&lt;&gt;();</span><br><span class="line">       Fill2.fill(coffeeQueue,Coffee.class,<span class="number">3</span>);</span><br><span class="line">       Fill2.fill(coffeeQueue,Latte.class,<span class="number">3</span>);</span><br><span class="line">       <span class="keyword">for</span>(Coffee coffee:coffeeQueue)&#123;</span><br><span class="line">           System.out.println(coffee);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Fill2对Collection的要求与Fill不同，它只需要实现了Addable的对象，而Addable已经为Fill编写了——它是我希望编译器帮我创建的潜在类型的一种体现<br>在这个版本中，我还<strong>添加了一个重载的fill,它接受一个Generateor而不是类型标记，Generator在编译器是类型安全的，编译器将确保传递的是正确的Generator,因此不会抛出任何异常</strong><br>第一个适配器，AddableCollectionAdapter，可以工作与基类Collection，这意味着Collection的任何实现都可以使用，这个版本直接存储Collection引用，并使用它来实现Add();<br>如果一个具体类型而不是继承结构的基类，那么当使用继承来创建适配器时，你可以稍微少写一些代码，但是这个适配器只适用于为特定的类型适配所需的接口，这种适配器称为“预适配器”，也就是预先定义好的适配器，之间创建使用即可，而第一种适配器需要传递需要适配的接口才能创建，这就是两种适配器设计模式的不同</p>
<h2 id="将函数对象作为策略"><a href="#将函数对象作为策略" class="headerlink" title="将函数对象作为策略"></a>将函数对象作为策略</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Combiner</span>&lt;<span class="title">T</span>&gt;</span>&#123; <span class="function">T <span class="title">combine</span><span class="params">(T x, T y)</span></span>;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UnaryFunction</span>&lt;<span class="title">R</span>,<span class="title">T</span>&gt;</span>&#123; <span class="function">R <span class="title">function</span><span class="params">(T x)</span></span>;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Collector</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">UnaryFunction</span>&lt;<span class="title">T</span>,<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">result</span><span class="params">()</span></span>;<span class="comment">//extract result of collecting parameter</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UnaryPredicate</span>&lt;<span class="title">T</span>&gt;</span>&#123; <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T x)</span></span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Functional</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">reduce</span><span class="params">(Iterable&lt;T&gt; seq,Combiner&lt;T&gt; combiner)</span></span>&#123;</span><br><span class="line">        Iterator&lt;T&gt; it=seq.iterator();</span><br><span class="line">        <span class="keyword">if</span>(it.hasNext())&#123;</span><br><span class="line">            T result=it.next();</span><br><span class="line">            <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">                result=combiner.combine(result,it.next());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Collector&lt;T&gt; <span class="title">forEach</span><span class="params">(Iterable&lt;T&gt; seq,Collector&lt;T&gt; func)</span></span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(T item:seq)&#123;</span><br><span class="line">           func.function(item);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> func;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;R,T&gt; <span class="function">List&lt;R&gt; <span class="title">transform</span><span class="params">(Iterable&lt;T&gt; seq,UnaryFunction&lt;R,T&gt; func)</span></span>&#123;</span><br><span class="line">        List&lt;R&gt; result=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(T t:seq)&#123;</span><br><span class="line">            result.add(func.function(t));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">filter</span><span class="params">(Iterable&lt;T&gt; seq, UnaryPredicate&lt;T&gt; pred)</span></span>&#123;</span><br><span class="line">        List&lt;T&gt; result =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(T t:seq)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pred.test(t))&#123;</span><br><span class="line">                result.add(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerAdder</span> <span class="keyword">implements</span> <span class="title">Combiner</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">combine</span><span class="params">(Integer a,Integer b)</span></span>&#123;<span class="keyword">return</span> a + b;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerSubtracter</span> <span class="keyword">implements</span>  <span class="title">Combiner</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">combine</span><span class="params">(Integer a, Integer b)</span></span>&#123;<span class="keyword">return</span> a-b;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BigDecimalAdder</span> <span class="keyword">implements</span> <span class="title">Combiner</span>&lt;<span class="title">BigDecimal</span>&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> BigDecimal <span class="title">combine</span><span class="params">(BigDecimal x,BigDecimal y)</span></span>&#123;<span class="keyword">return</span> x.add(y);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BigIntegerAdder</span> <span class="keyword">implements</span> <span class="title">Combiner</span>&lt;<span class="title">BigInteger</span>&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> BigInteger <span class="title">combine</span><span class="params">(BigInteger x,BigInteger y)</span></span>&#123;<span class="keyword">return</span> x.add(y);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">GreaterThan</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; <span class="keyword">implements</span> <span class="title">UnaryPredicate</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> T bound;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">GreaterThan</span><span class="params">(T bound)</span></span>&#123; bound=bound;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T item)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> item.compareTo(bound)&gt;<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiplyingInteger</span> <span class="keyword">implements</span> <span class="title">Collector</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer val=<span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">function</span><span class="params">(Integer x)</span></span>&#123;</span><br><span class="line">            val*=x;</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">result</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; l1= Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>);</span><br><span class="line">       </span><br><span class="line">        Integer addResult=reduce(l1,<span class="keyword">new</span> IntegerAdder());</span><br><span class="line">        Integer substractResult=reduce(l1,<span class="keyword">new</span> IntegerSubtracter());</span><br><span class="line">        List&lt;Integer&gt; listResult=filter(l1,<span class="keyword">new</span> GreaterThan&lt;Integer&gt;(<span class="number">4</span>));</span><br><span class="line">        forEach(l1,<span class="keyword">new</span> MultiplyingInteger()).result();</span><br><span class="line">        <span class="comment">//省略不写</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>策略模式可以产生非常优雅得的代码，因为它将“变化的事物”完全隔离到一个函数对象<strong>，函数对象就是在某种程度上行为像函数的对象——一般地，会有一个相关的方法，函数对象的价值就在于，与普通的方法不同，它们可以传递出去，并且还可以拥有在多个调用之间持久化的状态，当然可以用类中的任何方法来实现与此相似的工作，但是（与使用任何设计模式一样）函数对象主要是由其目的来区别的</strong>这里的，目的即使要创建某种事物，使它的行为就像一个可以传递出去的单个方法一样，这样，它就和策略模式紧耦合了，有时甚至无法区分<br>其实各种设计模式之间的界限真的很模糊，有时很难区分，有时靠设计目的区分，所以没有绝对的模式</p>
<h2 id="总结：转型真的如此之糟吗？"><a href="#总结：转型真的如此之糟吗？" class="headerlink" title="总结：转型真的如此之糟吗？"></a>总结：转型真的如此之糟吗？</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/14/泛型/" data-id="cjnzv2pti003ocorz24gut4zf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-类型信息" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/12/类型信息/" class="article-date">
  <time datetime="2018-10-12T05:21:23.000Z" itemprop="datePublished">2018-10-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习心得/">学习心得</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/12/类型信息/">类型信息</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>运行时类型信息（runtime Type information）使得你可以在程序运行时发现和使用类型信息<br>它使你从只能在编译期执行面向类型的操作的禁锢中解脱出来<br>java是如何让我们在运行时识别对象和类的信息的，主要有两种方式，一种是“传统的”RTTI，它假定我么不能在编译时已经知道了所有的类型，另一种是“反射”机制，它允许我们在运行时发现和使用类的信息  </p>
<h2 id="为什么需要RTTI"><a href="#为什么需要RTTI" class="headerlink" title="为什么需要RTTI"></a>为什么需要RTTI</h2><p>我们看一下多态的例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123; System.out.print(<span class="keyword">this</span>+<span class="string">".draw()"</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cricle</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">"Cricle"</span>;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">"Square"</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shapes</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;Shape&gt; shapeList= Arrays.asList(<span class="keyword">new</span> Cricle(),<span class="keyword">new</span> Square());</span><br><span class="line">        <span class="keyword">for</span>(Shape shape:shapeList)&#123;</span><br><span class="line">            shape.draw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，当把Shape对象放在List<shape>列表时会向上转型，但向上转型为Shape的时候，也丢失了Shape对象的具体的类型，对于列表而言，它们只是Shape类型的对象（我们这样思考一个问题，为什么我们在编程的时候，没有使用具有的引用类型，而是向上转型为更加通用的类型引用，诚然，我们可以使用更具体的类型来表示对象类型，拥有更多的方法可以操作这个类型，但是我们却没有办法写更适用的代码，每一个代码片段都与特定类型相关联，耦合度太高，我们要将类型向上转型为它的基类，这样拥有同样的接口，但是却丢失了关于这个对象具体类型的信息，<strong>注意，我们说的丢失了具体类型的信息指的是在编译期，在编译期，我们会将它的对象类型当作基类看待，实际上，对象本身的类型信息并没有丢失，我们可以在程序运行的时候重新拿到本来属于它的身份（类型信息）</strong>，这就是运行时类型信息的全部解释）<br>当从列表中取出元素时，这种容器——实际上将它所有的事物都当成Object持有——会自动将结果转型回Shape的，在java中所有的类型转换都是在运行是进行正确的检查，这也是RTTI名字的含义，在这个例子中，RTTI类型转换的并不彻底，Object被转型为Shape，而不是转换成Cricle，Square这种更具体的类型，这是因为我们只知道这个List<shape>保存的是Shape，将由容器和Java泛型机制保证这一点，而在运行时，由类型转换确保这一点</shape></shape></p>
<h2 id="Class对象"><a href="#Class对象" class="headerlink" title="Class对象"></a>Class对象</h2><p>要理解RTTI在java中的工作原理，首先必须知道类型信息在运行时是如何表示的，这项工作是被称为Class对象的特殊对象完成的，它包含了与类相关的信息， Class对象就是用来创建类的所有“常规”对象的，java使用Class对象来执行其RTTI，即使你正在执行类型转换这样的工作<br>类是程序的一部分，每个类都是一个Class对象，换言之，每当编写并且编译一个新类，就会产生一个Class对象（更恰当的说，是保存在一个同名的.class文件中，这个.class文件保存在关于这个类的一切信息，我们可以将这个.class文件看作对象，这和类加载之后在内存中创建的Class对象没有太大的分别，最大的区别也许就是存储位置的不同）为了生成这个类的对象，运行这个程序的Java虚拟机（JVM)将使用被称为“类加载器”的子系统<br>所有的类都是在第一次被使用时，动态加载到JVM中的，当程序创建第一个对类的静态成员的引用时，就会加载这个类，这额证明了构造器也是静态方法，虽然在它之前没有static关键字，因此，java程序在它开始之前并非完全加载，其各个部分都是在必需时才加载的，如果尚未加载，默认的类加载器就会根据类名查找.class文件，而这个类的字节码文件就被加载，它会接受验证，以确保其没有被破坏，并且不包含不良的Java代码<br>（从我的理解来看，程序是对象与对象之间通讯，而Class掌握着生成这些对象和怎样通讯的所有知识，我们编写程序就是编写这些类，类由虚拟机加载，并且通过虚拟机创建对象，互相在对象之间传递消息，那么虚拟机是什么？虚拟机是程序，是代码运行的平台，我们编写的类都是程序的构件，以供虚拟机使用）<br>一旦某个类的Class对象被载入内存，它就被用来创建这个类的所有对象</p>
<pre><code>Class Class.forName(String className);
</code></pre><p>上面的方法是Class类的一个静态方法，返回一个Class对象的引用，如果你有某个对象的引用，也可以使用Object的getClass()方法，得到一个Class对象的引用，对forName()的调用就是为了产生副作用，其实更准确的说，forName()方法的调用是为了加载某个类，所有，如果这个类还没有被加载，那么就加载它，在加载的过程中，类的static子句开始执行<br>记住，所有的Class对象都是Class类，这听起来感觉很奇怪，我们知道类的所有信息都是在.class文件保存着，类加载器子系统通过这些文件会在内存空间创建相应的Class对象，其实这些对象和普通的对象的共同点就是对象，只不过这个Class对象拥有着这个类型信息，而其他对象拥有着属性数据，那么这些Class对象之间肯定有着某种共性，而这种共性就是它们都是Class类型<br>我们得到了Class对象的引用，就可以操作它以获得它的数据（类型信息）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getName()</span><br><span class="line">getSimpleName()</span><br><span class="line">getCanonicalName()</span><br><span class="line">getInterfaces()</span><br><span class="line">isInterface()</span><br><span class="line">getSuperClass()</span><br><span class="line">newInstance()</span><br></pre></td></tr></table></figure></p>
<p>Class对象的newInstance()方法是实现“虚拟构造器”的一种途径，虚拟构造器允许你声明“我不知道你的确切类型”，但是啊无论如何要正确地创建你自己，<strong>比如up是一个Class引用，在编译期不具备任何更进一步的类型信息，当你创建新实例时，会得到一个Object对象</strong>，但是这个引用指向一个确切的类型，当然你可以发送Object能够接受的信息之外的任何消息之前，你必须更多的了解它，并进行某种转型，另外，使用newInstance()必须带有默认的构造器  </p>
<h3 id="类字面常量"><a href="#类字面常量" class="headerlink" title="类字面常量"></a>类字面常量</h3><p>java提供了另一种方法来生成对Class对象的引用，即使用类字面量常量 例如<br>    FancyToy.class<br>这样做不仅更简单，而且也更安全，因为它在编译时就会受到检查（因此不需要置于try语句块中），并且它根除了forName()方法的调用，所有也更高效<br>建议使用“.class”的形式，以保持与普通类的一致性<br>注意，有一点很有趣，使用“.class”来创建对Class对象的引用时，不会自动地初始化Class对象，为了使用类而做的准备工作实际上包含三个步骤</p>
<ol>
<li>加载：这是类加载器执行的，该步骤将查找字节码，并从这些字节码中创建一个Class对象</li>
<li>链接：在链接阶段将验证类中的字节码，为静态域分配存储空间，并且如果必需的话，将解析这个类对其他类的所有引用</li>
<li>初始化：如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块<br>初始化被延迟到了对静态方法（构造器隐式地是静态的）或非常数静态方法进行首次引用是才执行<br>初始化有效地实现了尽可能的“惰性”，仅使用.class语法来获得对类的引用不会引发初始化，和是和forName()不同的  <h3 id="泛化的Class引用"><a href="#泛化的Class引用" class="headerlink" title="泛化的Class引用"></a>泛化的Class引用</h3>Class引用总是指向某一个Class对象，它可以制造类的实例，并包含可作用与这些实例的所有方法代码，它还包括了该类的静态成员。因此。Class引用表示的就是指向它所指对象的确切类型，而该对象表示Class类的一个对象<br>如何将它的类型变得更具体，而<strong>这是通过允许你对Class引用所指向的Class对象的类型进行限定而实现的</strong>，这里使用了泛型语法，比如<br> Class<integer> classRef=int.class;<br>你也许会认为，下面的代码也是正确的<br> Class<number> classRef=int.class;<br>但是它是无法工作的，虽然Number是Integer的基类，但是Integer的Class对象不是Number的Class对象的子类，这个例子的正确做法是<br> Class&lt;? extends Number&gt; classRef=int.class;<br>当你使用泛型语法的时候将会发生一件有趣的事情，newInstance()将会返回该对象的确切的类型，而不是基本的Object,如下：<h3 id="新的转型语法"><a href="#新的转型语法" class="headerlink" title="新的转型语法"></a>新的转型语法</h3>Class引用的转型语法 cast()  不过我们很少使用<h2 id="类型转换前先做检查"><a href="#类型转换前先做检查" class="headerlink" title="类型转换前先做检查"></a>类型转换前先做检查</h2>目前我们已知的RTTI形式包括</number></integer></li>
<li>传统的类型转换 如“(Shape)” 由RTTI确保类型转换的正确性，如果执行了一个错误的转换，就会抛出一个ClassCastException</li>
<li>代表对象的类型的Class对象，通过查询Class对象可以获取运行时所需的信息</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/12/类型信息/" data-id="cjnzv2ps80035corzl91owmpz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-字符串" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/11/字符串/" class="article-date">
  <time datetime="2018-10-11T11:14:03.000Z" itemprop="datePublished">2018-10-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习心得/">学习心得</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/11/字符串/">字符串</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="不可变String"><a href="#不可变String" class="headerlink" title="不可变String"></a>不可变String</h2><p>&emsp;&emsp;String对象是不可变的，查看JDK文档，会发现，String类中每一个看起来会修改String值的方法，实际上都是创建了一个全新的String对象，以包含修改后的字符串内容，而最初的String对象纹丝未动，当吧String对象作为方法的参数时，都会复制一份引用，而该引用所指的对象其实一直待在单一的物理位置上，从未动过<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Immutable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">upcase</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String q=<span class="string">"howdy"</span>;</span><br><span class="line">        System.out.print(q);<span class="comment">//howdy</span></span><br><span class="line">        String qq=upcase(q);</span><br><span class="line">        System.out.print(qq);<span class="comment">//HOWDY</span></span><br><span class="line">        System.out.print(q);<span class="comment">//howdy</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;上例upcase()返回的引用已经指向了一个新的对象了，而原本的q则还在原地<br>&emsp;&emsp;String的这种行为方式其实正是我们想要的，难道我们真的希望upcase()改变参数的行为吗？参数是为该方法提供信息的，而不是先让该方法改变自己的</p>
<h2 id="重载“-”与StringBuilder"><a href="#重载“-”与StringBuilder" class="headerlink" title="重载“+”与StringBuilder"></a>重载“+”与StringBuilder</h2><p>&emsp;&emsp;String对象的不可变性带来了效率的问题，为String对象重载的“+”操作符就是一个例子，重载的意思是，一个操作符在应用于不同的类上，被赋予老特殊的含义<br>&emsp;&emsp;我们经常使用“+”操作进行字符串的拼接，可是由于String对象的不可变性，我们猜想每一次的连接操作都会产生一个新的String对象，若是进行多次的拼接操作，会有大量的中间String对象产生，会造成内存资源的浪费和垃圾回收器的负担，比如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String concatStr=<span class="string">"asdad"</span>+<span class="string">"asdas"</span>+<span class="string">"sfadfdf"</span>+<span class="string">"asdasd"</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;但是当我们使用javap，对上述代码jinx反编译的时候，就会看到，在进行字符拼接的时候，编译器帮我们做了优化，首先new StringBuilder对象，通过append()方法拼接，使用toString()返回一个字符串对象，编译器以及帮我们的源码进行了优化，那么是否我们就确信编译器优化，而毫无考虑的就到处使用“+”操作符进行字符串的拼接操作呢？我们在看一个例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(String str:StringArr[])&#123;</span><br><span class="line">    s+=str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">for</span>(String str:StringArr)&#123;</span><br><span class="line">   sb.append(str);</span><br><span class="line">&#125;</span><br><span class="line">sb.toString();</span><br></pre></td></tr></table></figure></p>
<p>我们在进行javap进行反编译，可知在上面的第一个例子，每次循环内都要创建new StringBuilder(),而第二个例子只创建一次，那么这个例子就可以说明什么时候应该使用StringBuilder来对字符串进行拼接操作了<br>StringBuilder提供了丰富而全面的方法，包括insert(),replace(),subString()甚至reverse(),但是最常用的还是append()a,toString()，还有delete()<br>Stringbuilder是Java SE5引入的，在这之前java用的是StringBuffer,后者是线程安全的，因此开销也会大些  </p>
<h2 id="无意识的递归"><a href="#无意识的递归" class="headerlink" title="无意识的递归"></a>无意识的递归</h2><p>我们一般经常都会调用一个对象的toString()方法，比如容器的打印，实际上也会调用每个元素的toString()方法，若我们想要打印对象的内存地址怎么办呢？下面是一个对象，重新定义了toString()方法，并且打印自己的内存地址<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InfiniteRecursion</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"asdasdas"</span>+<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的定义是对的吗？完全错误，如果我们调用这个对象的toString()方法就会导致递归，因为我们对this也执行了toString()调用，没完没了，正确的方法如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="string">"asdasdas"</span>+<span class="keyword">super</span>.toString();</span><br></pre></td></tr></table></figure></p>
<p>因为这样会调用基类的toString方法，就避免了递归</p>
<h2 id="String上的操作"><a href="#String上的操作" class="headerlink" title="String上的操作"></a>String上的操作</h2><p>下面是String对象具备的一些基本操作  </p>
<table>
<thead>
<tr>
<th>方法</th>
<th>参数，重载版本</th>
<th>应用</th>
</tr>
</thead>
<tbody>
<tr>
<td>构造器</td>
<td>重载版本：默认版本，String，StringBuilder<br>StringBuffer char数组，byte数组</td>
<td>创建String对象</td>
</tr>
<tr>
<td>length()</td>
<td></td>
<td>String中字符的个数</td>
</tr>
<tr>
<td>charAt()</td>
<td>int索引</td>
<td>取得String中该索引位置上的char</td>
</tr>
<tr>
<td>getChars(),getBytes()</td>
<td>要复制部分的起点和终点的索引，<br>复制的目标数组，目标数组，目标数组的起始索引</td>
<td>复制char或byte到一个目标数组中</td>
</tr>
<tr>
<td>toCharArray()</td>
<td></td>
<td>生成一个char[]</td>
</tr>
<tr>
<td>equals(),equalsIgnoreCase()</td>
<td>与之进行比较的String</td>
<td>比较两个String的内容是否相同</td>
</tr>
<tr>
<td>compareTo()</td>
<td>与之进行比较的String</td>
<td>按词典顺序比较String的内容，比较结果为负数，零，正数，注意，大小写不等价</td>
</tr>
<tr>
<td>contains()</td>
<td>要搜索的CharSequence</td>
<td>如果该String对象包含参数的内容，则返回true</td>
</tr>
<tr>
<td>containEquals()</td>
<td>与之进行比较的CharSequence或StringBuffer</td>
<td>如果该String与参数的内容一致，则返回true</td>
</tr>
<tr>
<td>equealsIgnoreCase()</td>
<td>与之进行比较的String</td>
<td>忽略大小写的比较相等性</td>
</tr>
<tr>
<td>regionMatcher()</td>
<td>该String的索引偏移量，另一个String及其索引偏移量，<br>要比较的长度，重载版本增加了“忽略大小写”功能</td>
<td>返回boolean结果，已表明所比较区域是否相等</td>
</tr>
<tr>
<td>StartsWith()</td>
<td>可能的起始String，重载版本在参数中增加了偏移量</td>
<td>返回值为boolean值</td>
</tr>
<tr>
<td>endsWith()</td>
<td>该String可能的后缀String</td>
<td>返回boolean值</td>
</tr>
<tr>
<td>indexOf(),lastIndexOf()</td>
<td>重载版本包括：char，char与起始索引，<br>String，String与起始索引</td>
<td>如果该String并不包含此参数，就返回-1<br>否则返回此参数在String中的起始索引，lastIndexOf()是从后向前搜索</td>
</tr>
<tr>
<td>subString()(subSequence())</td>
<td>重载版本：起始索引;起始索引+终点索引</td>
<td>返回一个新的String，以包含参数指定的字符串</td>
</tr>
<tr>
<td>concat()</td>
<td>要连接的字符串</td>
<td>返回一个新的String对象，内容为原始String连接上参数String</td>
</tr>
<tr>
<td>replace()</td>
<td>要替换掉的字符，用来进行替换的新字符。<br>也可以用一个CharSequence来替换另一个CharSequence</td>
<td>返回替换字符后的新String对象<br>如果，没有替换发生，则返回原始的String对象</td>
</tr>
<tr>
<td>toLowerCase(),toUpCase()</td>
<td></td>
<td>将字符的大小写改变，返回一个新的字符串</td>
</tr>
<tr>
<td>trim()</td>
<td></td>
<td>将字符串两端的空白字符删除</td>
</tr>
<tr>
<td>valueOf()</td>
<td>重载版本：Object;char[];char[],偏移量，与字符个数；<br>boolean；char;int;lang;float;double</td>
<td>返回一个表示参数内容的String</td>
</tr>
<tr>
<td>intern()</td>
<td></td>
<td>为每个唯一的字符序列生成一个且仅生成一个String引用  </td>
</tr>
</tbody>
</table>
<h2 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h2><p>在长久的等待之后，java SE5终于推出了C语言中printf()风格的格式化输出</p>
<h3 id="System-out-format"><a href="#System-out-format" class="headerlink" title="System.out.format"></a>System.out.format</h3><p>java SE5引入的format()方法可用于PrintStream或PrintWriter对象，format()方法模仿C语言的printf()，它只需要一个简单的格式化字符串和一串的参数就可，语法如下.以System.out为例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.format(<span class="string">"Row 1:[%d %f]\n"</span>,x,y);</span><br></pre></td></tr></table></figure></p>
<h3 id="Formatter类"><a href="#Formatter类" class="headerlink" title="Formatter类"></a>Formatter类</h3><p>在java中，所有新的格式化功能都由java.util.Formatter类处理,可以将Formatter看作一个翻译机，它将你的格式化字符串与数据翻译成需要的结果，当你创建一个Formatter对象的时候，可以向其构造器传递一些信息，告诉它最终的结果将向哪里输出  </p>
<h3 id="格式化说明符"><a href="#格式化说明符" class="headerlink" title="格式化说明符"></a>格式化说明符</h3><p>在插入数据时，如果想要控制空格与对齐，你需要更精细复杂的格式修饰符，一下是其抽象的语法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[argument_index$][flags][width].[precision]conversion</span><br></pre></td></tr></table></figure></p>
<p>最常用的是width控制一个域的最小尺寸，数据是右对齐的，可以添加“-”标志来控制对其方向<br>不是所有类型的元素都能用precision，而且不同类型的元素使用precision代表的含义也不相同<br>Formatter转换（conversion）<br>下面包含了最常用的类型转换   </p>
<table>
<thead>
<tr>
<th></th>
<th>：类型转换：</th>
</tr>
</thead>
<tbody>
<tr>
<td>d</td>
<td>整数型（十进制）</td>
</tr>
<tr>
<td>c</td>
<td>unicode字符</td>
</tr>
<tr>
<td>b</td>
<td>Boolean值</td>
</tr>
<tr>
<td>s</td>
<td>String</td>
</tr>
<tr>
<td>f</td>
<td>浮点数（十进制）</td>
</tr>
<tr>
<td>e</td>
<td>浮点数（科学计数）</td>
</tr>
<tr>
<td>x</td>
<td>整数（十六进制）</td>
</tr>
<tr>
<td>h</td>
<td>散列码</td>
</tr>
<tr>
<td>%</td>
<td>字符“%”</td>
</tr>
</tbody>
</table>
<h3 id="String-format"><a href="#String-format" class="headerlink" title="String.format()"></a>String.format()</h3><p>java SE5也参考了C的sprintf()的方法，以生成格式化的String对象，String.format()是一个static方法，它接受与Formatter.format()相同的参数，但返回一个String对象，当你只使用formatter()方法一次的时候，String.format()是个不错的选择，语法 类似如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String result = String.format(<span class="string">"(t%d,q%d) %s"</span>,transcationID,queryID,message);</span><br></pre></td></tr></table></figure></p>
<p>其实在String.format()内部，它是创建一个Formatter对象，然后将你的参数传递给它，不过与其自己做这些事情，不如使用便捷的String.format()代码更清晰易读</p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式是一种强大而灵活的文本处理工具，<strong>使用正则表达式，我们能够以编程的方式，构造复杂的文本，并对输入的字符串进行搜索，一旦找到匹配这些模式的部分，你就能够随心所欲地对它们进行处理</strong>，正则表达式提供了一种完全通用的方式，能够解决各种字符串处理相关的问题，匹配，选择，编辑以及验证</p>
<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>在其他的语言中,\\表示“我想要在表达式中插入一个普通的反斜线，请不要给他任何特殊的意义，而在java中，\\的意思是”我要插入正则表达式的反斜线，”，所以其后的字符具有一个特殊的意义，你想插入一个普通的反斜线，则应该这样\\\\”<br>应用正则表达式最简单的途径，就是利用String类内建的matches()方法<br>String还有一个非常有用的正则表达式工具——split()方法，其功能是“将字符串从正则表达式匹配的地方切开”，split()还有一个重载的版本，它允许你限制字符串分割的次数<br>如果只是需要使用一次正则表达式，那么上面的方法是很方便的吗，但是如果你想对一个正则表达式反复复用，那么非String类型的正则表达式具备更加的性能和功能</p>
<h3 id="创建正则表达式"><a href="#创建正则表达式" class="headerlink" title="创建正则表达式"></a>创建正则表达式</h3><hr>
<table>
<thead>
<tr>
<th></th>
<th>字符</th>
</tr>
</thead>
<tbody>
<tr>
<td>B</td>
<td>指定字符B</td>
</tr>
<tr>
<td>\xhh</td>
<td>十六进制值为0xhh的字符</td>
</tr>
<tr>
<td>\uhhhh</td>
<td>十六进制表示为oxhhhh的Unicode字符</td>
</tr>
<tr>
<td>\n</td>
<td>换行符</td>
</tr>
<tr>
<td>\t</td>
<td>制表符</td>
</tr>
<tr>
<td>\r</td>
<td>回车</td>
</tr>
<tr>
<td>\f</td>
<td>换页</td>
</tr>
<tr>
<td>\e</td>
<td>转义（Escape）</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th></th>
<th>字符类</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>任意字符</td>
</tr>
<tr>
<td>[abc]</td>
<td>包含a,b，c的任何字符（和a</td>
<td>b</td>
<td>c作用相同）</td>
</tr>
<tr>
<td>[^abc]</td>
<td>除了a,b,c之外的任意字符（否定）</td>
</tr>
<tr>
<td>[a-zA-Z]</td>
<td>从a到或从A到Z的任何一个字符</td>
</tr>
<tr>
<td>[abc[hij]]</td>
<td>任意a,b,c,h.i,j的字符（与a</td>
<td>b</td>
<td>c</td>
<td>h</td>
<td>i</td>
<td>j的作用相同）</td>
</tr>
<tr>
<td>[a-z&amp;&amp;[hij]]</td>
<td>任意h,i,j（交集）</td>
</tr>
<tr>
<td>\s</td>
<td>空白符（空格，tab,换行，换页或回车）</td>
</tr>
<tr>
<td>\S</td>
<td>非空白符</td>
</tr>
<tr>
<td>\d</td>
<td>数字[0-9]</td>
</tr>
<tr>
<td>\D</td>
<td>非数字[^0-9]</td>
</tr>
<tr>
<td>\w</td>
<td>词字符[a-zA-Z0-9]</td>
</tr>
<tr>
<td>\w</td>
<td>非词字符[^\w]</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th></th>
<th>逻辑操作符</th>
</tr>
</thead>
<tbody>
<tr>
<td>XY</td>
<td>Y紧跟在X后面</td>
</tr>
<tr>
<td>X</td>
<td>Y</td>
<td>X或Y</td>
</tr>
<tr>
<td>(X)</td>
<td>捕获组（capturing group）可以在表达式中引用\i第一i个捕获组</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th></th>
<th>边界匹配符</th>
</tr>
</thead>
<tbody>
<tr>
<td>^</td>
<td>一行的起始</td>
</tr>
<tr>
<td>$</td>
<td>一行的结束</td>
</tr>
<tr>
<td>\b</td>
<td>非词的边界</td>
</tr>
<tr>
<td>\B</td>
<td>词的边界</td>
</tr>
<tr>
<td>\G</td>
<td>前一个匹配的结束</td>
</tr>
</tbody>
</table>
<h3 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h3><p>量词描述了一个模式吸收输入文本的方式：</p>
<ul>
<li>贪婪型：量词总是贪婪的，除非有其他的选项被设置，贪婪表达式会为所有可能的模式发现尽可能多的匹配，导致此问题的一个典型理由就是假定我们的模式仅能匹配第一个可能的字符组，如果它是贪婪的，那么它就会继续往下匹配  </li>
<li>勉强型：用问好来指定，这个量词匹配满足模式所需最少字符数，因此也称做懒惰的，最少匹配的，非贪婪的，或不贪婪的  </li>
<li>占有型：目前，这种类型的量词只有java语言中才可用，并且也更高级，当正则表达式被应用于字符串时，它会产生相当多的状态，以便在匹配失败时可以回溯，而“占有的”量词并不保存这些中间状态，因此它们可以防止回溯，它们常常用于防止正则表达式失控，因此可以使正则表达式执行起来更有效  </li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>贪婪型</th>
<th>勉强型</th>
<th>占有型</th>
<th>如何匹配</th>
</tr>
</thead>
<tbody>
<tr>
<td>X?</td>
<td>X??</td>
<td>x?+</td>
<td>一个或零个X</td>
</tr>
<tr>
<td>X*</td>
<td>X*?</td>
<td>X*+</td>
<td>零个或者多个X</td>
</tr>
<tr>
<td>X+</td>
<td>X+?</td>
<td>X++</td>
<td>一个或者多个X</td>
</tr>
<tr>
<td>X{n}</td>
<td>X{n}?</td>
<td>X{n}+</td>
<td>恰好n次</td>
</tr>
<tr>
<td>X{n,}</td>
<td>X{n,}?</td>
<td>X{n,}+</td>
<td>至少n次</td>
</tr>
<tr>
<td>X{n,m}</td>
<td>X{n,m}?</td>
<td>X{n,m}+</td>
<td>X至少n次，最多m次</td>
</tr>
</tbody>
</table>
<p>要非常注意的是表达式X必须要用圆括号括起来，以便它能按照我们期望的效果去执行，例如 abc+和（abc）+,前面的表示表示匹配ab，后面跟随1个或者多个c，而(abc)+表示匹配一个或者多个abc<br>接口CharSequence从CharBuffer,String,StringBuffer,StringBuilder类之中抽象出了字符序列的一般化定义<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CharSequenece</span></span>&#123;</span><br><span class="line">  charAt();</span><br><span class="line">  length();</span><br><span class="line">  subSequence(<span class="keyword">int</span> start,<span class="keyword">int</span> end);</span><br><span class="line">  toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此，这些类都实现了接口，多数正则表达式操作都接受CharSequence类型的参数  </p>
<h3 id="Pattern和Matcher"><a href="#Pattern和Matcher" class="headerlink" title="Pattern和Matcher"></a>Pattern和Matcher</h3><p>比起功能有限的String，我们更愿意构造功能强大的正则表达式对象，只需要导入java.util.regex包，然后用static Pattern.compile()方法来编译你的正则表达式即可，它会根据你的String类型的正则表达式生成一个Pattern对象，接下来，把你想要检索的字符串传入Pattern对象的matcher()方法会生成一个Matcher对象，它有很多功能可用，例如它的replaceAll()方法能够将所有匹配的部分替换成你传入的参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRegularExpression</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            System.out.print(<span class="string">"args's count is not right"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String arg:args)&#123;</span><br><span class="line">            Pattern p = Pattern.compile(arg);</span><br><span class="line">            Matcher m = p.matcher(<span class="string">"args[0]"</span>);</span><br><span class="line">            <span class="keyword">while</span>(m.find())&#123;</span><br><span class="line">                System.out.print(m.group()+m.start()+m.end());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Pattern变量表示编译后的正则表达式，我们可以使用编译后的Pattern对象的matcher()方法，加上一个输入字符串，从而共同构造一个Matcher对象，同时Pattern类还提供了一个静态方法<br>    static boolean matcher(String regex,CharSequence input)<br>编译后的Pattern对象还提供了split()方法，它从匹配的regex的地方分割字符串，返回分割后的字符串的一个String数组<br>通过调用Pattern.matcher()方法，我们得到一个Matcher对象，使用Matcher上的方法，我们能够判断各种不同类型的匹配是否成功<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">lookingAt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">find</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> start)</span></span></span><br></pre></td></tr></table></figure></p>
<p>其中的matches()方法用来判断这个输入字符串是否匹配正则表达式，而lonkingAt()则用来判断该字符串（不必是整个字符串）的始部分是否匹配模式<br>find()像迭代器那样向前办理输入字符串，而第二个find(int start),该参数表示字符串中的字符位置，并以其作为搜索的起点</p>
<h3 id="Group-组"><a href="#Group-组" class="headerlink" title="Group(组)"></a>Group(组)</h3><p>组是用括号划分的正则表达式，可以根据组的编号来引用某个组，组号0表示整个表达式，组号1表示被第一对括号括起来的组，依次类推<br>A(B(C))D,这里有三个组，组0是ABCD,组1是BC,组2是C<br>Matcher（匹配器）对象提供了一些列的方法，用来获取与组相关的信息<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">groupCount</span><span class="params">()</span><span class="comment">//返回该匹配器的模式中的分组数量，第0组不算</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">group</span><span class="params">()</span><span class="comment">//返回前一次操作（例如find()）的第0组</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">group</span><span class="params">(<span class="keyword">int</span> i)</span><span class="comment">//返回前一次匹配操作期间指定的组号，如果匹配成功，但是指定的组没有匹配任何输入字符串的任何部分，则会返回null  </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> group)</span><span class="comment">//返回在前一次匹配操作中寻找到的组的起始索引</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">end</span><span class="params">(<span class="keyword">int</span> group)</span><span class="comment">//返回在前一次匹配操作中寻找到的组的最后一个字符索引加1的值</span></span></span><br></pre></td></tr></table></figure></p>
<p>start()和end()会返回前一次匹配操作的第一个字符位置和最后一个字符位置+1，如果匹配失败（或先于一个正在进行的匹配操作去尝试）。调用start()或end()都会产生一个IllegalStatException异常<br>find()可以在输入的任意位置定位正则表达式，而lookingAt()和matches()只有在正则表达式与输入的最开始位置处开始匹配才会成功</p>
<h3 id="Pattern标记"><a href="#Pattern标记" class="headerlink" title="Pattern标记"></a>Pattern标记</h3><p>Pattern的compile()还有另一个版本，它接受一个标记参数，以调整匹配的行为</p>
<pre><code>Pattern.compile(String regex,int flag)
</code></pre><p>其中的flag来自一下Pattern类中的常量  </p>
<table>
<thead>
<tr>
<th></th>
<th>编译标记</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>Pattern.CONON_EQ</td>
<td>两个字符当且仅当它们的完全规范分解相匹配时</td>
</tr>
<tr>
<td>Pattern.CASE.INSENSITIVE(?!)</td>
<td>默认情况下，大小写不敏感的匹配假定只有US-ASCII字符集中的字符才能进行，这个标记允许模式匹配不必考虑大小写（大写或小写），通过指定UNICODE_CASE标记及结合此标记，基于Unicode的大小写不敏感的匹配就可以开启了</td>
</tr>
<tr>
<td>Pattern.COMMENTS(?x)</td>
<td>在这种模式下，空格符将被忽略，并且以“#”开始直到行尾的注释也会被忽略掉，通过嵌入的标记表达式也可以开启Unix的行模式</td>
</tr>
<tr>
<td>Pattern.DOTALL(?s)</td>
<td>在dotall模式中，表达式“.”匹配所有的字符，包括行终结符。默认情况下“.”表达式不匹配行终结符</td>
</tr>
<tr>
<td>Pattern.MULTILINE</td>
<td>在多行模式下，表达式^和$分别匹配一行的开始和结束，^还匹配输入字符串的开始，而$还匹配输入字符串的结尾，默认情况下，这些表达式仅匹配输入的完整的字符串的开始和结束</td>
</tr>
<tr>
<td>Pattern.UNICODE_CASE(?u)</td>
<td>当指定这个标记，并且开启CASE.INSENSITIVE时，大小写不敏感的匹配将按照与Unicode标准相一致的方式进行，默认情况下，大小写不敏感的匹配假定只能在US-ASCII字符集中的字符才能进行  </td>
</tr>
<tr>
<td>Pattern.UNIX_LINES(?d)</td>
<td>在这种模式下，^和$行为中，其识别行终结符\n  </td>
</tr>
</tbody>
</table>
<h3 id="替换操作"><a href="#替换操作" class="headerlink" title="替换操作"></a>替换操作</h3><p>正则表达式特别便于替换文本，它提供了许多方法，replaceFirst(String replaceStr)替换掉第一个匹配成功的部分,replaceAll(String replaceStr)替换掉所有匹配成功的部分。appendReplacement(StringBuffer sbuf,String replaceent)此方法重要，允许你调用其他的方法来生成或处理replacement(replaceFirst()和replaceAll()则只能使用一个固定的字符串)，使得你能够以编程的方式来将目标分割成组，从而具备更强大的替换功能，appendTail(StringBuffer sbuf)，在执行完appendReplacement()之后，调用此方法可以将输入字符串余下的部分复制到sbuf中  </p>
<h3 id="reset"><a href="#reset" class="headerlink" title="reset()"></a>reset()</h3><p>通过reset()方法，可以将现有的Matcher对象应用于一个新的字符序列<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Resetting</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Matcher matcher = Pattern.compile(<span class="string">"[firb[aiu][gx]]"</span>).matcher(<span class="string">"fix the rug with bgs"</span>);</span><br><span class="line">        <span class="keyword">while</span>(matcher.find())&#123;</span><br><span class="line">            System.out.print(matcher.group());</span><br><span class="line">        &#125;</span><br><span class="line">        matcher.reset(<span class="string">"fix the rig rags"</span>);</span><br><span class="line">        <span class="keyword">while</span>(matcher.find())&#123;</span><br><span class="line">            System.out.print(matcher.group());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="正则表达式与I-O"><a href="#正则表达式与I-O" class="headerlink" title="正则表达式与I/O"></a>正则表达式与I/O</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/11/字符串/" data-id="cjnzv2pqq002dcorzz5pwyyp5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/学习心得/">学习心得</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML5/">HTML5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Maven/">Maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Oracle/">Oracle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Servlet-JSP/">Servlet&JSP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-MVC/">Spring MVC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-boot/">Spring boot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-cloud/">Spring cloud</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/HTML5/" style="font-size: 10px;">HTML5</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/Node-js/" style="font-size: 10px;">Node.js</a> <a href="/tags/Oracle/" style="font-size: 10px;">Oracle</a> <a href="/tags/Servlet-JSP/" style="font-size: 10px;">Servlet&JSP</a> <a href="/tags/Spring/" style="font-size: 10px;">Spring</a> <a href="/tags/Spring-MVC/" style="font-size: 10px;">Spring MVC</a> <a href="/tags/Spring-boot/" style="font-size: 10px;">Spring boot</a> <a href="/tags/Spring-cloud/" style="font-size: 10px;">Spring cloud</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/11/02/Servlets/">Servlets</a>
          </li>
        
          <li>
            <a href="/2018/10/27/并发/">并发</a>
          </li>
        
          <li>
            <a href="/2018/10/19/注解/">注解</a>
          </li>
        
          <li>
            <a href="/2018/10/19/枚举类型/">枚举类型</a>
          </li>
        
          <li>
            <a href="/2018/10/19/Java-I-O系统/">Java I/O系统</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 EgbertDay<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>