<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>代海峰</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="eating my owner dog food">
<meta property="og:type" content="website">
<meta property="og:title" content="代海峰">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="代海峰">
<meta property="og:description" content="eating my owner dog food">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="代海峰">
<meta name="twitter:description" content="eating my owner dog food">
  
    <link rel="alternate" href="/atom.xml" title="代海峰" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">代海峰</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">个人博客</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-注解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/19/注解/" class="article-date">
  <time datetime="2018-10-19T14:08:07.000Z" itemprop="datePublished">2018-10-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习心得/">学习心得</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/19/注解/">注解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/19/注解/" data-id="cjnj9osfv002ouwrz59vsqwql" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-枚举类型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/19/枚举类型/" class="article-date">
  <time datetime="2018-10-19T14:07:39.000Z" itemprop="datePublished">2018-10-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习心得/">学习心得</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/19/枚举类型/">枚举类型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/19/枚举类型/" data-id="cjnj9osdl0027uwrzb0ip1zzt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java-I-O系统" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/19/Java-I-O系统/" class="article-date">
  <time datetime="2018-10-19T14:06:30.000Z" itemprop="datePublished">2018-10-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习心得/">学习心得</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/19/Java-I-O系统/">Java I/O系统</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/19/Java-I-O系统/" data-id="cjnj9os6q000auwrzgtvphkgz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-容器深入研究" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/19/容器深入研究/" class="article-date">
  <time datetime="2018-10-19T14:05:34.000Z" itemprop="datePublished">2018-10-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习心得/">学习心得</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/19/容器深入研究/">容器深入研究</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="完整的容器分类法"><a href="#完整的容器分类法" class="headerlink" title="完整的容器分类法"></a>完整的容器分类法</h2><h2 id="填充容器"><a href="#填充容器" class="headerlink" title="填充容器"></a>填充容器</h2><p>虽然容器打印问题解决了，容器的填充仍然像Arrays一样面临着同样的问题，就像Arrays一样，相应的Collections类也有一些实用的static方法，其中包括fill(),与Arrays一样，此fill()方法也是只复制同一个对象引用来填充整个容器，并且只对List对象有用，但是所产生的列表可以传递给构造器或addAll()方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringAddress</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String s;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringAddress</span><span class="params">(String s)</span></span>&#123;s=s;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">super</span>.toString()+s;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FillingLists</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;StringAddress&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Collections.nCopies(<span class="number">4</span>, <span class="keyword">new</span> StringAddress(<span class="string">"Hello"</span>)));</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        Collections.fill(list,<span class="keyword">new</span> StringAddress(<span class="string">"world"</span>));</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">~~~上面这个例子展示了用对单个对象的引用来填充Collection的方式，第一种是使用Collections.nCopies()创建传递给构造器的List，这里填充的是ArrayList</span><br><span class="line">StringAddress的toString()调用了它的基类Object的toString()方法，这个方法返回的是该类的名字，后面紧跟着该对象的散列码的十六进制表示（通过hashCode()产生的），从输出中你可以看到所有引用都是指向的同一个对象，这在第二个方法被调用之后也是同样如此，fill()方法的作用有限，因为它只能替换已经在List中存在的元素，而不能添加新的元素</span><br><span class="line">### 一种Generator解决方案 ###</span><br><span class="line">**事实上，所有的Collection子类型都有一个接收另一个Collection对象的构造器，用所接收的Collection对象中的元素来填充新的容器**，为了更好地创建测试数据，我们需要做的是创建接受Generator和quantity数值并将它们当作参数的类</span><br><span class="line">**这个类使用Generator在容器中放置所需要的对象，然后所产生的容器可以传递给任何Collection的构造器**，这个构造器会把其中的数据复制到自身中，addAll()方法是所有Collection子类型的一部分，它也可以用来组装现有的Collection</span><br><span class="line">**泛型便利方法可以减少在使用类时所必需的类型检查**</span><br><span class="line">CollectionData是适配器设计模式的一个实例，它将Generator适配到Collection的构造器上</span><br><span class="line">~~~java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionData</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CollectionData</span><span class="params">(Generator&lt;T&gt; gen,<span class="keyword">int</span> quantity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;quantity;i++) &#123;</span><br><span class="line">           add(gen.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">CollectionData&lt;T&gt; <span class="title">list</span><span class="params">(Generator&lt;T&gt; gen,<span class="keyword">int</span> quantity)</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span>  <span class="keyword">new</span> CollectionData&lt;&gt;(gen,quantity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Map生成器"><a href="#Map生成器" class="headerlink" title="Map生成器"></a>Map生成器</h3><p>我们可以对Map使用相同的方法，但是这需要一个Pair类，因为为了组装Map,每次调用Generator的next()方法都必须产生一个对象对（一个键和一个值）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> K k;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V v;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(K k,V v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.k=k;</span><br><span class="line">        <span class="keyword">this</span>.v=v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>适配器现在可以使用不同的Generator，Iterator和常量值的组合来填充Map初始化对象了,你可以使用单一的Generator&lt;pair&lt;K,V&gt;&gt;,两个分离的Generator，一个Generator和一个常量值，一个Iterable和一个Generator，随你的心情定制<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapData</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapData</span><span class="params">(Generator&lt;Pair&lt;K,V&gt;&gt; gen,<span class="keyword">int</span> qantity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;qantity;i++) &#123;</span><br><span class="line">            put(gen.next().k, gen.next().v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapData</span><span class="params">(Generator&lt;K&gt; genK,Generator&lt;V&gt; genV,<span class="keyword">int</span> quantity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;quantity;i++)&#123;</span><br><span class="line">           put(genK.next(),genV.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapData</span><span class="params">(Generator&lt;K&gt; genK,V value,<span class="keyword">int</span> quantity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;quantity;i++)&#123;</span><br><span class="line">            put(genK.next(),value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapData</span><span class="params">(Iterable&lt;Pair&lt;K,V&gt;&gt; it,<span class="keyword">int</span> quantity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Pair&lt;K,V&gt; pair:it)&#123;</span><br><span class="line">            put(pair.k,pair.v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapData</span><span class="params">(Iterable&lt;K&gt; itK,Generator&lt;V&gt; genV)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(K key:itK)&#123;</span><br><span class="line">            put(key,genV.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="function">MapData&lt;K,V&gt; <span class="title">map</span><span class="params">(Generator&lt;Pair&lt;K,V&gt;&gt; gen,<span class="keyword">int</span> quantity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MapData&lt;&gt;(gen,quantity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="function">MapData&lt;K,V&gt; <span class="title">map</span><span class="params">(Generator&lt;K&gt; genK,Generator&lt;V&gt; genV,<span class="keyword">int</span> quantity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> MapData&lt;&gt;(genK,genV,quantity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="使用Abstrcat类"><a href="#使用Abstrcat类" class="headerlink" title="使用Abstrcat类"></a>使用Abstrcat类</h3><p>对于产生用于容器的测试数据问题，另一种解决方式是创建定制的Collection和Map实现，每个java.util容器都有其自己的Abstract类,它们提供了该容器的部分实现，因此你必须做的只是去实现那些产生想要容器所需的方法，如果所产生的容器是只读的，就像它通常用的测试数据那样，那么你需要提供的方法数量将减到最少<br>尽管在在比例中不是特别需要，但下面的的剞劂方案还是提供了一个机会来演示另一种设计模式：享元。你可以在普通的解决方案中需要过多的对象，后者产生普通对象太占空间时使用享元，享元使得对象的一部分可以被具体化，因此，与对象中的所有事物都包含在对象内部不同，我们可以在更加高效的外部表中查找对象的一部分或者整体（或者同某些其他节省空间的计算来产生对象的一部分或整体）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Countries</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String[][] DATA=&#123;</span><br><span class="line">            &#123;<span class="string">"ANGDAL"</span>,<span class="string">"Luanda"</span>&#125;,&#123;<span class="string">"NIID"</span>,<span class="string">"asdasd"</span>&#125;,&#123;<span class="string">"sdasdasd"</span>,<span class="string">"asdasdasd"</span>&#125;,</span><br><span class="line">            &#123;<span class="string">"asdasdasd"</span>,<span class="string">"adsdfasda"</span>&#125;,&#123;<span class="string">"GUPOOAD"</span>,<span class="string">"sdfsdf"</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyWeightMap</span> <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">String</span>,<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//创建一个嵌套的内部类Entry以提供EntrySet使用</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">String</span>,<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> index;</span><br><span class="line">            Entry(<span class="keyword">int</span> index)&#123;<span class="keyword">this</span>.index=index;&#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> DATA[index][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> DATA[index][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">setValue</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> DATA[index][<span class="number">0</span>].equals(o);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> DATA[index][<span class="number">0</span>].hashCode();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">String</span>,<span class="title">String</span>&gt;&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">            EntrySet(<span class="keyword">int</span> size)&#123;</span><br><span class="line">                <span class="keyword">if</span>(size&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">this</span>.size=<span class="number">0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(size&gt;DATA.length)&#123;</span><br><span class="line">                     <span class="keyword">this</span>.size=DATA.length;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">this</span>.size=size;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Iter</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">String</span>,<span class="title">String</span>&gt;&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">private</span> Entry entry=<span class="keyword">new</span> Entry(-<span class="number">1</span>);</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> entry.index&lt;size-<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> Map.<span class="function">Entry&lt;String, String&gt; <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    entry.index++;</span><br><span class="line">                    <span class="keyword">return</span> entry;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Iter();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Set&lt;Map.Entry&lt;String,String&gt;&gt; entries=<span class="keyword">new</span> EntrySet(DATA.length);</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet() &#123;</span><br><span class="line">            <span class="keyword">return</span> entries;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Map&lt;String,String&gt; <span class="title">select</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FlyWeightMap()&#123;</span><br><span class="line">            <span class="keyword">public</span> Set&lt;Map.Entry&lt;String,String&gt;&gt; entrySet()&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> EntrySet(size);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;String,String&gt; map=<span class="keyword">new</span> FlyWeightMap();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String,String&gt; <span class="title">map</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String,String&gt; <span class="title">capitals</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> select(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> List&lt;String&gt; names=<span class="keyword">new</span> ArrayList&lt;String&gt;(map.keySet());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">names</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> names;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">names</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;String&gt;(select(size).keySet());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>二维数组String DATA是public的，因此可以在其他地方使用，FlyweightMap必须实现entrySet()方法，它需要定制的Set实现和定制的Map.Entry类，这里正是享元的部分，每个Map.Entry对象只存储了它的索引，而不是实际的值和键，当你调用getKey()和getValue()得时候它们会使用该索引来返回恰当的DATA元素，，EntrySet可以确保它的size不会大于DATA<br>你可以在EntrySet.Iterator中看到享元的其他部分实现，与为DATA中的每个数据对都创建Map.Entry对象不同，每个迭代器只有一个Map.Entry,<strong>Entry对象被用作数据的视窗</strong>，它只包含在静态字符串数组的引用，<strong>你每次调用迭代器的next()方法时，Entry中的index都会递增，使其指向下一个元素对，然后从next()返回该Iterator所持有的单一的Entry对象</strong></p>
<h2 id="Collection的功能方法"><a href="#Collection的功能方法" class="headerlink" title="Collection的功能方法"></a>Collection的功能方法</h2><p>下面列出了可以通过Collection执行的所有操作（不包括从Object继承的方法），因此，它们也是可通过Set和List执行的所有方法（List有额外的功能），Map不是继承自Collection的</p>
<table>
<thead>
<tr>
<th></th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean add(T)</td>
<td>确保容器持有具有泛型类型T的参数，如果没有将此参数添加进容器，则返回false（这是“可选”的方法）</td>
</tr>
<tr>
<td>boolean addAll(Collection<t>)</t></td>
<td>添加参数中的所有元素，只要添加了任意元素就返回true（可选的）</td>
</tr>
<tr>
<td>void clear()</td>
<td>移除容器中的所有元素（可选）</td>
</tr>
<tr>
<td>boolean contains(T)</td>
<td>如果容器已经持有具有泛型类型T此参数，则返回true</td>
</tr>
<tr>
<td>Boolean containsAll(Collection<t>)</t></td>
<td>如果容器持有此参数中的所有元素，则返回true</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>容器中没有元素返回true</td>
</tr>
<tr>
<td>Iterator<t> iterator()</t></td>
<td>返回一个Iterator<t>,可以遍历容器中的元素</t></td>
</tr>
<tr>
<td>Boolean remove(Object)</td>
<td>如果参数在容器内，则移除该元素的一个实例，如果做了移除动作，则返回true（可选）</td>
</tr>
<tr>
<td>Boolean removeAll(Collection&lt;?&gt;)</td>
<td>移除参数中的所有元素，只要有移除动作发生就返回true（可选）</td>
</tr>
<tr>
<td>Boolean retainAll(Collection&lt;?&gt;)</td>
<td>只保存参数中的元素（应用集合论的“交集”概念），只要Collection发生了改变就返回true(可选)</td>
</tr>
<tr>
<td>int size()</td>
<td>返回容器中保存的元素个数</td>
</tr>
<tr>
<td>Object[] toArray()</td>
<td>返回一个数组，该数组包含容器中的所有元素</td>
</tr>
<tr>
<td><t> T[] toArray(T[] a)</t></td>
<td>返回一个数组，该数组包含容器中的所有元素，返回结果的运行是类型与，参数数组类型相同，而不是单纯的Object</td>
</tr>
</tbody>
</table>
<p>注意上面的方法不包括随机访问所选择元素的get()方法，因为Collection包括了Set，而Set是自己维护内部顺序的（这使得随机访问变得没有意义），因此，如果想检查Collection的元素，就必须使用迭代器</p>
<h2 id="可选操作"><a href="#可选操作" class="headerlink" title="可选操作"></a>可选操作</h2><p>什么是可选操作？就是接口声明的，但是实现类并不一定支持其实现的方法就是可选操作<br>执行各种不同的添加和移除的方法在Collection接口中都是可选操作，这意味着实现类并不一定选需要为这些方法提供功能定义（记住是不一定需要提供功能定义，但是必须提供实现，因为实现接口中声明的方法一定要有实现，实现可以什么都不做，也可以直接抛出一个UnsupportedException异常）<br>这是一种很不寻常的接口定义方式，<strong>接口是面向对象设计中的契约</strong>，它声明了“无论你选择任何实现该接口，我保证你可以向该接口发送这些消息”，但是可选操作违反了这个基本原则，它声明调用某些方法将不会执行任何有意义的行为，相反，它会抛出异常，这看起来好像是编译期的类型安全好像被抛弃了，因为编译期的类型检查就是为了运行期程序的正常执行<br>但是事情并不那么糟糕，如果一个操作是可选的，编译器仍然后要求你只能调用该接口中的方法，这样动态语言不同，<strong>动态语言可以在任何对象上调用任何方法，并且可以在运行时发现某个特定方法是否可以工作</strong>，另外将Collection当作参数接受的大部分方法只会从该Collection中读取，而Collection的读取都是不可选的<br><strong>为什么你会讲方法定义为可选的呢？那是因为这样做可以防止在设计中出现接口爆炸的情况</strong>，容器类型的其他设计看起来总是在描述每个主题的各种变体，而最终患上了令人困惑的接口过剩症，<strong>这种方式可以实现java容器类库的一个重要目标：容器应该是易学易用的（我们假定这样的一种情形，如果我们的Collection方法只声明了较少的方法，那么当我们需要具有某个特性的容器类时，我们必须在类库中添加具有这些特性的接口，这就造成了接口膨胀，而且当我们进行客户端编程的时候，要时刻区分那些容器类都实现了那些接口，这时我们不能仅仅将其向上转型为Collection类型了，因为Collection类型中仅有少量的方法可调用），未获支持的操作是一种特例，可以延迟到需要时才出现，但是，这种方式能够工作</strong><br>而且这种设计留下了一个后门，如果你想要创建新的Collection，但是没有为Collection接口中的所有方法都提供有意义的支持，那么它仍旧适合现有的类库<br>未获支持的异常只有在运行时才能探测到，因此它们表示动态类型检查<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Unsupported</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String msg,List&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">        Collection&lt;String&gt; c=list;</span><br><span class="line">        Collection&lt;String&gt; subList=list.subList(<span class="number">1</span>,<span class="number">8</span>);</span><br><span class="line">        Collection&lt;String&gt; c2=<span class="keyword">new</span> ArrayList&lt;&gt;(subList);</span><br><span class="line">        <span class="keyword">try</span>&#123; c.retainAll(subList); &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"retain"</span>+e); &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">try</span>&#123; c.remove(subList); &#125;<span class="keyword">catch</span>(Exception e)&#123; </span><br><span class="line">            System.out.println(<span class="string">"remove"</span>+e); &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">try</span>&#123; c.clear(); &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"clear"</span>+e); &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span>&#123; c.add(<span class="string">"x"</span>); &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"add"</span>+e); &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">try</span>&#123; c.addAll(c2); &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"addAll"</span>+e); &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">try</span>&#123; list.set(<span class="number">0</span>,<span class="string">"x"</span>); &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"List.set"</span>+e); &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list= Arrays.asList(<span class="string">"A B C D E F G H I "</span>.split(<span class="string">" "</span>));</span><br><span class="line">        test(<span class="string">"modifiable"</span>,<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">        test(<span class="string">"asList"</span>,list);</span><br><span class="line">        test(<span class="string">"unmodifiableList"</span>, Collections.unmodifiableList(<span class="keyword">new</span> ArrayList&lt;&gt;(list))); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最常见的未获支持的操作，都来源于背后由固定尺寸的数据结构支持的容器<br>我们看上面的一个例子。Arrays.asList()返回的容器对象就是以传入的数组对象为其底层的数据结构为基础提供容器的功能，因为我们知道，数组尺寸大小固定，所以对这个容器进行的增删都是未获支持的（容器的增删操作定义了执行这些操作时，容器的size必须改变，因为数组的length不可修改，所有，这样的容器自然不能进行增删操作了，不然就违反了容器原则）<br>但是我们将一个Arrays.asList（）返回的容器作为构造器的参数传递给ArrayList时，却发现了此时可以对这个容器进行增删操作了，这是因为，这样的方式会产生新的尺寸可调的底层数据结构。Collections类的“不可修改” 的方法将容器包装到了一个代理，只要进行任何试图修改容器的操作，这个代理都会产生一个UssupportedOperationException异常<br>最后一个方法set()比较有意思，对于Arrays.asList()返回的容器可以调用的，因为这个操作并不会改变尺寸，只是修改了某个位置元素而已，而对于Collections.unmodifiableLis()返回的容器只读，任何的写操作都不支持<br>最后，如果你要编写一个接受Collection类型的方法，其文档应该指定那些可选操作必须实现</p>
<h2 id="List的功能方法"><a href="#List的功能方法" class="headerlink" title="List的功能方法"></a>List的功能方法</h2><p>List继承了Collection接口，又添加了本身的一些接口方法，因此每一个实现了List接口的List容器实现都可以调用这些方法，这些方法可以查看api，见名知义，另外要注意的一个实现类LinkedList这个实现类不仅实现了List接口，还实现了其他的接口，所有具有普通List所不具有的特性和方法，如addFrist(),addLast(),removeFrist()等…,具体api请参见Queue接口</p>
<h2 id="Set和存储顺序"><a href="#Set和存储顺序" class="headerlink" title="Set和存储顺序"></a>Set和存储顺序</h2><table>
<thead>
<tr>
<th></th>
<th>接口或Set容器实现类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Set(interface)</td>
<td>放在Set中的每一个元素都必须是唯一的，因为Set不保存重复元素，加入Set的元素必须定义equals()方法以确保对象的唯一性，set与Collection有完全一样的接口，<strong>Set接口不保证维护元素的次序</strong></td>
</tr>
<tr>
<td>HashSet*</td>
<td>为快速查找设计的Set，存入HashSet的元素必须定义hashCode()</td>
</tr>
<tr>
<td>TreeSet</td>
<td>保持次序的Set，底层为树结构，使用它可以从Set中提取有序的方法，元素必须实现Comparable接口</td>
</tr>
<tr>
<td>LinkedHashSet</td>
<td>具有HashSet的查询速度，其内部使用链表维护元素的顺序（插入顺序），于是在使用迭代器遍历Set时，结果会按元素插入的次序显示，也必须定义hashCode()</td>
</tr>
</tbody>
</table>
<p>在HashSet上打星号，表示如无特殊的要求，这个应该是我们的首选<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SetType</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SetType</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;i=n;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o <span class="keyword">instanceof</span> SetType &amp;&amp; (i==((SetType) o).i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="string">"SetType"</span>+i; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashType</span> <span class="keyword">extends</span> <span class="title">SetType</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashType</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;<span class="keyword">super</span>(n);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hasCode</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeType</span> <span class="keyword">extends</span> <span class="title">SetType</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">TreeType</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeType</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;<span class="keyword">super</span>(n);&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(@NotNull TreeType o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (o.i&lt;i)? -<span class="number">1</span>:((o.i==<span class="number">0</span>)? <span class="number">0</span>:<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypesForSets</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Set&lt;T&gt; <span class="title">fillSet</span><span class="params">(Set&lt;T&gt; set,Class&lt;T&gt;  type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                set.add(type.getConstructor(<span class="keyword">int</span>.class).newInstance(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> set;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(Set&lt;T&gt; set,Class&lt;T&gt; type)</span></span>&#123;</span><br><span class="line">        fillSet(set,type);</span><br><span class="line">        fillSet(set,type);</span><br><span class="line">        fillSet(set,type);</span><br><span class="line">        System.out.println(set);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        test(<span class="keyword">new</span> HashSet&lt;HashType&gt;(),HashType.class);</span><br><span class="line">        test(<span class="keyword">new</span> LinkedHashSet&lt;HashType&gt;(),HashType.class);</span><br><span class="line">        test(<span class="keyword">new</span> TreeSet&lt;TreeType&gt;(),TreeType.class);</span><br><span class="line"></span><br><span class="line">        test(<span class="keyword">new</span> HashSet&lt;SetType&gt;(),SetType.class);</span><br><span class="line">        test(<span class="keyword">new</span> HashSet&lt;TreeType&gt;(),TreeType.class);</span><br><span class="line">        test(<span class="keyword">new</span> LinkedHashSet&lt;TreeType&gt;(),TreeType.class);</span><br><span class="line">        test(<span class="keyword">new</span> LinkedHashSet&lt;SetType&gt;(),SetType.class);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test(<span class="keyword">new</span> TreeSet&lt;HashType&gt;(), HashType.class);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            test(<span class="keyword">new</span> TreeSet&lt;SetType&gt;(),SetType.class);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果我们尝试着将没有恰当地支持必需的操作的类型用于需要这些方法的Set，那么将会有大麻烦，对于没有定义hashCode()的SetType或SetType,如果将它们放置到任何散列实现中都会产生重复值，这样就违背了Set的基本契约，这是相当烦人的，更烦人的是不会有任何的运行时错误，这是因为默认的hashCode()是合法的，即使它不正确<br>如果我们尝试着将没有实现Comparable的对象添加进TreeSet中，这会在运行期抛出异常，因为TreeSet的方法在内部会检测对象是否实现了Comparable</p>
<h3 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h3><p>SortedSet接口的唯一实现TreeSet,这个接口提供了一些附加的功能</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>comparator()</td>
<td>返回Comparator，或者返回null,表示以自然方式排序</td>
</tr>
<tr>
<td>T first()</td>
<td>返回容器的第一个元素</td>
</tr>
<tr>
<td>T last()</td>
<td>返回容器的最后一个元素</td>
</tr>
<tr>
<td>SortedSet<t> subSet(T fromElement,T toElement)</t></td>
<td>生成此Set的子集，范围从fromElement(包含)到toElement(不包含)</td>
</tr>
<tr>
<td>SortedSet<t>  headSet(T toElement)</t></td>
<td>由小于ToElement的元素组成的子集</td>
</tr>
<tr>
<td>SortedSet<t> tailSet(T fromElement</t></td>
<td>由大于或等于fromElement的元素组成的子集</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sorted</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SortedSet&lt;String&gt; set=<span class="keyword">new</span> TreeSet&lt;String&gt;();</span><br><span class="line">        Collections.addAll(set,<span class="string">"one two three"</span>.split(<span class="string">" "</span>));</span><br><span class="line">        System.out.println(set);</span><br><span class="line">        String low=set.first();</span><br><span class="line">        String high=set.last();</span><br><span class="line">        Iterator&lt;String&gt; it=set.iterator();</span><br><span class="line">        SortedSet&lt;String&gt; toFromSubSet=set.subSet(low,high);</span><br><span class="line">        SortedSet&lt;String&gt; headSubSet=set.headSet(high);</span><br><span class="line">        SortedSet&lt;String&gt; tailSubSet=set.tailSet(low);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>除了并发应用，Queue在java SE5中只有两个实现是LinkedList和PriorityQueue,它们的差异在于排序行为而不是性能<br>下面是涉及Queue实现的大部分操作的基本示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueBehavior</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count =<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(Queue&lt;T&gt; queue, Generator&lt;T&gt; gen)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">            queue.offer(gen.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(queue.peek()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(queue.remove()+<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Gen</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">        String[] s=<span class="string">"one two three four five six "</span>.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> s[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        test(<span class="keyword">new</span> LinkedList&lt;String&gt;(),<span class="keyword">new</span> Gen());</span><br><span class="line">        test(<span class="keyword">new</span> PriorityQueue&lt;String&gt;(),<span class="keyword">new</span> Gen());</span><br><span class="line">        test(<span class="keyword">new</span> ArrayBlockingQueue&lt;String&gt;(count),<span class="keyword">new</span> Gen());</span><br><span class="line">        test(<span class="keyword">new</span> LinkedBlockingQueue&lt;String&gt;(count),<span class="keyword">new</span> Gen());</span><br><span class="line">        test(<span class="keyword">new</span> ConcurrentLinkedQueue&lt;String&gt;(),<span class="keyword">new</span> Gen());</span><br><span class="line">        test(<span class="keyword">new</span> PriorityBlockingQueue&lt;String&gt;(),<span class="keyword">new</span> Gen());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h3><p>优先队列就是从一端插入，从另一端取出，而取出的顺序是按优先级的，所以元素要实现Comparable，我们看下一个简单的toDo列表的问题<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToDolist</span> <span class="keyword">extends</span> <span class="title">PriorityQueue</span>&lt;<span class="title">ToDolist</span>.<span class="title">ToDoItem</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ToDoItem</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ToDoItem</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">char</span> primary;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> secondary;</span><br><span class="line">        <span class="keyword">private</span> String item；</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ToDoItem</span><span class="params">(String item,<span class="keyword">char</span> primary,<span class="keyword">int</span> secondary)</span></span>&#123;</span><br><span class="line">            primary=primary;</span><br><span class="line">            secondary=secondary;</span><br><span class="line">            item=item;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(@NotNull ToDolist.ToDoItem o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(primary&gt;o.primary)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(primary==o.primary)&#123;</span><br><span class="line">                <span class="keyword">if</span>(secondary&gt;o.secondary)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(secondary==o.secondary)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String td,<span class="keyword">char</span> pri,<span class="keyword">int</span> sec)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.add(<span class="keyword">new</span> ToDoItem(td,pri,sec));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ToDolist toDolist=<span class="keyword">new</span> ToDolist();</span><br><span class="line">        toDolist.add(<span class="string">"Empty"</span>,<span class="string">'C'</span>,<span class="number">4</span>);</span><br><span class="line">        toDolist.add(<span class="string">"Feed Dog"</span>,<span class="string">'A'</span>,<span class="number">2</span>);</span><br><span class="line">        toDolist.add(<span class="string">"Empty"</span>,<span class="string">'B'</span>,<span class="number">7</span>);</span><br><span class="line">        toDolist.add(<span class="string">"Empty"</span>,<span class="string">'C'</span>,<span class="number">3</span>);</span><br><span class="line">        toDolist.add(<span class="string">"Empty"</span>,<span class="string">'A'</span>,<span class="number">1</span>);</span><br><span class="line">        toDolist.add(<span class="string">"Empty"</span>,<span class="string">'B'</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(!toDolist.isEmpty())&#123;</span><br><span class="line">            System.out.println(toDolist.remove());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h3><p><strong>双端队列就像是一个队列，但是你可以在任何一端添加或移除元素，在LinkedList中包含了双端队列的方法，但在java标准类库没有任何显式的用于双向队列的接口</strong>，因此你无法将一个LinkedList向上转型到Deque这样的接口（没有这样的接口），但是，你可以使用组合来创建一个Deque，并直接从LinkedList中暴露相关的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Deque</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;T&gt; deque=<span class="keyword">new</span> LinkedList&lt;T&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFrist</span><span class="params">(T item)</span></span>&#123;deque.addFirst(item);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(T item)</span></span>&#123;deque.addLast(item);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFrits</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> deque.getFirst();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span></span>&#123;<span class="keyword">return</span>  deque.getLast();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">removeFrist</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> deque.removeFirst();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">removeLast</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> deque.removeLast();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> deque.size();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> deque.toString();&#125;</span><br><span class="line">    <span class="comment">//other method</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实双端队列在程序中使用的并不是很多，因为我们也很少有需求需要在两端放入元素并取出它们</p>
<h2 id="理解Map"><a href="#理解Map" class="headerlink" title="理解Map"></a>理解Map</h2><p>映射表（关联数组）的基本思想是它维护键值关联，因此你可以使用键来查找值，标准的java类库包含了Map的几种基本实现。包括HashMap,TreeMap,LinedHashMap,WeakHashMap,ConcurretHashMap,IdentityHashMap,它们都有同样的基本接口Map，但是行为特性各不相同，这表现在效率，键值对的保存及呈现次序，对象的保存周期，映射表如何在多线程程序中工作和如何判定“键”等价性的策略等方面<br>我们先观察关联数组是如何创建的，下面是一个极其简单的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AssociativeArray</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[][] pairs;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">AssociativeArray</span><span class="params">(<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        pairs=<span class="keyword">new</span> Object[length][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key,V value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;=pairs.length)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException();</span><br><span class="line">        &#125;</span><br><span class="line">       pairs[index++]=<span class="keyword">new</span> Object[]&#123;key,value&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pairs[i][<span class="number">0</span>].equals(key))&#123;</span><br><span class="line">                <span class="keyword">return</span> (V)pairs[i][<span class="number">0</span>];</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuilder stb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line">            stb.append(pairs[i][<span class="number">0</span>]);</span><br><span class="line">            stb.append(<span class="string">":"</span>);</span><br><span class="line">            stb.append(pairs[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的例子是个很简单的Map实现，主要实现了put()和get(),而且是以Object数组为底层数据结构，并且不可自动调整尺寸的，这个例子看看就好</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>性能是映射表中的一个重要问题，当在get()中使用线性搜索时，执行速度会相当地慢，而这正是HashMap提高速度的地方，HashMap使用了特殊的值称作散列码，来取代对键的缓慢搜索，散列码是相对唯一的，，它通过对象的某些信息进行转换而成的，hashCode()是根类Object的方法，因此所有java对象都能产生散列码，HashMap就是使用对象的hashCode()进行快速搜索的，此方法能够显著提高速度<br>我们看下Map的各种实现</p>
<table>
<thead>
<tr>
<th>实现类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>HashMap</td>
<td>Map是基于散列表的实现（它取代了MaoTable）插入和查询“键值对”的开销是固定的，可以通过构造器设置容量和负载因子，以调整性能</td>
</tr>
<tr>
<td>LinkdHashMap</td>
<td>类似与HashMap，但是迭代遍历它时，取得“键值对”的顺序是其插入次序，或者是最近最少使用（LRU）的次序，只是比HashMap慢一点，而在迭代访问时反而更快，因为它使用链表维护内部次序</td>
</tr>
<tr>
<td>TreeMap</td>
<td>基于红黑树的实现，查看“键”或“键值对”时，它们会被排序（次序又Comparable或Comparator决定），TreeMap的特点在于，所得到的结果是经过排序的，TreeMap是唯一的带有SubMap()方法的Map，它可以返回一个子树</td>
</tr>
<tr>
<td>weakHashMap</td>
<td>弱键（weak key）映射，允许释放映射所指向的对象，这是为了解决某类特殊问题而设计的，如果映射之外没有引用指向某个“键”，则此“键”可以被垃圾回收器回收</td>
</tr>
<tr>
<td>ConcurrentHashMap</td>
<td>一种线程安全的Map，它不涉及同步加锁，我们将在“并发”中讨论它</td>
</tr>
<tr>
<td>IdentityHashMap</td>
<td>使用==代替equals()对“键”进行比较的散列映射，专为解决特殊问题而设计的</td>
</tr>
</tbody>
</table>
<p>对Map中使用的键的要求和对Set中的元素要求是一样的，任何键都要具有equals()方法，如果键被用于散列Map，则对象要有恰当的hashCode(),如果键被用于TreeMap，则它必须要实现Comparable<br>下面是Map接口的可用操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Maps</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printKeys</span><span class="params">(Map&lt;Integer,String&gt; map)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Size="</span>+map.size());</span><br><span class="line">        System.out.println(<span class="string">"Keys"</span>+map.keySet());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Map&lt;Integer,String&gt; map)</span></span>&#123;</span><br><span class="line">        System.out.println(map.getClass().getSimpleName());</span><br><span class="line">        map.putAll(<span class="keyword">new</span> CountringMapData(<span class="number">25</span>));</span><br><span class="line">        printKeys(map);</span><br><span class="line">        System.out.println(<span class="string">"values:"</span>+map.values());</span><br><span class="line">        System.out.println(map.containsKey(<span class="number">11</span>));</span><br><span class="line">        System.out.println(map.get(<span class="number">11</span>));</span><br><span class="line">        System.out.println(map.containsValue(<span class="string">"F0"</span>));</span><br><span class="line">        Iterator&lt;Integer&gt; keyIt=map.keySet().iterator();</span><br><span class="line">        Integer key=keyIt.next();</span><br><span class="line">        map.remove(key);</span><br><span class="line">        printKeys(map);</span><br><span class="line">        map.clear();</span><br><span class="line">        System.out.println(map.isEmpty());</span><br><span class="line">        map.putAll(<span class="keyword">new</span> CountringMapData(<span class="number">25</span>));</span><br><span class="line">        map.keySet().removeAll(map.keySet());</span><br><span class="line">        System.out.println(map.isEmpty());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="SortedMap"><a href="#SortedMap" class="headerlink" title="SortedMap"></a>SortedMap</h3><p>使用SortedMap(TreeMap是现阶段的唯一实现)，可用确保键处于排序状态，这使得它具有额外的功能，这些功能都是由SortedMap的接口提供的<br>Comparator comparator()返回当前Map使用的Comparator，或者返回null<br>T firstKey()返回Map中的第一个元素<br>T lastKey()返回Map中的最后一个元素<br>SortedMap subMap(fromKey,toKey)，SortedMap headMap(toKey) SortedMap tailMap(fromKey) 生成此Map的一个子集</p>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>为了提高速度，LinkedHashSet散列了所有元素，但是在遍历键值对时，却又以元素的插入顺序返回键值对，此外，可以构造器中设定LinkedhashMap，使之采用基于访问最近最少量（LRU）算法，于是没有被访问过的（可被看做需要删除的）元素就会出现在队列的前面，对于需要定期清理元素以节省空间的程序来说，此功能使得程序很容易得以实现，下面的例子演示了LinkedHashMap的这两个特点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMapDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        LinkedHashMap&lt;Integer,String&gt; linkedMap=<span class="keyword">new</span> LinkedHashMap&lt;&gt;(<span class="keyword">new</span> CountringMapData(<span class="number">25</span>));</span><br><span class="line">        System.out.println(linkedMap);</span><br><span class="line">        <span class="comment">//least-recent-used-order</span></span><br><span class="line">        linkedMap=<span class="keyword">new</span> LinkedHashMap&lt;&gt;(<span class="number">16</span>,<span class="number">0.75f</span>,<span class="keyword">true</span>);</span><br><span class="line">        linkedMap.putAll(<span class="keyword">new</span> CountringMapData(<span class="number">25</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">            linkedMap.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(linkedMap);</span><br><span class="line">        linkedMap.get(<span class="number">0</span>);</span><br><span class="line">        System.out.println(linkedMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的例子可以看出，可通过设定容器的容量和负载因子来调整容器的性能和行为</p>
<h2 id="散列和散列码"><a href="#散列和散列码" class="headerlink" title="散列和散列码"></a>散列和散列码</h2><p>使用标准类型的类当作HashMap的键来使用，是很好用的，因为这些类库在设计时，已经重新实现了一个比较恰当的hashCode()和equals()方法，但是如果自己创建的类，就有可能忘记在其中放置必需的方法，这通常会引起很大的错误<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Groundhog</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Groundhog</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;number=number;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">"GroundHog#"</span>+number;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Prediction</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand=<span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">shadow</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> rand.nextDouble()&gt;<span class="number">0.5</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(shadow())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Six more weeks of winter"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Early Spring"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDetecter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Groundhog&gt; <span class="function"><span class="keyword">void</span> <span class="title">detectSpring</span> <span class="params">(Class&lt;T&gt; type)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Constructor&lt;T&gt; ghog=type.getConstructor(<span class="keyword">int</span>.class);</span><br><span class="line">        Map&lt;Groundhog,Prediction&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            map.put(ghog.newInstance(i),<span class="keyword">new</span> Prediction());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        Groundhog gh=<span class="keyword">new</span> Groundhog(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">"looking up prediction for "</span> +gh);</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(gh))&#123;</span><br><span class="line">            System.out.println(map.get(gh));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"not found"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		            detectSpring(Groundhog.class);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的示例很简单，创建一个Map容器，将Groundhog(土拨鼠)与Prediction（天气预报）关联起来，可是这个示例是不工作的，当我们创建一个土拨鼠new Groundhog(3)时，是无法找到这个键的，根本原因是Groundhog继承了Object的hashCode()方法，而它默认是使用的对象的地址计算散列码，因此由Groundhog(3)生成的一个实例的散列码和第二个生成的实例的散列码并不相同，记住一点的是散列码的作用是查找（快速定位）<br>因此你可能会认为只要编写恰当的hashCode()就可以了，但是它仍然无法正常运行，除非你同时覆盖equals()方法，它也是Object的一部分，HashMap使用equals()判断当前的键是否与表中存在的键相同，继承自Object的equals()默认以对象的地址为判断依据<br>正确的equals()方法必须满足下列5个条件</p>
<ol>
<li>自反性：对于任意的x x.equals(x)一定返回true</li>
<li>对称性：任意的x,y 如果x.equals(y)返回true，则y.equals(x)一定返回true;</li>
<li>传递性：任意的x,y,z, x,equals(y) y.equals(z),则x.equals(z)</li>
<li>一致性：任意的x,y 如果对象中用于等价比较的信息没有改变，那么无论调用x.equals()多少次，返回的结果应该保持一致</li>
<li>对于任何不是null的x x.equals(null)返回false</li>
</ol>
<p>再次强调，默认的Object.equals()比较的是对象地址，因此，如果要将自己的类作为HashMap的键，一定要同时覆盖hashCode()和equals()</p>
<h3 id="理解hashCode"><a href="#理解hashCode" class="headerlink" title="理解hashCode()"></a>理解hashCode()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MapEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> K k;</span><br><span class="line">    <span class="keyword">private</span> V v;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapEntry</span><span class="params">(K key,V value)</span></span>&#123;</span><br><span class="line">        k=key;</span><br><span class="line">        v=value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v=value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShowMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;K&gt; listK=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;V&gt; listV=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key,V value)</span></span>&#123;</span><br><span class="line">        V oldValue=get(key);</span><br><span class="line">        <span class="keyword">if</span>(!listK.contains(key))&#123;</span><br><span class="line">            listK.add(key);</span><br><span class="line">            listV.add(value);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            listV.set(listK.indexOf(key),value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span></span>&#123;<span class="comment">//key is type Object not K</span></span><br><span class="line">        <span class="keyword">if</span>(!listK.contains(key))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> listV.get(listK.indexOf(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">        Set&lt;Map.Entry&lt;K, V&gt;&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Iterator&lt;K&gt; itk = listK.iterator();</span><br><span class="line">        Iterator&lt;V&gt; itV = listV.iterator();</span><br><span class="line">        <span class="keyword">while</span> (itk.hasNext()) &#123;</span><br><span class="line">            set.add(<span class="keyword">new</span> MapEntry&lt;K,V&gt;(itk.next(), itV.next()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> set;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">         SlowMap&lt;String,String&gt; m=<span class="keyword">new</span> SlowMap&lt;&gt;();</span><br><span class="line">         m.putAll(Countries.capitals(<span class="number">15</span>));</span><br><span class="line">         System.out.println(m);</span><br><span class="line">         System.out.println(m.entrySet());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面一个例子，最值得注意的问题，我觉得在定义get(Object o)方法的时候，我们期望的是get(K key)但是在这里是不可以的，提示说both motehed have same erasure,这是我感到疑惑的地方，我们知道在同一个类中，方法签名相同是不被允许的，但是这里通过在子类定义与基类中涉及泛型的方法签名相同的方法也是不被允许的，即使它们都被擦除为Object也不可以，这是为什么？<br>上面这个Map的实现并不好，因为<strong>entrySet()方法的调用创建了副本，这样就使得方法调用的效率变低，Map.Entry最好的实现应该是作为窗口通过它我们可以获得键和值，而且我们还应该可以通过这个视图修改底层数据，这些是副本做不到的</strong></p>
<h3 id="为速度而散列"><a href="#为速度而散列" class="headerlink" title="为速度而散列"></a>为速度而散列</h3><p>上面的例子，效率低的另一个原因是，我们搜索键的时候，使用的是线性查询，这种查询方式非常缓慢<br>散列的价值在于速度，散列使得查询得以快速进行，<strong>由于瓶颈在于查询速度，因此解决方案之一就是保持键的排序状态，然后使用Collection.binarySearch()进行查询</strong><br><strong>散列更进一步，它将键保存在某处，以便能够很快找到，存储一组元素最快的数据结构是数组，所以用它来保存键的信息，请留言，这里说的是键的信息，而不是键本身</strong>，这样有一个问题就是，数组尺寸固定的问题，如果我们希望在Map中保存数量不确定的值，这种问题能解决吗？<br>答案就是：数组不保存键本身，因为一旦保存的是键对象本身的话，那么这个数组位置上能保持的元素也只有一个了，其实很好解决，我们通过键对象获得一个数值，这个数值就是散列码，这个散列码表示数组的下标，通过下标将键值对存在这个数组下标位置上的一个容器，那么问题就解决了，任意数量的元素都能存储在Map中，即使hashCode()冲突也能够在数组索引位置上的容器对象上添加新的元素，解决hashCode冲突问题，<br>总结一下，查询一个值的过程是，计算键的hashCode，通过散列码查询数组，找到相应数组位置上的LinkedList，遍历LinkedList使用equals()判断该取LinkedList中存储的哪个元素，这种Map实现的方式使得每次查询只在少量的数据上进行遍历，效率得到提高</p>
<h3 id="覆盖hashCode"><a href="#覆盖hashCode" class="headerlink" title="覆盖hashCode()"></a>覆盖hashCode()</h3><p>如果要使得HashMap的执行效率更佳，那在我们向容器当作添加元素的时候，应该使得元素落在容器的槽位更加均衡才好，桶位下标的产生我们没有办法控制，因为这与HashMap对象的容量有关，而容量的改变与容器的充满程度和负载因子有关，hashCode生成的值经过计算才会生成桶位下标<br>设计hashCode的一个最重要的一个因素是，无论何时，对同一个对象调用hashCode()都应该生成相同的值<br>此外，也不应该使hashCode（）依赖于唯一性的对象信息，比如this，这也是我们在创建一个新类时，总会忽略的可怕问题，使得即使对象的信息描述完全相同，Map却依然将其视为不同的对象<br>基于对象的内容生成散列码是正确的选择<br>另外一个重要的影响因素，好的hashCode()应该产生分布均匀的散列码，否则，HashMap中的某些桶位负载过重，效率也不会更好<br>有一些建议，可以参考网上的资料</p>
<h2 id="选择接口的不同实现"><a href="#选择接口的不同实现" class="headerlink" title="选择接口的不同实现"></a>选择接口的不同实现</h2><p>尽管实际上只有四种容器：List，Set,Map和Queue，但是每种接口都有不止一个版本的实现，如果需要某种接口的功能，如何选择使用哪个实现？<br>容器之间的区别通常归结为由什么在背后“支持”它们，也就是说，所使用的接口是由什么样的数据结构实现的，<br>例如，ArrayList和LinkedList都实现了List接口，ArrayList底层是由数组支持，而LinkedList是由双向链表实现</p>
<h3 id="对List的选择"><a href="#对List的选择" class="headerlink" title="对List的选择"></a>对List的选择</h3><p>随机访问：ArrayList的随机访问要比LinkedList的随机访问要快，因为ArrayList是基于数组实现的，所以随机查找时，可以直接定位到一个对象的位置，而且随机访问速度不太会受到容器尺寸的影响，但是LinkedList的随机访问并不好，因为它是基于链表实现的，随机访问时要通过链表中的对象线性的查找对象的内存地址，所有性能很差，而且会随着尺寸的增大代价变得更加高昂<br>插入和删除，因为Arraylist的底层数组支持的原因，当向ArrayList插入一个元素时，必须创建空间并将它的所有引用先后移动，这种修改内存数据的行为，非常的耗时，但是ArrayList就比较简单，只需要连接两边的元素即可，这种方式的代价是固定的，不会随着尺寸的改变而改变</p>
<h3 id="对Set的选择"><a href="#对Set的选择" class="headerlink" title="对Set的选择"></a>对Set的选择</h3><p>HashSet的性能基本上总是比TreeSet好，特别是在添加和查询元素时，而这两个操作也是总重要的操作，TreeSet存在的唯一原因是它可以维持元素的排序状态，只有当需要一个排好序的Set时，才应该用TreeSet，TreeSet的迭代要比HashSet快、</p>
<h3 id="对Map选择"><a href="#对Map选择" class="headerlink" title="对Map选择"></a>对Map选择</h3><p>HashMap是我们平时应该默认使用的Map，TreeMap和TreeSet一样，是一种创建有序列表的方式，填充完TreeaMap之后，调用keySet()方法获得一个有序列表，LinkedHashSet在插入时比HashMap要慢一点，因为它在维持散列结果的同时也要维持插入顺序，正是由于这个原因，它的迭代速度也更快一些</p>
<h4 id="HashMap的性能因子"><a href="#HashMap的性能因子" class="headerlink" title="HashMap的性能因子"></a>HashMap的性能因子</h4><p>容量：桶位<br>初始容量：表在创建时所拥有的桶位数，HashMap和HashSet都具有允许你指定初始容量的构造器<br>尺寸：表当前存储的项数<br>负载因子：（尺寸/容量）空表的负载因子是0，半满表是0.5,依次类推，负载因子小的表产生冲突的可能性较小，但是会浪费较多的内存空间，也会使得频繁的扩容（这种是典型的空间换时间），HashMap和HashSet都允许你指定初始的负载因子，当达到该负载因子的水平的时候，容器自动增加其容量（桶位），实现的方式是使容量大致加倍，并重新将现有对象分布到新的桶位上（再散列）（HashMap的默认负载因子是0.75）</p>
<h2 id="实用方法"><a href="#实用方法" class="headerlink" title="实用方法"></a>实用方法</h2><p>Java中有大量的容器的卓越的使用方法，它们被称为java.util.Collections的静态方法，常用的方法总结如下</p>
<table>
<thead>
<tr>
<th></th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>checkedCollection(Collection<t> Class<t> type)<br>checkedList(List<t> Class<t> type)<br>checkedSet(Set<t> Class<t> type)<br>checkedMap(Map&lt;K,V&gt;,Class<k> kType,Class<v> vType)</v></k></t></t></t></t></t></t></td>
<td>产生Collection或者Collection子类型动态类型安全的容器，在不可能使用静态检查版本的时使用这些方法</td>
</tr>
<tr>
<td>max(Collection)<br>mix(Collection)</td>
<td>返回参数Collection中最大或最小的元素，采用Comparator比较</td>
</tr>
<tr>
<td>indexOfSubList(List source,List target)</td>
<td>返回target在source中第一次出现的位置，或者找不到返回-1</td>
</tr>
<tr>
<td>lastIndexOfSubList(List source,List target)</td>
<td>返回target在source中最后一次出现的位置，或者找不到返回-1</td>
</tr>
<tr>
<td>replaceAll(List<t>,T oldVal,T newVal)</t></td>
<td>使用newVal替换所有的oldVal</td>
</tr>
<tr>
<td>reverse(List)</td>
<td>逆转所有元素的顺序</td>
</tr>
<tr>
<td>reverseOrder()<br>reverseOrder&lt;Comparator<t>&gt;</t></td>
<td>返回一个Comparator，第二个版本返回一个反序的比较器</td>
</tr>
<tr>
<td>rotate(List,int distance)</td>
<td>所有的元素向后移动distance个位置，后面的元素循环移到前面</td>
</tr>
<tr>
<td>suffle(List)<br>suffle(List,Random)</td>
<td>随机改变元素的顺序</td>
</tr>
<tr>
<td>sort(List)<br> sort&lt;List<t>,Comparator&lt;? super T&gt;&gt;</t></td>
<td>使用List<t>中的自然排序，第二个方法使用比较器的排序</t></td>
</tr>
<tr>
<td>copy(List&lt;? extends T&gt; dist,List&lt;? super T&gt; src)</td>
<td>将src中的元素复制到dist</td>
</tr>
<tr>
<td>swap(List,int i,int j)</td>
<td>交换元素的位置</td>
</tr>
<tr>
<td>fill（List&lt;? super T&gt;,T x）</td>
<td>用对象x替换所有元素</td>
</tr>
<tr>
<td>nCopies(int n,T x)</td>
<td>返回大小为n的List<t>,此List不可改变，其中的引用都指向x</t></td>
</tr>
<tr>
<td>disjoint(Collection,Collection)</td>
<td>当两个集合中没有相同的元素时，返回true</td>
</tr>
<tr>
<td>ferquency(Collection,Object x)</td>
<td>返回Collection中等于x的元素个数</td>
</tr>
<tr>
<td>unmodifiedCollection(Collection)<br>unmodifiedList(List)<br>unmodifiedSet(Set)<br>unmodifiedMap(Map)</td>
<td>生成只读容器</td>
</tr>
<tr>
<td>concurrentCollection(Collection)<br>concurrentList(List)<br>concurrentSet(Set)<br>concurentMap(Map)</td>
<td>生成线程安全的容器</td>
</tr>
</tbody>
</table>
<h2 id="持有引用"><a href="#持有引用" class="headerlink" title="持有引用"></a>持有引用</h2><p>java.lang.ref类库包含了一组类，这些类为垃圾回收器提供了更大的灵活性，当存在可能耗尽内存的大对象时，这次类显得特别有用，有三个继承自抽线类Reference的类，SoftReferenc ,WeakRefrence,PhantomReference,当垃圾回收器正在考察的对象只能通过某个Reference对象才“可获得的”时候，上述这些类给垃圾回收器提供了不同级别的间接指示<br>对象是可获得的（reachable）是值对象能在程序的某处能够找到，不可获得对象，程序不能再访问它们，对这些对象的回收是安全的<br>如果想继续持有某个对象的引用，希望以后还能访问它们，但是也希望能够允许垃圾回收器在内存不足的时候释放它们，这时就可使用Reference对象<br>以Reference对象作为你和普通引用之间的媒介（代理），另外，一定不能有普通的引用指向这个对象，这样就能达到上述的目的，<strong>普通的引用指没有经过Reference对象包装过的引用</strong>，如果垃圾回收器发现某个对象通过引用是可达的，该对象就不会被释放<br>SoftRefenece，WeakReference，PhantomReference由强到弱排列，对应不同级别的“可获得性”，SoftReference用以实现内存敏感的高速缓存，weakReference是为了实现“规范映射”而设计的，，它不妨碍垃圾回收映射的“键”（或“值”），“规范映射”中对象的实例可以在程序的多处被同时使用，以节省内存空间，PhantomReference用于调度回收器的清理工作，它比Java终止机制更灵活<br>使用SoftReference和WeakReferenc时，可以选择是否将它们放入ReferenceQueue(用作垃圾回收前的清理工作的工具)，而PhantomReference只能依赖于ReferenceQueue<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VeryBig</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE=<span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span>[] la =<span class="keyword">new</span> <span class="keyword">long</span>[SIZE];</span><br><span class="line">    <span class="keyword">private</span> String ident;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VeryBig</span><span class="params">(String s)</span></span>&#123;ident=s;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123; <span class="keyword">return</span>  ident; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Finalizing"</span>+ident );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">References</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReferenceQueue&lt;VeryBig&gt; rf=<span class="keyword">new</span> ReferenceQueue();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Reference&lt;? extends VeryBig&gt; inq=rf.poll();</span><br><span class="line">        <span class="keyword">if</span>(inq!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"In Queue"</span>+inq.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size=<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(args.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            size=<span class="keyword">new</span> Integer(args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LinkedList&lt;SoftReference&lt;VeryBig&gt;&gt; sa=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            sa.add(<span class="keyword">new</span> SoftReference&lt;VeryBig&gt;(<span class="keyword">new</span> VeryBig(<span class="string">"Soft"</span>+i),rf));</span><br><span class="line">            System.out.println(<span class="string">"Just created"</span>+sa.getLast());</span><br><span class="line">            checkQueue();</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedList&lt;WeakReference&lt;VeryBig&gt;&gt; wa=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            wa.add(<span class="keyword">new</span> WeakReference&lt;VeryBig&gt;(<span class="keyword">new</span> VeryBig(<span class="string">"Weak"</span>+i),rf));</span><br><span class="line">            System.out.println(<span class="string">"Just created"</span>+wa.getLast());</span><br><span class="line">            checkQueue();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        SoftReference&lt;VeryBig&gt; s=<span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> VeryBig(<span class="string">"Soft"</span>));</span><br><span class="line">        WeakReference&lt;VeryBig&gt; w=<span class="keyword">new</span> WeakReference&lt;&gt;(<span class="keyword">new</span> VeryBig(<span class="string">"weak"</span>));</span><br><span class="line">        </span><br><span class="line">        System.gc();</span><br><span class="line">        </span><br><span class="line">        LinkedList&lt;PhantomReference&lt;VeryBig&gt;&gt; pa=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            pa.add(<span class="keyword">new</span> PhantomReference&lt;VeryBig&gt;(<span class="keyword">new</span> VeryBig(<span class="string">"Phantom"</span>+i),rf));</span><br><span class="line">            System.out.println(<span class="string">"Just created"</span>+pa.getLast());</span><br><span class="line">            checkQueue();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h3><p>容器类中有一种特殊的Map，即WeakHashMap,它被用来保存WeakReference，它使得规范映射更易于使用，在这种映射中，每个值只保存一份实例以节省存储空间，当程序需要那个“值”的时候，便在映射中查询现有的对象，然后使用它（而不是重新再创建），映射可将值作为其初始化的一部分，不过通常是在需要的时候才生成“值”<br>这是一种节省空间的技术，因为WeakHashMap允许垃圾回收器自动清理键和值，所以它显得十分便利，对于向WeakHashMap添加键和值的操作，则没有什么特殊的要求，映射会自动使用WeakReference包装它们，允许清理元素的触发条件是，不再需要此键，如下所示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Element</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String ident;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Element</span><span class="params">(String id)</span></span>&#123;ident=id;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span>  ident;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> ident.hashCode();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o <span class="keyword">instanceof</span>  Element &amp;&amp; ident==((Element)o).ident;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fianlzie</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Finalizing"</span>+getClass().getSimpleName()+ident);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Element</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Key</span><span class="params">(String id)</span></span>&#123;<span class="keyword">super</span>(id);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Value</span> <span class="keyword">extends</span>  <span class="title">Element</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Value</span><span class="params">(String id)</span></span>&#123;<span class="keyword">super</span>(id);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CanonicalMapping</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size=<span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">if</span>(args.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            size=<span class="keyword">new</span> Integer(args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        Key[]  keys=<span class="keyword">new</span> Key[size];</span><br><span class="line">        WeakHashMap&lt;Key,Value&gt; wm=<span class="keyword">new</span> WeakHashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">           Key k=<span class="keyword">new</span> Key(Integer.toString(i));</span><br><span class="line">           Value v=<span class="keyword">new</span> Value(Integer.toString(i));</span><br><span class="line">           <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">               keys[i]=k;<span class="comment">//save as "real"  reference</span></span><br><span class="line">           &#125;</span><br><span class="line">           wm.put(k,v);</span><br><span class="line">        &#125;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/19/容器深入研究/" data-id="cjnj9osak001tuwrzzn6yfhjf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-数组" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/19/数组/" class="article-date">
  <time datetime="2018-10-18T17:15:45.000Z" itemprop="datePublished">2018-10-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习心得/">学习心得</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/19/数组/">数组</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="数组为什么特殊"><a href="#数组为什么特殊" class="headerlink" title="数组为什么特殊"></a>数组为什么特殊</h2><p>java中有大量的方式可以持有对象，那么，到底是什么使数组变的与众不同？<br><strong>数组与其他种类容器之间的主要区别有三个方面：效率，类型和保存基本类型的能力</strong><br>效率：数组是一种效率最高的存储和随机访问对象引用序列的方式，数组就是一个线性序列，这使得元素访问非常快速，但是为了这种速度所付出的代价就是数组对象的大小被固定，这是一种典型的以空间换时间的取舍，数组的创建使得数组对象本身的存储空间被固定下来，因此，数组不能扩容，但是带来的好处确实，我们随机访问一个元素时非常快，因为虚拟机很容易就能定位到元素的内存地址<br>类型：在泛型之前，其他的容器类在处理对象时，都将它们视为没有具体类型，也就是说，它们将这些对象都当作Java中所有类的根类处理，这种做法在泛型之前是没有问题的，因为我们不应该将一个容器类指定为只能保存特定类型，如果如此的话，我们要创建大量的容器类，还有我们没有预见的容器类，这是不可能的，也是不现实的，因此将所有对象视为Object是合理的，但是这样的处理方式使得我们没有办法在编译期保证类型的正确性，只有在从容器中取出对象时才可能发现插入类型的不正确，泛型容器的出现，使得我们能够将类型检查放在编译期，从而解决了这个问题，数组对象本身对象的结构性天然的使得它具有只能持有类型正确对象的特性，也就是可以实现编译期的类型检查<br>持有基本类型：容器没有办法持有基本类型，这也很容易理解，因为一般基本类型对象的创建是在栈中，除非基本类型作为对象的属性存储在对象的内存空间内，容器类和数组存储结构最大的不同是在于，容器持有的对象并不在容器对象的内存空间中，它必须通过容器对象保存的元素的引用来访问元素对象，这些元素对象必须要被存储在堆中，所有造成了，容器不能持有（管理）基本类型，如果容器要想具有持有基本类型的能力必须通过包装器这种方式，而数组不同，数组的元素就存储在数组内存空间之中，这种特性很容易使得数组具有持有基本类型的能力<br>因为泛型和自动包箱和拆箱的出现，容器可以很容易的持有基本类型了，数组仅存的优点就是效率，可是使用数值又会受到太多的限制，所以一般情况下我们会选择使用容器而不是数组</p>
<h2 id="数组是第一级对象"><a href="#数组是第一级对象" class="headerlink" title="数组是第一级对象"></a>数组是第一级对象</h2><p>无论使用哪种类型的数组，数组标识符其实只是一个引用，指向堆中创建的一个真实对象，这个（数组）对象用以保存指向其他对象的引用（这里指的是引用数组），如果是基本类型数组，数组对象保存的是基本类型的值<br>只读成员length是数组对象的一部分（事实上，这是唯一yield可以访问的字段或方法），表示此数组对象可以存储多少元素，“[]”语法是访问数组对象元素的唯一方式<br>创建数组方式：</p>
<ol>
<li>作为数组初始化语法的一部分隐式创建，如 <code>String[] strs={&quot;hello&quot;,&quot;world&quot;}</code></li>
<li>使用new关键字显式地创建，如 <code>String[] strs = new String[2]</code>或者<code>String strs=new String[]{&quot;hello&quot;,&quot;world&quot;}</code></li>
</ol>
<p>有几个需要注意的地方：</p>
<ol>
<li>length只表示数组能够容纳多少个元素，也就是说length是数组大小（主要是用来做下标检查，并且不可变），而不是实际保存的元素的个数</li>
<li>数组创建时就已经完成了初始化，未被显式赋值的引用被初始化为null,基本类型被初始化为“零值<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><strong>创建多维数组很方便，对于基本类型的多维数组，可以通过使用花括号将每个向量分隔开</strong>，实际上多维数组中是通过每一维数组保存下一维数组对象的引用实现的<br>数组中的每个向量可以具有任意长度（这被称为粗糙数组）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RaggedArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        Random rand=new Random(<span class="number">47</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span>[][][] a=<span class="keyword">new</span> <span class="keyword">int</span>[rand.nextInt(<span class="number">7</span>)][][];<span class="comment">//创建数组时，第一维下标必须要被初始化，</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            a[i]=a[rand.nextInt(<span class="number">5</span>)];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;a[i].length;j++)&#123;</span><br><span class="line">                a[i][j]=<span class="keyword">new</span> <span class="keyword">int</span>[rand.nextInt(<span class="number">5</span>)];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.deepToString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="数组与泛型"><a href="#数组与泛型" class="headerlink" title="数组与泛型"></a>数组与泛型</h2><p>通常数组和泛型不能很好地结合，你不能实例化具有参数化类型的数组<br>    Peel<banana>[] peels=new Peel<banana>[10]//illegal<br><strong>擦除会移除参数类型信息，而数组必须知道它们所持有的确切类型，以强制保证类型安全</strong><br>但是，你可以参数化数组本身的类型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassParameter</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> T[] f(T[] arg)&#123; <span class="keyword">return</span>  arg;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodParameter</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] f(T[] arg)&#123;<span class="keyword">return</span> arg;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParameterizedArrayType</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Integer[] ints=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        Double[] doubles=&#123;<span class="number">1.1</span>,<span class="number">2.2</span>,<span class="number">3.3</span>,<span class="number">4.4</span>,<span class="number">5.5</span>&#125;;</span><br><span class="line">        Integer[] ints2=<span class="keyword">new</span> ClassParameter&lt;Integer&gt;().f(ints);</span><br><span class="line">        Double[] doubles2=<span class="keyword">new</span> ClassParameter&lt;Double&gt;().f(doubles);</span><br><span class="line">        Integer[] ints3=MethodParameter.f(ints);</span><br><span class="line">        Double[] doubles3=MethodParameter.f(doubles);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></banana></banana></p>
<p>注意，使用参数化方法而不使用参数化类的方便之处：你不必为需要应用的每种不同的类型都使用一个参数去实例化这个类，并且你可以将其定义为静态，当然，你不能总是选择使用参数方法而不是参数化类，但它应该成为首选<br>上面的例子证明了，不能创建泛型数组的这一说法并不准确，诚然，编译器确实不让你实例化泛型数组，但是，它允许你创建对这种数组的引用，例如<br>    List<string> list<br>这条语句可以顺利地通过编译器而不报任何错误，而且，尽管你不能创建实际的持有泛型的数组对象，但是你可以创建非泛型的数组，然后将其转型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayOfGenerics</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt;[] ls;</span><br><span class="line">        List[] la=<span class="keyword">new</span> List[<span class="number">10</span>];</span><br><span class="line">        ls=(List&lt;String&gt;[])la;<span class="comment">//"unchecked" warning</span></span><br><span class="line">        ls[<span class="number">0</span>]=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="comment">//ls[1]=new ArrayList&lt;Integer&gt;();compile-error checking produces an error</span></span><br><span class="line">        Object[] objects=ls;</span><br><span class="line">        <span class="comment">//compiles and runs without complaint</span></span><br><span class="line">        objects[<span class="number">1</span>]=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//howerve if your needs are straightforward it is</span></span><br><span class="line">        <span class="comment">//possible to create an array of generics,albeit("虽然")</span></span><br><span class="line">        <span class="comment">//with an "unchecked" warning</span></span><br><span class="line">        List&lt;BerylliumSphere&gt;[] spheres=(List&lt;BerylliumSphere&gt;[]) <span class="keyword">new</span> List[<span class="number">10</span>];</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;spheres.length;i++)&#123;</span><br><span class="line">				   spheres[i]=<span class="keyword">new</span> ArrayList&lt;BerylliumSphere&gt;();</span><br><span class="line">				&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></string></p>
<p>一旦拥有了对List<string>[]的引用，你就会看到你将得到某些编译器检查<br><strong>数组是协变类型的</strong>，因此向数组中添加元素，可以是数组声明类型的子类，这样在取出数组时，得到的是引用声明的类型，记住，<strong>引用类型主要是给编译器提供类型信息</strong><br>如果你知道将来不会向上转型，并且需求也相对简单，那么你仍旧可以创建泛型数组，它可以提供基本的编译期类型检查，但是，<strong>事实上，泛型容器总是比泛型数据更好的选择</strong><br>一般而言你会发现泛型在类或者方法的边界很有效，而在类或方法的内部，擦除通常会是泛型变得不适用，例如你不能创建泛型数组，如<code>new T[]</code>是错误的，因为数组的创建一定要确切的类型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayOfGenericType</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T[] array;<span class="comment">//is ok</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayOfGenericType</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="comment">//array=new T[size];  不可以创建泛型数组</span></span><br><span class="line">        <span class="comment">//所有对象的引用在堆中所占据的内存空间大小是一样的，所以我们先创建一个Object</span></span><br><span class="line">        <span class="comment">//的数组，给定size，数组在堆中分配的内存空间确定下来，我们将这个创建的数组</span></span><br><span class="line">        <span class="comment">//使用（T[]）进行转型，需要记住的这只是给了编译器一个转型提示，实际底层数组对象</span></span><br><span class="line">        <span class="comment">//头部保存的对象类型信息任何没有改变，它记录了自己保存的是Object类型的数据，</span></span><br><span class="line">        <span class="comment">//但是数组的引用类型指示了当向这个数组插入对象时进行类型检查需要的信息，以及在运行时</span></span><br><span class="line">        <span class="comment">//从数组中取出数据进行动态的类型转换</span></span><br><span class="line">        array=(T[])<span class="keyword">new</span> Object[size];<span class="comment">//unchecked warning </span></span><br><span class="line">        <span class="comment">//public &lt;U&gt; U[] makeArray()&#123; return; new U[10]&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></string></p>
<p>擦出再次成为了障碍——本例试图创建的类型以及被擦除了，因而是类型未知的数组，注意，你可以创建Obeject数组，然后将其转型，但是，如果没有@DSupressWarnings注解，你将在编译期得到一个“不受检查”的警告消息，因为这个组没有真正持有或动态检查类型T,也就是说，如果我创建了一个String[]，java在编译器和运行期都会强制我只能将String对象置于改数组中，如果创建的是Object数组，那么我可以将除基本类型之外的任何对象置于该数组</p>
<h2 id="创建测试数据"><a href="#创建测试数据" class="headerlink" title="创建测试数据"></a>创建测试数据</h2><p>通常，在实验数组和程序时，能够很方便地生成填充了测试数据的数组，将会很有帮助，我们来看看如何利用工具将数值和对象填充进数组</p>
<h3 id="Arrays-fill"><a href="#Arrays-fill" class="headerlink" title="Arrays.fill()"></a>Arrays.fill()</h3><p>java的标准类库Arrays有一个作用很有限的fill()方法，只能用一个填充各个位置，<strong>而针对对象而言，就是复制同一个引用来填充</strong>，可以填充整个数组，也可以填充数组的某个区域，但是由于只能使用单一的数值来调用Arrays.fill()，因此这个方法并没什么用</p>
<h3 id="数据生成器"><a href="#数据生成器" class="headerlink" title="数据生成器"></a>数据生成器</h3><p>为了灵活的方式创建更有趣的数组，我们使用Gererator的概念，如果某个工具使用了Generator,那么你就可以通过选择Generator的类型来创建任何类型的数据（这是策略模式的一个实例——每个不同的Generator都表示一个不同的策略）<br>首先创建这些包装器类嵌套在CountingGenerator类中，注意这里的包装器类只是为了区别各种生成器取和java类库包装器相同的名字而已，它们是在CountingGenerator中，且在不同的命名空间下，所以不是同一类型，这点注意，实现Generator<t>接口的next方法就可以了，如下，省写<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountingGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Boolean</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">java</span>.<span class="title">lang</span>.<span class="title">Boolean</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> value=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">public</span> java.lang.<span class="function">Boolean <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> !value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Byte</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">java</span>.<span class="title">lang</span>.<span class="title">Byte</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">byte</span> value=<span class="number">0</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> java.lang.<span class="function">Byte <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">char</span>[] chars=<span class="string">"abcdefghijklmnopqrstuvwlyz"</span>.toCharArray();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Character</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">java</span>.<span class="title">lang</span>.<span class="title">Character</span>&gt;</span>&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">public</span> java.lang.<span class="function">Character <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> chars[(index++)%chars.length];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span>  <span class="title">Generator</span>&lt;<span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> length=<span class="number">7</span>;</span><br><span class="line">        Generator&lt;java.lang.Character&gt; generator=<span class="keyword">new</span> Character();</span><br><span class="line">        <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">char</span>[] chars=<span class="keyword">new</span> <span class="keyword">char</span>[length];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">                chars[i]=generator.next();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Arrays.toString(chars);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></p>
<p>这些生成器大多都是这样的，实现generator接口的next()方法只是具体的实现不同而已</p>
<h3 id="从Generator中创建数组"><a href="#从Generator中创建数组" class="headerlink" title="从Generator中创建数组 ###"></a>从Generator中创建数组 ###</h3><p>为了接收Generator并产生数组，我们需要两个转换工具，一个工具使用任意的Generator来产生Object子类型的数组，为了处理基本类型，第二个工具接收任意基本类型的包装器类型数组，并产生相应的基本类型数组<br>我们看下第一个工具的两种选择，第一个使用重载的array方法，该方法接受一个已有的数组，并使用某个Generator填充它，而第二个版本接受一个Class对象（类型标记）,一个Generator和所需的元素数量，然后创建一个新数组，并使用所接收的Generator来填充它，注意这个工具只能阐释Object子类型的数组，而不能产生基本类型数组<br>因为泛型不能用于基本类型，而我们确实需要一个生成器来填充基本类型数组，很简单，先使用生成器生成包装器类型数组，然后通过一个转换器生成基本类型数组，所以我们要创建一个转换器类，里面有重载的转换方法接受不同类型的包装器数组，然后在方法内部创建基本类型数组，依次取出包装器数组的数据赋值即可，很简单，不写了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/19/数组/" data-id="cjnj9osdx002auwrzw5degw9h" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-泛型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/14/泛型/" class="article-date">
  <time datetime="2018-10-14T11:22:59.000Z" itemprop="datePublished">2018-10-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习心得/">学习心得</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/14/泛型/">泛型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一般的类和方法，只能使用具体的类型，要么是基本类型，那么是自定义的类，如果要编写可以应用与多种类型的代码，这种刻板的限制对代码的束缚就会很大<br>在面向对象语言中，动态算是一种泛化机制，你可以将方法的掺水设为基类，那么该方法就可以接受从这个基类中导出的任何类作为参数，这样的方法也更加通用些，可以应用的地方也更多些，但是考虑到除了final类不能被扩展，其他任何类都可以被扩展，所以这种灵活性大多时候也会有一些性能损耗<br>有时候，拘泥于单继承体系，也会使程序受限太多，如果方法的参数是一个接口，而不是一个类，这种限制就放松了很多，因为任何事实现了该接口的类都能满足该方法，这也包括了暂时还不存在的类，这给了客户端程序员一种选择，他可以选择实现一个接口来满足类或方法的<br>可是有时候，即使使用接口，对程序的约束也还是太强了，因为一旦指明了接口，它就要求你的代码必须使用特定的接口，而我们希望达到的目的是编写更通用的代码，要使代码能够用于“某种不具体的类型”而不是具体的接口或类<br>java SE5的重大变化之一，就是泛型的概念，泛型实现了参数化类型的概念，使代码可以应用于多种类型，“泛型”这个术语的意思就是：“适用于多种类型”，<strong>泛型在编程语言出现时，其最初的目的是希望类或方法能够具备更广泛的表达能力</strong>，如何做到这一点的呢？正是实现通过解耦类和方法与所使用的类型之间的解耦，扫后你将会看到，java中的泛型并没有那么高的追求<br>在学习了java的泛型之后，泛型确实是一个很好的补充，在你创建<strong>参数化类型</strong>的一个实例时，编译器会为你负责转型操作，并确保类型的正确性，这是一个进步<br>但是java中的泛型还没有能够做到像C++那样实现了纯粹的泛型，你不要对java的泛型期望太高，在java中使用一个别人已经建好的泛型类型很容易，但是如果自己创建一个泛型实例，就会遇到很多令人吃惊的事情  </p>
<h2 id="与C-d的比较"><a href="#与C-d的比较" class="headerlink" title="与C++d的比较"></a>与C++d的比较</h2><p>java的设计灵感来自于C++,那么先了解C++的泛型机制对理解java泛型有些帮助，了解C++魔板的某些方面，有助于你理解泛型的基础，你可以了解java泛型的局限是什么，已经为什么会有这些限制，最终的目的是帮助理解，java泛型的边界在哪里，理解了边界所在，你才会知道某个技术不能做什么，你才能更好地做到所能做的  </p>
<h2 id="简单泛化"><a href="#简单泛化" class="headerlink" title="简单泛化"></a>简单泛化</h2><p>许多的原因促使了泛型的出现，而最引人注目的一个原因，就是为了创造容器类，我们先来看下一个只能持有单一对象的类，当然这个对象可以明确指定其持有对象的类型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Automobile</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Automobile automobile;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">(Automobile automobile)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.automobile = automobile;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Automobile <span class="title">getAutomobile</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  automobile;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面自定义的容器类Holder，指定了只能存储Automobile这种类型的对象，这个类的可重用性就不怎么样，难道我们要为每一种类型都要创建一个像这样的容器类吗？当然不<br>在java SE5之前我们可以让一个类直接持有Object类型的对象，实际上，我们是使用了关于基类的编程，这要这个类能够应用于这个基类，那么基类的导出类也适用于这个代码，因为导出类本质上也是基类类型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder2</span><span class="params">(Object obj)</span></span>&#123;<span class="keyword">this</span>.obj=obj;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObj</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> obj;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Holder2 holder2=<span class="keyword">new</span> Holder2(<span class="keyword">new</span> Automobile());</span><br><span class="line">        Automobile automobile=(Automobile) holder2.getObj();</span><br><span class="line">        <span class="comment">//特别是这段代码，虽然getObj()返回的实际类型是Automolie类型，我们还是可以做转型操作，编译器才会发现类型转换失败</span></span><br><span class="line">        String s=(String) holder2.getObj();</span><br><span class="line">        holder2.setObj(<span class="string">"Not a Automoblie"</span>);</span><br><span class="line">        String str=(String) holder2.getObj();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~~~在有些情况下，我们确实希望容器具有能持有不同类型的能力，但是，通常情况下，我们希望使用容器来存储一种特定的类型，泛型的主要目的之一就是用来指定容器要持有什么类型的对象，而且由编译器来保证类型的正确性  </span><br><span class="line">因此，与其使用Object，我们更喜欢暂时不指定类型，而是稍后再决定具体使用什么类型，要达到这个目的，需要使用**类型参数**，用尖括号括住，放在类名后面，然后在什么这个类的时候，再用实际的类型替换此类型参数  </span><br><span class="line">~~~java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder3</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder3</span><span class="params">(T a)</span></span>&#123;<span class="keyword">this</span>.a=a;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T a)</span></span>&#123;<span class="keyword">this</span>.a=a;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> a;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Holder3&lt;Automobile&gt; h3=<span class="keyword">new</span> Holder3&lt;&gt;(<span class="keyword">new</span> Automobile());</span><br><span class="line">        Automobile automobile=h3.get();</span><br><span class="line">        <span class="comment">//h3.set(1);</span></span><br><span class="line">        <span class="comment">//h3.set("not a Automoblie");</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当你创建h3对象时，必须指明想要持有什么类型的对象，将其置于尖括号内，然后你就只能在Hold3中存入该类型（或者子类，多态和泛型不冲突，明确指定了泛型类型，那么这个类型的子类型也是该类型，基类与导出类的关系）<br>这就是java泛型的核心概念：告诉编译器想要什么什么类型，然后编译器处理一切   </p>
<h3 id="一个元祖类库"><a href="#一个元祖类库" class="headerlink" title="一个元祖类库"></a>一个元祖类库</h3><p>仅一次方法调用就返回多个对象，我们经常需要这个功能，可是return只能返回一个对象，因此解决办法就是创建一个对象，用它来持有想要返回的多个对象<br>难道我们每次都要创建这样的一个类，指定它能够保存的类型，所有每次需要保存不同类型的元组时，都要创建保存不同类型的类吗？<br>有了泛型，我们不需要这样做，这样一个类保存两种类型的对象，这个类在创建时才指定它需要用到的类型，同时我们在编译期就能确保类型安全<br>这个概念被称为“元组” ，它是将一组对象直接打包存储于其他的一个单一对象，这个容器对象允许读取其中元素，但是不允许向其中存放新的对象，这和对象就被称为<strong>数据传送对象或者信使 </strong><br>通常，元组可以具有任意长度，同时，元组中的对象可以是任意不同的类型，不过我们希望能够为每一个对象指明类型，并且从容器中读取出来时，能够得到正确的类型，看下下面的二维元组，它能够持有两个对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoTuple</span>&lt;<span class="title">A</span>,<span class="title">B</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> A first;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> B second;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TwoTuple</span><span class="params">(A a,B b)</span></span>&#123;</span><br><span class="line">        first=a;</span><br><span class="line">        second=b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">"("</span>+first+second+<span class="string">")"</span>;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>仔细看上面的代码，我们或许会疑惑，上面的代码违反了java编程的安全性原则，first和second应该被声明为private，然后提供getFirst()和getSecond()子类的访问方法才对，让我们看下这个例子的安全性，客户端程序可以读取fisrt和second，然后随心所欲的使用它们，但是，它们却无法赋值给first和second，因为final声明为你提供了相同的安全性，而且这种格式更简洁明了<br>还有另外一个设计考虑，你确实希望客户端程序员改变first或second所引用的对象，如果是这样的话，就强制程序员另外创建一个新的TwoTuple对象<br>我们可以利用继承机制实现长度更长的元组，下面的例子可以看到，增加类型参数是件很简单的事情<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeTuple</span>&lt;<span class="title">A</span>,<span class="title">B</span>,<span class="title">C</span>&gt; <span class="keyword">extends</span> <span class="title">TwoTuple</span>&lt;<span class="title">A</span>,<span class="title">B</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> C third;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreeTuple</span><span class="params">(A a,B b,C c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(a,b);</span><br><span class="line">        third=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">super</span>.toString()+third;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到下面的代码也可以编译通过，这两个代码定义的泛型的导出类是一样的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeTuple</span>&lt;<span class="title">D</span>,<span class="title">E</span>,<span class="title">C</span>&gt; <span class="keyword">extends</span> <span class="title">TwoTuple</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> C third;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreeTuple</span><span class="params">(D a,E b,C c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(a,b);</span><br><span class="line">        third=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">super</span>.toString()+third;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这表明了继承一个泛型类是，基类不一定要添加&lt;A,B&gt;这样的参数类型，导出类添加参数类型即可，实际上我们在定义导出类的泛型类型，而且参数类型只是一个占位符，名称无所谓，只要能够与内部的代码对应就好<br>元组代码测试<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TupleTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TwoTuple&lt;String,Integer&gt; <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span>  <span class="keyword">new</span> TwoTuple&lt;&gt;(<span class="string">"hi"</span>,<span class="number">46</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreeTuple&lt;Automobile,String,Integer&gt; <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span>  <span class="keyword">new</span> ThreeTuple&lt;&gt;(<span class="keyword">new</span> Automobile(),<span class="string">"hi"</span>,<span class="number">46</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      TwoTuple&lt;String,Integer&gt; ttsi=f();</span><br><span class="line">      System.out.print(ttsi);</span><br><span class="line">      ttsi.first=<span class="string">"can't change"</span></span><br><span class="line">      System.out.print(g());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="一个堆栈类"><a href="#一个堆栈类" class="headerlink" title="一个堆栈类"></a>一个堆栈类</h3><p>传统的下推堆栈，在之前的例子，我们是用一个LinkList实现的，LinkedListb本身具备了创建堆栈所需的所有方法<br>现在我们不用LinkedList，来实现自己的内部链式存储机制<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.generics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedStack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">U</span>&gt;</span>&#123;</span><br><span class="line">        U item;</span><br><span class="line">        Node&lt;U&gt; next;</span><br><span class="line">        Node()&#123;</span><br><span class="line">            item=<span class="keyword">null</span>;</span><br><span class="line">            next=<span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node(U item,Node&lt;U&gt; next)&#123;</span><br><span class="line">            <span class="keyword">this</span>.item=item;</span><br><span class="line">            <span class="keyword">this</span>.next=next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> item==<span class="keyword">null</span> &amp;&amp; next==<span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; top =<span class="keyword">new</span> Node&lt;T&gt;();<span class="comment">//哨兵</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T item)</span></span>&#123;</span><br><span class="line">        top=<span class="keyword">new</span> Node&lt;T&gt;(item,top);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        T result = top.item;</span><br><span class="line">        <span class="keyword">if</span>(!top.end())&#123;</span><br><span class="line">            top=top.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        LinkedStack&lt;String&gt; list=<span class="keyword">new</span> LinkedStack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String s:<span class="string">"Phasers on stun!"</span>.split(<span class="string">" "</span>))&#123;</span><br><span class="line">            list.push(s);</span><br><span class="line">        &#125;</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span>((s=list.pop())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到内部类Node也是一个泛型，它拥有自己的参数类型</p>
<h3 id="RandomList"><a href="#RandomList" class="headerlink" title="RandomList"></a>RandomList</h3><p>作为另一个例子，假设我们需要一个特定类型对象的列表，每次调用其上的select()方法时，它可以随机地选取一个元素，如果我们希望以此构建一个可以应用与各种类型的对象的工具，就需要泛型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;T&gt; storage=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Random random=<span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T item)</span></span>&#123;storage.add(item);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">select</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> storage.get(random.nextInt());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        RandomList&lt;String&gt; rs=<span class="keyword">new</span> RandomList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String s:<span class="string">"the queue broken brown fox"</span>.split(<span class="string">" "</span>))&#123;</span><br><span class="line">            rs.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            System.out.println(rs.select());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>泛型也可以应用于接口，例如生成器，这是一种专门负责创建对象的类，实际上，这是工厂方法设计模式的一种应用，不过，当使用生成器创建新的对象时，它不需要任何参数，而工厂方法需要参数，也就是说，生成器无需额外的信息就知道如何创建对象，<br>一般而言，一个生成器只定义一个方法，该方法用于产生新的对象，在这里就是next()方法<br><code>public interface Generator&lt;T&gt; {
    T next();
}</code><br>首先我们先创建一个Coffee类及其子类，我们将创建一个生成咖啡的生成器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id =counter++;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName()+id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Latte</span> <span class="keyword">extends</span> <span class="title">Coffee</span></span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mocha</span> <span class="keyword">extends</span>  <span class="title">Coffee</span></span>&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cappuccino</span> <span class="keyword">extends</span> <span class="title">Coffee</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Americano</span> <span class="keyword">extends</span> <span class="title">Coffee</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>在创建一个实现了生成器泛型接口和迭代器的coffee生成器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoffeeGenerator</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">Coffee</span>&gt;,<span class="title">Iterable</span>&lt;<span class="title">Coffee</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class[] types=&#123;Latte.class,Cappuccino.class,Americano.class,Mocha.class&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random random=<span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CoffeeGenerator</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CoffeeGenerator</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;size=a;&#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CoffeeIterator</span> <span class="keyword">implements</span>  <span class="title">Iterator</span>&lt;<span class="title">Coffee</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> counter=<span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> counter&gt;<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Coffee <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            counter--;</span><br><span class="line">            <span class="keyword">return</span> CoffeeGenerator.<span class="keyword">this</span>.next();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Coffee&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CoffeeIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Coffee <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Coffee) types[random.nextInt(types.length)].newInstance();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        CoffeeGenerator gen=<span class="keyword">new</span> CoffeeGenerator();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.out.println(gen.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们再来看下实现Generator泛型接口的另一个实现 Fibonacci数列<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fibonacci</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">next</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> fib(count++); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> fib(n-<span class="number">2</span>)+fib(n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们还想要更近一步，编写一个实现了Itearable的Fibonacci生成器，我们的第一个选择是重写这个类，可是我们并不是总能拥有代码的控制权，并且除非必要，我们也不愿重写代码，我们还有另一种选择，那就是创建一个适配器（adapter）来实现所需要的接口，有很多方法可以实现适配器模式，我们先来看看第一种吧，通过继承实现适配<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FibonacciAdapter</span> <span class="keyword">extends</span> <span class="title">Fibonacci</span> <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FibonacciAdapter</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;<span class="keyword">this</span>.n=n;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Integer&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;Integer&gt;()&#123;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> n&gt;<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                n--;</span><br><span class="line">                <span class="keyword">return</span> FibonacciAdapter.<span class="keyword">this</span>.next();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Integer i:<span class="keyword">new</span> FibonacciAdapter(<span class="number">10</span>))&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>泛型可以应用到整个类上，但同样的也可在类中包含参数化方法，这个方法所在的类可以是泛型类，也可以不是，也就是说，是否用于泛型方法，与其所在的类是否是泛型没有关系<br>一个基本的指导原则是：无论何时，只要你能做到，你就应该尽量使用泛型方法，也就是说，如果使用泛型方法可以取代将整个类泛型话，那么就应该值使用泛型方法，因为它可以使事情更清除明白，<strong>另外，对于一个static的方法而言，无法访问类的类型参数，所以，如果static方法需要使用泛型能力的话，就必须称为泛型方法</strong><br><strong>要定义泛型方法，只需要将泛型参数列表置于返回值之前</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericMothed</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">        System.out.println(x.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        GenericMothed gm=<span class="keyword">new</span> GenericMothed();</span><br><span class="line">        gm.f(<span class="string">""</span>);</span><br><span class="line">        gm.f(<span class="number">1</span>);</span><br><span class="line">        gm.f(<span class="number">1.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的GenericMothed类不是泛型类，尽管这个类和其内部的方法可以被同时参数化，<strong>在使用泛型类时，必须在创建对象的时候指定类型参数的值，而使用泛型方法的时候，通常不必指明参数类，因为编译器会为我们找出具体的类型，这被称为类型参数推断（type argument inference）</strong></p>
<h3 id="杠杆利用类型参数推断"><a href="#杠杆利用类型参数推断" class="headerlink" title="杠杆利用类型参数推断"></a>杠杆利用类型参数推断</h3><p>以前我们在使用泛型的时候，总是会抱怨需要向程序中添加更多的代码，现在编译器可以使得我们能够省略到对泛型参数列表的重复了，我们看下之前我们的代码的例子<br>    Map&lt;Person,List&lt;? extends Pet&gt;&gt; map=new HashMap&lt;Person,List&lt;? extends Pet&gt;&gt;();<br>现在可以这样写<br>    Map&lt;Person,List&lt;? extends Pet&gt;&gt; map=new HashMap&lt;&gt;();<br>参数类型推断也可以用在泛型方法中  下面的例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">New</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="function">Map&lt;K,V&gt; <span class="title">map</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HashMap&lt;K,V&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">list</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Map&lt;String,Integer&gt; map=New.map();</span><br><span class="line">        List&lt;String&gt; list=New.list();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>类型参数推断避免了重复的泛型参数列表<br>类型参数推断只对赋值有效，其他时候并不起作用，如果将一个泛型方法调用的结果作为参数，传递给另一个方法，这时编译器并不会执行类型推断，在这种情况下，编译器认为，调用泛型方法后，其返回值被赋给列哦一个Object类型的变量，<br>    f(New.map())//does not compile<br>应该这样说，编译器之所以能够进行类型推断的一个基本的条件是，编译器能够获得泛型参数的信息，将泛型方法的返回值直接赋给一个泛型类引用，可以通过这个泛型类引用的类型参数推断出泛型方法的泛型参数，但是如果将泛型方法的返回值直接传递给一个方法，编译器得不到指导  </p>
<h3 id="显示的类型说明"><a href="#显示的类型说明" class="headerlink" title="显示的类型说明"></a>显示的类型说明</h3><p>在泛型方法中，可以显式地指明类型，不过这种语法比较少见，<strong>要显示地指明类型，必须在点操作符与方法名之间插入尖括号，然后把类型置于尖括号内如果是在定义该方法的类的内部，必须在点操作符之前使用this关键字，如果是使用static的方法，必须在点操作符之前加上类名</strong><br>    f(New.&lt;String,Integer&gt;map());</p>
<h3 id="可变参数列表与泛型方法"><a href="#可变参数列表与泛型方法" class="headerlink" title="可变参数列表与泛型方法"></a>可变参数列表与泛型方法</h3><p>泛型和可变参数列表能够很好地共存<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericVarargs</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">makeList</span><span class="params">(T... args)</span></span>&#123;</span><br><span class="line">        List&lt;T&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(T item:args)&#123;</span><br><span class="line">            list.add(item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; ls=makeList(<span class="string">"A"</span>);</span><br><span class="line">        System.out.println(ls);</span><br><span class="line">        ls=makeList(<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>);</span><br><span class="line">        ls=makeList(<span class="string">"ABCDRFGHIJKMLNOPQRST"</span>.split(<span class="string">""</span>));</span><br><span class="line">        System.out.println(ls);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="用于Generator的泛型方法"><a href="#用于Generator的泛型方法" class="headerlink" title="用于Generator的泛型方法"></a>用于Generator的泛型方法</h3><p>下面的程序为任何类构造一个Generator，只要该类有没默认的构造器，并且构造器可访问<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicGenerator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; type;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BasicGenerator</span><span class="params">(Class&lt;T&gt; type)</span></span>&#123;</span><br><span class="line">        type=type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> type.newInstance();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Generator&lt;T&gt; <span class="title">create</span><span class="params">(Class&lt;T&gt; type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> BasicGenerator&lt;&gt;( type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面我们创建一个具有默认构造器的类，来测试上面的泛型生成器（generator<t>）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id=count++;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CounterObject</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">id</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> id;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">"CounterObject"</span>+id;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicGenertorDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Generator&lt;CounterObject&gt; gen=BasicGenerator.create(CounterObject.class);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            gen.next();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="一个Set实用工具"><a href="#一个Set实用工具" class="headerlink" title="一个Set实用工具"></a>一个Set实用工具</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sets</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Set&lt;T&gt; <span class="title">union</span><span class="params">(Set&lt;T&gt; a,Set&lt;T&gt; b)</span> </span>&#123;</span><br><span class="line">        Set&lt;T&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;(a);</span><br><span class="line">        result.addAll(b);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Set&lt;T&gt; <span class="title">intersection</span><span class="params">(Set&lt;T&gt; a,Set&lt;T&gt; b)</span></span>&#123;</span><br><span class="line">        Set&lt;T&gt; result =<span class="keyword">new</span> HashSet&lt;&gt;(a);</span><br><span class="line">        result.retainAll(b);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Set&lt;T&gt; <span class="title">different</span><span class="params">(Set&lt;T&gt; superSet,Set&lt;T&gt; subSet)</span></span>&#123;</span><br><span class="line">        Set&lt;T&gt; result=<span class="keyword">new</span> HashSet&lt;&gt;(superSet);</span><br><span class="line">        result.removeAll(subSet);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Set&lt;T&gt; <span class="title">complement</span><span class="params">(Set&lt;T&gt; a,Set&lt;T&gt; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> different(union(a,b),intersection(a,b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>泛型还可以应用于内部类和匿名内部类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id =counter++;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Customer</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">"Customer"</span>+id;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Generator&lt;Customer&gt; <span class="title">generator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Generator&lt;Customer&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Customer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Customer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teller</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id=counter++;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Teller</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">"Teller"</span>+id;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Generator&lt;Teller&gt; <span class="title">create</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Generator&lt;Teller&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Teller <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Teller();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="构建复杂模型"><a href="#构建复杂模型" class="headerlink" title="构建复杂模型"></a>构建复杂模型</h2><p>泛型的一个重要好处就是能够简单而安全地创建复杂的模型，例如我们很容易地创建元组列表这样的结构<br>    class TupleList&lt;A,B,C,D&gt; extends List&lt;FourTuple&lt;A,B,C,D&gt;&gt;{}<br>下面这个示例，展示了使用泛型来创建复杂模型是多么简单，即使每个类都作为一个构建块创建，但是其整个还是包含很多部分，在这个例子中，构建一个零售商，它包含走廊，货架和商品<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Product</span><span class="params">(<span class="keyword">int</span> IDNumber,String descr,<span class="keyword">double</span> price)</span></span>&#123;</span><br><span class="line">        id= IDNumber;</span><br><span class="line">        description=descr;</span><br><span class="line">        price=price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id+<span class="string">":"</span>+description+price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">priceChange</span><span class="params">(<span class="keyword">double</span> price)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price=price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Generator&lt;Product&gt; generator=<span class="keyword">new</span> Generator&lt;Product&gt;() &#123;</span><br><span class="line">        <span class="keyword">private</span> Random rand=<span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Product <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Product(rand.nextInt(<span class="number">1000</span>),<span class="string">"Test"</span>,Math.round(rand.nextDouble()*<span class="number">1000</span>)+<span class="number">0.99</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shelf</span> <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">Product</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Shelf</span><span class="params">(<span class="keyword">int</span> nProduct)</span></span>&#123;</span><br><span class="line">        Generators.fill(<span class="keyword">this</span>,Product.generator,nProduct);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Aisle</span> <span class="keyword">extends</span>  <span class="title">ArrayList</span>&lt;<span class="title">Shelf</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Aisle</span><span class="params">(<span class="keyword">int</span> nShives,<span class="keyword">int</span> nProduct)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nShives;i++)&#123;</span><br><span class="line">            add(<span class="keyword">new</span> Shelf(nProduct));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Checkoutstand</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Office</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Store</span> <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">Aisle</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Checkoutstand&gt; checkoutstands= <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Office&gt; offices=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Store</span><span class="params">(<span class="keyword">int</span> nAisles,<span class="keyword">int</span> nShives,<span class="keyword">int</span> nProduct)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nAisles;i++)&#123;</span><br><span class="line">            add(<span class="keyword">new</span> Aisle(nShives,nProduct));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuilder stb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(Aisle aisle:<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(Shelf shelf:aisle)&#123;</span><br><span class="line">                <span class="keyword">for</span>(Product product:shelf)&#123;</span><br><span class="line">                    stb.append(product.toString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="擦除的神秘之处"><a href="#擦除的神秘之处" class="headerlink" title="擦除的神秘之处"></a>擦除的神秘之处</h2><p>当开始真正研究泛型的时候，会发现大量的东西初看起来是没有任何意义的，例如，尽管可以声明ArrayList.class。但是不能声明ArrayList<integer>.class 再看下面的例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErasedTypeEquivalence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Class c1=<span class="keyword">new</span> ArrayList&lt;String&gt;().getClass();</span><br><span class="line">        Class c2=<span class="keyword">new</span> ArrayList&lt;Integer&gt;().getClass();</span><br><span class="line">        System.out.println(c1==c2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></integer></p>
<p>ArrayList<string>与ArrayList<integer>很容易被认为是不同的类型，不同的类型在行为上肯定不同，比如尝试将一个Integer放入一个ArrayLIst<string>中，但是上面的程序确实认为它们是相同的<br>我们再来看一个例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Frob</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quark</span>&lt;<span class="title">Q</span>&gt;</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LostInformation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Map&lt;String,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Quark&lt;Frob&gt; quark=<span class="keyword">new</span> Quark&lt;&gt;();</span><br><span class="line">        System.out.println(Arrays.toString(list.getClass().getTypeParameters()));</span><br><span class="line">        System.out.println(Arrays.toString(map.getClass().getTypeParameters()));</span><br><span class="line">        System.out.println(Arrays.toString(quark.getClass().getTypeParameters()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*output</span></span><br><span class="line"><span class="comment">[E]</span></span><br><span class="line"><span class="comment">[K,V]</span></span><br><span class="line"><span class="comment">[Q]</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></string></integer></string></p>
<p>根据JDK文档的描述，<strong><code>Class.getTypeParameters()</code>将“返回一个TypeVariable对象数组”,表示有泛型声明所声明的类型参数…</strong>，这就好像是在暗示你可能发现参数类型的信息，但是，正是正如我们所看到的，我们发现的只是作为参数占位符的标识符，这并非是有用的信息<br>我的理解是，如果在我们第一次创建泛型类的对象的时候，传递给它的构造器一个参数类型，在这个类加载生成Class对象里能够保存这个参数类型的信息就好了，可是我们看到，事实并不是这样<br>因此，残酷的现实是：<br><strong>在泛型代码内部，无法获得任何关于泛型参数类型的信息</strong><br>你可以知道诸如类型参数标记和泛型类型边界这类的信息——你却无法知道用来创建某个特定实例的实际的类型参数<br>java泛型是使用擦除来实现的，这意味着当你在使用泛型时，任何具体的类型信息都被擦除了</p>
<h3 id="C-的方式"><a href="#C-的方式" class="headerlink" title="C++的方式"></a>C++的方式</h3><p>下面是使用模板的C++示例<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Manipulate</span>&#123;</span></span><br><span class="line"> T obj;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Manipulate(T x)&#123;obj=x;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">mainpulate</span><span class="params">()</span></span>&#123;obj.f();&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasF</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"HasF::f()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  HasF hf;</span><br><span class="line">  manipulate&lt;HasF&gt; manipulate(hf)；</span><br><span class="line">  manipulate.manipulate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*output</span></span><br><span class="line"><span class="comment">HasF::f()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<p>Manipulate类存储了一个类型T的对象，有意思的地方是manipulate()方法，它在obj上调用f(),它怎么知道f()方法时为类型参数T而存在的呢？当你实例化一个模板时，C++编译器将会进行检查，因此在Manipulate<hasf>被实例化的那一刻，它看到HasF拥有一个f()方法，否则，就会得到一个编译器错误，这样类型安全就会得到保障<br>我们可以将上面的代码用java的方式重写一次，可是这会出现问题，因此擦除的原因，代码内部并不清楚参数类型是什么？我们就没办法去编写类似obj.f()这样的代码<br>为了能够调用f()，我们必须帮助泛型类，给定泛型类的边界，以表示编译器只能接受遵循这个边界的类型，有可以保证给泛型关于参数类型的信息，<br>在这里我们重用extends这个关键字<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manipulate</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">HasF</span>&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> T obj;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Manipulate</span><span class="params">(T x)</span></span>&#123;obj=x;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">manipulate</span><span class="params">()</span></span>&#123;obj.f();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></hasf></p>
<p>边界<t extends="" hasf=""> 声明T必须具有类型HasF或者从HasF导出的类，如果情况确实如此，就可以安全地使用obj.f()了<br>我们说泛型参数将擦除到它的第一个边界（它可能会有多个边界），我们还提到了类型参数的擦除，编译器实际上会把类型参数替换为它的擦除，就像上面的例子一样，T擦除到了HasF，就好像在类的声明中用HasF替换了T一样<br>我们有看到了，在上面的一个提过了泛型的例子好像并没有贡献什么好处，只需要很容易地自己去执行擦除，就可以创建没有泛型的类，而且代码也比较泛化，看下一个我们主动执行擦除的例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manipulate</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> HasF obj;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Manipulate</span><span class="params">(HasF x)</span></span>&#123;obj=x;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">manipulate</span><span class="params">()</span></span>&#123;obj.f();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></p>
<p>这给来哦我们很重要的启示，<strong>只有当你希望使用的类型参数比某个具体类型（以及它所有的子类类型）更加“泛化”的时——也就是说，当你希望代码能够跨越多个类工作时，使用泛型才有所帮助</strong><br><strong>但是</strong>，我们也不要认为<t extends="" hasf="">形式的任何东西都是有缺陷的，例如，如果某个类有一个返回T的方法，那么泛型就会非常有用，因为在使用这个泛型类的时候，泛型参数给了编译器提示，编译器很容易会将T转换为我们使用泛型时指定的参数类型，可以帮助我们很轻松的解决返回值的转型问题  </t></p>
<h3 id="迁移兼容性"><a href="#迁移兼容性" class="headerlink" title="迁移兼容性"></a>迁移兼容性</h3><p>为了减少潜在的关于擦除的混淆，你必须清楚地认识到这不是一个语言特性，它是java的泛型实现的一种折中，因为泛型不是java语言出现时就有的组成部分，所以这种折中是必须的，虽然它会让你很痛苦<br>擦除减少了泛型的泛化性，泛型在java中仍然有用，但是不如它们本来设想的那么有用，而原因就是擦除<br>在基于擦除的实现中，泛型类型被当作第二类类型处理，即不能在某些重要的上下文环境中使用的类型，<strong>泛型类型只有在静态类型检查期间才出现，在此之后，程序中的所有泛型类型都被擦除，替换为它们的非泛型上界</strong>，例如List<t>这样的类型注解将被擦除为List,而普通的类型变量在未指定边界的情况下将被擦除为Object<br><strong>擦除的核心动机是它使得泛化的客户端可以用非泛化的类库来使用，反之亦然，这经常被称为“迁移兼容性”</strong> 在现实中，即使程序员只编写泛型代码，他们也必须处理在Java SE5之前编写的非泛化类库，这些类库饿作者可能从没想过要泛化它们的代码，或者可能刚刚接触泛型<br><strong>因此java泛化不仅必须支持向后兼容性，即现有的代码和类文件仍旧合法 </strong>（这句话的意思是，在泛化之前出现的类库，那些代码并没有考虑使用泛化的情况，如果我们为了使用泛化，那么就无法使用之前以及创建好的而且很成熟的类库了，为了增加泛化特性，就要抛弃以往已经被实践所验证的代码库，即使是对现有代码库进行修改这样代价也太大了）</t></p>
<h3 id="擦除的问题"><a href="#擦除的问题" class="headerlink" title="擦除的问题"></a>擦除的问题</h3><p>因此，擦除主要的正当理由是从非泛化代码到泛化代码的转变过程，以及在不随意破坏现有类库的情况下，将泛型融入到java语言，擦除使得现有的非泛型客户端代码能够在不改变的情况下继续使用，直至客户端准备好用泛型重写这些代码，这是一个崇高的动机，因为它不会破坏所有现有的代码<br>擦除的代价是显著的，<strong>泛型不能被显式地被引用至运行时类型的操作之中</strong>，例如转型，instanceOf操作和new表达式，因为所有有关参数的类型信息都丢失了，无论何时，<strong>当你在编写泛型代码的时候，必须时刻提醒自己，你只是看起来好像拥有有关参数的类型信息而已</strong><br>    Foo<cat> foo=new Foo<cat>();<br>class Foo中代码应该知道现在工作于Cat之上，而泛型语法也在强烈地暗示，在整个类的各个地方，类型都在被替换，<strong>但是事实并非如此</strong>，无论何时，当你编写这个代码的时，时刻提醒自己“不，它只是个Object”<br>另外，擦除和迁移兼容性意味着，使用泛型并不是强制的，尽管你可能希望这样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericBasic</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T element;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  T <span class="title">getElement</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> element;&#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setElement</span><span class="params">(T x)</span></span>&#123;element=x;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived1</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">GenericBasic</span>&lt;<span class="title">T</span>&gt;</span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived2</span> <span class="keyword">extends</span> <span class="title">GenericBasic</span></span>&#123;&#125; <span class="comment">//no Warning没有警告</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErasuereAndInheritance</span> </span>&#123;</span><br><span class="line">    Derived2 d2=<span class="keyword">new</span> Derived2();</span><br><span class="line">    Object obj=d2.getElement();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//d2.set(obj) //warning here  在这里警告</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></cat></cat></p>
<h3 id="边界处的动作"><a href="#边界处的动作" class="headerlink" title="边界处的动作"></a>边界处的动作</h3><p>正因为有了擦除，泛型最令人困惑的方面源于这样一个事实，即可以表示没有任何意义的事物 ，例如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayMaker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; type;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayMaker</span><span class="params">(Class&lt;T&gt; type)</span></span>&#123;type=type;&#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    T[] create(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">return</span> (T[])Array.newInstance(type,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ArrayMaker&lt;String&gt; stringMaker=<span class="keyword">new</span> ArrayMaker&lt;&gt;(String.class);</span><br><span class="line">        String[] stringArray=stringMaker.create(<span class="number">10</span>);</span><br><span class="line">        System.out.println(Arrays.toString(stringArray));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[null,null,null,null,null,null,null,null,null,null]</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
<p>即使type被存储为Class<t>,**擦除也意味着它将被存储为Class,没有任何参数，因此，当你使用它的时候，例如在创建数组时，Array.newInstance()实际上并未拥有kind所蕴含的类型信息，因此它不会产生具体的结果，所以必须转型，这将产生一条令你无法满意的警告<br>注意，对于在泛型中创建数组，使用Array.newInstance()是推荐的方式<br>如果我们要创建一个容器而不是一个数组，情况就有些不同了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListMaker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">create</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//指定了参数类型，实际上就是给了编译器的一个指示，以使得编译期的静态类型检查和转型代码的插入</span></span><br><span class="line">        ListMaker&lt;String&gt; listMaker=<span class="keyword">new</span> ListMaker&lt;T&gt;();</span><br><span class="line">        List&lt;String&gt; list=listMaker.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></p>
<p>编译器不会给出任何警告，尽管我们知道在create()内部的new ArrayList<t>的T被移除了——在运行时，这个类的内部没有任何<t>,因此看起来毫无意义，但是如果你遵从这种思路，并将这个表达式改为new ArrayList()编译器就会给出警告<br>是否真的毫无意义呢？如果返回list之前，将某些对象放入其中，就像下面这样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilledListMaker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">create</span><span class="params">(T item,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        List&lt;T&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            list.add(item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        FilledListMaker&lt;String&gt; fl=<span class="keyword">new</span> FilledListMaker&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; list=fl.create(<span class="string">"hello"</span>,<span class="number">4</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></t></p>
<p><strong>即使，编译器无法知道有关create()中的T信息，但是它仍旧可以在编译期确保你放置到result中的对象具有T类型，使其合适ArrayList<t>,因此，即使擦除在方法或者类内部移除了有关实际类型的信息，编译器仍旧可以确保在方法或类中使用的类型的内部一致性</t></strong><br><strong>因为擦除在方法体中移除了类型信息，所以在运行时的问题就是边界，即对象进入和离开方法的地点，这些正是编译器在编译期执行类型检查并插入转型代码的地点</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObj</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> obj;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">(Object obj)</span></span>&#123;obj=obj;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以使用javap-c SimpleHolder反编译这个代码<br>我们再来看下下面的代码，除了类名和添加了类型参数之外，和上面的代码几乎完全一样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericHolder</span> &lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  T <span class="title">getObj</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> obj;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">(T x)</span></span>&#123;obj=x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        GenericHolder&lt;String&gt; gen =<span class="keyword">new</span> GenericHolder&lt;&gt;();</span><br><span class="line">        gen.setObj(<span class="string">"hello"</span>);</span><br><span class="line">        String str=gen.getObj();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们再来反编译上面的代码，可以看出，转型是在调用get()的时候接受检查的，从get()返回之后的转型消失，但是我们还知道传递给set()的值在编译期接收检查<br>从上面的例子，我们可以得出这样的结论，在使用泛型类的时候，指定参数类型信息，其实是给编译器一个指示，通过添加的参数类型信息，编译器在编译过程中，会主动进行类型检查和添加转型代码，但是在运行期，参数类型信息被擦除<br>所以在泛型中的所有动作都发生在边界处——对传递进来的值进行额外的编译期类型检查，并插入对传递出去的值的转型，这有助于我们澄清对擦除的混淆，记住，<strong>边界是发生动作的地方</strong></p>
<h2 id="擦除的补偿"><a href="#擦除的补偿" class="headerlink" title="擦除的补偿"></a>擦除的补偿</h2><p><strong>擦除丢失了在泛型代码中执行某些操作的能力，任何运行是需要知道确切类型信息的操作都无法工作</strong> 如下例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Erased</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE=<span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Object args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args <span class="keyword">instanceof</span> T)&#123;&#125;<span class="comment">//error</span></span><br><span class="line">        <span class="keyword">new</span> T();<span class="comment">//error</span></span><br><span class="line">        T[] array=<span class="keyword">new</span> T[SIZE];<span class="comment">//error</span></span><br><span class="line">        T[] array=(T) <span class="keyword">new</span> Object[SIZE];<span class="comment">//unckecked warning</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>偶尔可以绕开这些问题，<strong>但是有时必须通过引入类型标签来对擦除进行补偿，这意味着你需要显式地传递你的类型的Class对象，以便你可以在类型表达式中使用它</strong><br>如前面的例子中使用instanceof的尝试失败了，因为其类型信息已经被擦除了，如果引入类型标签，就可以转而使用动态的isInstance();<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassTypeCapture</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; type;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassTypeCapture</span><span class="params">(Class&lt;T&gt; type)</span></span>&#123;type=type;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">f</span><span class="params">(Object arg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  type.isInstance(arg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ClassTypeCapture&lt;String&gt; ct=<span class="keyword">new</span> ClassTypeCapture&lt;&gt;(String.class);</span><br><span class="line">        <span class="keyword">boolean</span> b=ct.f(<span class="string">"hello"</span>);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译器将确保类型标签可以匹配任何泛型参数</p>
<h3 id="创建类型实例"><a href="#创建类型实例" class="headerlink" title="创建类型实例"></a>创建类型实例</h3><p><strong>在Erased.java中创建一个new T()的尝试将无法实现，部分原因是因为擦除，而另一部分原因是因为编译器不能验证T具有默认（无参）构造器</strong><br>在C++中，这种操作是很自然且直观的因为它在编译期受到检查<br>java中的解决办法是传递一个工厂对象，并用它来创建新的实例，最便利的工厂对象就是Class对象，因此如果使用类型标签，那么你就可以使用new Instance（）来创建这个类型的新对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassAsFactory</span> &lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T x;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassAsFactory</span><span class="params">(Class&lt;T&gt; type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            x = type.newInstance();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstantiateGenericType</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ClassAsFactory&lt;Employee&gt; fe=<span class="keyword">new</span> ClassAsFactory&lt;&gt;(Employee.class);</span><br><span class="line">        System.out.println(<span class="string">"ClassAsFactory&lt;Employee&gt; succeeded"</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ClassAsFactory&lt;Integer&gt; ci=<span class="keyword">new</span> ClassAsFactory&lt;&gt;(Integer.class);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"ClassAsFactory&lt;Integer&gt; failed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这可以编译，但是会因为ClassAsFactory<integer>而失败，因为Integer没有默认构造器，因为这个错误不是在编译器捕获的，所以这种方式使用泛型创建对象并不太好，我们没有尽最大的努力将错误隔绝在编译期，<br>Sun建议使用显式的工厂，并限制其类型，使得只能接受实现了这个工厂的类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">FactoryI</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo2</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T x;</span><br><span class="line">    <span class="keyword">public</span> &lt;F extends FactoryI&lt;T&gt;&gt; Foo2(F factory)&#123;<span class="comment">//这里是重点，确保传递的参数必须是那些可向上转型为FactoryI的的类型</span></span><br><span class="line">        x=factory.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntegerFactory</span> <span class="keyword">implements</span> <span class="title">FactoryI</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;  <span class="comment">//这些类都实现料Factory接口，使得对象的创建得到了保证</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span>  Integer <span class="title">create</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> Integer(<span class="number">0</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">FactoryI</span>&lt;<span class="title">Widget</span>&gt;</span>&#123;  <span class="comment">//Widget.Factory也是实现了FcatoryI的接口</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Widget <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Widget();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryConstraint</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Foo2&lt;Integer&gt;(<span class="keyword">new</span> IntegerFactory());</span><br><span class="line">        <span class="keyword">new</span> Foo2&lt;Widget&gt;(<span class="keyword">new</span> Widget.Factory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></integer></p>
<p>注意，这确实是传递Class<t>的一种变体，两种方式都传递了工厂对象，Class<t>碰巧是内建的工厂对象，而上面的方式创建了一个显式的工厂对象，但是你却获得了编译器检查<br>另一种方式是模板方法设计模式，在这个示例中，get是模板方法，而create()是在子类中定义的，用来产生子类类型的对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericWithCreate</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> T element;</span><br><span class="line">    GenericWithCreate()&#123;</span><br><span class="line">        element=create();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> T <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Creator</span> <span class="keyword">extends</span> <span class="title">GenericWithCreate</span>&lt;<span class="title">X</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">X <span class="title">create</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> X();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(element.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreatorGeneric</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Creator creator= <span class="keyword">new</span> Creator();<span class="comment">//在创建导出类对象的时候,element就得到了初始化，</span></span><br><span class="line">        creator.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></t></p>
<h3 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h3><p>Erased.java看到，不能创建泛型数组，一般的解决办法是在任何想要创建泛型数组的地方都使用ArrayList<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListOfGeneric</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; array=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T item)</span></span>&#123;</span><br><span class="line">        array.add(item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> array.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是有时你仍然想要创建泛型类型的数组，<br>数组将会跟着它们的实际类型，而这个类型是在数组被创建时确定的，因此，即使gia已经被转型为Generic<integer>[],但是这个信息只存在与编译器，在运行时，它仍然是Object数组，而这将会引起问题，成功创建泛型数组的唯一方式就是创建一个被擦除类型的新数组，然后对其转型<br>因为有了擦除，数组在运行时类型就只能是Object[],如果我们立即将其转型为T[]，那么在编译器该数组的实际类型就会丢失，而编译器可能会错过某些潜在的错误检查，正因这样，最好是在集合内部使用Object[]，然后当你使用数组元素时，添加一个对T的转型，让我们看下面这个例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericArray2</span> &lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] array;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericArray2</span><span class="params">(<span class="keyword">int</span> sz)</span></span>&#123;</span><br><span class="line">        array=<span class="keyword">new</span> Object[sz];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> index,T item)</span></span>&#123;</span><br><span class="line">        array[index]=item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"Unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;<span class="keyword">return</span> (T)array[index];&#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"Unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> T[] rep()&#123;</span><br><span class="line">        <span class="keyword">return</span> (T[])array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        GenericArray2&lt;Integer&gt; gia=<span class="keyword">new</span> GenericArray2&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            gia.put(i,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.out.println(gia.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Integer[] ia=gia.rep();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></integer></p>
<p>初看起来没什么太多变化，只是转型挪了地方，如果没有@SuppressWranings注解，你依然会得到unchecked警告，但是，现在的内部表示是Object而不是T[],<strong>当get()被调用的时，它将对象转型为T,这实际上是正确的类型，因此也是安全的，然而，如果你调用rep()，它还是尝试着将Object数组转型为T[],这仍旧不正确的，将在编译器生成警告，在运行时产生异常，因此，没有任何方式可以推翻底层的数组类型，它只能是Object[],</strong>在内部将array当作Object[]而不是T[]处理的优势是，我们不太可能忘记这个数组的运行时类型，从而意外地引入缺陷（尽管大多数也可能是所有这类缺陷都可以在运行时快速地探测到）<br>对于新代码，应该传递一个类型标记，在这种情况下，GenericArray看起来应该像下面这样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericArrayWithToken</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"Unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericArrayWithToken</span><span class="params">(Class&lt;T&gt; type,<span class="keyword">int</span> sz)</span></span>&#123;</span><br><span class="line">        array=(T[]) Array.newInstance(type,sz);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> index,T item)</span></span>&#123;</span><br><span class="line">        array[index]=item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T[] rep()&#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        GenericArrayWithToken&lt;Integer&gt; gia=<span class="keyword">new</span> GenericArrayWithToken&lt;&gt;(Integer.class,<span class="number">10</span>);</span><br><span class="line">        Integer[] ia=gia.rep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意，Class<t>被传递到构造器，以便从擦除中恢复，使得我们可创建需要的实际类型的数组</t></strong>，由此，也可以看出，rep()返回的数组被Integer[]捕获在运行期也没有问题，因为数组底层是type类型的元素，数组的创建也是以type为元素类型创建的，所以没有任何问题，所有从这里也可以看出来，数组类型和数组元素类型是不相同的两个概念</p>
<h2 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h2><p><strong>边界使得你可以在用于泛型的参数类型上设置限制条件，尽管这样使得你可以强制规定泛型可以应用的类型，但是潜在的一个更重要的效果是你可以按照自己的边界类型调用方法</strong><br><strong>因为擦除移除了类型信息，所有，可以用无界泛型参数调用的方法只是那些可以用Object调用的方法，但是，如果能够将这个参数限制为某个参数子集，那么你就可以用这些类型子集来调用方法，为了执行这种限制，java重用了extends关键字</strong>，对你来说有一点很重要，即要理解extends关键字在泛型边界上下文环境中和在普通情况下所具有的意义是完全不同的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">HasColor</span></span>&#123;</span><br><span class="line">    <span class="function">Color <span class="title">getColor</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Colored</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">HasColor</span>&gt;</span>&#123;</span><br><span class="line">    T item;</span><br><span class="line">    Colored(T item)&#123; item=item;&#125;</span><br><span class="line">    <span class="function">T <span class="title">getItem</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item;&#125;</span><br><span class="line">    <span class="function">Color <span class="title">getColor</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item.getColor();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dimnension</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x,y,z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColoredDimension</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Dimnension</span> &amp; <span class="title">HasColor</span>&gt;</span>&#123;</span><br><span class="line">    T item;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ColoredDimension</span><span class="params">(T item)</span></span>&#123;</span><br><span class="line">        item=item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">getItem</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item;&#125;</span><br><span class="line">    <span class="function">Color <span class="title">getColor</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item.getColor() ;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item.x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span></span>&#123;<span class="keyword">return</span>  item.y;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getZ</span><span class="params">()</span></span>&#123;<span class="keyword">return</span>  item.z;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Weight</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">weight</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solid</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Dimnension</span> &amp; <span class="title">HasColor</span> &amp; <span class="title">Weight</span>&gt;</span>&#123;</span><br><span class="line">    T item;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solid</span><span class="params">(T item)</span></span>&#123;</span><br><span class="line">        item=item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">getItem</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item;&#125;</span><br><span class="line">    <span class="function">Color <span class="title">getColor</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item.getColor();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item.x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">weight</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item.weight();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bounded</span> <span class="keyword">extends</span> <span class="title">Dimnension</span> <span class="keyword">implements</span> <span class="title">HasColor</span>,<span class="title">Weight</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Color <span class="title">getColor</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">weight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicBounds</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Solid&lt;Bounded&gt; solid=<span class="keyword">new</span> Solid&lt;&gt;(<span class="keyword">new</span> Bounded());</span><br><span class="line">        solid.getColor();</span><br><span class="line">        solid.weight();</span><br><span class="line">        solid.getX();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面是一个很简单的一个例子，我们创建里一个泛型类，这个泛型类能够接受的类型必须是 <code>extends Diamension &amp; HasColor &amp; Weight</code>的，这种对参数类型进行限定的方式，因为编译器的静态类型检查，我们可以很安全的使用这些基类或接口的方法<br>下面例子，看看如何在继承的每个层次上添加边界限制<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HoldItem</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    T item;</span><br><span class="line">    HoldItem(T item)&#123;</span><br><span class="line">        item=item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Colored2</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">HasColor</span>&gt; <span class="keyword">extends</span> <span class="title">HoldItem</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    Colored2(T item)&#123;<span class="keyword">super</span>(item);&#125;</span><br><span class="line">    <span class="function">Color <span class="title">getColor</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item.getColor();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColoredDimension2</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Dimnension</span> &amp; <span class="title">HasColor</span>&gt; <span class="keyword">extends</span> <span class="title">Colored</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">      ColoredDimension2(T item)&#123;<span class="keyword">super</span>(item);&#125;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item.x;&#125;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span></span>&#123;<span class="keyword">return</span>  item.y;&#125;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getZ</span><span class="params">()</span></span>&#123;<span class="keyword">return</span>  item.z;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solid2</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Dimnension</span> &amp; <span class="title">HasColor</span> &amp; <span class="title">Weight</span>&gt; <span class="keyword">extends</span> <span class="title">ColoredDimension2</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    Solid2(T item)&#123;<span class="keyword">super</span>(item);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">weight</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item.weight();&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritBounds</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Solid2&lt;Bounded&gt; solid2=<span class="keyword">new</span> Solid2&lt;&gt;(<span class="keyword">new</span> Bounded());</span><br><span class="line">        solid2.getColor();</span><br><span class="line">        solid2.getX();</span><br><span class="line">        solid2.weight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>HoldItem持有一个对象，因此这种行为被继承到了Color2中，它也要求其参数与HasColor一致，</strong>或者说参数类型要与HoldItem的参数限定的保存一致，这样才能继承基类那些涉及到限定参数类型的方法</p>
<h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><p>我们首先先看一下数组的一种特殊行为，可以向导出类型的数组赋予基类型的数据引用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CovariantArrays</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Fruit[] fruits=<span class="keyword">new</span> Apple[<span class="number">10</span>];</span><br><span class="line">        fruits[<span class="number">0</span>] = <span class="keyword">new</span> Apple();</span><br><span class="line">        fruits[<span class="number">1</span>] = <span class="keyword">new</span> Jonathan();</span><br><span class="line">        <span class="comment">//runtime type is Apple[],not Fruit[] or Orange[]</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            fruits[<span class="number">0</span>]=<span class="keyword">new</span> Fruit();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123; System.out.println(e);&#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            fruits[<span class="number">0</span>]=<span class="keyword">new</span> Orange();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;System.out.println(e);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>main()第一行创建了一个Apple数组，并将其赋值给一个Fruit数组引用，这是有意义的，因为Apple也是一种Fruit，因此Apple数组应该也是Fruit数组<br><strong>但是，如果实际的数组类型是Apple[],你应该只能往里面放Apple或者Apple的子类型，这在编译器和运行期都可以工作</strong>，但是请注意，编译器允许你将Fruit放置到这个数组，这对于编译器是有意义的，因为它有一个Fruit引用——它有什么理由拒绝将Fruit对象或者任何从Fruit继承出来的对象呢放置到这个数组中呢？因此，编译期，这是允许的，但是，运行时的数组机制知道它处理的是Apple[],因此会向数组中放置异构类型是抛出异常<br>我的理解是这样的，数组和其他的对象是不同的，数组对象中的元素所在的内存空间就在数组对象的内存空间呢，当数组对象创建完成后数组的内存空间，所保存的元素的类型信息就已经定下来了，不能改变，那么这也保证了数组不能保存异构类型的元素<br>实际上，向上转型不适合用在这里，你真正做的是将一个数组赋值给另一个数组，数组行为应当是它可以持有其他对象，这里只是因为我们能够向上转型而已，所有很明显，数组对象可以保留有关它们包含的对象类型的规则，就好像数组对它们持有的对象是有意识的，因此在编译器检查和运行时检查之间，你不能滥用它们<br>对数组的这种滥用并不那么可怕，因为在运行时可以发现你已经插入了不正确的类型，<strong>但是泛型的主要目标之一就是将这种错误检测移到编译期</strong>，因此当我们试图使用泛型容器来替代数组时，会发生什么？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//compile error</span></span><br><span class="line">List&lt;Fruit&gt; fruit=<span class="keyword">new</span> ArrayList&lt;Apple&gt;()</span><br></pre></td></tr></table></figure></p>
<p>尽管你在第一次阅读这段代码时会认为：“不能讲一个Apple容器赋值给一个Fruit容器”，别忘了，<strong>泛型不仅和容器相关正确的说法是：“不能把一个涉及Apple的泛型赋给一个设计Fruit的泛型</strong>”，如果就像在数组中的情况一样，编译器对代码的了解足够多，可以确定所涉及的容器，那么它可能留有一些余地，但是它不知道任何有关这方面的信息，因此它拒绝向上转型，<strong>实际上，这里也不是向上转型—</strong>—Apple的List不是Fruit的List，Apple的List将持有Apple和Apple的子类型，而Fruit的List将持有任何类型的Fruit,诚然，这包括Apple，一个Apple的List，它仍然是Fruit的List，Apple的List在类型上不等价于Fruit的List,即使Apple是一种Fruit类型，我们还记得运行时类型信息讲过的<code>Class&lt;Number&gt; Nclass=Integer.class</code>会引发编译错误也是这个原因<br><strong>真正的问题是我们在谈容器的类型，而不是容器持有的类型</strong>，与数组不同，泛型没没有内建的协变类型，这是因为数组在语言上是完全定义的，因为可以内建了编译期和运行时的检查，但是，<strong>在使用泛型时，编译器和运行时系统都不知道你想用类型做些什么，以及应该采用什么样的规则</strong><br>但是有时你想要在两个类型之间建立某种类型的向上转型关系，这正是通配符所允许的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericAndCovariance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;? extends Fruit&gt; fruit=<span class="keyword">new</span> ArrayList&lt;Apple&gt;();</span><br><span class="line">        <span class="comment">//fruit.add(new Apple())编译错误</span></span><br><span class="line">        <span class="comment">//fruit.add(new Fruit());</span></span><br><span class="line">        <span class="comment">//fruit.add(new Object());</span></span><br><span class="line">        fruit.add(<span class="keyword">null</span>);<span class="comment">//legal but uninstersting</span></span><br><span class="line">        <span class="comment">// we know that it returns at least Fruit;</span></span><br><span class="line">        Fruit f = fruit.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>fruit类型现在是List&lt;? extends Fruit&gt;,你可以将其读作“具有任何从Fruit继承的类型的列表”，<strong>但是实际上， 并不意味着这个List将持有任何类型的Fruit</strong>，<strong>通配符引用的是明确的类型</strong>，<strong>因此它意味着“某种fruit引用没有指定的具体类型</strong>”，因此这个被赋值的List必须持有诸如Fruit或Apple这样的某种指定类型，但是为了向上转型为fruit，这个类型是什么并没有人关心<br>如果唯一的限制是这个List要持有某种具体的Fruit或Fruit的子类型，但是你实际上并不关系它是什么，那么你能用这样的List做什么呢？如果不知道List持有什么类型，那么你怎样才能安全地向其中添加对象呢？你不能，除非编译器而不是运行时系统可以阻止这种操作的发生（也就是说只有编译器阻止向其中添加对象，你添加对象的行为才是安全的，这也是为什么我们不能向List&lt;? extends Fruit&gt;这种类型的对象添加对象的原因，一切都是为了类型安全，我们无法容忍在添加之后，运行时才发现问题的这种情况的发生）<br>你可能认为，事情变得有点走极端了，因为现在你甚至不能向刚刚声明过将持有Apple对象的List中放置一个Apple对象了，是的，编译器并不知道这一点，List&lt;? extends Fruit&gt;可以合法地指向一个List<orange>,一旦指向这种类型的向上转型，你就会丢失掉向其中传递任何对象的能力，甚至Object也不行<br>一方面，如果你调用一个返回Fruit的方法，则是安全的，因为你知道在这个List中的任何对象都至少具有Fruit类型，因此编译器允许这么做 </orange></p>
<h3 id="编译器有多聪明"><a href="#编译器有多聪明" class="headerlink" title="编译器有多聪明"></a>编译器有多聪明</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompileIntelligence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;? extends Fruit&gt; fruits=<span class="keyword">new</span> ArrayList&lt;Apple&gt;();</span><br><span class="line">        Apple a=(Apple)fruits.get(<span class="number">0</span>);</span><br><span class="line">        fruits.contains(<span class="keyword">new</span> Apple());<span class="comment">//argument is "Object"</span></span><br><span class="line">        fruits.indexOf(<span class="keyword">new</span> Apple()); <span class="comment">//argument is "Object"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以看到，对contains()和indexOf()的调用，这两个方法都接受Apple对象作为参数，而这些调用都可以正常执行，这是否意味着编译器实际上将检查代码，以查看是否有某个特定的方法修改了它的对象？<br>通过查看ArrayList文档，我们发现，编译器并没有那么充满，尽管add()方法接受一个具有泛型参数类型的参数，但是contains()和indexOf()将接受一个Object类型的参数，因此当你指向一个ArrayList&lt;? extends Fruit&gt;时，add()的参数就变成了“？extends Fruit”(我在编辑add()方法的时候，确实IDE会提醒这个方法的参数是“？ extends Fruit”，这里的意思是：这个方法接受Fruit类型及其子类型的参数，从这个描述中看，编译器也不确定，接受的是哪个确切的类型，因为编译器对参数类型的信息了解的并不多，为了类型安全（编译期的静态类型检查），编译器拒绝接受任何类型的参数)<br>在使用contains()和indexOf()时，参数类型是Object，因此不涉及任何通配符，而编译器也将允许这个调用，这意味这个将由泛型类的设计来决定哪些调用是“安全”的，并使用Object类型作为其参数类型，<strong>为了在类型中使用了通配符的情况下禁止这类调用，我们需要在参数列表中使用类型参数</strong><br>我们来做个总结，当我们使用类似&lt;? extends Fruit&gt;这样的类型参数时，泛型类中那些在方法列表中不涉及类型参数的方法可以正常调用，而在参数列表中使用了类型参数的方法将会被编译器禁止调用<br>看下面是一个很简单的例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T item;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">(T item)</span></span>&#123;</span><br><span class="line">        item=item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T item)</span></span>&#123;item=item;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.equals(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Holder&lt;Apple&gt; apple=<span class="keyword">new</span> Holder&lt;&gt;(<span class="keyword">new</span> Apple);</span><br><span class="line">        Apple d=apple.get();</span><br><span class="line">        apple.set(<span class="keyword">new</span> Apple());</span><br><span class="line">        Holder&lt;? extends Fruit&gt; fruit=apple;</span><br><span class="line">        Fruit p=fruit.get();</span><br><span class="line">        d=(Apple) fruit.get();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Orange o = (Orange) fruit.get();<span class="comment">//可以，但是运行时类型转换异常</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//fruit.set(new Orange()); 参数列表中涉及到类型参数的方法不能调用</span></span><br><span class="line">        <span class="comment">//fruit.set(new Apple());</span></span><br><span class="line">        System.out.println(fruit.equals(d));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="逆变"><a href="#逆变" class="headerlink" title="逆变"></a>逆变</h3><p><strong>还可以走另外一条路，即使用超类型通配符，这里，可以声明通配符是由某个特定类的任意基类来界定，方法是指定&lt;? super MyClass&gt;，甚至或者使用类型参数&lt;? extends T&gt;</strong>（尽管你不能对泛型参数给出一个超类型边界，即不能声明<t super="" myclass="">）,<strong>这使得你可以安全地传递一个类型对象到泛型类型中</strong> 看下面一个例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperTypeWildcards</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeTo</span><span class="params">(List&lt;? <span class="keyword">super</span> Apple&gt; apples)</span></span>&#123;</span><br><span class="line">        apples.add(<span class="keyword">new</span> Apple());</span><br><span class="line">        apples.add(<span class="keyword">new</span> Jonathan());</span><br><span class="line">        <span class="comment">//apples.add(new Fruit()); //error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></p>
<p>从这例子看出&lt;? super Apple&gt;表明参数类型被指定为Apple的基类，因此泛型类的那些方法的参数列表就变为&lt;? super Apple&gt;，方法接受的类型是Apple的基类，Apple是下界，这样向这些方法传递Apple及其子类型是安全的，（Apple的基类都能接受，Apple及Apple的子类型更是不在话下）</p>
<p>因此你可能根据如何能够向一个泛型类型“写入”(传递给一个方法)，以及如何能够从一个泛型类型中“读取”（从一个方法中返回），来这手思考子类型边界&lt;? extends MyClass&gt;和超类型边界(&lt;? super MyClass&gt;)<br>超类型边界放松了在可以向方法传递参数上所作的限制<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericWriting</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">writeExact</span><span class="params">(List&lt;T&gt; list,T item)</span></span>&#123;</span><br><span class="line">        list.add(item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">writeWithSuperWildcard</span><span class="params">(List&lt;? <span class="keyword">super</span> T&gt; list,T item)</span></span>&#123;</span><br><span class="line">        list.add(item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> List&lt;Apple&gt; apples= <span class="keyword">new</span> ArrayList&lt;Apple&gt;();</span><br><span class="line">    <span class="keyword">static</span> List&lt;Fruit&gt; fruit =<span class="keyword">new</span> ArrayList&lt;Fruit&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        writeExact(apples,<span class="keyword">new</span> Apple());</span><br><span class="line">        writeExact(fruit,<span class="keyword">new</span> Apple());<span class="comment">//为什么，没有编译错误？</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        writeWithSuperWildcard(apples,<span class="keyword">new</span> Apple());</span><br><span class="line">        writeWithSuperWildcard(fruit,<span class="keyword">new</span> Apple());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        f1();</span><br><span class="line">        f2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在《编程思想》中，writeExact(fruit，new Apple())中指明这种方式有编译错误，found Fruit required Apple,但是为什么，我在编译器中没有发现任何编译错误的提示呢？难道是java之后的版本支持了向List<fruit>类型的引用，传递Apple?<br>回来再研究这个问题<br>下面的例子，作为对协变和通配符的一个复习<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericReading</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">readExact</span><span class="params">(List&lt;T&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> List&lt;Apple&gt; apples=Arrays.asList(<span class="keyword">new</span> Apple());</span><br><span class="line">    <span class="keyword">static</span> List&lt;Fruit&gt; fruits=Arrays.asList(<span class="keyword">new</span> Fruit());</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">     Apple a=readExact(apples);</span><br><span class="line">     Fruit f=readExact(fruits);</span><br><span class="line">     f=readExact(apples);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Reader</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">        <span class="function">T <span class="title">readExact</span><span class="params">(List&lt;T&gt; list)</span></span>&#123; <span class="keyword">return</span> list.get(<span class="number">0</span>);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Reader&lt;Fruit&gt; fruitReader=<span class="keyword">new</span> Reader&lt;&gt;();</span><br><span class="line">        Fruit f=fruitReader.readExact(fruits);</span><br><span class="line">        <span class="comment">//error raedFruit(List&lt;Fruit&gt;) cannot be applied to (Lisy&lt;Apple&gt;)</span></span><br><span class="line">        <span class="comment">//Fruit a=fruitReader.readExact(apples);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CovariantReader</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function">T <span class="title">readCovariant</span><span class="params">(List&lt;? extends T&gt; list)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        CovariantReader&lt;Fruit&gt; convariantRead=<span class="keyword">new</span> CovariantReader&lt;&gt;();</span><br><span class="line">        Fruit f=convariantRead.readCovariant(apples);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        f1();f2();f3()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></fruit></p>
<p>第1个方法readExact()使用了精确类型，因此如果使用了这个没有任何通配符的精确类型，就可以向List中写入和读取这个精确类型，另外，对于返回值，静态的泛型方法readExact()可以有效地“适应”每个方法调用，并能从List<apple>中返回一个Apple，从List<fruit>，返回一个Fruit,就像f1()看到的那样，因此，如果可以摆脱静态泛型方法，那么当只是读取时，就不需要协变类型了<br>但是，如果有个泛型类，那么当你创建这个类的实例时，要为这个类确定参数，就像在f2()中看到的那样，fruitReader实例可以从List<fruit>中读取一个Fruit，因为这就是它的确切类型，但是List<apple>还应该产生一个Fruit对象，而fruitReader不允许这么做<br>为了修正这个问题。CovariantReader.readCovariant()方法将接受List&lt;? extends T&gt;,因此，从这个列表读取一个T是安全的（你知道在这个列表中的所有对象至少是一个T，并且可能是从T导出的某种对象），在f3()中，你可以看到现在可以从List<apple><br>中读取Fruit了</apple></apple></fruit></fruit></apple></p>
<h3 id="无界通配符"><a href="#无界通配符" class="headerlink" title="无界通配符"></a>无界通配符</h3><p>无界通配符&lt;?&gt;看起来意味着“任何事物”，因此使用无界通配符好像等价于使用原生类型，事实上，编译器初看起来是支持这种判断的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnboundWildcards1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> List list1;</span><br><span class="line">    <span class="keyword">static</span> List&lt;?&gt; list2;</span><br><span class="line">    <span class="keyword">static</span> List&lt;? extends Object&gt; list3;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign1</span><span class="params">(List list)</span></span>&#123;</span><br><span class="line">        list1=list;</span><br><span class="line">        list2=list;</span><br><span class="line">        <span class="comment">//list3=list; warning:unchecked coversion</span></span><br><span class="line">        <span class="comment">//found List,Required: List&lt;? extends Object&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign2</span><span class="params">(List&lt;?&gt; list)</span></span>&#123;</span><br><span class="line">        list1=list;</span><br><span class="line">        list2=list;</span><br><span class="line">        list3=list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign3</span><span class="params">(List&lt;? extends Object&gt; list)</span></span>&#123;</span><br><span class="line">        list1=list;</span><br><span class="line">        list2=list;</span><br><span class="line">        list3=list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assign1(<span class="keyword">new</span> ArrayList());</span><br><span class="line">        assign2(<span class="keyword">new</span> ArrayList());</span><br><span class="line">        <span class="comment">//assign3(new ArrayList()); warning unchecked conversion found ArrayList Required:list&lt;? extends Object&gt;</span></span><br><span class="line">        assign1(<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">        assign2(<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">        assign3(<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">        List&lt;?&gt; wildList=<span class="keyword">new</span> ArrayList();</span><br><span class="line">        wildList=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        assign1(wildList);</span><br><span class="line">        assign2(wildList);</span><br><span class="line">        assign3(wildList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有很多情况都和你在这里看到的情况类似，即编译器很少关心使用的原生类型还是&lt;?&gt;。在这种情况中，&lt;?&gt;可以被认为是一种装饰，但是它仍旧是有价值的，<strong>因为实际上，它是在声明：我想要java的泛型来编写这段代码，我在这里并不是要用原生类型，但是在当前这种情况下，泛型参数可以持有任何类型</strong><br>下面一个示例展示了无界通配符的一个重要应用，<strong>当你在处理多个泛型参数时，有时允许一个参数可以是任何类型，因此为其他参数确定某种特定类型的这种能力很重要</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Unboundwildcards2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Map map1；</span><br><span class="line">    <span class="keyword">static</span> Map&lt;?,?&gt; map2;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;String,?&gt; map3;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign1</span><span class="params">(Map map)</span></span>&#123;</span><br><span class="line">        map1=map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign2</span><span class="params">(Map&lt;?,?&gt; map)</span></span>&#123;map2=map;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign3</span><span class="params">(Map&lt;String,?&gt; map)</span></span>&#123;map3=map;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        assign1(<span class="keyword">new</span> HashMap());</span><br><span class="line">        assign2(<span class="keyword">new</span> HashMap());</span><br><span class="line">        <span class="comment">//assign3(new HashMap());//warning</span></span><br><span class="line">        assign1(<span class="keyword">new</span> HashMap&lt;String,Integer&gt;());</span><br><span class="line">        assign2(<span class="keyword">new</span> HashMap&lt;String,Integer&gt;());</span><br><span class="line">        assign3(<span class="keyword">new</span> HashMap&lt;String,Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是，当你拥有的是全部的无界通配符时，就像在Map&lt;?,?&gt;中看到的那样，编译器看起来即无法将其与原生Map区分开了，另外，UnboundWildcard1.java展示了编译器处理List&lt;?&gt;和List&lt;? extends Object&gt;时是不同的<br>令人困惑的是，编译器并非总是关注像List&lt;?&gt;和List之间的这种差异，因此它们看起来就像是相同的事物，因为，事实上，由于泛型参数将擦除到它的第一边界，因此List&lt;?&gt;看起来等价于List<object>，而实际上也是List<object>——除非这些语句都不为真，List世家上表示“持有任何Object类型的原生List”，而List&lt;?&gt;表示“具有某种特定类型的非元素List,只是我们不知道那种类型是什么”<br>编译器何时才会关注原生类型和涉及无界通配符的类型之间的差异呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wildcards</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rawArgs</span><span class="params">(Holder holder,Object args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//holder.set(args);//warning unchecked call to set(T) as a member of the raw Holder</span></span><br><span class="line">       <span class="comment">// holder.set(new Wildcards());//simple warning</span></span><br><span class="line">        Object obj=holder.get();</span><br><span class="line">        <span class="comment">//can't do this; don't have any T</span></span><br><span class="line">        <span class="comment">//T t=holder.get();</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unboundedArgs</span><span class="params">(Holder&lt;?&gt; holder,Object args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//holder.set(args);error注意这里是直接错误而不是警告</span></span><br><span class="line">        <span class="comment">//set(captre of ?) in Holder&lt;capture of ?&gt;</span></span><br><span class="line">        <span class="comment">//can't do this; don't have any T</span></span><br><span class="line">        <span class="comment">//T t=holder.get();</span></span><br><span class="line">        <span class="comment">//ok but type information has been lost</span></span><br><span class="line">        Object obj=holder.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">exact1</span><span class="params">(Holder&lt;T&gt; holder)</span></span>&#123;</span><br><span class="line">        T t= holder.get();</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">exact2</span><span class="params">(Holder&lt;T&gt; holder,T args)</span></span>&#123;</span><br><span class="line">        holder.set(args);</span><br><span class="line">        T t = holder.get();</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">wildSubType</span><span class="params">(Holder&lt;? extends T&gt; holder,T args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//holder.set(args); error</span></span><br><span class="line">        T t= holder.get();</span><br><span class="line">        <span class="keyword">return</span>  t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">wildSupType</span><span class="params">(Holder&lt;? <span class="keyword">super</span> T&gt; holder,T args)</span></span>&#123;</span><br><span class="line">        holder.set(args);</span><br><span class="line">        <span class="comment">//T t=holder.get();error</span></span><br><span class="line">        Object obj=holder.get();<span class="comment">//but type information has been lost</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Holder raw =<span class="keyword">new</span> Holder&lt;Long&gt;();</span><br><span class="line">        <span class="comment">//or</span></span><br><span class="line">        raw=<span class="keyword">new</span> Holder();</span><br><span class="line">        Holder&lt;Long&gt; qualified=<span class="keyword">new</span> Holder&lt;&gt;();</span><br><span class="line">        Holder&lt;?&gt; unbounded=<span class="keyword">new</span> Holder&lt;Long&gt;();</span><br><span class="line">        Holder&lt;? extends Long&gt; bounded=<span class="keyword">new</span> Holder&lt;Long&gt;();</span><br><span class="line">        Long lng=<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">        rawArgs(raw,lng);</span><br><span class="line">        rawArgs(qualified,lng);</span><br><span class="line">        rawArgs(unbounded,lng);</span><br><span class="line">        rawArgs(bounded,lng);</span><br><span class="line"></span><br><span class="line">        unboundedArgs(raw,lng);</span><br><span class="line">        unboundedArgs(qualified,lng);</span><br><span class="line">        unboundedArgs(unbounded,lng);</span><br><span class="line">        unboundedArgs(bounded,lng);</span><br><span class="line"></span><br><span class="line">        Object r1=exact1(raw);<span class="comment">//warnning</span></span><br><span class="line">        Long r2 =exact1(qualified);</span><br><span class="line">        Object r3=exact1(unbounded);<span class="comment">//Must return Object</span></span><br><span class="line">        Long r4=exact1(bounded);</span><br><span class="line"></span><br><span class="line">        Long r5=exact2(raw,lng)<span class="comment">//warning</span></span><br><span class="line">        Long r6 =exact2(qualified,lng);</span><br><span class="line">        <span class="comment">//Long r7 = exact2(unbounded,lng);//Error</span></span><br><span class="line">        <span class="comment">//Long r8=exact2(bounded,lng);//error</span></span><br><span class="line">        <span class="comment">//exact2(Holder&lt;T&gt;,T) cannot be applied</span></span><br><span class="line">        <span class="comment">//to (Holder&lt;capture of ? extends Long&gt;,Long)</span></span><br><span class="line"></span><br><span class="line">        Long r9=wildSubType(raw,lng);<span class="comment">//warnings</span></span><br><span class="line">        <span class="comment">//unchecked conversion form Holder to Holder&lt;? extends Long&gt;</span></span><br><span class="line">        <span class="comment">//unchecked method invocation:</span></span><br><span class="line">        <span class="comment">//wildSubType(Holder&lt;? extends T&gt;,T) is applied to (Holder,Long)</span></span><br><span class="line"></span><br><span class="line">        Long r10=wildSubType(qualified,lng);</span><br><span class="line">        <span class="comment">//ok but can only return Object</span></span><br><span class="line">        Object r11=wildSubType(unbounded,lng);</span><br><span class="line">        Long r12=wildSubType(bounded,lng);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//wildSubType(raw,lng);warnnings</span></span><br><span class="line">        <span class="comment">//unchecked conversion from Holder to Holder&lt;? super Long&gt;</span></span><br><span class="line">        <span class="comment">//nchecked method invocation;</span></span><br><span class="line">        <span class="comment">//wildSupType(Holder&lt;? super T&gt;,T) is applied to (Holder,Long)</span></span><br><span class="line"></span><br><span class="line">        wildSupType(qualified,lng);</span><br><span class="line">        <span class="comment">//wildSupType(unbounded,lng);//error</span></span><br><span class="line">        <span class="comment">//wildSuType(Holder&lt;? super T&gt;,T) cannot be applied to (Holder&lt;Capture of ?&gt;,Long)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//wildSupType(bounded,lng);error</span></span><br><span class="line">        <span class="comment">//wildSpType(Holder&lt;? super T&gt;,T)cannot be applied to (Holder&lt;capture of ? extends Long&gt;,Long )</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></object></object></p>
<p>在rawArgs()中，编译器知道Holder是一个泛型类型，因此即使它在这里表示成一个原生类型，编译器仍然知道向set()传递一个Obeject是不安全的，由于它是原生类型，你可以将任何类型的对象传递给set()，而这个对象将被向上转型为Object，因此无论何时，<strong>只要使用了原生类型，都会放弃编译器检查</strong>，对get()的调用说明了相同的问题，没有任何T类型的睇相，因此结果只能是一个Object<br>人们很自然会开始考虑原生类型Holder和Holder&lt;?&gt;是大致相同的事物，但是unboundArg()强调了它们的不同——它揭示了相同的问题，但是它将这些问题作为错误而不是警告报告，<strong>因为原生Holder将持有任何类型的组合，而Holder&lt;?&gt;将持有具有某种具体类型的同构集合，因此不能只是向其中传递Object</strong><br>在exact1()和exact2()中，你可以看到使用了确切的泛型类型——没有任何通配符，你将看到，exact2和exact1()有不同的限制，因为它有额外的参数<br>在wildSubType()中，在Holder类型上的限制被放松为包括持有任何扩展子T的对象的Holder，这还是意味着如果T是Fruit，那么Holder可以是Holder<apple>,这是合法的，为了防止将Orange()放置到Holder<apple>中，对set()的调用（或者任何接受这个类型参数的方法的调用）都是不允许的，但是，你仍旧知道任何来自Holder&lt;? extends Fruit&gt;的对象至少都是Fruit的，因此get()(任何参数列表不涉及类型参数的方法)的调用都是允许的<br>wildSupType()展示了超类型通配符，因此set()可以接受T,因为任何可以工作于基类的对象都可以多态地作用于导出类（这里就是T），但是尝试着调用get()是没用的，因此由Holder持有的类型可以是任何超类型，因此唯一安全的类型即使Object,但是这样具体的类型信息就会丢失<br>这个例子还展示了对于unbounded()中使用无界通配符能够做什么不能做什么所做出的限制，对于迁移兼容性，rawArgs()将接受所有Holder的不同变体，而不会产生警告，unboundedArgs()方法也可以接受相同的所有类型，尽管如前所示，它在方法体内部处理这些类型的方式并不相同<br><strong>如果向接受“确切”泛型类型（没有通配符）的方法产地一个原生Holder引用，就会得到一个警告，因为确切的参数期望得到在原生类型中并不存在的信息</strong>如果向exact1()传递一个无界引用，就不会有任何可以确定返回类型的类型信息<br>可以看到，exact2()具有更多的限制，因为它希望精确地得到一个Holder<t>，已经一个具有T类型的参数，正因如此，它将产生错误或者警告，除非提供确切的参数，有时，这样做很好，但是如果它过于受限，那么就可以使用通配符，这取决与是否想要从泛型参数中返回类型确定返回值（就像在wildSubType中看到的那样），或者是否想要向泛型参数传递类型确定的参数（就像在wildSupType()中看到的那样）<br>因此使用确切类型来替代通配符的好处是，可以用泛型参数来做更多事，但是使用通配符使得你必须接受范围更宽的参数化类型作为参数，因此，必须逐个情况地权衡利弊，找到更适合你的方法</t></apple></apple></p>
<h3 id="捕获转换"><a href="#捕获转换" class="headerlink" title="捕获转换"></a>捕获转换</h3><p><strong>有一种情况特别需要使用&lt;?&gt;而不是原生类型，如果像一个使用&lt;?&gt;的方法传递原生类型，那么对与编译器来说，可能会推断出实际的参数类型，使得这个方法可以回转并调用另一个使用这个确切类型的方法</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CaptureConversion</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(Holder&lt;T&gt; holdedr)</span></span>&#123;</span><br><span class="line">        T t=holdedr.get();</span><br><span class="line">        System.out.println(t.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">(Holder&lt;?&gt; holder)</span></span>&#123;</span><br><span class="line">        f1(holder);<span class="comment">//call with capture type</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Holder raw = <span class="keyword">new</span> Holder&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//f1(raw);//warnings</span></span><br><span class="line">        f2(raw);<span class="comment">//no warning</span></span><br><span class="line">        Holder rawBasic=<span class="keyword">new</span> Holder();</span><br><span class="line">        rawBasic.set(<span class="keyword">new</span> Object());<span class="comment">//warning</span></span><br><span class="line">        f2(rawBasic);<span class="comment">//no warning</span></span><br><span class="line">        Holder&lt;?&gt; wildcarded=<span class="keyword">new</span> Holder&lt;Double&gt;();</span><br><span class="line">        f2(wildcarded);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output</span></span><br><span class="line"><span class="comment">Integer</span></span><br><span class="line"><span class="comment">Object</span></span><br><span class="line"><span class="comment">Double</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
<p>f1()的参数类型都是确切的，没有通配符或边界，在f2()中，Holder参数是一个无界通配符，因此它看起来是未知的，但是，在f2()中，f1()被调用，而f1()需要一个已知参数，<strong>这里发生的是，参数类型在调用f2()的过程中被捕获，因此它可以在对f1()的调用中被使用</strong><br>你可能想知道，这项技术是否可以用于写入，但是这要求要在床底Holder&lt;?&gt;同时传递以恶搞具体类型，捕获站好只有在这样的情况下才能工作：即在方法内部，你需要使用确切的类型  </p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="任何基本类型都不能作为类型参数"><a href="#任何基本类型都不能作为类型参数" class="headerlink" title="任何基本类型都不能作为类型参数"></a>任何基本类型都不能作为类型参数</h3><h3 id="实现参数化接口"><a href="#实现参数化接口" class="headerlink" title="实现参数化接口"></a>实现参数化接口</h3><p>一个类不能实现一个泛型接口的两种变体，由于擦除的影响，这两个变体会成为相同的接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Payable</span>&lt;<span class="title">T</span>&gt;</span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Payable</span>&lt;<span class="title">Employee</span>&gt;</span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hourly</span> <span class="keyword">extends</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Payable</span>&lt;<span class="title">Hourly</span>&gt;</span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>Hourly不能编译成功，因为擦除会将Payable<eployee>和Payable<hourly>简化成相同的类Payable</hourly></eployee></p>
<h3 id="转型和警告"><a href="#转型和警告" class="headerlink" title="转型和警告"></a>转型和警告</h3><p>使用带有泛型参数的转型或instanceof不会产生任何效果，下面的容器在内部将各个值存储为Object，并在获取这些值时，再将它们转型回T<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FixedSizeStack</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Object[] storage;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FixedSizeStack</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">       storage=<span class="keyword">new</span> Object[size]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T item)</span></span>&#123;storage[index++]=item;&#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> (T)storage[index--];&#125;<span class="comment">//重点在这一行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericCast</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE=<span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        FixedSizeStack&lt;String&gt; strings=<span class="keyword">new</span> FixedSizeStack&lt;&gt;(SIZE);</span><br><span class="line">        <span class="keyword">for</span>(String str:<span class="string">"A B C D E F G H I J"</span>.split(<span class="string">" "</span>))&#123;</span><br><span class="line">            strings.push(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;SIZE;i++)&#123;</span><br><span class="line">            String s=strings.pop();</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果没有@SuppressWranings注解，编译将会产生“unchecked cast”警告,<strong>由于擦除的影响，编译器无法知道这个转型是否是安全的，并且pop()方法实际上没有执行任何转型，这是因为，T被擦除到它的第一个边界，默认情况下是Object，因此pop()实际上只是将Object转型为Object</strong><br><strong>有时，泛型没有消除对转型的需要，就会产生编译器警告，而这个警告是不恰当的，例如</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NeedCasting</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]));</span><br><span class="line">        List&lt;Widget&gt; shape=(List&lt;Widget&gt;)in.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>readObject()无法知道它正在读取的是什么，因此它返回的是必须转型的对象，但是当注释点@SuppressWranings注解，并编译这个程序的时，就会出现下面的警告<br>Note:NeedCasting,java uses unchecked or unsafe operations<br>Note:Recompile with —Xlint:unchecked for detail<br>如果遵循这条指示，使用—Xlint：unchecked来重新编译<br>NeedCasting.java:12: warning:[unckecked] unchecked cast<br>found :java.lang.Object<br>required: java.util.List<widget><br>   List<shape> shapes=(List<widget>)in.readObject();<br>你会被强制要求转型，但是又被告知不应该转型，为了解决这个问题，必须使用在java SE5中引入的新的转型形式，既通过泛型类来转型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NeedCasting</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]));</span><br><span class="line">        <span class="comment">//List&lt;Widget&gt; lw1=List&lt;Widget&gt;.class.cast(in.readObject());</span></span><br><span class="line">        List&lt;Widget&gt; lw2=List.class.cast(in.readObject());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></widget></shape></widget></p>
<p>这里是相当奇怪的</p>
<h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>下面的程序是不能编译的，即使编译它是一种合理的尝试<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseList</span>&lt;<span class="title">W</span>,<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(List&lt;T&gt; v)</span></span>&#123;&#125;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(List&lt;W&gt; v)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于擦除的影响，重载方法将产生相同的类型签名</p>
<h3 id="基类劫持了接口"><a href="#基类劫持了接口" class="headerlink" title="基类劫持了接口"></a>基类劫持了接口</h3><p>假设你有一个Pet类，它可以与其他的Pet类对象进行比较（实现了Comparable接口）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparablePet</span>  <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ComparablePet</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(@NotNull ComparablePet o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对可以与ComparablePet的子类比较的类型进行窄化是有意义的，例如，一个Cat对象就只能与其他Cat对象进行比较<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">ComparablePet</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Cat</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(@NotNull Cat o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>遗憾的是上面代码错误，一旦为Comparable确定了ComparablePet参数，那么其他任何实现类都不能与ComparablePet之外的任何对象比较<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hamster</span> <span class="keyword">extends</span> <span class="title">ComparablePet</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ComparablePet</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(ComparablePet args)</span></span>&#123;<span class="keyword">return</span>  <span class="number">1</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Hasmter说明再次实现ComparablePet中的接口是可能的，只要它们精确地相同，包括参数类型在内</p>
<h2 id="自限定的类型"><a href="#自限定的类型" class="headerlink" title="自限定的类型"></a>自限定的类型</h2><p>在java中，经常出现一个令人费解的惯用法<br>class SelfBound&lt;T extends SelfBound<t>&gt;<br>这就像是两面镜子彼此看着对方产生的炫目感，是一种无限循环，SelfBound接受泛型参数T，而T由一个边界类限定，这个边界就是拥有T作为参数的ShefBound</t></p>
<h3 id="古怪的循环泛型"><a href="#古怪的循环泛型" class="headerlink" title="古怪的循环泛型"></a>古怪的循环泛型</h3><p>我们先从简单的版本入手<br><strong>不能直接继承一个泛型参数，但是，可以继承在其自己的定义中使用这个泛型参数的类</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericType</span>&lt;<span class="title">T</span>&gt;</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuriouslyRecurringGeneric</span> <span class="keyword">extends</span> <span class="title">GenericType</span>&lt;<span class="title">CuriouslyRecurringGeneric</span>&gt;</span>&#123; &#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的例子可以称为“古怪的循环”，<strong>“古怪的循环”是指类相当古怪地出现在自己的基类中这一事实</strong><br>为了理解其含义，努力地大声说“<strong>我正在创建一个新类吗，这个类继承子一个泛型类型，这个泛型类型的接受我的类的名字作为其参数</strong>”，当给出导出类的名字时，<strong>这个泛型基类能够实现什么呢？好吧，java中的泛型关乎参数和返回类型，因此它能够产生使用导出类作为参数和返回类型的积累，它还能将导出类用作其域类型，甚至那些将其擦除为Object的类型</strong><br>下面是一个普通的泛型类,它的方法将接受和产生具有参数类型的对象，还有一个方法将在其存储的域上执行操作（尽管只在这个域上执行Object操作）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicHolder</span> &lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T item;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setItem</span><span class="params">(T item)</span></span>&#123;item=item;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getItem</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(item.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面这个示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubType</span> <span class="keyword">extends</span> <span class="title">BasicHolder</span>&lt;<span class="title">SubType</span>&gt;</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CRWithBasicHolder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">      SubType subType1=<span class="keyword">new</span> SubType();</span><br><span class="line">      SubType subType2=<span class="keyword">new</span> SubType();</span><br><span class="line">      subType1.setItem(subType2);</span><br><span class="line">      SubType subType3=subType1.getItem();</span><br><span class="line">      subType1.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>新类SubType接受的参数和返回的值具有SubType类型而不仅仅是基类Basicholder的类型，这就是CRG(古怪的循环)的本质，<strong>基类用导出类替代其参数</strong>，<strong>这意味着泛型基类变成了一种其所有导出类的公共功能的模版，但是这些功能对于其所有参数和返回值，将使用导出类型，也就是说，在产生的类中将使用确切类型而不是其基类型</strong>，因此，在SubType中，传递给set()的参数和从get()返回的类型都是确切的SubType</p>
<h3 id="自限定"><a href="#自限定" class="headerlink" title="自限定"></a>自限定</h3><p>BasicHolder可以使用任何类型作为其泛型参数，就像下面看到的那样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Other</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicOther</span> <span class="keyword">extends</span> <span class="title">BasicHolder</span>&lt;<span class="title">Other</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        BasicOther b=<span class="keyword">new</span> BasicOther();</span><br><span class="line">        b.setItem(<span class="keyword">new</span> Other());</span><br><span class="line">        Other o=b.getItem();</span><br><span class="line">        b.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>自限定将采取额外的步骤，强制泛型当作其自己的边界参数来使用</strong><br>观察所产生的类可以如何使用以及不可以如何使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelfBounded</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&gt;</span>&#123;</span><br><span class="line">    T element;</span><br><span class="line">    <span class="function">SelfBounded&lt;T&gt; <span class="title">set</span><span class="params">(T arg)</span></span>&#123;</span><br><span class="line">        element=arg;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">A</span>&gt;</span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">A</span>&gt;</span>&#123;&#125;<span class="comment">//also ok</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">C</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">C <span class="title">setAndGet</span><span class="params">(C arg)</span></span>&#123;</span><br><span class="line">        set(arg);</span><br><span class="line">        <span class="keyword">return</span> get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//class E extends SelfBounded&lt;D&gt;&#123;&#125;can't do this</span></span><br><span class="line"><span class="comment">//compile error : Type parameter D is not within its bound</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//also you can do this ,so you can't force the idiom</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelfBounding</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        A a =<span class="keyword">new</span> A();</span><br><span class="line">        a.set(<span class="keyword">new</span> A());</span><br><span class="line">        a=a.set(<span class="keyword">new</span> A()).get();</span><br><span class="line">        a=a.get();</span><br><span class="line"></span><br><span class="line">        C c=<span class="keyword">new</span> C();</span><br><span class="line">        c=c.setAndGet(<span class="keyword">new</span> C());</span><br><span class="line"></span><br><span class="line">        B b=<span class="keyword">new</span> B();</span><br><span class="line">        b.set(<span class="keyword">new</span> A());</span><br><span class="line">        A ba=b.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>自限定所做的，就是要求在继承关系中，像下面这样使用这个类</strong><br>    class A extends SelfBounded<a>{}<br><strong>这会强制要求将正在定义的类当作参数传递给基类</strong><br>从基类的类型参数的表达式也能看的出来</a></p>
<p>&lt;T extends SelfBounded<t>&gt; T表示类型参数，这个参数的类型是其自身类型的导出类<br>自限定的参数有何意义呢？它可以保证类型参数必须与正在被定义的类相同<br>正如你从B类的定义所看到的，还可以从另一个SelfBounded参数的SelfBounded中导出，尽管A类看到的用法是最主要的用法<br>对定义E的尝试说明不能使用不是SelfBounded的类型参数<br>遗憾的是，F可以编译，不会有任何警告，这是比较奇怪的吗？这也说明了自限定惯用法不是可强制执行的，如果它确实很重要，可以要求一个外部工具来确保不会使用原生类型来替代参数化类型<br>注意，可以移除自限定这个限制，这样所有的类仍旧可以编译的，但是E也因此可编译成功<br>其实自限定类型的目的就是限定导出类在继承基类的时候，必须将参数类型替换为导出类（只要是基类的导出类都可以，一般我们惯用的是新建的这个导出类自身来替代参数类型而已，一次泛型类的自限定对于继承自它的类来说，没什么一样，自限定最大的功效就是强制而已）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A2</span> <span class="keyword">extends</span> <span class="title">NotSelfBounded</span>&lt;<span class="title">A</span>&gt;</span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span> <span class="keyword">extends</span> <span class="title">NotSelfBounded</span>&lt;<span class="title">A2</span>&gt;</span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C2</span> <span class="keyword">extends</span> <span class="title">NotSelfBounded</span>&lt;<span class="title">C2</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">C2 <span class="title">getAndSet</span><span class="params">(C2 arg)</span></span>&#123; set(arg);<span class="keyword">return</span> get(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E2</span> <span class="keyword">extends</span> <span class="title">NotSelfBounded</span>&lt;<span class="title">D2</span>&gt;</span>&#123;&#125;<span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotSelfBounded</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T element;</span><br><span class="line">    <span class="function">NotSelfBounded&lt;T&gt; <span class="title">set</span><span class="params">(T arg)</span></span>&#123;</span><br><span class="line">        element=arg;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> element;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></p>
<p>这里E2能够编译，即使D2不在NotSelfBounded继承关系中，因此得出结论：<strong>自限定限制只能强制作用于继承关系</strong>。<br>自限定也可以用在泛型方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelfBoundedMethods</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T extends SelfBounded&lt;T&gt;&gt; <span class="function">T <span class="title">f</span><span class="params">(T arg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arg.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        A a=f(<span class="keyword">new</span> A());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="参数协变"><a href="#参数协变" class="headerlink" title="参数协变"></a>参数协变</h3><p>自限定类型的价值是它可以产生协变参数类型——方法参数类型会随着子类而变化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">OrdinaryGetter</span></span>&#123;</span><br><span class="line">    <span class="function">Base <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">DerivedGetter</span> <span class="keyword">extends</span> <span class="title">OrdinaryGetter</span></span>&#123;</span><br><span class="line">    <span class="function">Derived <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CovariantReturnType</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(DerivedGetter d)</span></span>&#123;</span><br><span class="line">        Derived d2=d.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>DerivedGetter中的get()方法覆盖了OrderinaryGetter中的get()方法，并返回一个从OrderinaryGetter.get()返回类型中导出的类型，尽管这是很合理的，导出类方法应该能够返回比它覆盖的基类方法更具体的类型，但是这在java之前的版本中是不合法的<br>自限定泛型实际上将产生确切的导出类型作为其返回值，就像在get()中看到的那样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GenericGetter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">GenericGetter</span>&lt;<span class="title">T</span>&gt;&gt;</span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Getter</span> <span class="keyword">extends</span> <span class="title">GenericGetter</span>&lt;<span class="title">Getter</span>&gt;</span>&#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsAndGetter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(Getter g)</span></span>&#123;</span><br><span class="line">        Getter result=g.get();</span><br><span class="line">        GenericGetter gg=g.get();<span class="comment">//also the base type</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在非泛代码中，参数类型不能随子类型发生变化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrdinarySetter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Base base)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"OrdinarySetter.set(Base)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedSetter</span> <span class="keyword">extends</span> <span class="title">OrdinarySetter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Derived derived)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"DerivedSetter.set(Derived)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderinaryArguments</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Base base=<span class="keyword">new</span> Base();</span><br><span class="line">        Derived derived=<span class="keyword">new</span> Derived();</span><br><span class="line">        DerivedSetter ds=<span class="keyword">new</span> DerivedSetter();</span><br><span class="line">        ds.set(derived);</span><br><span class="line">        ds.set(base);<span class="comment">//这是重载，不是覆盖，overloade，not overridden</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">DerivedSetter.set(Derived)</span></span><br><span class="line"><span class="comment">OrdinarySetter,set(Base)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
<p>set(Derived)和set(Base)都是合法的，因此DerivdeSetter.set(Derived)方法没有覆盖OrdinarySetter.set(Base)方法，而是重载了它，基类版本的代码依然是可用的<br>但是，在使用自限定类型时，在导出类中只有一个方法，并且这个方法接受导出类而不是基类型为参数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SelfBoundSetter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SelfBoundSetter</span>&lt;<span class="title">T</span>&gt;&gt;</span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">set</span><span class="params">(T arg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Setter</span> <span class="keyword">extends</span> <span class="title">SelfBoundSetter</span>&lt;<span class="title">Setter</span>&gt;</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelfBoundingAndConvariantArguments</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testA</span><span class="params">(Setter s1,Setter s2,SelfBoundSetter sb3)</span></span>&#123;</span><br><span class="line">        s1.set(s2);</span><br><span class="line">        <span class="comment">//s1.set(sb3);  set(Setter) in SelfBoundSetter&lt;Setter&gt;</span></span><br><span class="line">        <span class="comment">//cannot be applied to SelfBoundSetter</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>上面这个例子可以看出，编译器不能识别将基类当作参数传递给setter()的尝试，因为没有任何方法具有这样的签名</strong><br>如果不使用自限定类型，普通的继承机制就会介入，而你将能够重载，就像在非泛型的情况下一样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericSetter</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(T arg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"GenericSetter.set(Base)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedGs</span> <span class="keyword">extends</span> <span class="title">GenericSetter</span>&lt;<span class="title">Base</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Derived derived)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"DerivedGs.set(Derived)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlainGenericInheritance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Base base=<span class="keyword">new</span> Base();</span><br><span class="line">        Derived derived=<span class="keyword">new</span> Derived();</span><br><span class="line">        DerivedGs derivedGs=<span class="keyword">new</span> DerivedGs();</span><br><span class="line">        derivedGs.set(base);</span><br><span class="line">        derivedGs.set(derived);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">GenericSetter.set(Base)</span></span><br><span class="line"><span class="comment">DerivedGs.set(Derived)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
<h2 id="动态类型安全"><a href="#动态类型安全" class="headerlink" title="动态类型安全"></a>动态类型安全</h2><p>因为可以向java SE5之前的代码传递容器，所以旧式代码仍旧有可能破坏你的容器（这句话的意思，向你的容器插入不正确的类型）,java SE5的java.util.Collections中有一组便利的工具，可以解决在这种情况下的类型检查问题，它们是，静态方法checkedCollection(),checkedList(),checkedMap(),checkedSet(),checkedSortedMap()和checkedSortedSet(),这些方法每一个都将会希望动态检查的容器作为第一第一个参数接受，并将你希望强制要求的类型作为第二个参数接受<br>受检查的容器，在你试图插入类型不正确的对象时抛出ClassCastException，这与泛型之前的（原生）容器形成对比，对于后者来说，当你将对象从容器中取出的时候，才会通知你出现了问题，而且你也不知道问题是什么时候造成的，受检查的容器与其不同，当向这个容器插入不良对象的时候我们就立刻知道问题发生了<br>用受检查的容器来看看“将猫插入狗列表中”这个问题，这里oldStyleMethod代表遗留代码，因为它接受原生容器List，而@SuppressWarnings注解对这些遗留代码是必需的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pet</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span>  <span class="title">Pet</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span>  <span class="title">Pet</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckedList</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">oldStyleMethod</span><span class="params">(List probablyDogs)</span></span>&#123;</span><br><span class="line">        probablyDogs.add(<span class="keyword">new</span> Cat());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;Dog&gt; dogs1=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        oldStyleMethod(dogs1);<span class="comment">//Quietyly accepts a Cat//不会抛出异常 也不会警告，因为遗留代码使用了原生类型作为参数</span></span><br><span class="line">        List&lt;Dog&gt; dogs2= Collections.checkedList(<span class="keyword">new</span> ArrayList&lt;Dog&gt;(),Dog.class);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oldStyleMethod(dogs2);<span class="comment">//抛出异常</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//derived Type work fine</span></span><br><span class="line">        List&lt;Pet&gt;  pets=Collections.checkedList(<span class="keyword">new</span> ArrayList&lt;Pet&gt;(),Pet.class);</span><br><span class="line">        pets.add(<span class="keyword">new</span> Dog());</span><br><span class="line">        pets.add(<span class="keyword">new</span> Cat());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行这个程序，会发现向dog1插入Cat没有任何问题，如果问题出现也只会在以后从容器中取出时才会发现，因为遗留代码使用了原生类型而不是泛型类型，向dog2插入一个Cat会立马抛出异常</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>由于擦除的影响，将泛型应用于异常是非常受限的。catch语句不能捕获泛型类型的异常，因为在编译期和运行期都必须知道异常的确切类型，泛型类也不呢个直接或间接继承自Throwable(这将进一步阻止你去定义一个不能捕获的泛型异常)<br>但是，类型参数可能会在一个方法的throws子句中用到，这使得你可以编写随检查型异常的类型而发生变化的泛型代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Processor</span>&lt;<span class="title">T</span>,<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Exception</span>&gt;</span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;T&gt; resultCollector)</span><span class="keyword">throws</span> E</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProcessRuuner</span>&lt;<span class="title">T</span>,<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Exception</span>&gt; <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">Processor</span>&lt;<span class="title">T</span>,<span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">processAll</span><span class="params">()</span><span class="keyword">throws</span> E</span>&#123;</span><br><span class="line">        List&lt;T&gt; resultCollector=<span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Processor&lt;T,E&gt; p:<span class="keyword">this</span>)&#123;</span><br><span class="line">            p.process(resultCollector); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  resultCollector;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Failure1</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Processor1</span> <span class="keyword">implements</span> <span class="title">Processor</span>&lt;<span class="title">String</span>,<span class="title">Failure1</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;String&gt; resultCollector)</span> <span class="keyword">throws</span> Failure1 </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count--&gt;<span class="number">1</span>)</span><br><span class="line">            resultCollector.add(<span class="string">"hep!"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            resultCollector.add(<span class="string">"Ho!"</span>);</span><br><span class="line">        <span class="keyword">if</span>(count&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Failure1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Failuer2</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Processor2</span> <span class="keyword">implements</span>  <span class="title">Processor</span>&lt;<span class="title">Integer</span>,<span class="title">Failuer2</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;Integer&gt; resultCollector)</span> <span class="keyword">throws</span> Failuer2 </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count-- == <span class="number">0</span>)</span><br><span class="line">            resultCollector.add(<span class="number">11</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            resultCollector.add(<span class="number">47</span>);</span><br><span class="line">        <span class="keyword">if</span>(count&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Failuer2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowGenericException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ProcessRuuner&lt;String,Failure1&gt; runner1=<span class="keyword">new</span> ProcessRuuner&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            runner1.add(<span class="keyword">new</span> Processor1());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(runner1.processAll());</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Failure1 e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ProcessRuuner&lt;Integer,Failuer2&gt; runner2 = <span class="keyword">new</span> ProcessRuuner&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            runner2.add(<span class="keyword">new</span> Processor2());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(runner2.processAll());</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Failuer2 e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码是很简单的，虽然看起来很长，说明了异常也可以参数化</p>
<h2 id="混型"><a href="#混型" class="headerlink" title="混型"></a>混型</h2><p>混型（混合的类型，使得这个类型可以混合多个类的能力）随着时间的推移好像拥有无数的含义，<strong>但是其最基本的概念是混合多个类型的能力，以产生一个可以表示混型中所有类型的类</strong>，这往往是你最后的手段，它使得组装多个类型变得简单易行</p>
<h3 id="C-中的混型"><a href="#C-中的混型" class="headerlink" title="C++中的混型"></a>C++中的混型</h3><p>代码不写了，C++中，使用多重继承的最大理由，就是为了使用混型，但是对于混型来说，更有趣，更优雅的方式是使用参数化类型，因为混型就是继承子其类型参数的类，在C++中，可以很容易的创建混型，因为C++能够记住模版参数的类型</p>
<h3 id="与接口混合"><a href="#与接口混合" class="headerlink" title="与接口混合"></a>与接口混合</h3><p>在java中，最常见的解决方案就是使用接口来产生混型的效果,类似这样的吧<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">C</span></span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span></span>;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">C</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mix</span> <span class="keyword">extends</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">B</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="使用装饰器模式"><a href="#使用装饰器模式" class="headerlink" title="使用装饰器模式"></a>使用装饰器模式</h3><p>当你观察混型的使用方式时，你会发现混型概念好像与装饰器模式关系很近，装饰器常用于满足各种可能的组合，而直接子类化会产生过多的类，因此是不实际的<br><strong>装饰器模式使用了分层对象来动态透明地向单个对象添加责任，装饰器是指包装在最初的对象周围的所有对象都具有的基本接口</strong>，某些事物是可装饰的，可以通过是其他类包装在这个可装饰对象的四周，来将功能分层，这使得对装饰器的使用是透明的——无论对象是否被装饰，你都拥有一个可以向对象发送的公共接口集，装饰器也可以添加新的方法，但是正如你所见的，这将是受限的<br><strong>装饰器是使用组合和形式化结构（可装饰物/装饰器层次结构）来实现的</strong>，而混型是基于继承的，因此可以将基于参数化类型的混型当作是一种泛型装饰器机制，这种机制不需要装饰器设计模式的继承结构<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Processor</span>&lt;<span class="title">T</span>,<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Exception</span>&gt;</span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;T&gt; resultCollector)</span><span class="keyword">throws</span> E</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProcessRuuner</span>&lt;<span class="title">T</span>,<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Exception</span>&gt; <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">Processor</span>&lt;<span class="title">T</span>,<span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">processAll</span><span class="params">()</span><span class="keyword">throws</span> E</span>&#123;</span><br><span class="line">        List&lt;T&gt; resultCollector=<span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Processor&lt;T,E&gt; p:<span class="keyword">this</span>)&#123;</span><br><span class="line">            p.process(resultCollector); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  resultCollector;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Failure1</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Processor1</span> <span class="keyword">implements</span> <span class="title">Processor</span>&lt;<span class="title">String</span>,<span class="title">Failure1</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;String&gt; resultCollector)</span> <span class="keyword">throws</span> Failure1 </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count--&gt;<span class="number">1</span>)</span><br><span class="line">            resultCollector.add(<span class="string">"hep!"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            resultCollector.add(<span class="string">"Ho!"</span>);</span><br><span class="line">        <span class="keyword">if</span>(count&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Failure1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Failuer2</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Processor2</span> <span class="keyword">implements</span>  <span class="title">Processor</span>&lt;<span class="title">Integer</span>,<span class="title">Failuer2</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;Integer&gt; resultCollector)</span> <span class="keyword">throws</span> Failuer2 </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count-- == <span class="number">0</span>)</span><br><span class="line">            resultCollector.add(<span class="number">11</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            resultCollector.add(<span class="number">47</span>);</span><br><span class="line">        <span class="keyword">if</span>(count&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Failuer2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowGenericException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ProcessRuuner&lt;String,Failure1&gt; runner1=<span class="keyword">new</span> ProcessRuuner&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            runner1.add(<span class="keyword">new</span> Processor1());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(runner1.processAll());</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Failure1 e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ProcessRuuner&lt;Integer,Failuer2&gt; runner2 = <span class="keyword">new</span> ProcessRuuner&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            runner2.add(<span class="keyword">new</span> Processor2());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(runner2.processAll());</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Failuer2 e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>产生自泛型的类包含所有感兴趣的方法，<strong>但是由使用装饰器所产生的对象类型是最后被装饰的类型，也就是说，尽管可以添加多个层，但是最后一层才是实际的类型，因此只有最后一层的方法时可视的</strong>，而混型的类型是所有被混合到一起的类型，因此对于装饰器来说，其明显的缺陷就是它只能有效地工作于装饰器中的一层（最后一层），而混型方法显然会更自然一些，因此，装饰器只是对由混型提出的问题的一种局限的解决方案</p>
<h3 id="与动态代理混合"><a href="#与动态代理混合" class="headerlink" title="与动态代理混合"></a>与动态代理混合</h3><p><strong>可以使用动态代理来创建一种比装饰器更贴近混型模型的机制，通过使用动态代理，所产生的类的动态类型将会是已经混入的组合类型</strong><br>由于动态代理的限制，每个被混入的类都必须是某个接口的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MixinProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">    Map&lt;String,Object&gt; delegatesByMethod;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mixin</span><span class="params">(TwoTuple&lt;Object,Class&lt;?&gt;&gt;... pairs)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(TwoTuple&lt;Object,Class&lt;?&gt;&gt; pair:pairs)&#123;</span><br><span class="line">          <span class="keyword">for</span>(Method method:pair.second.getMethods())&#123;</span><br><span class="line">              String methodName=method.getName();</span><br><span class="line">              <span class="comment">//the first inferface in the map</span></span><br><span class="line">              <span class="comment">//implements the method</span></span><br><span class="line">              <span class="keyword">if</span>(!delegatesByMethod.containsKey(methodName))&#123;</span><br><span class="line">                  delegatesByMethod.put(methodName,pair.first);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        String methodName=method.getName();</span><br><span class="line">        Object delegate=delegatesByMethod.get(methodName);</span><br><span class="line">        <span class="keyword">return</span> method.invoke(delegate,args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newInstance</span><span class="params">(TwoTuple... pairs)</span></span>&#123;</span><br><span class="line">        Class[] interfaces=<span class="keyword">new</span> Class[pairs.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pairs.length;i++)&#123;</span><br><span class="line">            interfaces[i]=(Class) pairs[i].second</span><br><span class="line">        &#125;</span><br><span class="line">        ClassLoader c1=pairs[<span class="number">0</span>].first.getClass().getClassLoader();</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(c1,interfaces,<span class="keyword">new</span> MixinProxy(pairs));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyMixin</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Object mixin=MixinProxy.newInstance(</span><br><span class="line">                tuple(<span class="keyword">new</span> BasicImp(),Basic.class),tuple(<span class="keyword">new</span> TimeStampedImp(),TimeStamped.class),</span><br><span class="line">                tuple(<span class="keyword">new</span> SerialNumberedImp(),SerialNumbered.class));</span><br><span class="line">        Basic b=(Basic)mixin;<span class="comment">//重点在这里</span></span><br><span class="line">        TimeStamped t=(TimeStamped)mixin;</span><br><span class="line">        SerialNumbered s=(SerialNumbered)mixin;</span><br><span class="line">        b.set(<span class="string">"Hello"</span>);</span><br><span class="line">        b.get();</span><br><span class="line">        t.getStamp();<span class="comment">//重点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为只有动态类型而不是静态类型才包含所有的混入类型，因此这种方式依然不如C++的方式好，因为可以在具有这些类型的对象上调用方法之前，你必须被强制要求向下转型到恰当的类型，但是，它明显更接近于真正的混型</p>
<h2 id="潜在类型机制"><a href="#潜在类型机制" class="headerlink" title="潜在类型机制"></a>潜在类型机制</h2><p>泛型的理想就是能够编写尽可能泛化代码，为了实现这一点，我们需要各种途径来放松带我们代码将要作用的类型所做的限制，同时不丢失静态类型检查的好处，然后，我们就可以编写出无需修改就可以应用于更多情况的代码，即更加“泛化”的代码<br>java泛型看起来是向这一方向迈进了一步，但你编写或使用只是持有对象的泛型时，这些代码可以引用于任何类型，后者，换个角度，“持有器”泛型能够声明：“我不关心你是什么类型”，如果代码不关心它将要作用的类型，那么这种代码就可以真正地被用在任何地方，并因此而相当地泛化<br>还是正如你所看到的那样，<strong>当要在泛型类型上执行操作（即调用Object方法之外的操作）时，就会产生问题，因为擦除要求指定可能会用到的泛型参数的边界，以安全地调用代码中的泛型对象上的具体方法，这是对“泛化”概念 的一种很明显地限制，因为限制了你的泛型类型，使它们继承自特定的类，或者实现特定的接口，在某些情况下，你最终可能会使用普通类或普通接口，因为限定边界的泛型可能会和指定类和接口没有任何区别</strong><br>某些编程语言提供了一种解决方案称为潜在类型机制或结构化参数机制，而更古怪的术语称为“鸭子类型机制”，鸭子理论非常有名，如果“它走起来像鸭子，叫起来像鸭子，那你你就可以将它当作鸭子看待”<br>泛型代码典型地将在泛型类型上调用少量的代码，而且潜在类型机制的语言只要求实现某个方法的子集，而不是某个特定的接口，从而方式了这种限制（并且产生了更加泛化的代码），正由于此，<strong>潜在类型机制使得你可以横跨多个类继承结构，调用不属于某个公共接口的方法，因此，实际上一段代码可以声明：“我不关心你是什么类型，只要你可以speck()和sit()即可</strong>”由于不要求具体类型，因此代码更加泛化<br>潜在类型机制是一种代码组织和复用机制，有了它编写出的代码相对没有它编写出的代码，能够更容易复用，代码组织和复用是所有计算机编程的基本手段，编写一次，多次使用，并在一个位置上保存代码，因为我并未被要求去命名我的代码要操作于其上的确切接口<br><strong>两种支持潜在类型机制的语言实例是Python和C++，Python是动态类型语言（实际上所有的类型检查都发生在运行时），而C++是静态类型语言（类型检查发生在编译期），因此潜在类型机制不要求静态类型还是动态类型检查</strong><br>我们下Python和C++的代码吧，即使你没有学过这两门语言，你也能理解下面代码的概念</p>
<h2 id="对缺乏潜在类型安全机制的补偿"><a href="#对缺乏潜在类型安全机制的补偿" class="headerlink" title="对缺乏潜在类型安全机制的补偿"></a>对缺乏潜在类型安全机制的补偿</h2><p>尽管java不支持潜在类型机制，但是这并不意味着有界泛型代码不能在不同的类型层次结构之间应用，也就是说，我们仍旧可以创建真正的泛型代码，但是这需要付出一些额外的努力</p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>下面的profrom就是用了潜在类型机制<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mime</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walkAgainstTheWind</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span></span>&#123;System.out.println(<span class="string">"pretending to sit"</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushInvisibleWalls</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">"Mime"</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartDog</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;System.out.println(<span class="string">"Woof"</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span></span>&#123;System.out.println(<span class="string">"Sitting"</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reproduct</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommunicateReflectively</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">perform</span><span class="params">(Object specker)</span></span>&#123;</span><br><span class="line">        Class&lt;?&gt; spkr=specker.getClass();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Method m = spkr.getMethod(<span class="string">"speak"</span>);</span><br><span class="line">                m.invoke(specker);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                System.out.println(specker + <span class="string">" cannot speak"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Method m = spkr.getMethod(<span class="string">"sit"</span>);</span><br><span class="line">                m.invoke(specker);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                System.out.println(specker + <span class="string">"cannot sit"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(specker.toString(),e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LatentReflection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        CommunicateReflectively.perform(<span class="keyword">new</span> Mime());</span><br><span class="line">        CommunicateReflectively.perform(<span class="keyword">new</span> SmartDog());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的例子，类完全啊彼此分离的，没有任何公共基类（除了Object）或接口,通过反射，CommunicateReflectively.perform()能够动态地确定所需要的方法是否可用并调用它们，它甚至能够处理Mime只具有一个必须的方法这一事实，并能够部分实现其目标</p>
<h3 id="将一个方法应用于序列"><a href="#将一个方法应用于序列" class="headerlink" title="将一个方法应用于序列"></a>将一个方法应用于序列</h3><p><strong>反射提供了一些有趣的可能性，但是它将所有的类型检查都转移到了运行时，因此在许多情况下并不是我们所希望的，如果能够实现编译器类型检查，这通常更符合要求</strong>，但是有可能实现编译器类型检查和潜在类型机制吗？<br>我们看一个说明这个问题的示例，假设想要创建一个apply()方法，它能够将任何方法应用于谋而序列的所有对象，这是接口看起来并不适合的情况，因为你想要将任何方法应用到一个对象集合，而接口对于描述“任何方法”存在过多的限制，任何用java来实现这个需求呢？<br>最初，我们可以用反射来解决这个问题，由于有JavaSE5的可变参数，这种方法被证明是优雅的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apply</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T ,S extends Iterable&lt;? extends T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(S seq, Method f, Object... args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (T t : seq) &#123;</span><br><span class="line">                f.invoke(t, args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">()</span></span>&#123;System.out.println(<span class="keyword">this</span>+<span class="string">"rotate"</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reSize</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;System.out.println(<span class="keyword">this</span>+<span class="string">"resize"</span>+size);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilledList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">FilledList</span><span class="params">(Class&lt;? extends T&gt; type,<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">              add(type.newInstance());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplyTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        List&lt;Shape&gt;  shapes=<span class="keyword">new</span> FilledList&lt;&gt;(Shape.class,<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            shapes.add(<span class="keyword">new</span> Shape());</span><br><span class="line">        &#125;</span><br><span class="line">        Apply.apply(shapes, Shape.class.getMethod(<span class="string">"rotate()"</span>));</span><br><span class="line">        Apply.apply(shapes,Shape.class.getMethod(<span class="string">"reSize"</span>, <span class="keyword">int</span>.class),<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Square&gt; squares=<span class="keyword">new</span> FilledList&lt;&gt;(Square.class,<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            squares.add(<span class="keyword">new</span> Square());</span><br><span class="line">        &#125;</span><br><span class="line">        Apply.apply(squares,Square.class.getMethod(<span class="string">"retate"</span>));</span><br><span class="line">        Apply.apply(squares,Square.class.getMethod(<span class="string">"reSize"</span>, <span class="keyword">int</span>.class),<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        Apply.apply(<span class="keyword">new</span> FilledList&lt;Shape&gt;(Shape.class,<span class="number">10</span>),Shape.class.getMethod(<span class="string">"retate"</span>));</span><br><span class="line">        Apply.apply(<span class="keyword">new</span> FilledList&lt;Shape&gt;(Square.class,<span class="number">10</span>),Square.class.getMethod(<span class="string">"retate"</span>));</span><br><span class="line">        SimpleQueue&lt;Shape&gt; shapeQ=<span class="keyword">new</span> SimpleQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            shapeQ.add(<span class="keyword">new</span> Shape());</span><br><span class="line">            shapeQ.add(<span class="keyword">new</span> Square());</span><br><span class="line">        &#125;</span><br><span class="line">        Apply.apply(shapeQ,Shape.class.getMethod(<span class="string">"retate"</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们运气很好，因为碰巧在Java中内建了一个由Java容器类库使用的Iterable接口，因此，apply()方法可以接受任何实现了Iterable接口的事物，实际上，它还接受其他任何事物，只要能够使得这些事物是Iterable的就可以了<br>注意，我们必须要使用边界和通配符，以便是Apply和FilledList在所需要的情况下都可以使用，<br><strong>FilledList表示有些进退两难的情况，为了使用某种类型，它必须要有默认的构造器，但是java没有任何方式可以在编译器断言这件事，因此变成了一个运行时问题，确保编译器检查的有个常见的建议是定义一个工厂接口</strong>，它有一个可以生产对象的方法，然后FilledList接受这个接口而不是这个类型标记的“原生工厂（Class对象）”，<strong>但是，大部分的类都是在不了解你的接口的情况下创建的，因此也就没有实现这个接口</strong>，稍后，我们展示一种使用适配器的解决办法<br>使用类型标记是一种合理的折中，错误在运行时报告，所有你要有把握，这些错误将在开发过程的早期出现<br>注意，使用类型标记是java文献推荐的技术，但是也有很多人强烈推荐使用工厂方法让错误在编译器就被发现<br>尽管java解决方案被证明很优雅，但是我们必须知道使用反射（尽管反射在最近的版本中以及明显的改善）可能比非反射的实现要慢一些，因为大多数动作都是在运行时发生的，但是这不应该成为你使用这个解决方案的脚本，至少可以将其作为一种马上就能想到的解决方案  </p>
<h3 id="当你并未碰巧拥有正确的接口时"><a href="#当你并未碰巧拥有正确的接口时" class="headerlink" title="当你并未碰巧拥有正确的接口时"></a>当你并未碰巧拥有正确的接口时</h3><p>我们看到上面的例子，Iterable接口是内建，我们很容易创建容器并使用它，但是如果不存在刚好适合你的需求的接口呢？<br>看下面一个例子，让我们泛化FilledList中的思想，创建一个参数化的方法fill(),它接受一个序列<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fill</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(Collection&lt;T&gt; collection, Class&lt;? extends T&gt; type, <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                collection.add(type.newInstance());</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Contract</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id =counter++;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getSimpleName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TitleTransfer</span> <span class="keyword">extends</span> <span class="title">Contract</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FillTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       List&lt;Contract&gt; contracts=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       Fill.fill(contracts,Contract.class,<span class="number">3</span>);</span><br><span class="line">       Fill.fill(contracts,TitleTransfer.class,<span class="number">2</span>);</span><br><span class="line">       <span class="keyword">for</span>(Contract c:contracts)&#123;</span><br><span class="line">           System.out.println(c);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//don't work fill()is not generic enough;</span></span><br><span class="line">       <span class="comment">//SimpleQueue&lt;Contract&gt; simpleQueue=new SimpleQueue&lt;&gt;();</span></span><br><span class="line">       <span class="comment">//Fill.fill(simpleQueue,Contract.class,3);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们使用java编写代码时，会陷入问题之中，因为没有任何像前面实例的Iterable接口那样的“Addable”便利接口，因此你不能说：“可以在任何事物上调用add()”,而必须说：“可以在Collection的子类型上调用add()”,这样产生的代码就不是特别泛化，因为它必须被限制为只能工作于Collection的实现，如果我试图使用没有实现Collection的类，那么我的泛化代码将不能工作<br>上面的情况中，因为java设计着（可以理解地）没有预见对“Addable()”接口的需要，所有我们被现在在Collection的继承层次结构之内，即便SimpleQueue有个add()方法，它也不能工作，因此这样的代码不是特别泛化，有了潜在类型机制，情况就会不同了</p>
<h3 id="用适配器仿真潜在类型机制"><a href="#用适配器仿真潜在类型机制" class="headerlink" title="用适配器仿真潜在类型机制"></a>用适配器仿真潜在类型机制</h3><p>java泛型并不是没有潜在类型机制，而我们需要使用潜在类型机制这样的东西去编写能够跨类边界应用的代码（也就是“泛化”代码），存在某种方式可以绕过这项限制吗？<br>潜在类型机制将在这里实现什么？它意味着你可以编写代码声明：“我不关心我在这里使用的类型，只要它们具有这些方法即可”，<strong>实际上，潜在类型机制创建了一个包含所需方法的隐式接口</strong>，因此它遵循这样的规则，如果我们手工编写了所需的接口（因为java并没有为我们做这些事），那么它就应该能够解决问题<br><strong>从我们拥有的接口中编写代码来产生我们需要的接口，这就是适配器设计模式的一个典型示例</strong>，我们可以使用适配器来适配已有的接口，以产生想要的接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Addable</span>&lt;<span class="title">T</span>&gt;</span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(T item)</span></span>;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fill2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(Addable&lt;T&gt; addable,Class&lt;? extends T&gt; type,<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                addable.add(type.newInstance());</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载的fill()的类型参数Generator&lt;T&gt; 确保了编译期的类型安全，所以将错误阻止在编译期，在运行时不会抛出</span></span><br><span class="line">    <span class="comment">//任何错误，这种方式比使用类型标记更安全</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(Addable&lt;T&gt; addable,Generator&lt;T&gt; generator,<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            addable.add(generator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//to adapter a base Type,you must use composition</span></span><br><span class="line"><span class="comment">//make any Collection Addable using composition</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddableCollectionAdapter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Addable</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Collection&lt;T&gt; c;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AddableCollectionAdapter</span><span class="params">(Collection&lt;T&gt; c)</span></span>&#123; c=c;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T item)</span></span>&#123; c.add(item); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//a Helper to capture the type automatically</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Addable&lt;T&gt; <span class="title">collectionAdapetr</span><span class="params">(Collection&lt;T&gt; c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AddableCollectionAdapter&lt;T&gt;(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//to adapt a specific type,you can use inheritance</span></span><br><span class="line"><span class="comment">//make a SimpleQueue Addable using inheritance</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddableSimpleQueue</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">SimpleQueue</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Addable</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T item)</span></span>&#123; <span class="keyword">super</span>.add(item);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fill2Test</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       List&lt;Coffee&gt; coffees=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       Fill2.fill(<span class="keyword">new</span> AddableCollectionAdapter&lt;&gt;(coffees),Coffee.class,<span class="number">3</span>);</span><br><span class="line">       Fill2.fill(Adapter.collectionAdapetr(coffees),Coffee.class,<span class="number">3</span>);</span><br><span class="line">       Fill2.fill(Adapter.collectionAdapetr(coffees),Latte.class,<span class="number">3</span>);</span><br><span class="line">       <span class="keyword">for</span>(Coffee coffee:coffees)&#123;</span><br><span class="line">           System.out.println(coffee);</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(<span class="string">"-------------------------------------------------------"</span>);</span><br><span class="line">       AddableSimpleQueue&lt;Coffee&gt; coffeeQueue=<span class="keyword">new</span> AddableSimpleQueue&lt;&gt;();</span><br><span class="line">       Fill2.fill(coffeeQueue,Coffee.class,<span class="number">3</span>);</span><br><span class="line">       Fill2.fill(coffeeQueue,Latte.class,<span class="number">3</span>);</span><br><span class="line">       <span class="keyword">for</span>(Coffee coffee:coffeeQueue)&#123;</span><br><span class="line">           System.out.println(coffee);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Fill2对Collection的要求与Fill不同，它只需要实现了Addable的对象，而Addable已经为Fill编写了——它是我希望编译器帮我创建的潜在类型的一种体现<br>在这个版本中，我还<strong>添加了一个重载的fill,它接受一个Generateor而不是类型标记，Generator在编译器是类型安全的，编译器将确保传递的是正确的Generator,因此不会抛出任何异常</strong><br>第一个适配器，AddableCollectionAdapter，可以工作与基类Collection，这意味着Collection的任何实现都可以使用，这个版本直接存储Collection引用，并使用它来实现Add();<br>如果一个具体类型而不是继承结构的基类，那么当使用继承来创建适配器时，你可以稍微少写一些代码，但是这个适配器只适用于为特定的类型适配所需的接口，这种适配器称为“预适配器”，也就是预先定义好的适配器，之间创建使用即可，而第一种适配器需要传递需要适配的接口才能创建，这就是两种适配器设计模式的不同</p>
<h2 id="将函数对象作为策略"><a href="#将函数对象作为策略" class="headerlink" title="将函数对象作为策略"></a>将函数对象作为策略</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Combiner</span>&lt;<span class="title">T</span>&gt;</span>&#123; <span class="function">T <span class="title">combine</span><span class="params">(T x, T y)</span></span>;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UnaryFunction</span>&lt;<span class="title">R</span>,<span class="title">T</span>&gt;</span>&#123; <span class="function">R <span class="title">function</span><span class="params">(T x)</span></span>;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Collector</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">UnaryFunction</span>&lt;<span class="title">T</span>,<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">result</span><span class="params">()</span></span>;<span class="comment">//extract result of collecting parameter</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UnaryPredicate</span>&lt;<span class="title">T</span>&gt;</span>&#123; <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T x)</span></span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Functional</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">reduce</span><span class="params">(Iterable&lt;T&gt; seq,Combiner&lt;T&gt; combiner)</span></span>&#123;</span><br><span class="line">        Iterator&lt;T&gt; it=seq.iterator();</span><br><span class="line">        <span class="keyword">if</span>(it.hasNext())&#123;</span><br><span class="line">            T result=it.next();</span><br><span class="line">            <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">                result=combiner.combine(result,it.next());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Collector&lt;T&gt; <span class="title">forEach</span><span class="params">(Iterable&lt;T&gt; seq,Collector&lt;T&gt; func)</span></span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(T item:seq)&#123;</span><br><span class="line">           func.function(item);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> func;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;R,T&gt; <span class="function">List&lt;R&gt; <span class="title">transform</span><span class="params">(Iterable&lt;T&gt; seq,UnaryFunction&lt;R,T&gt; func)</span></span>&#123;</span><br><span class="line">        List&lt;R&gt; result=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(T t:seq)&#123;</span><br><span class="line">            result.add(func.function(t));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">filter</span><span class="params">(Iterable&lt;T&gt; seq, UnaryPredicate&lt;T&gt; pred)</span></span>&#123;</span><br><span class="line">        List&lt;T&gt; result =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(T t:seq)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pred.test(t))&#123;</span><br><span class="line">                result.add(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerAdder</span> <span class="keyword">implements</span> <span class="title">Combiner</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">combine</span><span class="params">(Integer a,Integer b)</span></span>&#123;<span class="keyword">return</span> a + b;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerSubtracter</span> <span class="keyword">implements</span>  <span class="title">Combiner</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">combine</span><span class="params">(Integer a, Integer b)</span></span>&#123;<span class="keyword">return</span> a-b;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BigDecimalAdder</span> <span class="keyword">implements</span> <span class="title">Combiner</span>&lt;<span class="title">BigDecimal</span>&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> BigDecimal <span class="title">combine</span><span class="params">(BigDecimal x,BigDecimal y)</span></span>&#123;<span class="keyword">return</span> x.add(y);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BigIntegerAdder</span> <span class="keyword">implements</span> <span class="title">Combiner</span>&lt;<span class="title">BigInteger</span>&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> BigInteger <span class="title">combine</span><span class="params">(BigInteger x,BigInteger y)</span></span>&#123;<span class="keyword">return</span> x.add(y);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">GreaterThan</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; <span class="keyword">implements</span> <span class="title">UnaryPredicate</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> T bound;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">GreaterThan</span><span class="params">(T bound)</span></span>&#123; bound=bound;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T item)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> item.compareTo(bound)&gt;<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiplyingInteger</span> <span class="keyword">implements</span> <span class="title">Collector</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer val=<span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">function</span><span class="params">(Integer x)</span></span>&#123;</span><br><span class="line">            val*=x;</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">result</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; l1= Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>);</span><br><span class="line">       </span><br><span class="line">        Integer addResult=reduce(l1,<span class="keyword">new</span> IntegerAdder());</span><br><span class="line">        Integer substractResult=reduce(l1,<span class="keyword">new</span> IntegerSubtracter());</span><br><span class="line">        List&lt;Integer&gt; listResult=filter(l1,<span class="keyword">new</span> GreaterThan&lt;Integer&gt;(<span class="number">4</span>));</span><br><span class="line">        forEach(l1,<span class="keyword">new</span> MultiplyingInteger()).result();</span><br><span class="line">        <span class="comment">//省略不写</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>策略模式可以产生非常优雅得的代码，因为它将“变化的事物”完全隔离到一个函数对象<strong>，函数对象就是在某种程度上行为像函数的对象——一般地，会有一个相关的方法，函数对象的价值就在于，与普通的方法不同，它们可以传递出去，并且还可以拥有在多个调用之间持久化的状态，当然可以用类中的任何方法来实现与此相似的工作，但是（与使用任何设计模式一样）函数对象主要是由其目的来区别的</strong>这里的，目的即使要创建某种事物，使它的行为就像一个可以传递出去的单个方法一样，这样，它就和策略模式紧耦合了，有时甚至无法区分<br>其实各种设计模式之间的界限真的很模糊，有时很难区分，有时靠设计目的区分，所以没有绝对的模式</p>
<h2 id="总结：转型真的如此之糟吗？"><a href="#总结：转型真的如此之糟吗？" class="headerlink" title="总结：转型真的如此之糟吗？"></a>总结：转型真的如此之糟吗？</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/14/泛型/" data-id="cjnj9osis0037uwrzmqe5r80p" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-类型信息" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/12/类型信息/" class="article-date">
  <time datetime="2018-10-12T05:21:23.000Z" itemprop="datePublished">2018-10-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习心得/">学习心得</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/12/类型信息/">类型信息</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>运行时类型信息（runtime Type information）使得你可以在程序运行时发现和使用类型信息<br>它使你从只能在编译期执行面向类型的操作的禁锢中解脱出来<br>java是如何让我们在运行时识别对象和类的信息的，主要有两种方式，一种是“传统的”RTTI，它假定我么不能在编译时已经知道了所有的类型，另一种是“反射”机制，它允许我们在运行时发现和使用类的信息  </p>
<h2 id="为什么需要RTTI"><a href="#为什么需要RTTI" class="headerlink" title="为什么需要RTTI"></a>为什么需要RTTI</h2><p>我们看一下多态的例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123; System.out.print(<span class="keyword">this</span>+<span class="string">".draw()"</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cricle</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">"Cricle"</span>;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">"Square"</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shapes</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;Shape&gt; shapeList= Arrays.asList(<span class="keyword">new</span> Cricle(),<span class="keyword">new</span> Square());</span><br><span class="line">        <span class="keyword">for</span>(Shape shape:shapeList)&#123;</span><br><span class="line">            shape.draw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，当把Shape对象放在List<shape>列表时会向上转型，但向上转型为Shape的时候，也丢失了Shape对象的具体的类型，对于列表而言，它们只是Shape类型的对象（我们这样思考一个问题，为什么我们在编程的时候，没有使用具有的引用类型，而是向上转型为更加通用的类型引用，诚然，我们可以使用更具体的类型来表示对象类型，拥有更多的方法可以操作这个类型，但是我们却没有办法写更适用的代码，每一个代码片段都与特定类型相关联，耦合度太高，我们要将类型向上转型为它的基类，这样拥有同样的接口，但是却丢失了关于这个对象具体类型的信息，<strong>注意，我们说的丢失了具体类型的信息指的是在编译期，在编译期，我们会将它的对象类型当作基类看待，实际上，对象本身的类型信息并没有丢失，我们可以在程序运行的时候重新拿到本来属于它的身份（类型信息）</strong>，这就是运行时类型信息的全部解释）<br>当从列表中取出元素时，这种容器——实际上将它所有的事物都当成Object持有——会自动将结果转型回Shape的，在java中所有的类型转换都是在运行是进行正确的检查，这也是RTTI名字的含义，在这个例子中，RTTI类型转换的并不彻底，Object被转型为Shape，而不是转换成Cricle，Square这种更具体的类型，这是因为我们只知道这个List<shape>保存的是Shape，将由容器和Java泛型机制保证这一点，而在运行时，由类型转换确保这一点</shape></shape></p>
<h2 id="Class对象"><a href="#Class对象" class="headerlink" title="Class对象"></a>Class对象</h2><p>要理解RTTI在java中的工作原理，首先必须知道类型信息在运行时是如何表示的，这项工作是被称为Class对象的特殊对象完成的，它包含了与类相关的信息， Class对象就是用来创建类的所有“常规”对象的，java使用Class对象来执行其RTTI，即使你正在执行类型转换这样的工作<br>类是程序的一部分，每个类都是一个Class对象，换言之，每当编写并且编译一个新类，就会产生一个Class对象（更恰当的说，是保存在一个同名的.class文件中，这个.class文件保存在关于这个类的一切信息，我们可以将这个.class文件看作对象，这和类加载之后在内存中创建的Class对象没有太大的分别，最大的区别也许就是存储位置的不同）为了生成这个类的对象，运行这个程序的Java虚拟机（JVM)将使用被称为“类加载器”的子系统<br>所有的类都是在第一次被使用时，动态加载到JVM中的，当程序创建第一个对类的静态成员的引用时，就会加载这个类，这额证明了构造器也是静态方法，虽然在它之前没有static关键字，因此，java程序在它开始之前并非完全加载，其各个部分都是在必需时才加载的，如果尚未加载，默认的类加载器就会根据类名查找.class文件，而这个类的字节码文件就被加载，它会接受验证，以确保其没有被破坏，并且不包含不良的Java代码<br>（从我的理解来看，程序是对象与对象之间通讯，而Class掌握着生成这些对象和怎样通讯的所有知识，我们编写程序就是编写这些类，类由虚拟机加载，并且通过虚拟机创建对象，互相在对象之间传递消息，那么虚拟机是什么？虚拟机是程序，是代码运行的平台，我们编写的类都是程序的构件，以供虚拟机使用）<br>一旦某个类的Class对象被载入内存，它就被用来创建这个类的所有对象</p>
<pre><code>Class Class.forName(String className);
</code></pre><p>上面的方法是Class类的一个静态方法，返回一个Class对象的引用，如果你有某个对象的引用，也可以使用Object的getClass()方法，得到一个Class对象的引用，对forName()的调用就是为了产生副作用，其实更准确的说，forName()方法的调用是为了加载某个类，所有，如果这个类还没有被加载，那么就加载它，在加载的过程中，类的static子句开始执行<br>记住，所有的Class对象都是Class类，这听起来感觉很奇怪，我们知道类的所有信息都是在.class文件保存着，类加载器子系统通过这些文件会在内存空间创建相应的Class对象，其实这些对象和普通的对象的共同点就是对象，只不过这个Class对象拥有着这个类型信息，而其他对象拥有着属性数据，那么这些Class对象之间肯定有着某种共性，而这种共性就是它们都是Class类型<br>我们得到了Class对象的引用，就可以操作它以获得它的数据（类型信息）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getName()</span><br><span class="line">getSimpleName()</span><br><span class="line">getCanonicalName()</span><br><span class="line">getInterfaces()</span><br><span class="line">isInterface()</span><br><span class="line">getSuperClass()</span><br><span class="line">newInstance()</span><br></pre></td></tr></table></figure></p>
<p>Class对象的newInstance()方法是实现“虚拟构造器”的一种途径，虚拟构造器允许你声明“我不知道你的确切类型”，但是啊无论如何要正确地创建你自己，<strong>比如up是一个Class引用，在编译期不具备任何更进一步的类型信息，当你创建新实例时，会得到一个Object对象</strong>，但是这个引用指向一个确切的类型，当然你可以发送Object能够接受的信息之外的任何消息之前，你必须更多的了解它，并进行某种转型，另外，使用newInstance()必须带有默认的构造器  </p>
<h3 id="类字面常量"><a href="#类字面常量" class="headerlink" title="类字面常量"></a>类字面常量</h3><p>java提供了另一种方法来生成对Class对象的引用，即使用类字面量常量 例如<br>    FancyToy.class<br>这样做不仅更简单，而且也更安全，因为它在编译时就会受到检查（因此不需要置于try语句块中），并且它根除了forName()方法的调用，所有也更高效<br>建议使用“.class”的形式，以保持与普通类的一致性<br>注意，有一点很有趣，使用“.class”来创建对Class对象的引用时，不会自动地初始化Class对象，为了使用类而做的准备工作实际上包含三个步骤</p>
<ol>
<li>加载：这是类加载器执行的，该步骤将查找字节码，并从这些字节码中创建一个Class对象</li>
<li>链接：在链接阶段将验证类中的字节码，为静态域分配存储空间，并且如果必需的话，将解析这个类对其他类的所有引用</li>
<li>初始化：如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块<br>初始化被延迟到了对静态方法（构造器隐式地是静态的）或非常数静态方法进行首次引用是才执行<br>初始化有效地实现了尽可能的“惰性”，仅使用.class语法来获得对类的引用不会引发初始化，和是和forName()不同的  <h3 id="泛化的Class引用"><a href="#泛化的Class引用" class="headerlink" title="泛化的Class引用"></a>泛化的Class引用</h3>Class引用总是指向某一个Class对象，它可以制造类的实例，并包含可作用与这些实例的所有方法代码，它还包括了该类的静态成员。因此。Class引用表示的就是指向它所指对象的确切类型，而该对象表示Class类的一个对象<br>如何将它的类型变得更具体，而<strong>这是通过允许你对Class引用所指向的Class对象的类型进行限定而实现的</strong>，这里使用了泛型语法，比如<br> Class<integer> classRef=int.class;<br>你也许会认为，下面的代码也是正确的<br> Class<number> classRef=int.class;<br>但是它是无法工作的，虽然Number是Integer的基类，但是Integer的Class对象不是Number的Class对象的子类，这个例子的正确做法是<br> Class&lt;? extends Number&gt; classRef=int.class;<br>当你使用泛型语法的时候将会发生一件有趣的事情，newInstance()将会返回该对象的确切的类型，而不是基本的Object,如下：<h3 id="新的转型语法"><a href="#新的转型语法" class="headerlink" title="新的转型语法"></a>新的转型语法</h3>Class引用的转型语法 cast()  不过我们很少使用<h2 id="类型转换前先做检查"><a href="#类型转换前先做检查" class="headerlink" title="类型转换前先做检查"></a>类型转换前先做检查</h2>目前我们已知的RTTI形式包括</number></integer></li>
<li>传统的类型转换 如“(Shape)” 由RTTI确保类型转换的正确性，如果执行了一个错误的转换，就会抛出一个ClassCastException</li>
<li>代表对象的类型的Class对象，通过查询Class对象可以获取运行时所需的信息</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/12/类型信息/" data-id="cjnj9oseg002euwrz57judnq7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-字符串" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/11/字符串/" class="article-date">
  <time datetime="2018-10-11T11:14:03.000Z" itemprop="datePublished">2018-10-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习心得/">学习心得</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/11/字符串/">字符串</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="不可变String"><a href="#不可变String" class="headerlink" title="不可变String"></a>不可变String</h2><p>&emsp;&emsp;String对象是不可变的，查看JDK文档，会发现，String类中每一个看起来会修改String值的方法，实际上都是创建了一个全新的String对象，以包含修改后的字符串内容，而最初的String对象纹丝未动，当吧String对象作为方法的参数时，都会复制一份引用，而该引用所指的对象其实一直待在单一的物理位置上，从未动过<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Immutable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">upcase</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String q=<span class="string">"howdy"</span>;</span><br><span class="line">        System.out.print(q);<span class="comment">//howdy</span></span><br><span class="line">        String qq=upcase(q);</span><br><span class="line">        System.out.print(qq);<span class="comment">//HOWDY</span></span><br><span class="line">        System.out.print(q);<span class="comment">//howdy</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;上例upcase()返回的引用已经指向了一个新的对象了，而原本的q则还在原地<br>&emsp;&emsp;String的这种行为方式其实正是我们想要的，难道我们真的希望upcase()改变参数的行为吗？参数是为该方法提供信息的，而不是先让该方法改变自己的</p>
<h2 id="重载“-”与StringBuilder"><a href="#重载“-”与StringBuilder" class="headerlink" title="重载“+”与StringBuilder"></a>重载“+”与StringBuilder</h2><p>&emsp;&emsp;String对象的不可变性带来了效率的问题，为String对象重载的“+”操作符就是一个例子，重载的意思是，一个操作符在应用于不同的类上，被赋予老特殊的含义<br>&emsp;&emsp;我们经常使用“+”操作进行字符串的拼接，可是由于String对象的不可变性，我们猜想每一次的连接操作都会产生一个新的String对象，若是进行多次的拼接操作，会有大量的中间String对象产生，会造成内存资源的浪费和垃圾回收器的负担，比如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String concatStr=<span class="string">"asdad"</span>+<span class="string">"asdas"</span>+<span class="string">"sfadfdf"</span>+<span class="string">"asdasd"</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;但是当我们使用javap，对上述代码jinx反编译的时候，就会看到，在进行字符拼接的时候，编译器帮我们做了优化，首先new StringBuilder对象，通过append()方法拼接，使用toString()返回一个字符串对象，编译器以及帮我们的源码进行了优化，那么是否我们就确信编译器优化，而毫无考虑的就到处使用“+”操作符进行字符串的拼接操作呢？我们在看一个例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(String str:StringArr[])&#123;</span><br><span class="line">    s+=str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">for</span>(String str:StringArr)&#123;</span><br><span class="line">   sb.append(str);</span><br><span class="line">&#125;</span><br><span class="line">sb.toString();</span><br></pre></td></tr></table></figure></p>
<p>我们在进行javap进行反编译，可知在上面的第一个例子，每次循环内都要创建new StringBuilder(),而第二个例子只创建一次，那么这个例子就可以说明什么时候应该使用StringBuilder来对字符串进行拼接操作了<br>StringBuilder提供了丰富而全面的方法，包括insert(),replace(),subString()甚至reverse(),但是最常用的还是append()a,toString()，还有delete()<br>Stringbuilder是Java SE5引入的，在这之前java用的是StringBuffer,后者是线程安全的，因此开销也会大些  </p>
<h2 id="无意识的递归"><a href="#无意识的递归" class="headerlink" title="无意识的递归"></a>无意识的递归</h2><p>我们一般经常都会调用一个对象的toString()方法，比如容器的打印，实际上也会调用每个元素的toString()方法，若我们想要打印对象的内存地址怎么办呢？下面是一个对象，重新定义了toString()方法，并且打印自己的内存地址<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InfiniteRecursion</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"asdasdas"</span>+<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的定义是对的吗？完全错误，如果我们调用这个对象的toString()方法就会导致递归，因为我们对this也执行了toString()调用，没完没了，正确的方法如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="string">"asdasdas"</span>+<span class="keyword">super</span>.toString();</span><br></pre></td></tr></table></figure></p>
<p>因为这样会调用基类的toString方法，就避免了递归</p>
<h2 id="String上的操作"><a href="#String上的操作" class="headerlink" title="String上的操作"></a>String上的操作</h2><p>下面是String对象具备的一些基本操作  </p>
<table>
<thead>
<tr>
<th>方法</th>
<th>参数，重载版本</th>
<th>应用</th>
</tr>
</thead>
<tbody>
<tr>
<td>构造器</td>
<td>重载版本：默认版本，String，StringBuilder<br>StringBuffer char数组，byte数组</td>
<td>创建String对象</td>
</tr>
<tr>
<td>length()</td>
<td></td>
<td>String中字符的个数</td>
</tr>
<tr>
<td>charAt()</td>
<td>int索引</td>
<td>取得String中该索引位置上的char</td>
</tr>
<tr>
<td>getChars(),getBytes()</td>
<td>要复制部分的起点和终点的索引，<br>复制的目标数组，目标数组，目标数组的起始索引</td>
<td>复制char或byte到一个目标数组中</td>
</tr>
<tr>
<td>toCharArray()</td>
<td></td>
<td>生成一个char[]</td>
</tr>
<tr>
<td>equals(),equalsIgnoreCase()</td>
<td>与之进行比较的String</td>
<td>比较两个String的内容是否相同</td>
</tr>
<tr>
<td>compareTo()</td>
<td>与之进行比较的String</td>
<td>按词典顺序比较String的内容，比较结果为负数，零，正数，注意，大小写不等价</td>
</tr>
<tr>
<td>contains()</td>
<td>要搜索的CharSequence</td>
<td>如果该String对象包含参数的内容，则返回true</td>
</tr>
<tr>
<td>containEquals()</td>
<td>与之进行比较的CharSequence或StringBuffer</td>
<td>如果该String与参数的内容一致，则返回true</td>
</tr>
<tr>
<td>equealsIgnoreCase()</td>
<td>与之进行比较的String</td>
<td>忽略大小写的比较相等性</td>
</tr>
<tr>
<td>regionMatcher()</td>
<td>该String的索引偏移量，另一个String及其索引偏移量，<br>要比较的长度，重载版本增加了“忽略大小写”功能</td>
<td>返回boolean结果，已表明所比较区域是否相等</td>
</tr>
<tr>
<td>StartsWith()</td>
<td>可能的起始String，重载版本在参数中增加了偏移量</td>
<td>返回值为boolean值</td>
</tr>
<tr>
<td>endsWith()</td>
<td>该String可能的后缀String</td>
<td>返回boolean值</td>
</tr>
<tr>
<td>indexOf(),lastIndexOf()</td>
<td>重载版本包括：char，char与起始索引，<br>String，String与起始索引</td>
<td>如果该String并不包含此参数，就返回-1<br>否则返回此参数在String中的起始索引，lastIndexOf()是从后向前搜索</td>
</tr>
<tr>
<td>subString()(subSequence())</td>
<td>重载版本：起始索引;起始索引+终点索引</td>
<td>返回一个新的String，以包含参数指定的字符串</td>
</tr>
<tr>
<td>concat()</td>
<td>要连接的字符串</td>
<td>返回一个新的String对象，内容为原始String连接上参数String</td>
</tr>
<tr>
<td>replace()</td>
<td>要替换掉的字符，用来进行替换的新字符。<br>也可以用一个CharSequence来替换另一个CharSequence</td>
<td>返回替换字符后的新String对象<br>如果，没有替换发生，则返回原始的String对象</td>
</tr>
<tr>
<td>toLowerCase(),toUpCase()</td>
<td></td>
<td>将字符的大小写改变，返回一个新的字符串</td>
</tr>
<tr>
<td>trim()</td>
<td></td>
<td>将字符串两端的空白字符删除</td>
</tr>
<tr>
<td>valueOf()</td>
<td>重载版本：Object;char[];char[],偏移量，与字符个数；<br>boolean；char;int;lang;float;double</td>
<td>返回一个表示参数内容的String</td>
</tr>
<tr>
<td>intern()</td>
<td></td>
<td>为每个唯一的字符序列生成一个且仅生成一个String引用  </td>
</tr>
</tbody>
</table>
<h2 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h2><p>在长久的等待之后，java SE5终于推出了C语言中printf()风格的格式化输出</p>
<h3 id="System-out-format"><a href="#System-out-format" class="headerlink" title="System.out.format"></a>System.out.format</h3><p>java SE5引入的format()方法可用于PrintStream或PrintWriter对象，format()方法模仿C语言的printf()，它只需要一个简单的格式化字符串和一串的参数就可，语法如下.以System.out为例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.format(<span class="string">"Row 1:[%d %f]\n"</span>,x,y);</span><br></pre></td></tr></table></figure></p>
<h3 id="Formatter类"><a href="#Formatter类" class="headerlink" title="Formatter类"></a>Formatter类</h3><p>在java中，所有新的格式化功能都由java.util.Formatter类处理,可以将Formatter看作一个翻译机，它将你的格式化字符串与数据翻译成需要的结果，当你创建一个Formatter对象的时候，可以向其构造器传递一些信息，告诉它最终的结果将向哪里输出  </p>
<h3 id="格式化说明符"><a href="#格式化说明符" class="headerlink" title="格式化说明符"></a>格式化说明符</h3><p>在插入数据时，如果想要控制空格与对齐，你需要更精细复杂的格式修饰符，一下是其抽象的语法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[argument_index$][flags][width].[precision]conversion</span><br></pre></td></tr></table></figure></p>
<p>最常用的是width控制一个域的最小尺寸，数据是右对齐的，可以添加“-”标志来控制对其方向<br>不是所有类型的元素都能用precision，而且不同类型的元素使用precision代表的含义也不相同<br>Formatter转换（conversion）<br>下面包含了最常用的类型转换   </p>
<table>
<thead>
<tr>
<th></th>
<th>：类型转换：</th>
</tr>
</thead>
<tbody>
<tr>
<td>d</td>
<td>整数型（十进制）</td>
</tr>
<tr>
<td>c</td>
<td>unicode字符</td>
</tr>
<tr>
<td>b</td>
<td>Boolean值</td>
</tr>
<tr>
<td>s</td>
<td>String</td>
</tr>
<tr>
<td>f</td>
<td>浮点数（十进制）</td>
</tr>
<tr>
<td>e</td>
<td>浮点数（科学计数）</td>
</tr>
<tr>
<td>x</td>
<td>整数（十六进制）</td>
</tr>
<tr>
<td>h</td>
<td>散列码</td>
</tr>
<tr>
<td>%</td>
<td>字符“%”</td>
</tr>
</tbody>
</table>
<h3 id="String-format"><a href="#String-format" class="headerlink" title="String.format()"></a>String.format()</h3><p>java SE5也参考了C的sprintf()的方法，以生成格式化的String对象，String.format()是一个static方法，它接受与Formatter.format()相同的参数，但返回一个String对象，当你只使用formatter()方法一次的时候，String.format()是个不错的选择，语法 类似如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String result = String.format(<span class="string">"(t%d,q%d) %s"</span>,transcationID,queryID,message);</span><br></pre></td></tr></table></figure></p>
<p>其实在String.format()内部，它是创建一个Formatter对象，然后将你的参数传递给它，不过与其自己做这些事情，不如使用便捷的String.format()代码更清晰易读</p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式是一种强大而灵活的文本处理工具，<strong>使用正则表达式，我们能够以编程的方式，构造复杂的文本，并对输入的字符串进行搜索，一旦找到匹配这些模式的部分，你就能够随心所欲地对它们进行处理</strong>，正则表达式提供了一种完全通用的方式，能够解决各种字符串处理相关的问题，匹配，选择，编辑以及验证</p>
<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>在其他的语言中,\\表示“我想要在表达式中插入一个普通的反斜线，请不要给他任何特殊的意义，而在java中，\\的意思是”我要插入正则表达式的反斜线，”，所以其后的字符具有一个特殊的意义，你想插入一个普通的反斜线，则应该这样\\\\”<br>应用正则表达式最简单的途径，就是利用String类内建的matches()方法<br>String还有一个非常有用的正则表达式工具——split()方法，其功能是“将字符串从正则表达式匹配的地方切开”，split()还有一个重载的版本，它允许你限制字符串分割的次数<br>如果只是需要使用一次正则表达式，那么上面的方法是很方便的吗，但是如果你想对一个正则表达式反复复用，那么非String类型的正则表达式具备更加的性能和功能</p>
<h3 id="创建正则表达式"><a href="#创建正则表达式" class="headerlink" title="创建正则表达式"></a>创建正则表达式</h3><hr>
<table>
<thead>
<tr>
<th></th>
<th>字符</th>
</tr>
</thead>
<tbody>
<tr>
<td>B</td>
<td>指定字符B</td>
</tr>
<tr>
<td>\xhh</td>
<td>十六进制值为0xhh的字符</td>
</tr>
<tr>
<td>\uhhhh</td>
<td>十六进制表示为oxhhhh的Unicode字符</td>
</tr>
<tr>
<td>\n</td>
<td>换行符</td>
</tr>
<tr>
<td>\t</td>
<td>制表符</td>
</tr>
<tr>
<td>\r</td>
<td>回车</td>
</tr>
<tr>
<td>\f</td>
<td>换页</td>
</tr>
<tr>
<td>\e</td>
<td>转义（Escape）</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th></th>
<th>字符类</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>任意字符</td>
</tr>
<tr>
<td>[abc]</td>
<td>包含a,b，c的任何字符（和a</td>
<td>b</td>
<td>c作用相同）</td>
</tr>
<tr>
<td>[^abc]</td>
<td>除了a,b,c之外的任意字符（否定）</td>
</tr>
<tr>
<td>[a-zA-Z]</td>
<td>从a到或从A到Z的任何一个字符</td>
</tr>
<tr>
<td>[abc[hij]]</td>
<td>任意a,b,c,h.i,j的字符（与a</td>
<td>b</td>
<td>c</td>
<td>h</td>
<td>i</td>
<td>j的作用相同）</td>
</tr>
<tr>
<td>[a-z&amp;&amp;[hij]]</td>
<td>任意h,i,j（交集）</td>
</tr>
<tr>
<td>\s</td>
<td>空白符（空格，tab,换行，换页或回车）</td>
</tr>
<tr>
<td>\S</td>
<td>非空白符</td>
</tr>
<tr>
<td>\d</td>
<td>数字[0-9]</td>
</tr>
<tr>
<td>\D</td>
<td>非数字[^0-9]</td>
</tr>
<tr>
<td>\w</td>
<td>词字符[a-zA-Z0-9]</td>
</tr>
<tr>
<td>\w</td>
<td>非词字符[^\w]</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th></th>
<th>逻辑操作符</th>
</tr>
</thead>
<tbody>
<tr>
<td>XY</td>
<td>Y紧跟在X后面</td>
</tr>
<tr>
<td>X</td>
<td>Y</td>
<td>X或Y</td>
</tr>
<tr>
<td>(X)</td>
<td>捕获组（capturing group）可以在表达式中引用\i第一i个捕获组</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th></th>
<th>边界匹配符</th>
</tr>
</thead>
<tbody>
<tr>
<td>^</td>
<td>一行的起始</td>
</tr>
<tr>
<td>$</td>
<td>一行的结束</td>
</tr>
<tr>
<td>\b</td>
<td>非词的边界</td>
</tr>
<tr>
<td>\B</td>
<td>词的边界</td>
</tr>
<tr>
<td>\G</td>
<td>前一个匹配的结束</td>
</tr>
</tbody>
</table>
<h3 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h3><p>量词描述了一个模式吸收输入文本的方式：</p>
<ul>
<li>贪婪型：量词总是贪婪的，除非有其他的选项被设置，贪婪表达式会为所有可能的模式发现尽可能多的匹配，导致此问题的一个典型理由就是假定我们的模式仅能匹配第一个可能的字符组，如果它是贪婪的，那么它就会继续往下匹配  </li>
<li>勉强型：用问好来指定，这个量词匹配满足模式所需最少字符数，因此也称做懒惰的，最少匹配的，非贪婪的，或不贪婪的  </li>
<li>占有型：目前，这种类型的量词只有java语言中才可用，并且也更高级，当正则表达式被应用于字符串时，它会产生相当多的状态，以便在匹配失败时可以回溯，而“占有的”量词并不保存这些中间状态，因此它们可以防止回溯，它们常常用于防止正则表达式失控，因此可以使正则表达式执行起来更有效  </li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>贪婪型</th>
<th>勉强型</th>
<th>占有型</th>
<th>如何匹配</th>
</tr>
</thead>
<tbody>
<tr>
<td>X?</td>
<td>X??</td>
<td>x?+</td>
<td>一个或零个X</td>
</tr>
<tr>
<td>X*</td>
<td>X*?</td>
<td>X*+</td>
<td>零个或者多个X</td>
</tr>
<tr>
<td>X+</td>
<td>X+?</td>
<td>X++</td>
<td>一个或者多个X</td>
</tr>
<tr>
<td>X{n}</td>
<td>X{n}?</td>
<td>X{n}+</td>
<td>恰好n次</td>
</tr>
<tr>
<td>X{n,}</td>
<td>X{n,}?</td>
<td>X{n,}+</td>
<td>至少n次</td>
</tr>
<tr>
<td>X{n,m}</td>
<td>X{n,m}?</td>
<td>X{n,m}+</td>
<td>X至少n次，最多m次</td>
</tr>
</tbody>
</table>
<p>要非常注意的是表达式X必须要用圆括号括起来，以便它能按照我们期望的效果去执行，例如 abc+和（abc）+,前面的表示表示匹配ab，后面跟随1个或者多个c，而(abc)+表示匹配一个或者多个abc<br>接口CharSequence从CharBuffer,String,StringBuffer,StringBuilder类之中抽象出了字符序列的一般化定义<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CharSequenece</span></span>&#123;</span><br><span class="line">  charAt();</span><br><span class="line">  length();</span><br><span class="line">  subSequence(<span class="keyword">int</span> start,<span class="keyword">int</span> end);</span><br><span class="line">  toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此，这些类都实现了接口，多数正则表达式操作都接受CharSequence类型的参数  </p>
<h3 id="Pattern和Matcher"><a href="#Pattern和Matcher" class="headerlink" title="Pattern和Matcher"></a>Pattern和Matcher</h3><p>比起功能有限的String，我们更愿意构造功能强大的正则表达式对象，只需要导入java.util.regex包，然后用static Pattern.compile()方法来编译你的正则表达式即可，它会根据你的String类型的正则表达式生成一个Pattern对象，接下来，把你想要检索的字符串传入Pattern对象的matcher()方法会生成一个Matcher对象，它有很多功能可用，例如它的replaceAll()方法能够将所有匹配的部分替换成你传入的参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRegularExpression</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            System.out.print(<span class="string">"args's count is not right"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String arg:args)&#123;</span><br><span class="line">            Pattern p = Pattern.compile(arg);</span><br><span class="line">            Matcher m = p.matcher(<span class="string">"args[0]"</span>);</span><br><span class="line">            <span class="keyword">while</span>(m.find())&#123;</span><br><span class="line">                System.out.print(m.group()+m.start()+m.end());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Pattern变量表示编译后的正则表达式，我们可以使用编译后的Pattern对象的matcher()方法，加上一个输入字符串，从而共同构造一个Matcher对象，同时Pattern类还提供了一个静态方法<br>    static boolean matcher(String regex,CharSequence input)<br>编译后的Pattern对象还提供了split()方法，它从匹配的regex的地方分割字符串，返回分割后的字符串的一个String数组<br>通过调用Pattern.matcher()方法，我们得到一个Matcher对象，使用Matcher上的方法，我们能够判断各种不同类型的匹配是否成功<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">lookingAt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">find</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> start)</span></span></span><br></pre></td></tr></table></figure></p>
<p>其中的matches()方法用来判断这个输入字符串是否匹配正则表达式，而lonkingAt()则用来判断该字符串（不必是整个字符串）的始部分是否匹配模式<br>find()像迭代器那样向前办理输入字符串，而第二个find(int start),该参数表示字符串中的字符位置，并以其作为搜索的起点</p>
<h3 id="Group-组"><a href="#Group-组" class="headerlink" title="Group(组)"></a>Group(组)</h3><p>组是用括号划分的正则表达式，可以根据组的编号来引用某个组，组号0表示整个表达式，组号1表示被第一对括号括起来的组，依次类推<br>A(B(C))D,这里有三个组，组0是ABCD,组1是BC,组2是C<br>Matcher（匹配器）对象提供了一些列的方法，用来获取与组相关的信息<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">groupCount</span><span class="params">()</span><span class="comment">//返回该匹配器的模式中的分组数量，第0组不算</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">group</span><span class="params">()</span><span class="comment">//返回前一次操作（例如find()）的第0组</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">group</span><span class="params">(<span class="keyword">int</span> i)</span><span class="comment">//返回前一次匹配操作期间指定的组号，如果匹配成功，但是指定的组没有匹配任何输入字符串的任何部分，则会返回null  </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> group)</span><span class="comment">//返回在前一次匹配操作中寻找到的组的起始索引</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">end</span><span class="params">(<span class="keyword">int</span> group)</span><span class="comment">//返回在前一次匹配操作中寻找到的组的最后一个字符索引加1的值</span></span></span><br></pre></td></tr></table></figure></p>
<p>start()和end()会返回前一次匹配操作的第一个字符位置和最后一个字符位置+1，如果匹配失败（或先于一个正在进行的匹配操作去尝试）。调用start()或end()都会产生一个IllegalStatException异常<br>find()可以在输入的任意位置定位正则表达式，而lookingAt()和matches()只有在正则表达式与输入的最开始位置处开始匹配才会成功</p>
<h3 id="Pattern标记"><a href="#Pattern标记" class="headerlink" title="Pattern标记"></a>Pattern标记</h3><p>Pattern的compile()还有另一个版本，它接受一个标记参数，以调整匹配的行为</p>
<pre><code>Pattern.compile(String regex,int flag)
</code></pre><p>其中的flag来自一下Pattern类中的常量  </p>
<table>
<thead>
<tr>
<th></th>
<th>编译标记</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>Pattern.CONON_EQ</td>
<td>两个字符当且仅当它们的完全规范分解相匹配时</td>
</tr>
<tr>
<td>Pattern.CASE.INSENSITIVE(?!)</td>
<td>默认情况下，大小写不敏感的匹配假定只有US-ASCII字符集中的字符才能进行，这个标记允许模式匹配不必考虑大小写（大写或小写），通过指定UNICODE_CASE标记及结合此标记，基于Unicode的大小写不敏感的匹配就可以开启了</td>
</tr>
<tr>
<td>Pattern.COMMENTS(?x)</td>
<td>在这种模式下，空格符将被忽略，并且以“#”开始直到行尾的注释也会被忽略掉，通过嵌入的标记表达式也可以开启Unix的行模式</td>
</tr>
<tr>
<td>Pattern.DOTALL(?s)</td>
<td>在dotall模式中，表达式“.”匹配所有的字符，包括行终结符。默认情况下“.”表达式不匹配行终结符</td>
</tr>
<tr>
<td>Pattern.MULTILINE</td>
<td>在多行模式下，表达式^和$分别匹配一行的开始和结束，^还匹配输入字符串的开始，而$还匹配输入字符串的结尾，默认情况下，这些表达式仅匹配输入的完整的字符串的开始和结束</td>
</tr>
<tr>
<td>Pattern.UNICODE_CASE(?u)</td>
<td>当指定这个标记，并且开启CASE.INSENSITIVE时，大小写不敏感的匹配将按照与Unicode标准相一致的方式进行，默认情况下，大小写不敏感的匹配假定只能在US-ASCII字符集中的字符才能进行  </td>
</tr>
<tr>
<td>Pattern.UNIX_LINES(?d)</td>
<td>在这种模式下，^和$行为中，其识别行终结符\n  </td>
</tr>
</tbody>
</table>
<h3 id="替换操作"><a href="#替换操作" class="headerlink" title="替换操作"></a>替换操作</h3><p>正则表达式特别便于替换文本，它提供了许多方法，replaceFirst(String replaceStr)替换掉第一个匹配成功的部分,replaceAll(String replaceStr)替换掉所有匹配成功的部分。appendReplacement(StringBuffer sbuf,String replaceent)此方法重要，允许你调用其他的方法来生成或处理replacement(replaceFirst()和replaceAll()则只能使用一个固定的字符串)，使得你能够以编程的方式来将目标分割成组，从而具备更强大的替换功能，appendTail(StringBuffer sbuf)，在执行完appendReplacement()之后，调用此方法可以将输入字符串余下的部分复制到sbuf中  </p>
<h3 id="reset"><a href="#reset" class="headerlink" title="reset()"></a>reset()</h3><p>通过reset()方法，可以将现有的Matcher对象应用于一个新的字符序列<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Resetting</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Matcher matcher = Pattern.compile(<span class="string">"[firb[aiu][gx]]"</span>).matcher(<span class="string">"fix the rug with bgs"</span>);</span><br><span class="line">        <span class="keyword">while</span>(matcher.find())&#123;</span><br><span class="line">            System.out.print(matcher.group());</span><br><span class="line">        &#125;</span><br><span class="line">        matcher.reset(<span class="string">"fix the rig rags"</span>);</span><br><span class="line">        <span class="keyword">while</span>(matcher.find())&#123;</span><br><span class="line">            System.out.print(matcher.group());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="正则表达式与I-O"><a href="#正则表达式与I-O" class="headerlink" title="正则表达式与I/O"></a>正则表达式与I/O</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/11/字符串/" data-id="cjnj9osa3001puwrz88yw6u8p" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-通过异常处理错误" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/11/通过异常处理错误/" class="article-date">
  <time datetime="2018-10-11T07:57:21.000Z" itemprop="datePublished">2018-10-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习心得/">学习心得</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/11/通过异常处理错误/">通过异常处理错误</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;java的理念是：结构不佳的代码不能运行<br>&emsp;&emsp;发现错误最好的时期是在编译阶段，也就是在你试图运行程序之前，然而，编译期间并不能找出所有的错误，余下的错误必须要在运行期间解决，这就需要错误源能够通过某种方式，将恰当的信息传递给某个对象——该接收者知道如何正确处理这个问题<br>&emsp;&emsp;改进的错误恢复机制是提供代码健壮性的最强有力的方式，错误恢复在我们所编写的每一个程序都是基本的元素，java使用异常来提供一直的错误报告模型，<strong>使得构件能与客户端代码可靠地沟通问题</strong>  </p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>&emsp;&emsp;C以及早期的语言常常具有多种错误处理模式，这些模式往往建立在约定俗成的基础之上，而这不属于语言的一部分，通常会返回某个特殊值或者设置某个标志，并且假定接收者将对这个返回值或者标志进行检查，以判断是否发生错误，但，随着时间的推移，人们发现很多的程序员更倾向于忽略对这些返回值和标志的检查，因为他们总是在想“这是别人的问题，不关我的事”，这对于构建大型的，健壮性，可维护的程序而言，这种错误处理机制已经成为阻碍<br>&emsp;&emsp;解决的办法是，用强制规定的形式来消除错误处理过程中随心所欲的因素<br>&emsp;&emsp;“异常”这个词有“我对此感到意外”的意思，问题出现了，你也许不清楚该如何处理，当你确实不该置之不理，你要停下来，看看是不是有别人或在别的地方，能够处理这个问题，只要是在当前环境中还没有足够的信息来解决这个问题，就将这个问题提交到一个更高的环境中，在这里将作出正确的决定<br>&emsp;&emsp;使用异常所带来的一个好处是，它往往能够降低错误处理代码的复杂度，如果不使用异常，那么就必须检查特定的错误，并在程序中的许多地方去处理它，而如果使用异常，那就不必再方法调用处进行检查，因为<strong>异常机制保证能够捕获这个错误</strong>，并且，只在一个地方处理错误，即所谓的异常处理程序中，这样不仅节省代码，而且把描述在<strong>正常情况下“执行过程中做什么事”的代码和“出了问题怎么办”的代码相分离</strong></p>
<h2 id="基本异常"><a href="#基本异常" class="headerlink" title="基本异常"></a>基本异常</h2><p>&emsp;&emsp;异常清晰（exceptional condition）是指阻止当前方法或作用域继续执行的问题，把异常情形与普通问题相区分很重要，普通问题是指，在当前环境下能够得到足够的信息，总能处理这个错误，而对异常情形，就不能继续下去了，因为当前环境下无法获得必要的信息来解决这个问题<br>&emsp;&emsp;当抛出异常后，有几件事会相继发生，甚至，同java中其他对象的创建一样，将使用new在堆上创建异常对象，然后，当前的执行路径（既不能继续下去了）被终止，并且从当前的环境中弹出异常对象的引用，此时，异常处理机制接管程序，并开始寻找一个恰当的地方继续执行程序，这个恰当的地方就是异常处理程序，它的任务是将程序从错误状态恢复<br>&emsp;&emsp;异常最重要的方面之一就是如果发生问题，它们将不允许程序沿着其正常的路径继续走下去  </p>
<h3 id="异常参数"><a href="#异常参数" class="headerlink" title="异常参数"></a>异常参数</h3><p>&emsp;&emsp;与使用java中的其他对象一样，我们总是用new在堆上创建异常对象，这也伴随着存储空间的分配和构造器的调用，所有的异常类都有两个构造器，一个是默认构造器，另一个是接收字符串作为参数，以便能够把相关信息放入到异常对象的构造器<br>&emsp;&emsp;关键字throw将产生很有趣的结果，一个是新生成的异常对象的引用通过throw关键字传递到更大的环境，另一个效果是通过抛出异常的方式退出方法或作用域 此外还能抛出任意类型的Throwable对象，它是异常类型的根类</p>
<h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><h3 id="监控区域"><a href="#监控区域" class="headerlink" title="监控区域"></a>监控区域</h3><p>&emsp;&emsp;<strong>如果在方法的内部抛出了异常（或者在方法调用的其他方式抛出了异常），这个方法将在抛出异常的过程中结束，如果不希望方法就此结束，可以在方法内部设置一个特殊的块来捕获异常</strong>  </p>
<h3 id="异常处理程序"><a href="#异常处理程序" class="headerlink" title="异常处理程序"></a>异常处理程序</h3><p>&emsp;&emsp;抛出的异常必须在某个地方得到处理，这个地点就是异常处理程序，而且针对每一个要捕获的异常准备相应的异常处理程序  </p>
<h3 id="终止与恢复"><a href="#终止与恢复" class="headerlink" title="终止与恢复"></a>终止与恢复</h3><p>&emsp;&emsp;异常处理理论有两种基本模型，java支持终止模型，在这种模型中，将假设错误非常关键，以至于无法回到错误发生的地方继续执行，一旦异常被抛出，就表明错误无法挽回，也不能回来继续执行<br>&emsp;&emsp;另一种是恢复模型，意思是异常处理程序的工作是修正错误，然后尝试调用出问题的方法，并认为第二次能成功，java也可实现这种错误处理，将异常处理程序一个while循环中吗，直到程序执行成功<br>&emsp;&emsp;虽然恢复模型很吸引人，但是这种错误恢复机制的代码非常难以编写，而且你真的了解错误的所有方方面面吗？所以后来大部分的语言选择转向程序终止模型  </p>
<h2 id="创建自定义异常"><a href="#创建自定义异常" class="headerlink" title="创建自定义异常"></a>创建自定义异常</h2><p>&emsp;&emsp;java提供的异常体系不可能预见所有的希望加以报告的错误，所以可以自己定义异常类来表示程序中可能会遇到的特定问题<br>&emsp;&emsp;要定义自己的异常类，必须从已有的异常类继承，最好是意思相近的，其实无所谓，异常最重要的是类名，建立新的异常类最简单的方式就是让编译器为你产生默认的构造器</p>
<h2 id="异常说明"><a href="#异常说明" class="headerlink" title="异常说明"></a>异常说明</h2><p>&emsp;&emsp;<strong>java鼓励人们把方法可能会抛出的异常告知使用此方法的客户端程序员</strong>，这是种优雅的做法，它使得调用者能确切地知道应该写什么代码借用捕获所有的异常，java提供了相应的语法（并强制这个语法）使得你能以礼貌的方式告知客户端程序员某个方法可能会抛出的异常，然后客户端程序员会进行相应的处理，这就是异常说明，它属于方法声明的一部分，紧跟在形式参数列表之后 <code>void f()throws TooBig,TooSmall{}</code><br>&emsp;&emsp;如果代码方法产生了异常却没有对此说明，编译器会发现这错误并提醒你，那么处理这个异常，要么声明这个方法将会抛出异常<br>&emsp;&emsp;这种在编译器就被强制检测的异常被称为<code>被检查的异常</code></p>
<h2 id="捕获所有的异常"><a href="#捕获所有的异常" class="headerlink" title="捕获所有的异常"></a>捕获所有的异常</h2><p>&emsp;&emsp;可以只写一个异常来捕获所有类型的异常，通过捕获异常类型的基类Exception可以做到这一点,因为Exception是与编程有关的所有异常类的基类，所有它不会包含太多的信息，可以调用它从其基类Throwable继承来的方法<br>&emsp;&emsp;String getMessage()<br>&emsp;&emsp;String getLocalizedMessage()<br>&emsp;&emsp;或用本地语言表示的详细信息<br>&emsp;&emsp;String toString()<br>&emsp;&emsp;void printStackTrace()<br>&emsp;&emsp;void printStackTrace(PrintStream)<br>&emsp;&emsp;void printStackTrace(java.io.PrintWriter)<br>&emsp;&emsp;打印Throwable和Throwable的<code>调用栈轨迹</code>，调用栈显式了“把你带到异常抛出地点”的方法调用序列，其中第一个版本输出到标准错误，后两个版本允许选择要输出的流<br>&emsp;&emsp;Throwable fillStackTrace()<br>&emsp;&emsp;<strong>用于在Throwable对象的内部记录栈帧的当前转态，这在程序重新抛出错误或者异常时很有用</strong><br>&emsp;&emsp;此外还可以使用继承自Object的方法，比如getClass()返回Class类型对象，可以获得更多关于这个异常对象的信息</p>
<h3 id="栈轨迹"><a href="#栈轨迹" class="headerlink" title="栈轨迹"></a>栈轨迹</h3><p>&emsp;&emsp;<code>printStrackTrace()</code>方法所提供的信息可以通过<code>StackTraceElement getStackTrace()</code>方法来直接访问，这个方法将<strong>返回一个由栈轨迹中的元素所组成的数组，其中每一个元素都表示栈中的一祯，元素0是栈顶元素，并且是调用序列中的最后一个方法调用（这个Throwable被创建和抛出之处）</strong>数组中的最后一个元素和栈底是调用序列中的第一个方法调用</p>
<h3 id="重新抛出异常"><a href="#重新抛出异常" class="headerlink" title="重新抛出异常"></a>重新抛出异常</h3><p>&emsp;&emsp;重抛异常会把异常抛给上一级环境中的异常处理程序，此外，异常的所有信息都会得以保持，所以上一级环境中捕获此异常的处理程序通过通过这个异常对象得到所有的信息<br>&emsp;&emsp;如果只是将当前的异常对象重新抛出，那么printStackTrace()方法显示的将是原来异常抛出的调用栈信息，而非重新抛出点的信息，要想更新这个信息，<strong>可以调用fillInStackTrace()方法，这个方法将返回一个Throwable对象，它是通过把当前调用栈信息填入原来那个异常对象而建立的,因此调用fillinStackTrace()的那一行就成了异常的新发地</strong><br>&emsp;&emsp;有可能在捕获异常之后抛出另一种异常，那么这么做，得到的效果就类似与使用finInStackTrace(),有关原来异常发生地点的信息就会丢失剩下的是与新的抛出点有关的信息</p>
<h3 id="异常链"><a href="#异常链" class="headerlink" title="异常链"></a>异常链</h3><p>&emsp;&emsp;常常会想要在捕获一种异常之后抛出另一种异常，并且希望把原始异常的信息保存下来，这被称为异常链，现在所有的Throwable的子类在构造器中都可以接受一个cause(因由)对象作为参数，这个cause就用来表示原始异常，<strong>这样通过把原始异常传递给新的异常，使得即使在当前创建并抛出新的异常，也能够通过这个异常链追踪到异常最初发生的位置</strong><br>&emsp;&emsp;语法: <code>throw new NewException(CauseException)</code></p>
<h2 id="java标准异常"><a href="#java标准异常" class="headerlink" title="java标准异常"></a>java标准异常</h2><p>&emsp;&emsp;Throwable这个类被用来表示任何可以作为异常抛出的类。Throwable对象，可以分为两种类型（指从Throwable继承中得到的类型），Error用来表示编译时和系统错误（除特殊情况，一般你不用关心），Exception是可以抛出的异常，在java类库，用户方法以及运行时故障中都可能抛出这个Exception异常，所有java程序员关心的异常类型通常是Exception  </p>
<h3 id="特例-RuntimeExcepton"><a href="#特例-RuntimeExcepton" class="headerlink" title="特例 RuntimeExcepton"></a>特例 RuntimeExcepton</h3><p>&emsp;&emsp;属于运行时的异常类型有很多，它们会自动被java虚拟机抛出，所有不必在异常说明中吧它们列出来，这些异常都是从RuntimeException类继承而来的，不需要再异常说明中声明的异常也被称为“不受检查的异常”，尽管通常不用捕获RuntimeException异常，但还是可以在代码中抛出RuntimeException异常<br>&emsp;&emsp;如果不主动捕获这种类型的异常会发生什么事情呢？因为编译器没有在这个问题上对遗产说明进行强制检查，RuntimeException类型的异常也许会穿越所有的执行过程直达main()方法，而不会被捕获</p>
<h2 id="使用finally进行清理"><a href="#使用finally进行清理" class="headerlink" title="使用finally进行清理"></a>使用finally进行清理</h2><p>&emsp;&emsp;对于一些代码，你可能希望，无论try块中的异常是否抛出，它们都能得到执行，<strong>这通常适用于内存回收之外的情况</strong>（因为内存回收由垃圾回收器完成），为了达到这个效果，可以在try块之后加上finally子句</p>
<h3 id="finally用来做什么"><a href="#finally用来做什么" class="headerlink" title="finally用来做什么"></a>finally用来做什么</h3><p>&emsp;&emsp;finally非常重要，它能使程序员保证，无论try块里发生什么，内存总能得到释放，但java有垃圾回收机制，所以内存释放不再是问题<br>&emsp;&emsp;<strong>当把除内存之外的资源恢复到它们的初始转态时，就要用到finally子句</strong>，这种需要清理的资源包括，已经打开的文件或网络连接，在屏幕上画的图形，甚至是外部世界的某个开关  </p>
<h3 id="缺憾：异常丢失"><a href="#缺憾：异常丢失" class="headerlink" title="缺憾：异常丢失"></a>缺憾：异常丢失</h3><p>&emsp;&emsp;遗憾的是，java的异常实现也有瑕疵，异常通常作为程序出错的标志，绝不应该被忽视，但是还是有可能被轻易忽视，用某些特殊方法的finally放肆使用子句，就会发生这种情况，这种情况的方式吗，一般是在finally子句抛出新的遗产替换了正常方法中抛出的异常，这是相当严重的缺陷</p>
<h2 id="异常的限制"><a href="#异常的限制" class="headerlink" title="异常的限制"></a>异常的限制</h2><p>&emsp;&emsp;当覆盖方法的时候只能抛出在基类方法的异常说明里列的那些异常，这个限制很有用，因为这意味着，当基类方法使用的代码应用到派生类对象的时候，一样能够工作，异常也不例外，这样的规则在java随处可见，比如，派生类覆盖基类的方法，访问权限一定不能比基类的要小，这些规则都保证了，能调用基类的方法就一定可以调用导出类的方法这个原则</p>
<h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p>&emsp;&emsp;如果异常发生了，所有的东西都能被正确清理吗？因为涉及到构造器，问题就出现了，构造器会把对象设置成安全的初始转态，但是还会有别的动作，比如打开一个文件，这样的动作只有在对象使用完毕并且用户调用了特殊的清理方法之后才能的已清理，如果构造器内抛出了异常，这些清理行为也许就不能正常工作了，这意味着编写构造器时要格外小心，其实我们很少会遇到这也的问题，我们遵循的一条原则就是用尽量简单的方法构建对象</p>
<h2 id="异常匹配"><a href="#异常匹配" class="headerlink" title="异常匹配"></a>异常匹配</h2><p>异常处理系统会按照代码书写的书信找出“最近”的处理程序，找到匹配的处理程序之后，就认为异常得到了处理，就不在继续查找了查找的时候并不要去抛出的异常同处理程序声明的异常完全匹配，派生类的对象也可以匹配其基类的处理程序，所有一个原则是将更加特定的异常类型放在最前面</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/11/通过异常处理错误/" data-id="cjnj9osfe002kuwrz753ro8de" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-持有对象" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/10/持有对象/" class="article-date">
  <time datetime="2018-10-10T15:50:46.000Z" itemprop="datePublished">2018-10-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习心得/">学习心得</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/10/持有对象/">持有对象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;如果一个程序只包含固定数量的且其生命周期都是已知的对象，那么这是一个非常简单的程序<br>&emsp;&emsp;通常，程序总是根据运行时才知道的某些条件去创建对象，在此之前，不会知道所需对象的数量，甚至不知道确切的类型，为了解决这个普遍的编程问题，需要在任意时刻和任意位置创建任意数量的对象，所以，就不能依靠创建命名的引用<code>MyType aReference</code>来持有每一个对象<br>&emsp;&emsp;java有多种保存对象的方式，数组是个保存对象的最有效的方式之一，可是数组具有固定的尺寸，而在一般的情况中，你在写程序的时候根本不知道将需要多少的对象<br>&emsp;&emsp;Java实用类库提供了一整套完整的容器来来解决这个问题，其中基本的类型是List,Set,Queue和Map,这些对象也称为集合类，但是由于java的类库使用了Collection这个名字来指代该类库的一个特殊子集，所以我们使用范围更广的术语“容器”称呼它们<br>&emsp;&emsp;容器还有一些其他的特性，例如，Set对每个值都只保存一个对象，Map是允许你将某些对象与其他的一些对象关联起来的关联数组，java容器类都可以自动调整自己的尺寸，因此，与数组不同，在编程时，你可以将任意数量的对象放置在容器中，而且不需要担心容器应该设置为多大  </p>
<h2 id="泛型和类型安全的容器"><a href="#泛型和类型安全的容器" class="headerlink" title="泛型和类型安全的容器"></a>泛型和类型安全的容器</h2><p>&emsp;&emsp;在java SE5之前的容器有一个主要的问题就是编译器允许你向容器插入不正确的类型，而在之后，你可以通过预定义的泛型容器通过类型参数来指定你将要向容器中插入的数据类型，编译器将会放置错误的对象放置到容器中，而且不需要转型就可以从容器中取出正确类型的对象，因为容器知道自己保持的对象是什么类型</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>&emsp;&emsp;java容器类类库的用途就是“保存对象”，并将其划分为两个不同的概念  </p>
<ol>
<li>Collection 一个独立元素的序列，这些元素都服从一条或者多条规则  </li>
<li>Map 一组成对的“键值对”的对象，允许你通过键查找对象，ArrayList允许你使用数字来查找值，从某种意义上，它是将数字和对象关联在一起，映射表允许我们使用另一个对象查找另一个对象，它也被称为“关联数组”   <h2 id="添加一组元素"><a href="#添加一组元素" class="headerlink" title="添加一组元素"></a>添加一组元素</h2>&emsp;&emsp;在<code>java.util</code>包中的<code>Arrays</code>和<code>Collections</code>类中都有很多使用的方法，可以在一个<code>Collection</code>中添加一组元素，<code>Arrays.asList()</code>方法接受一个数组或者一个用逗号分隔的元素列表(可变参数)并将其转换为一个<code>List</code>对象，<code>Collections.addAll()</code>方法接受一个<code>Collection</code>对象，以及一个数组或是一个用逗号分隔的列表，将元素添加到<code>Collection</code>对象中  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddingGroup</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Collection&lt;Integer&gt; collection=<span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>));</span><br><span class="line">        Integer[] moreInt = &#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        Collections.addAll(collection,moreInt);</span><br><span class="line">        Collections.addAll(collection,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>);</span><br><span class="line">        List&lt;Integer&gt; list=Arrays.asList(<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">10</span>);</span><br><span class="line">        list.set(<span class="number">1</span>,<span class="number">99</span>);</span><br><span class="line">        <span class="comment">//list.add(21);runtime error because the underlying array connot be resized</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>&emsp;&emsp;Collection构造器可以接受另一个Collection，用它将自身初始化，Collection.addAll()和Collections.addAll()是两个完全不同的两个方法，前者是集合的通用接口中定义的方法，后者是Collections工具类定义的一个静态方法，Collection.addAll()方法只能接受另一个Collection对象作为参数，因此它不如Arrays.list()和Collections.addAll()来的灵活，这两个方法使用的都是可变参数列表<br>&emsp;&emsp;你可以直接使用ArrayList.asList()的输出，将其当做List,但是在这种情况下，其底层表示的是数组，因此不能调整尺寸，如果你试图用add()或delete()方法在这种列表中添加或删除元素，就有可能引发去改变数组尺寸的尝试，会得到一个运行时错误  </p>
<h2 id="容器的打印"><a href="#容器的打印" class="headerlink" title="容器的打印"></a>容器的打印</h2><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>&emsp;&emsp;List承诺可以将元素维护在特定的序列中，List接口在Collecton的基础上添加了大量的方法，使得可以在List中间插入和移除元素<br>&emsp;&emsp;有两种类型的List：</p>
<ul>
<li>基本的ArrayList，它长于随机访问元素，但在List的中间插入和移除元素时较慢</li>
<li>LinkedList，它通过代价较低的在List中间进行插入和删除操作，提供了优化的顺序访问，LinkedList在随机访问方面相对较慢，但是它的特性集叫ArrayList更大  </li>
<li>为什么ArrayList和LinkedList对于不同的操作的性能不同的原因是因为底层实现的不同  <img src="/2018/10/10/持有对象/绘图1.png" title="ArrayList">
<img src="/2018/10/10/持有对象/绘图2.png" title="LinkedList">
&emsp;&emsp;关于List接口api请查看<a href="http://tool.oschina.net/apidocs/apidoc?api=jdk-zh" target="_blank" rel="noopener">http://tool.oschina.net/apidocs/apidoc?api=jdk-zh</a><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2>&emsp;&emsp;任何容器类，都必须有某种方式可以插入元素并将它们取回，毕竟，持有事物是容器的基本工作<br>&emsp;&emsp;如果从更高层的角度思考，我们在对容器的确切类型进行编程方面有一个缺点，那就是如果原本是对List编码的，但是后来我想将相同的代码应用于Set，那会显得很不方便，此时应该怎么做呢？或者打算从头开始编写通用的代码，它们只是使用容器，不知道或者说不关心容器的类型，那么如何才能不重写代码就能应用于不同的容器呢？<br>&emsp;&emsp;迭代器（也是一种设计模式）的概念可以用于达成此目的，迭代器是一个对象，它的工作是遍历并选择序列中的对象，而客户端程序员不必知道或关心该序列底层的结构，java的Iterator只能呢个单向移动，这个Iterator只能用来  </li>
</ul>
<ol>
<li>使用iterator()方法要求容器返回一个Iterator，Iterator将准备返回序列的第一个元素</li>
<li>使用next()获得序列的下一个元素</li>
<li>使用hasNext()方法检查序列中是否还有元素</li>
<li>使用remove()将迭代器新返回的元素删除<br>&emsp;&emsp;注意:Iterator可以删除next()产生的最后一个元素，这意味着调用remove()之前必须先调用next()<br>&emsp;&emsp;<strong>接受对象容器并传递它，从而在每个对象上都执行某种操作，这种思想十分强大</strong><h3 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h3>ListIterator是一个更加强大的Iterator的子类型，它只能用于各种List类的访问，尽管Iterator只能向前移动，但是ListIterator可以双向移动，它还可以产生相对于迭代器在列表中指向的当前位置的前一个和后一个元素的索引，并且可以使用set()方法替换它访问过的最后一个元素,你可以通过listIterator()方法产生一个指向List开始处的ListIterator，并且还可以通过调用listIterator(n)方法创建一个一开始就指向列表索引为n的元素处的ListIterator<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2>&emsp;&emsp;LinkedList也像ArrayList一样实现了List接口，在删除和插入方面的效率比ArrayList更高效，但是在随机访问方面却要逊色一些<br>&emsp;&emsp;<strong>LinkedList还添加了可以使其用作栈，队列或者双端队列的方法</strong><br>&emsp;&emsp;这些方法有些彼此之间只是名称有些差异，后者只存在少许差异，以使得这些名称在特定用法的上下文环境中更加适用（特别是在Queue中）例如，getFirst()和element()完全一样，它们都是返回列表头元素，而并不移除它，如果List为空的话，则抛出NoSuchElementException,<br>peek()方法与这两个方法只是稍有差异，它在列表为空时返回null<br>&emsp;&emsp;removeFirst()和remove()也是完全一样，它们移除并返回列表的头，而在列表为空时，抛出NoSuchElementExcption，poll()稍有差异，它在列表为空的时候，返回null<br>&emsp;&emsp;addFirst()与add()和addLast()，它们都是将元素插入列表的尾（端）部<br>&emsp;&emsp;removerLast()移除并返回最后一个元素<br>&emsp;&emsp;因此我们在使用LinkedList这些方法时，要注意各种方法的不同，进而选择怎样去处理<h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2>&emsp;&emsp;“栈”通常是指“后进先出”(LIFO)的容器，有时栈也被称为叠加栈，如果用一种事物来形容的话，栈的行为就像是弹夹一样，有“压入”和“弹出”<br>&emsp;&emsp;LinkedList具有能实现栈的所有功能的方法，所有我们可以定义一个栈，通过组合的形式复用LinkedList，很简单，这里就不写了<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2>&emsp;&emsp;Set不保存重复的元素，如果你试图将相同对象的多个实例添加到Set中，那么它就会阻止这种重复的发生，Set最常用被使用的是<strong>测试归属性</strong>，你很容易地询问某个对象是否在某个Set中，因此，查找就成了Set中最重要的操作，因此，你可以选择HashSet的实现，它专门对快速查找进行优化<br>&emsp;&emsp;Set和Collection具有完全一样的接口，因此没有额外的功能，实际上Set就是Collection，只是行为不同<br>&emsp;&emsp;Set有不同的实现，HashSet使用了散列函数，使得更快速的保存和查找，TreeSet使用了红黑树数据结构中，LInkedHashSet因为查找的速度也使用了散列，但是看起来它使用了链表来维护元素的插入顺序<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2>&emsp;&emsp;将对象映射到其他对象的能力是一种解决编程问题的杀手锏<br>Map与数组和其他的Collection一样，可以很容易地扩展到多维，我们通过容器的组合，可以很容易生成强大的数据结构  <h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2>&emsp;&emsp;队列是一个“先进先出”（FIFO）的容器，即从容器的另一端放入元素，从容器的另一端取出，<strong>队列常被当作一种可靠的将对象从程序的一个区域传递到另一个区域的途径</strong><br>&emsp;&emsp;LinkedList提供了方法以支持队列的行为，它实现了Queue接口，因此可以将LinkedList作为Queue的一种实现，通过将LinkedList向上转型为Queue  <h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h3>&emsp;&emsp;x先进先出描述了最典型的队列规则，<strong>队列规则是指在给定一组队列中的元素的情况下，确定下一个弹出队列的元素的规则</strong><br>&emsp;&amp;emsp优先队列声明下一个弹出的元素是最需要的元素（具有最高的优先级），当你在PriorityQueue上调用offer()方法插入一个对象时，这个对象会在队里中被排序，默认的排序将使用对象在队列中的自然排序，但是你也可以通过提供自己的Comparator来修改这个顺序，PriorityQueue可以确保当你调用peek()，poll()和remove()方法时，获得的元素将是队列中优先级最高的元素  <h2 id="Collection和Iterator"><a href="#Collection和Iterator" class="headerlink" title="Collection和Iterator"></a>Collection和Iterator</h2>&emsp;&emsp;Collection是描述所有序列容器的共性的根接口，它可能被认为是一个“附属接口”，即因为要表示其他若干接口的共性而出现的接口<br>&emsp;&emsp;使用接口的一个理由就是它可以使我们能够创建更通用的代码，通过针对接口而非具体的实现类编写代码，那么我们的代码就可以应用于更多的类型，然后我们也可以看到有趣的事情是，我们一般是通过迭代器来表现这种共性的，在java中，这两种方式实际上绑定在一起了，如果要一个新类实现Collection接口，也要必须通过iterator()接口，但是如果让一个类去实现Collection接口，虽然可以通过继承AbstractCollection来提供一些默认的实现，但是必须还有提供iterator()，而且如果这个类本身已经继承了其他类，那么就不能再通过继承将其定义为一个Collection类型了，所有相比之下，使用通过迭代器的方式来提供容器的共性更加可取，我们也知道，迭代器模式实际上就是利用了内部类的特性，产生了一个能够访问外围类的闭包对象，我们就可以对外围的成员进行操作  <h3 id="Foreach与迭代器"><a href="#Foreach与迭代器" class="headerlink" title="Foreach与迭代器"></a>Foreach与迭代器</h3>&emsp;&emsp;在java SE5引入了新的被称为Iterable的接口，该接口包含了一个能够产生Iteratoer的Iterator()方法，并且Iterator接口被foreach用来在序列中移动，<strong>因此，如果你创建了任何实现了Iteratable的类，都可以将它用于foreach语法</strong></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/10/持有对象/" data-id="cjnj9osce0020uwrz26e26228" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/学习心得/">学习心得</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML5/">HTML5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Maven/">Maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Oracle/">Oracle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-MVC/">Spring MVC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-boot/">Spring boot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-cloud/">Spring cloud</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/HTML5/" style="font-size: 10px;">HTML5</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/Node-js/" style="font-size: 10px;">Node.js</a> <a href="/tags/Oracle/" style="font-size: 10px;">Oracle</a> <a href="/tags/Spring/" style="font-size: 10px;">Spring</a> <a href="/tags/Spring-MVC/" style="font-size: 10px;">Spring MVC</a> <a href="/tags/Spring-boot/" style="font-size: 10px;">Spring boot</a> <a href="/tags/Spring-cloud/" style="font-size: 10px;">Spring cloud</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/10/19/注解/">注解</a>
          </li>
        
          <li>
            <a href="/2018/10/19/枚举类型/">枚举类型</a>
          </li>
        
          <li>
            <a href="/2018/10/19/Java-I-O系统/">Java I/O系统</a>
          </li>
        
          <li>
            <a href="/2018/10/19/容器深入研究/">容器深入研究</a>
          </li>
        
          <li>
            <a href="/2018/10/19/数组/">数组</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 EgbertDay<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>