<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>代海峰</title>
  
  <subtitle>个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-29T22:14:16.988Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>EgbertDay</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>并发</title>
    <link href="http://yoursite.com/2018/10/27/%E5%B9%B6%E5%8F%91/"/>
    <id>http://yoursite.com/2018/10/27/并发/</id>
    <published>2018-10-27T06:39:53.000Z</published>
    <updated>2018-10-29T22:14:16.988Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本的线程机制"><a href="#基本的线程机制" class="headerlink" title="基本的线程机制"></a>基本的线程机制</h2><p>并发编程使得我们可以将程序划分为多个分离，独立运行的任务，通过使用多线程机制，这些独立任务（也被称为子任务）中的每一个都将由执行线程来驱动，一个线程就是在进程中的一个单一的顺序控制流，因此，单个进程可以拥有多个并发执行的任务，但是你的程序使得每个任务都好像有其自己的CPU一样，其地城机制划分CPU时间，但通常你不必考虑它<br>线程模型为编程带来了便利，它简化了在单一程序中同时交织在一起的多个操作的处理，在使用线程时，CPU将轮流给每个任务分配其占用时间，每个任务都觉得自己在一直占用CPU，但实际上CPU时间是划分成片段分配给了所有的任务（例外情况是程序确实运行在多CPU之上），<strong>线程的一大好处是可以使用你从这个层次抽身出来，即代码不必知道它是运行在具有一个还是多个CPU的机器上，所以，使用线程机制是一种建立透明的，可扩展的程序的方法</strong>，如线运行的太慢，为机器添加CPU就能很容易地加快程序的运行速度，多任务和多线程往往是使用多处理器系统的最合理方式</p><h3 id="定义任务"><a href="#定义任务" class="headerlink" title="定义任务"></a>定义任务</h3><p><strong>线程可以驱动任务，因此你需要一种描述任务的方式，这可以由Runnable接口来提供，</strong>要想定义任务，只需实现这个接口并实现run()方法，使得该任务可以执行你的命令<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LiftOff</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> countDown=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">int</span> taskCounter=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id =taskCounter++;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LiftOff</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LiftOff</span><span class="params">(<span class="keyword">int</span> countDown)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.countDown=countDown;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">status</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"#"</span>+id+<span class="string">"("</span>+</span><br><span class="line">                (countDown&gt;<span class="number">0</span>?countDown:<span class="string">"LiftDown!"</span>)+<span class="string">"),"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(countDown-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(status());</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>任务的run()方法通常总会有某种形式的循环（这也是我们编写多线程的惯例，使得线程一直保持存在，并在获得时间片的时候，重新做某些条件检查），使得线程一直运行下去直到不再需要，所以要设定跳出循环的条件（一种选择是直接从run()返回），通常，run()被写成无限循环的形式，这就意味着，除非有某个条件使得run()终结，否则它将永远运行下去<br>在run()中对静态方法Thread.yield()调用是对<strong>线程调度器</strong>（java线程机制的一部分，可以将CPU从一个线程转移给另一个线程）的一种建议，它声明：“我已经执行完生命周期中最重要的部分了，此刻正是切换给其他任务执行一段时间的大好时机”，这完全是选择性的，但是这里使用它是因为它会在这些示例中产生更加有趣的输出:你更可能会看到任务换进换出的证据</p><p>看下面的一个例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        LiftOff launch=<span class="keyword">new</span> LiftOff();</span><br><span class="line">        launch.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>这例子中的run()不是由单独的线程驱动的</strong>，它是在main方法中直接调用的（实际上，这里仍然使用了线程，即总是分配给main()的那个线程）<br><strong>当从Runnable导出一个类时，它必须具有run()方法，但是这个方法并无特殊之处——它不会缠身任何内在的线程能力，要实现线程的行为，你必须显式地将一个任务附着到线程上</strong></p><h3 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h3><p>将Runnable对象转变为工作任务的传统方式是把它提交给一个Thread构造器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Thread t=<span class="keyword">new</span> Thread(<span class="keyword">new</span> LiftOff());</span><br><span class="line">        t.start();</span><br><span class="line">        System.out.println(<span class="string">"waiting for LiftOff"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Thread构造器只需要一个Runnable对象，调用Thread对象的start()方法为该线程执行必要的初始化操作，然后调用Runnable的run()方法，以便在这个新线程中启动该任务，尽管start()方法看起来是产生了一个对长期运行方法的调用，但是从输出中可以看到，start()迅速地返回了，因此你仍旧可以执行main()线程中的其他操作，main()和LiftOff.run()是程序中与其他贤臣“同时”执行的代码<br>你可以很容易地添加更多的线程去驱动更多的任务<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoreBasicThreads</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> LiftOff()).start();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"waiting for liftdowm"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当main()创建Thread对象时，它并没有捕获任何这些对象的引用，每个Thread都“注册”了它自己，因此确实有一个对它的引用，而且在它的任务退出其run()并死亡之前，垃圾回收器是无法清除它的，因此一个线程会创建一个但多的执行线程，在对start()的调用之后，它仍旧会继续存在                                                                                                                                   </p><h3 id="使用Executor"><a href="#使用Executor" class="headerlink" title="使用Executor"></a>使用Executor</h3><p>Java SE5的java.util.concurrennt包中的执行器（Executor）将为你管理Thread对象，从而简化了并发编程，Executor在客户端和任务执行之间提供了一个间接层，与客户端直接执行任务不同，这个中介对象将执行任务，Executor允许你管理异步任务的执行，而无须显式地管理线程的生命周期，Executor在java SE5/6中是启动任务的优选方法<br>我们使用executor来代替上面例子中显式地创建Thread对象，LiftOff对象知道如何运行具体的任务，与命令模式一眼，它暴露了要执行的单一方法，<strong>ExecutorService（具有服务生命周期的Executor，例如关闭）知道如何创建恰当的上下文来执行Runnable</strong>,下面的示例中，CachedThreadPool将为每个任务都创建一个线程，注意，ExecutorService对象是使用静态的Excutors的方法创建的额，这个方法可以确定其Executor类型<br>非常常见的情况是，单个的Executor被用来创建和管理系统中所有的任务<br>对shutdown()方法的调用可以防止新任务被提交给这个Executor，当前线程（在本例中，即驱动main()的线程）将继续运行在shutdown()被调用之前提交的所有任务，这个程序将在Executor中所有任务完成之后尽快提出<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachedThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> LiftOff());</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以很容易地将前面的实例中的CachedThreadPool替换成不同类型的Executor，下面是FixedThreadPool使用了有限的线程集来执行所提交的任务<br>有了FixedThreadPool，你就可以一次性地预先执行代价高昂的线程分配，因而也就可以限制线程的数量了，这可以节省时间，因为你不用为每一个任务都固定地付出创建线程的开销<br><strong>注意，在任何线程池中，现有的线程在可能的情况下，都会被自动复用</strong><br>尽管在线程学习中，我们将使用CachedThreadPool，但是也应当考虑在产生线程的代码中使用FixedTheadPool，CachedThreadPool在程序执行过程中通常会创建与所需数量相同的线程，然后它在回收旧线程时停止创建新线程，因此它是合理的Executor的首选，只有当这种方式会引发问题时，你才需要切换到FixedThreadPool<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FixedThreadpool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] ars)</span></span>&#123;</span><br><span class="line">        ExecutorService exec= Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> LiftOff());</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也可以使用SingleThreadPool,SingleThreadPool就像是线程数量为1的FixedThreadPool,这对于你希望在另一个线程中连续运行的任何事物来说，都是很有用的，如果想SingleThreadPool提交了多个任务，那么这些任务将排队，每个任务都会在下一个任务开始之前结束，因此，SingleThreadPool会序列化所有提交给它的额任务，并会维护它自己（隐藏）的悬挂任务队列<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ExecutorService exec= Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> LiftOff());</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="从任务中产生返回值"><a href="#从任务中产生返回值" class="headerlink" title="从任务中产生返回值"></a>从任务中产生返回值</h3><p>Runnable是执行工作的独立任务，但是它不返回任何值，如果你希望任务在完成时能够返回一个值，那么可以实现Callable接口而不是Runnable接口，在java SE5中引入的Callable是一中具有类型参数的泛型，它的类型参数表示的是从方法call()(而不是run())中返回的值，并且必须使用ExecutorService.sumbit()方法调用它<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        ArrayList&lt;Future&lt;String&gt;&gt; results=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            results.add(exec.submit(<span class="keyword">new</span> TaskWithResult(i)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Future&lt;String&gt; fs:results)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                System.out.println(fs.get());</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                System.out.println(e);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(ExecutionException e)&#123;</span><br><span class="line">                System.out.println(e);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                exec.shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>sumbit()方法会产生Future对象，它用Callable返回结果的特定类型进行参数化，你可以isDone()方法来查询Future是否已经完成，当任务完成时，它具有一个结果，你可以调用get()方法来获取该结果，你也可以不用isDone()进行检查就直接调用get()，在这种情况下，get()将阻塞，直至结果准备就绪，你还可以在试图调用get()来获取结果之前，先调用具有超时的get()或者调用isDone()来查看任务是否完成</p><h3 id="休眠"><a href="#休眠" class="headerlink" title="休眠"></a>休眠</h3><p>影响任务行为的一种简单的方法就是调用sleep(),它将使任务中止执行给定的时间<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepingTask</span>  <span class="keyword">extends</span> <span class="title">LiftOff</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(countDown-- &gt;<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(status());</span><br><span class="line">                <span class="comment">//Old-style</span></span><br><span class="line">                <span class="comment">//Thread.sleep(100)</span></span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            System.err.println(<span class="string">"Interrupted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> SleepingTask());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>对sleep()的调用可以抛出InterruptedException异常，它在run()中被捕获，因为异常不能跨线程传播会mai(),所以你需要在本地处理所有在任务内部产生的异常</strong><br>java SE5引入了更加显式的sleep()版本，作为TimeUtil类的一部分，这个方法允许你指定sleep()延迟的时间单元，因此可以提供更好的阅读性</p><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>线程的优先级将线程的重要性传递给了调度器，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimplePriorities</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>  countDown=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">double</span> d;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> priority;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimplePriorities</span><span class="params">(<span class="keyword">int</span> priority)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.priority=priority;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread()+<span class="string">":"</span>+countDown;<span class="comment">//Thread.currentThread()返回Thread之后调用它的toString()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         Thread.currentThread().setPriority(priority);<span class="comment">//设置执行当前线程的优先级</span></span><br><span class="line">         <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">100000</span>;i++)&#123;</span><br><span class="line">                 d+=(Math.PI+Math.E)/(<span class="keyword">double</span>)i;</span><br><span class="line">                 <span class="keyword">if</span>(i%<span class="number">1000</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                     Thread.yield();</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             System.out.println(<span class="keyword">this</span>);</span><br><span class="line">             <span class="keyword">if</span>(--countDown==<span class="number">0</span>)</span><br><span class="line">                 <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">           exec.execute(<span class="keyword">new</span> SimplePriorities(Thread.MIN_PRIORITY));</span><br><span class="line">        &#125;</span><br><span class="line">        exec.execute(<span class="keyword">new</span> SimplePriorities(Thread.MAX_PRIORITY));</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-6 10,mian]:5</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-6 10,mian]:4</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-6 10,mian]:3</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-6 10,mian]:2</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-6 10,mian]:1</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-3 1,mian]:5</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-2 10,mian]:5</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-1 10,mian]:5</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-5 10,mian]:5</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-4 10,mian]:5</span></span><br><span class="line"><span class="comment">.....</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p>通过上面程序的输出，我们能够看出来，优先级越高的线程，所分配得的时间片越多，注意，优先级的设定是在run()的开头部分设定，在构造器中设置它们不会有任何好处，因为Executor在此刻还没有开始执行任务（也就是说，只有在执行run（）时任务才被传递给一个线程，在此之前它是不知道哪个线程将会执行它），我们也知道通过调用Thread.currentthread()来获得对<strong>驱动</strong>（理解驱动的概念）该任务的Threa的引用<br>尽管JDK有10个优先级，但它与多数操作系统都不能映射的很好，比如windows有7个优先级且不是固定的，所有这种映射关系也不是固定的，对于不同的操作系统来说，唯一可一直的方法是当调整优先级的时候，只使用MAX_PRIORITYY，NORM_PRIORITY,MIN_PRIORITYY三种</p><h3 id="让步"><a href="#让步" class="headerlink" title="让步"></a>让步</h3><p>如果知道已经完成了在run()方法的循环的一次迭代过程中所需的工作，就可以给线程调度机制一个暗示；你的工作已经做的差不多了，可以让别的线程使用CPU了，这个暗示将通过调用yield()方法来作出（不过只是个暗示，没有任何机制保证它将会被采纳），当调用yield()时，你也是在建议具有相同优先级的其他线程可以运行，yield()可以使得任务之间产生良好的处理机制，但是不要依赖yield(),实际上，yield经常被滥用</p><h3 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h3><p>所谓后台（daemon）线程，是指在程序运行的时候在后台提供的一种通用服务的线程，并且这种线程并不属于程序中不可或缺的部分，因此，当所有的非后台线程结束时，程序也就终止了，同时还会杀死进程中的所有后台线程，反过来说，只要有任何非后台线程还在运行，程序就不会终止，比如，执行main()就是一个非后台线程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDaemons</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">                System.out.println(Thread.currentThread()+<span class="string">" "</span>+<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"sleep() interrupted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            Thread daemon=<span class="keyword">new</span> Thread(<span class="keyword">new</span> SimpleDaemons());</span><br><span class="line">            daemon.setDaemon(<span class="keyword">true</span>);<span class="comment">//must call before start</span></span><br><span class="line">            daemon.start();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"All daemon started"</span>);</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">175</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的例子一旦main()完成其工作，就没什么能阻止程序终止了，因为除了后台线程外，已经没有什么线程在运行了<br>SimpleDaemons.java创建了显式的线程，以便可以显式设置它们的标志，通过编写定制的ThreadFactory可以定制由Executor创建的线程的属性（后台，优先级，名称）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(@NotNull Runnable r)</span> </span>&#123;</span><br><span class="line">        Thread t=<span class="keyword">new</span> Thread(r);</span><br><span class="line">        t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在你可用一个全新的DeamnoThreadFactory作为参数传递给Executors.newCachedThreadPool()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeamonFromFactory</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                TimeUnit.MICROSECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">                System.out.println(Thread.currentThread()+<span class="string">" "</span>+<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Interrupted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//接受ThreadFactory参数用来创建新的线程</span></span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool(<span class="keyword">new</span> DaemonThreadFactory());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> DeamonFromFactory());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以通过调用isDaeamon()方法来确定线程是否是一个后台线程，如果是一个后台线程，那么它创建的任何线程将被自动设置成后台线程<br>Daemon线程被设置成后台线程，然后派生出许多子线程，这些线程并没有被显式地设置为后台模式，不过它们的确是后台线程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DaemponSpawn</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Daemon</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Thread[] t=<span class="keyword">new</span> Thread[<span class="number">10</span>];</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            t[i]=<span class="keyword">new</span> Thread(<span class="keyword">new</span> DaemponSpawn());</span><br><span class="line">            t[i].start();</span><br><span class="line">            System.out.println(<span class="string">"DaemonSpawn"</span>+i+<span class="string">"  started"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t.length;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">"t["</span>+i+<span class="string">"].isDaemon()="</span>+t[i].isDaemon());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Daemons</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Thread d=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Daemon());</span><br><span class="line">        d.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        d.start();</span><br><span class="line">        System.out.println(<span class="string">"d,isDaemon()="</span>+d.isDaemon());</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>你应该意识到后台线程在不执行finally子句的情况下就会终止其run()方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ADaemon</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">          System.out.println(<span class="string">"Starting Daemon"</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Exiting via InterruptedException"</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"this should always run?"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeamonsDonotRunFinally</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Thread t=<span class="keyword">new</span> Thread(<span class="keyword">new</span> ADaemon());</span><br><span class="line">        t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output</span></span><br><span class="line"><span class="comment">Starting ADaemon</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p><p>当你运行这个程序时，将会看到finally子句就不会执行但是如果你注释掉对setDaemon的调用，就会看到finally子句将会执行<br>这种行为是对的，因为，当一个后台非后台线程终止时，后台线程会“突然”终止，因此一旦main()退出，jav就会立即关闭所有的后台进程，而不会有任何你希望出现的确认形式，因为你不能以优雅的方式关闭后台线程，所以它们几乎不是一种好的思想，非后台线程的Executor通常是一种更好的方式，因为Executor控制的所有任务可以同时被关闭，这种关闭时以有序的方式进行的</p><h3 id="编码的变体"><a href="#编码的变体" class="headerlink" title="编码的变体"></a>编码的变体</h3><p>当目前位置，在你所看到的示例中，任务类都实现了Runnable，在非常简单的情况下，你可能会希望使用直接从Thread继承这种可替换的方式，就像下面这样<br>你可以通过调用适当的Thread构造器为Thread对象赋予具体的名字这个名字可以通过使用getName()获得<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> countDown=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> threadCount=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(Integer.toString(++threadCount));</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"#"</span>+getName()+<span class="string">"("</span>+countDown+<span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span>(--countDown==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> SimpleThread();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>另一种可能会看到的惯用法是自管理的Runnable,自管理的代码看起来好像晦涩难懂一些，但是好处就会可以继承其他的类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelfManaged</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> countDown=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> Thread t=<span class="keyword">new</span> Thread(<span class="keyword">this</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SelfManaged</span><span class="params">()</span></span>&#123;t.start();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName()+<span class="string">"("</span>+countDown+<span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>);</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> SimpleThread();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意。start()方法是在构造器中调用的，这个示例比较简单，因此可能是安全的，但是我们知道构造器应该尽量简单的只是做一些初始化的工作，在构造器中调用start()，这意味着任务是访问一个不稳定的对象（对象在全部执行完初始化动作时才是稳定的），这也是优选Executor而不是Thread的原因<br>有时通过使用内部类来将线程代码隐藏在类中将会很有用，其中的一个原因是，当你使用内部类的任务类的代码时，外围类的对象已经创建好了<br>下面看这些示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="comment">//Using a named Inner class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerThread1</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> countDown=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> Inner inner;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        Inner(String name)&#123;</span><br><span class="line">            <span class="keyword">super</span>(name);</span><br><span class="line">            start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">if</span>(--countDown==<span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    sleep(<span class="number">10</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                System.out.println(<span class="string">"Interrupted"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getName()+<span class="string">":"</span>+countDown;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InnerThread1</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        inner=<span class="keyword">new</span> Inner(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Using a anonymous inner class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> countDown=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> Thread t;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InnerThread2</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        t=<span class="keyword">new</span> Thread(name)&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">                        <span class="keyword">if</span> (-countDown == <span class="number">0</span>)</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"Interrupted"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Thread.currentThread().getName()+<span class="string">"("</span>+countDown+<span class="string">")"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Using a named Runnable Implementation</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerRunnable1</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> countDown=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> Inner inner;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InnerRunnable1</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Inner(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        Inner(String name)&#123;</span><br><span class="line">            t=<span class="keyword">new</span> Thread(<span class="keyword">this</span>,name);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">if</span> (--countDown == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                System.out.println(<span class="string">"interrupted"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> t.getName() + <span class="string">"("</span> + countDown + <span class="string">")"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Using an anonymous Runnable implementation</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerRunnable2</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> countDown=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> Thread t;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InnerRunnable2</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        t=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">                        <span class="keyword">if</span> (--countDown == <span class="number">0</span>)</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"Interrupted"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Thread.currentThread().getName()+<span class="string">"("</span>+countDown+<span class="string">")"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,name);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//a separator method to run some code as a task</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadMethod</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> countDown=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> Thread t;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadMethod</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runTask</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="keyword">null</span>)&#123;</span><br><span class="line">            t=<span class="keyword">new</span> Thread(name)&#123;</span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                  <span class="keyword">try</span>&#123;</span><br><span class="line">                      <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                          System.out.println(<span class="keyword">this</span>);</span><br><span class="line">                          <span class="keyword">if</span>(--countDown==<span class="number">0</span>)</span><br><span class="line">                              <span class="keyword">return</span>;</span><br><span class="line">                          sleep(<span class="number">10</span>);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                        System.out.println(<span class="string">"interrupted"</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">                  <span class="keyword">return</span> getName()+<span class="string">"("</span>+countDown+<span class="string">")"</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadVariations</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> InnerThread1(<span class="string">"InnerThread1"</span>);</span><br><span class="line">        <span class="keyword">new</span> InnerThread2(<span class="string">"InnerThread2"</span>);</span><br><span class="line">        <span class="keyword">new</span> InnerRunnable1(<span class="string">"InnerRunnable1"</span>);</span><br><span class="line">        <span class="keyword">new</span> InnerRunnable2(<span class="string">"InnerRunnable2"</span>);</span><br><span class="line">        <span class="keyword">new</span> ThreadMethod(<span class="string">"ThreadMethod"</span>).runTask();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p>在java中，你可以选择如何实现并发编程，并且这个选择会令人困惑，这个问题通常来自于用来描述并发程序技术的术语，特别是涉及线程的那些<br>当目前位置，你应该能够看到要执行的任务和驱动它的线程之间的差异这个差异在java类库尤为明显，因为你对Thread类实际没有任何控制权（并且这种隔离在使用执行器时更加明显，因为执行器将替你处理线程的创建和管理），你创建任务，并通过某种方式讲一个线程附着在任务上，以使得这个线程可以执行任务<br>在java中，Thread类本身不执行任何操作，它只是驱动赋予它的任务，但是线程研究中总是不变的使用“线程执行这项或那项任务”这样的语言，因此，你得到的印象就是“线程就是任务”这种错误的想法，线程与任务之间有一种明显的“是一个”关系，这会诱使人这样想“我应该从Thread中继承一个任务”，哈哈，这些想法都是错的<br>从概念上讲，我们希望创建独立于其他任务的任务，因此我们应该能够定义任何，然后说“开始”，并且不用操心其细节，<strong>但是在物理上，创建线程可能会代价高昂，因此必须保存并管理它们，这样，从现实的角度看，将任务从线程中分离出来时有意义的</strong><br>为了澄清这些讨论，我们接下来，将尝试着在描述将要执行的工作时使用术语“任务”，只有在引用到驱动任务的具体机制是，才使用“线程”</p><h3 id="加入一个线程"><a href="#加入一个线程" class="headerlink" title="加入一个线程"></a>加入一个线程</h3><p>一个线程可以在其他线程上调用join()方法，其效果是等待一段时间直到第二个线程结束才继续执行，如果某个线程是在另一个线程t上调用t.join()，此线程将被挂起，直到目标线程结束才恢复（即isAlive()返回false）<br>也可以在调用join()时带上一个超时参数（单位可以是毫秒，或者毫秒和纳秒），这样如果目标线程在这段时间到期时还没有结束的话，join()方法总能返回<br>对join()方法的调用可以被中断，做法是在调用线程上调用interrupt()方法，这时需要用到try{}catch(){}<br>下面演示这些操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sleeper</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> duration;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sleeper</span><span class="params">(String name,<span class="keyword">int</span> sleepTime)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        duration=sleepTime;</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sleep(duration);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            System.out.println(getName()+<span class="string">"was interrupted"</span></span><br><span class="line">            +<span class="string">"isInterrupted()"</span>+isInterrupted());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(getName()+<span class="string">"has awakened"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Joiner</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Sleeper sleeper;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Joiner</span><span class="params">(String name,Sleeper sleeper)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.sleeper=sleeper;</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sleeper.join();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"interrupted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(getName()+<span class="string">"join completed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Joining</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Sleeper sleepy=<span class="keyword">new</span> Sleeper(<span class="string">"Sleepy"</span>,<span class="number">1500</span>);</span><br><span class="line">        Sleeper grumpy=<span class="keyword">new</span> Sleeper(<span class="string">"Grumpy"</span>,<span class="number">1500</span>);</span><br><span class="line">        Joiner dopey=<span class="keyword">new</span> Joiner(<span class="string">"Dopey"</span>,sleepy);</span><br><span class="line">        Joiner doc=<span class="keyword">new</span> Joiner(<span class="string">"Doc"</span>,grumpy);</span><br><span class="line">        grumpy.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output</span></span><br><span class="line"><span class="comment">Grumpy was interrupted isInterrupted() false isInterrupted()总是返回false</span></span><br><span class="line"><span class="comment">Doc join completed</span></span><br><span class="line"><span class="comment">Sleepy has awakened</span></span><br><span class="line"><span class="comment">Dppey join completed</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p><p>Sleepy是一个Thread类型，我们通过向其构造器传入一个休眠的时间参数，让它休眠一段时间，sleep()方法有可能在指定时间返回，也可能被中断，在catch子句中，将根据IsInterrupted()的返回值报告这个中断，当另一个线程在该线程上调用interrupt()时，将给线程设定一个标识，标识这个线程的中断状态，然而异常被捕获时将清理这个标志，所以在catch子句中，在异常被捕获的时候这个标志总是为假，除了异常之外，这个标志还可用于其他情况，比如线程可能会检测其中断状态<br>Joiner线程将通过在Sleep对象上调用join()方法来等待Sleeper醒来，在main()中，每个Sleeper都有个Joiner,这可以从输出中发现，如果sleeper被中断或者正常结束，Joiner将和Sleeper一同结束<br>注意Java SE5de java.util.concurrent类库包含诸如CyclicBarrier,这样的工具，可能比最初的线程类型的join()更加合适</p><h3 id="创建有响应的用户界面"><a href="#创建有响应的用户界面" class="headerlink" title="创建有响应的用户界面"></a>创建有响应的用户界面</h3><h3 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h3><p>线程组持有线程的一个集合</p><h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p>由于线程的本质特性，使得你不能捕获从线程中逃逸的异常，一旦异常逃逸出任务的run()方法它就会向外传播到控制台，除非你才有特殊的步骤捕获这种错误的异常，在java SE5之前，你需要线程组来捕获这些异常，现在你可以使用Executor来解决这个问题，因此你不再需要了解线程组的知识了<br>我们看下面的两个代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        exec.execute(<span class="keyword">new</span> ExceptionThread());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的程序运行之后会打印出栈信息<br>下面我们试着将上面关于线程的代码放在main()所在线程的try{}catch()里面看看会发生什么<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NaiaveExceptionHandling</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">            exec.execute(<span class="keyword">new</span> ExceptionThread());</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Exception has been handled"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果和上面一样，异常也是未被捕获<br><strong>为了解决这个问题，我们修改Executor产生线程的方式，Thread.UncaughtExceptionHandler是java SE5的新接口，它运行你在每个Thread对象上都附着一个异常处理器，Thread.UncaughtExceptionHandler.uncaughtException()会在线程因未捕获的异常而临近死亡时被调用</strong><br>为了使用它，我们创建一个新类型的ThreadFactory,它将在每个新创建的Thread对象上附着一个Threaed.UncaughtExceptionHandler,我们将这个工厂传递给Executors创建新的ExcutorService的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.jetbrains.annotations.NotNull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个任务将会抛出异常并打印出驱动它的线程和线程上的异常处理器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExceptionThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t=Thread.currentThread();</span><br><span class="line">        System.out.println(<span class="string">"run() by"</span>+t);</span><br><span class="line">        System.out.println(<span class="string">"eh="</span>+t.getUncaughtExceptionHandler());</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个异常处理器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyUncaughtExceptionHandler</span> <span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"caught"</span>+e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线程工厂,new的Thread都附着一个异常处理器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HandlerThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(@NotNull Runnable r)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>+<span class="string">"creating new Thread"</span>);</span><br><span class="line">        Thread t=<span class="keyword">new</span> Thread(r);</span><br><span class="line">        t.setUncaughtExceptionHandler(<span class="keyword">new</span> MyUncaughtExceptionHandler());</span><br><span class="line">        System.out.println(</span><br><span class="line">          <span class="string">"eh="</span>+t.getUncaughtExceptionHandler()</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span>  t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnCaptureUncaughtException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool(<span class="keyword">new</span> HandlerThreadFactory());</span><br><span class="line">        exec.execute(<span class="keyword">new</span> ExceptionThread2());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行上面的程序，将会看到任务抛出的异常将会被线程上的异常处理器捕获<br>上面的示例使得你可以按照具体情况逐个地设置处理器，如果你知道将要在代码中处处使用相同的异常处理器，那么更简单的方法是在Thread类中设置一个静态域，并将这个处理器设置为默认的未捕获异常处理器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SettingDefaultHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread.setDefaultUncaughtExceptionHandler(</span><br><span class="line">                <span class="keyword">new</span> MyUncaughtExceptionHandler()</span><br><span class="line">        );</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        exec.execute(<span class="keyword">new</span> ExceptionThread2());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个处理器只有在不存在线程专有的未捕获异常处理器的情况下才会被调用，系统会建厂线程专有版本，如果没有发现，则检查线程组中是否有其专有的unCaughtException()方法，如果还没有，再调用defaultUncaughtExceptionHandler</p><h2 id="共享受限资源"><a href="#共享受限资源" class="headerlink" title="共享受限资源"></a>共享受限资源</h2><p>可以把单线程程序当作问题域求解的单一实体，每次只能做一件事，因为只有一个实体，所以永远不用担心诸如“两个实体试图使用同一个资源”的问题<br>有了并发就可以同时做很多事情了，但是，两个或者多个线程彼此互相干涉的问题也就出现了</p><h3 id="不正确地访问资源"><a href="#不正确地访问资源" class="headerlink" title="不正确地访问资源"></a>不正确地访问资源</h3><p>考虑下面一个例子，其中一个任务产生偶数，而其他任务消费这些数字，这里消费者任务的唯一工作就是检查偶数的有效性<br>我们先定义一个Intgenerator，即生产者，再定义一个消费者，EvenChecker<br>下面定义了一个抽象类<br>IntGnerator有个cancel()方法，可以修改boolean类型的canceled标志的状态，各个在线程中执行的任务可以通过这个canceled来选择是否终止执行（线程驱动的任务终结），<strong>因为canceled标志是boolean类型的，所以它是原子性的，既诸如赋值和返回值这样的简单操作在发生时没有中断的可能，因此你就不会看到这个域处于只允许这些简单操作的过程的中间状态</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">IntGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> canceled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>&#123;canceled=<span class="keyword">true</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCanceled</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> canceled;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意，在本例中可以被撤销的类不是Runnable，而是所有依赖于IntGennerator对象的EvenChceker任务将测试它，以查看他首发已经被撤销了，通过这种方式。共享公共资源的任务可以观察该类的终止信号（这里是canceled），这样就消除所谓竞争条件，即两个或更多的任务竞争响应某个条件，因此产生冲突或者不一致结果的情况，你可以执行考虑并防范系统失败的所有可能途径，例如，一个任务不能依赖另一个任务，因为任务关闭的顺序得不到保证，这里，<strong>通过使任务依赖于非任务对象，我们可以消除潜在的竞争条</strong><br>EvenChecker任务总是读取和测试从其相关的IntGenerator返回的值，注意，如果generator.isCanceled()为true，则run()返回，这将告知EvenChecker.test()中的Excutor该任务完成了，任何EvenChecker任务都可以与其相关联的IntGenerator上调用cancel()，这将导致所有其他使用该IntGenerator的EvenChecker得体地关闭<br>下面的例子执行之后，执行一段时间（经过执行，发现这段时间很短，几乎使得所有的线程执行的任务都退出了）后，会发现EvneGenerator产生了奇数，这在单线程是不可能存在的，但是在多线程中，线程是通过线程调度器取得的时间片段，在执行next()的时候，可能未将next()完之后就切换到其他线程开始继续执行，那么就会使EvenGenerator处于“不恰当”的状态，因此得出结论是如果想要使得多线程能够正常的执行，就必须保证这些共享资源（这里的共享资源是EvenGenerator）必须每一时刻（即使在切换线程前后）都要是“安全”的状态<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvenChecker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IntGenerator generator;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EvenChecker</span><span class="params">(IntGenerator g,<span class="keyword">int</span> ident)</span></span>&#123;</span><br><span class="line">        generator=g;</span><br><span class="line">        id=ident;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!generator.isCanceled())&#123;</span><br><span class="line">            <span class="keyword">int</span> val=generator.next();</span><br><span class="line">            <span class="keyword">if</span>(val%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(val+<span class="string">"note even!"</span>);</span><br><span class="line">                generator.cancel();<span class="comment">//cancels all EvenChecker</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//创建线程池，将任务传递给执行器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(IntGenerator gp,<span class="keyword">int</span> counter)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Press control-c to exit"</span>);</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;counter;i++)&#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> EvenChecker(gp,i));</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(IntGenerator gp)</span></span>&#123;</span><br><span class="line">        test(gp,<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvenGenerator</span> <span class="keyword">extends</span> <span class="title">IntGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentEvenValue=<span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ++currentEvenValue;<span class="comment">//danger point here</span></span><br><span class="line">        ++currentEvenValue;</span><br><span class="line">        <span class="keyword">return</span> currentEvenValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        EvenChecker.test(<span class="keyword">new</span> EvenGenerator());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决共享资源竞争"><a href="#解决共享资源竞争" class="headerlink" title="解决共享资源竞争"></a>解决共享资源竞争</h3><p>前面的示例展示了使用线程的一个基本问题：你永远不知道一个线程何时在运行，这就导致一个问题，当你的线程开始去执行任务（对共享对象进行访问），此时这个共享对象的状态突然发生预期外的改变（通过其他线程的作用），这个时候你接下来的要访问的共享资源不再是你想要访问的共享资源了，这个时候就有可能会发生问题，我将这种情形解释为：“谁动了我的奶酪”，其实谁动了我的奶酪没有太大关系，重点是，如果这块奶酪依然可以被我享用，OK,其他人拿走了它，但是在我打算吃它的时候，有将它放在原处，没有问题，在我打算吃之前有人在上面加了一颗草莓也没什么太大关系，至少它还是奶酪啊，虽然它的状态发生了变化，也还好，但是如果有人在上面吐了一口水，那我就不能在吃了<br>这就关系到了线程协作问题，每一个线程都应该尽力保证当处理完共享资源的时候，贡献资源的状态应该是正常的<br><strong>对于并发问题，你需要某种方式来防止两个任务访问相同的资源</strong>（如果不加限制，在多处理器中，两个任务同时访问相同的资源是很正常的事情）至少在关键阶段不能出现这种情况<br><strong>防止这种冲突的方法就是当资源被一个任务使用时，在其上加锁，第一个访问某项资源的任务必须锁定这项资源，使得其他任务在其被解锁之前，就无法访问它了，而在其解锁之后，另一个任务就可以锁定并使用它，以此类推</strong><br><strong>基本上所有的并发模式在解决线程冲突问题的时候，都是采用序列化访问共享资源的方案</strong>，着意味着在给定的时刻只允许一个任务可以运行这段代码，<strong>因为锁语句产生了一种互相排斥的效果，所以这种机制常常被称为互斥量（mutex）</strong><br>java提供关键字synchronized的形式，为防止资源冲突提供了内置支持，当任务要执行被synchronized关键字保护的代码片段的时候，它将检查锁是否可用，然后获得锁，执行代码，释放锁<br>共享资源一般是以对象形式存在的内存片段，但也可以是文件hi安，输入和输出端口，或者是打印机，要控制对共享资源的访问，得先把它们包装在一个对象，然后把所有要访问这个资源的方法标记为synchronized<br>synchronized void f()<br>synchronized void g()<br>所有对象都自动含有单一的锁（也称为监视器），当在对象上调用其任意synchronized方法的时候，此对象就会被加锁，这时该对象上的其他synchronized方法只有等到前一个方法调用完毕并释放了锁之后才能被调用<br><strong>对于某个特定对象而言，其所有synchronized方法共享同一个锁</strong>，因此，当一个任务访问f()方法获得锁的时候，其他任务访问g()时也会遭到“拒绝”<br><strong>注意，在使用并发时，将域设置为private是非常重要的，否则，synchronized关键字就不能防止其他任务直接访问域，这样就会产生冲突</strong><br><strong>一个任务可以多次获得对象的锁，</strong>如果一个方法在同一个对象上调用第二个方法，后者又调用了同一个对象上的另一个方法，就会发生这种情况，jvm负责跟着对象被加锁的次数，如果一个对象被解锁（即锁被完全释放），其计数变0，在任务第一次给对象加锁的时候，计数变1，每当这个任务在这个对象上获得锁的时候，计数都会递增，显然，只有首先获得了锁的任务才能继续获取多个锁，每当任务离开一个synchronized方法的时候幂级数递减，当计数为0的时候，锁完全被释放，此时别的任务就可以使用此资源了<br><strong>针对每个类，也有一个锁（作为类的Class对象的一部分），所以synchronized static方法可以在类的范围内防止对static数据的并发访问</strong><br>你应该在什么时候同步呢？可以运用Brian的同步规则</p><blockquote><p>如果你正在写一个变量，它可能接下来将被另一个线程读取，或者正在读取一个上一次已经被其他线程写过的变量，那么你必须使用同步，并且，读写线程都必须使用相同的监视器锁同步<br><strong>如果你的类中有超过一个方法在处理临界数据，那么你必须同步所有相关的方法</strong>，如果只同步一个方法，那么其他的方法会随意地忽略这个对象锁，并可以在无任何惩罚的情况下被调用，这是很重要的一点，每个访问临界共享资源的方法都必须被同步，否则它们就不会正确地工作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedEvenGenerator</span> <span class="keyword">extends</span> <span class="title">IntGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentEvenValue=<span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span>  <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ++currentEvenValue;<span class="comment">//danger point here</span></span><br><span class="line">        Thread.yield();<span class="comment">//cause failure faster</span></span><br><span class="line">        ++currentEvenValue;</span><br><span class="line">        <span class="keyword">return</span> currentEvenValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        EvenChecker.test(<span class="keyword">new</span> EvenGenerator());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>使用Thread.yield()，以提高在currentEvenValue是奇数状态时上下文切换的可能性。因为互斥防止多个任务同时进入<strong>临界区</strong>，所以这不会产生任何失败</p><h4 id="使用显式的Lock对象"><a href="#使用显式的Lock对象" class="headerlink" title="使用显式的Lock对象"></a>使用显式的Lock对象</h4><p>java SE5的java.util.concuurent类库还包含有定义在java.util.concurrent.locks中的显式的互斥机制，Lock对象必须被显式地创建，锁定和释放，因此，它与内建的锁形式相比，代码缺乏优雅性，但是，对于解决某些类型的问题来说，它更灵活<br>下面是使用Lock重写的是SynChronizedEvenGenerator.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutexEvenGenerator</span> <span class="keyword">extends</span> <span class="title">IntGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentEvenValue=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ++currentEvenValue;</span><br><span class="line">            Thread.yield();</span><br><span class="line">            ++currentEvenValue;</span><br><span class="line">            <span class="keyword">return</span> currentEvenValue;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">          lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>MutexEvenGenerator添加了互斥调用的锁，并使用lock()和unlock()方法在next()内部创建临界资源，将这里所示的惯用法内部化是很重要的，紧接着是对lock()的调用，你必须放置在finally子句中带有unlock()的try-finally语句中，注意，return与语句必须在try子句中出现，以确保unlock()不会过早发生，从而将数据暴露给了第二个任务<br>尽管try-catch所需的代码比synchronized关键字多，但是这也代表了显示的Lock对象的优点之一：<strong>如果在使用synchronized关键字时，某些事物失败了，那么就会抛出一个异常，但是你没有机会去做任何清理工作，以维护系统使其处于良好状态，有了显式的Lock对象，你就可以使用finally子句将系统维护在正确的状态了</strong><br>一般情况下我们还是使用synchronized,因为代码量少，并且用户错误出现的可能性也会降低，因此通常只有在解决特殊问题时，才使用显式的Lock对象，例如，用synchronized关键字不能尝试着获取锁且最终获取锁会失败，或者尝试着获取锁一段时间，然后释放它，要实现这些，你必须使用concurrent类库<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AttemptLocking</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">untimed</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> captured=lock.tryLock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"tryLock()"</span>+captured);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(captured)&#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timed</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> captured=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            captured=lock.tryLock(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"tryLock(2.TimeUnit.SECONDS)"</span>+</span><br><span class="line">            captured);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(captured)&#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> AttemptLocking al=<span class="keyword">new</span> AttemptLocking();</span><br><span class="line">        al.untimed();<span class="comment">//true---lock is available;</span></span><br><span class="line">        al.timed();<span class="comment">//true --- lock is available;</span></span><br><span class="line">        <span class="comment">//Now create s separate task to grap the lock</span></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            &#123;setDaemon(<span class="keyword">true</span>);&#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                al.lock.lock();</span><br><span class="line">                System.out.println(<span class="string">"acquired"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        Thread.yield();</span><br><span class="line">        al.untimed();<span class="comment">//false--lock grabbed by task</span></span><br><span class="line">        al.timed();<span class="comment">//false--lock grabbed by task</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="原子性与易变性"><a href="#原子性与易变性" class="headerlink" title="原子性与易变性"></a>原子性与易变性</h3><p>在关于java线程的讨论中，一个不正常的知识是：“原子操作不需要进行同步控制”，原子操作是不能被线程调度机制中断的操作，一旦操作开始，那么它一定可以在可能发生的“上下文切换”前（切换到其他线程执行）执行完毕，依赖原子性是很棘手且危险的，记住，如果你是一个并发专家，你才应该使用原子性来替代同步，否则不要去考虑<br>了解原子性是很有用的，并且知道原子性与其他高级技术一道，在java.util.concurrent类库中已经实现了某些更加巧妙的构件，但是要坚决抵挡住完全依赖自己的能力去进行处理的这种欲望<br>原子性可以应用于除了long和double之外的所有基本类型之上的“简单操作”对于读取和写入除long和double之外的基本类型变量这样的操作，可以保证它们会被当作不可分（原子）的操作来操作内存，但是JVM可以将64位（long和double变量）的读取和写入当作两个分离的32位操作来执行，这就产生了在读取和写入的操作中间发生上下文切换，从而导致不同的任务可以看到不正常结果的可能性（有时这被称为“字撕裂”），因为你可能看到部分被修改的数值，当你定义long和double变量时，如果使用volatile关键字，就会获得（简单的赋值和返回操作的）原子性，不同的JVM可以任意地保证提供更强的保证，但是你不应该依赖于平台相关的特性<br>在多处理器系统（现在以多核处理器的形式出现，即在单个芯片上有多个CPU）上，相对于单线程系统而言，可视性问题远比原子性问题多得多，一个任务做出的修改，<strong>即使在不中断的意义上讲是原子性的，对其他任务也可能是不可视的，（例如，修改只是暂时性地存储在本地处理器的缓存上），因此不同的任务对应用有不同的视图，另一方面，同步机制强制在处理器系统中，一个任务做出的修改必须在应用中是可视的，如果没有同步机制，那么修改时可视就无法确定</strong><br><strong>volatile关键字还确保了应用中的可视性，如果你讲一个域声明为volatile的，那么只要对这个域产生了写操作，那么所有的写操作都可以看到这个修改，即使使用了本地缓存，情况也确实如此</strong>，volatile域会被写入到<strong>主存</strong>中，而读取操作就发生在<strong>主存</strong>上<br><strong>理解原子性和易变性是不同的概念这一点很重要</strong>，在非volatile域上的原子操作不必刷新到主存中去，因此其他读取该域的任务也不必看到这个新值，如果多个任务在同时访问某个域，那么这个域应该是volatile的，否则这个域就应该只能经由同步访问（也就是说，原子性只是保证了操作的完整性，而并不能保证在这些操作完成之后，其他的任务能够看到这些操作所做的修改），<strong>同步会导致向主存刷新</strong>，因此，如果一个域完全由synchronizied方法或语句块来防护（synchronized起到了两个效果，原子性和可视性都能得到保证），那就不必将其设置为valatile的<br><strong>一个任务所做的任何写操作对这个任务来说都是可视的，因此如果它只需要在这个任务内部可视，那么你就不需要将其设置为volatile</strong>(记住的是，每个任务或者说线程都对自己的操作是可视的，也就是说，我知道我做过那些事情，以及这些操作完成之后的，域的状态是什么，我都能获悉，所有对应我自己独有的域，不需要与其他任务共享的域来说，我不需要使用volatile关键字修饰域使得别的任务能够立即看到我做操作的结果，当操作结束之后不必刷新到主存，只要我自己能够看到它就可以)<br>当一个域的值依赖于它之前的值时（也就是说下次的计算要能获得上次正确的数），例如递增一个计数器，volatile就无法工作，如果某个域的值受到其他域的值的限制，那么valatile也无法工作，例如Range类的lower和upper边界就必须遵循lower&lt;upper<br>使用volatile而不是synchronized的唯一安全的情况是类中只有一个可变的域，再次提醒，你的第一选择是synchronized关键字，这是最安全的方式，而尝试其他任何方式都是有风险的<br>什么才属原子操作？对域中的值做赋值和返回操作通常都是原子性的，但是在java中<br>i++;<br>i+=2;<br>都不是原子性的，上述这些操作实际被分成了几个指令，因此在获取和放置指令之间，另一个任务可能会修改这个域，所有这些操作都不是原子性的<br>如果你盲目的使用原子性概念，那么你就会看到下面程序中的getValue()符合上面的描述<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicityTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> i;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">evenIncrement</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            evenIncrement();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ExecutorService exec=Executors.newCachedThreadPool();</span><br><span class="line">        AtomicityTest at=<span class="keyword">new</span> AtomicityTest();</span><br><span class="line">        exec.execute(at);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> val=at.getValue();</span><br><span class="line">            <span class="keyword">if</span> (val% <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(val);</span><br><span class="line">                System.exit(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的程序当找到奇数就终止，<strong>虽然reture i 确实是原子性的，但是缺乏同步（同步的意思也就是我拿到数据的时候和你的数据要保持一致，这就是同步的概念）使得其数值可以处在不稳定的中间状态时被读取，除此之外，由于i也不是volatile的，因此还存在可视性的问题，getValue()和evenIncrument()必须都是synchronized的</strong>，<br>第二个示例，考虑一些更简单的事情，一个产生序列数字的类，每当nextSerialNumber()被调用的时候，它必须向调用者返回唯一的值<br>SerialNumberGenerator很简单，如果在C++中serialNumber++这种递增操作是原子性的，因为C++递增可以作为一条微处理器指令来实现，但是在java，这种递增操作却不是，这里设立了一个读一个写操作，（我的理解是，本质上应该说这是JVM虚拟机造成的，对于相同意图的操作，各虚拟机的实现是不同的，因此也就造成了，相同的操作在不同的语言中的原子性不同）<br>基本上，如果一个域可能会被多个任务同时访问，或者这些任务中至少有一个是写入任务，那么你就应该将这个域设置为volatile的，如果你将一个域设置成volatile，那么它就会告诉编译器不要执行任何移出（原文写到是移除，我觉得应该是写错了）读取和写入操作的优化，这些操作的目的是用线程中的局部变量维护对这个域的精确同步。实际上，读取和写入都是针对内存的，而却没有被缓存，但是<strong>，volatile并不能对递增不是原子性操作这一事实产生影响</strong><br>我们从这两个例子得出的经验是，原子性操作并不会导致同步，原子性只保证操作是完整不可分的，但是多个任务的视图不一定相同<br>volatile导致了同步，但是不能保证操作的原子性<br>也就是为什么我们synchronized是我们并发编程的首选，因为这个关键字既保证了原子性，又保证了同步<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialNumberGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> serialNumber=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextSerialNumber</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serialNumber++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了测试SerialNumberGenerator，我们需要不会耗尽内存的集（Set）下面例子的CricularSet就是这样一个集合，这个例子很简单，我们创建了多个线程竞争序列数，判断集合中有无线程取到的序列数，如果没有，则将产生的序列数放入数组，如果集合中包含了该任务产生的序列数，那么说明了之前的线程产生的序列数和现在线程拿到的序列数相同了，如果nextSerialNumber()的操作是原子性的，不会发生这种情况，<strong>得出结论就是volatile保证了同步但是不能保证操作的原子性</strong><br>对基本类型的读取和赋值操作被认为是安全的原子性操作，但是，正如在AtomicityTest.java中看到的，当对象处于不稳定状态时，仍然很可能使用原子性来访问它们，对这个问题的假设是棘手和危险的，最明智的做法是遵循同步规则<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CricularSet</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CricularSet</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        array=<span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        len=size;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            array[i]=-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        array[index]=i;</span><br><span class="line">        <span class="comment">//wrap index and write over old element</span></span><br><span class="line">        index=++index%len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i]==val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialNumberChecker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CricularSet serials=<span class="keyword">new</span> CricularSet(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialChecker</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">               <span class="keyword">int</span> serial=SerialNumberGenerator.nextSerialNumber();</span><br><span class="line">               <span class="keyword">if</span>(serials.contains(serial))&#123;</span><br><span class="line">                   System.out.println(<span class="string">"Duplicate:"</span>+serial);</span><br><span class="line">                   System.exit(<span class="number">1</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               serials.add(serial);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;SIZE;i++)&#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> SerialChecker());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(args.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Integer(args[<span class="number">0</span>]));</span><br><span class="line">            System.out.println(<span class="string">"no duplicates detected"</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h3><p>Java SE5引入了诸如AtomicInteger,AtomicLong,AtomicReference等特殊的原子性变量类，它们提供了下面形式的原子性条件更新操作<br>boolean comparaAndSet(expectedValue,updateValue)<br>这些类被调整为可以使用在某些现代处理器上的可获得的，并且是在机器级别上的原子类，因此使用它们时，通常不需要担心，对于常规编程来说，它们很少会派上用场，但是涉及性能调优上，它们就大有用武之地了，例如，我们可以使用AtomicInteger来重写AtomicityTest.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Time;</span><br><span class="line"><span class="keyword">import</span> java.util.Timer;</span><br><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger i=<span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> i.get();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">evenIncrement</span><span class="params">()</span></span>&#123;i.addAndGet(<span class="number">2</span>);&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">           evenIncrement();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Timer().schedule(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.err.println(<span class="string">"Aborting"</span>);</span><br><span class="line">                System.exit(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">5000</span>);</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        AtomicIntegerTest ait=<span class="keyword">new</span> AtomicIntegerTest();</span><br><span class="line">        exec.execute(ait);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> val=ait.getValue();</span><br><span class="line">            <span class="keyword">if</span>(val%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(val);</span><br><span class="line">                System.exit(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里我们通过使用AtomicInterger而消除了synchronized关键字，因为这个程序不会失败，所以我们添加了一个Timer，以便在5秒后终结程序<br>Atomic类被设计的目的主要是为了重建java.util.concurrent中的类，因此只有在特殊情况下才会使用它们，通常依赖锁更安全一些（要么使用synchronized关键字或者显式的Lock）</p><h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p><strong>有时，你只是希望防止多个线程同时访问方法内部的部分代码而不是防止整个方法，通过这种方式分离出来的代码段被称为临界区（critical section）</strong>，它也是使用synchronized建立的，这里synchronized被用来指定某个对象，此对象的锁可以被用来对花括号内的代码进行同步的控制<br>    synchronized(synObject){<br>      //this code can be accessed<br>      //by only one task at a time<br>    }<br>这样被称为同步块，在进入此段代码前，必须得到synObject对象的锁，如果其他线程已经得到了这个锁，那么就得等到锁被释放以后，才能进入临界区<br>通过同步块，而不是对整个方法进行同步控制，可以使得多个任务访问对象的时间性能得到显著的提升<br>下面的例子演示了，如何将一个非保护类型的类，在其他类的保护和控制之下，应用于多线程的环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line">package xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">class Pair&#123;</span><br><span class="line">    private int x;</span><br><span class="line">    private int y;</span><br><span class="line">    public Pair(int x,int y)&#123;</span><br><span class="line">        this.x=x;</span><br><span class="line">        this.y=y;</span><br><span class="line">    &#125;</span><br><span class="line">    public Pair()&#123;this.x=0;this.y=0;&#125;</span><br><span class="line">    public int getX()&#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getY()&#123;</span><br><span class="line">        return y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void incrementX()&#123;x++;&#125;</span><br><span class="line">    public void incrementY()&#123;y++;&#125;</span><br><span class="line">    public String toString()&#123;</span><br><span class="line">        return &quot;x:&quot;+x+&quot;,y:&quot;+y;</span><br><span class="line">    &#125;</span><br><span class="line">    public class PairValuesNoEqualException</span><br><span class="line">    extends Exception&#123;</span><br><span class="line">        public PairValuesNoEqualException()&#123;</span><br><span class="line">            super(&quot;Pair values not equals&quot;+Pair.this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void checkState()throws PairValuesNoEqualException&#123;</span><br><span class="line">        if(x!=y)&#123;</span><br><span class="line">            throw new PairValuesNoEqualException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract class PairManager&#123;</span><br><span class="line">    AtomicInteger checkcounter=new AtomicInteger(0);</span><br><span class="line">    protected Pair pair=new Pair();</span><br><span class="line">    private List&lt;Pair&gt; storage= Collections.synchronizedList(new ArrayList&lt;Pair&gt;());</span><br><span class="line">    public synchronized Pair getPair()&#123;</span><br><span class="line">        return new Pair(pair.getX(),pair.getY());</span><br><span class="line">    &#125;</span><br><span class="line">    protected void store(Pair pair)&#123;</span><br><span class="line">        storage.add(pair);</span><br><span class="line">        try&#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(50);//在这里故意增加了持有锁的时间</span><br><span class="line">        &#125;catch(InterruptedException e)&#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract void increment();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PairManager1 extends PairManager&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public synchronized  void increment() &#123;</span><br><span class="line">       pair.incrementX();</span><br><span class="line">       pair.incrementY();</span><br><span class="line">       store(getPair());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PairManager2 extends PairManager&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void increment() &#123;</span><br><span class="line">        Pair temp;</span><br><span class="line">        synchronized (this)&#123;</span><br><span class="line">           pair.incrementX();</span><br><span class="line">           pair.incrementY();</span><br><span class="line">           temp=getPair();</span><br><span class="line">        &#125;</span><br><span class="line">        store(temp);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PairManipulator implements Runnable&#123;</span><br><span class="line">    private PairManager pm;</span><br><span class="line">    public PairManipulator(PairManager pm)&#123;</span><br><span class="line">        this.pm=pm;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            pm.increment();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String toString()&#123;</span><br><span class="line">        return &quot;Pair:&quot;+pm.getPair()+&quot;checkCouter=&quot;+pm.checkcounter.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PairChecker implements Runnable&#123;</span><br><span class="line">    private PairManager pm;</span><br><span class="line">    public PairChecker(PairManager pm)&#123;</span><br><span class="line">        this.pm=pm;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                pm.checkcounter.incrementAndGet();</span><br><span class="line">                pm.getPair().checkState();</span><br><span class="line">            &#125;catch(Pair.PairValuesNoEqualException e)&#123;</span><br><span class="line">                System.out.println(&quot;NoEqual&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class CriticalSection &#123;</span><br><span class="line">    static void testApproaches(PairManager pman1,PairManager pman2)&#123;</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        PairManipulator pm1=new PairManipulator(pman1);</span><br><span class="line">        PairManipulator pm2=new PairManipulator(pman2);</span><br><span class="line">        PairChecker pc1=new PairChecker(pman1);</span><br><span class="line">        PairChecker pc2=new PairChecker(pman2);</span><br><span class="line">        exec.execute(pm1);</span><br><span class="line">        exec.execute(pm2);</span><br><span class="line">        exec.execute(pc1);</span><br><span class="line">        exec.execute(pc2);</span><br><span class="line">        try&#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(500);</span><br><span class="line">        &#125;catch(InterruptedException e)&#123;</span><br><span class="line">            System.out.println(&quot;Sleep interrupted&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;pm1:&quot;+pm1+&quot;\npm2&quot;+pm2);</span><br><span class="line">        System.exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main()&#123;</span><br><span class="line">        PairManager pman1=new PairManager1();</span><br><span class="line">        PairManager pman2=new PairManager2();</span><br><span class="line">        testApproaches(pman1,pman2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的例子Pair不是线程安全的，因为它的约束条件（虽然是任意的）需要两个变量维持成相同的值，，在本例中，自增加操作不是线程安全的，并且因为没有任何方法被标记为synchronzied，所以不能保证一个Pair对象在多个线程中不会被破环<br>想象这样一种情况，<strong>你有一个非线程安全的Pair类，而你需要在一个线程安全的环境中去使用它，通过创建PairManager类可以做到这一点</strong>，PairManager持有一个Pair对象并控制它的一切访问，注意唯一public方法是getPair(),它是同步的（它也应当是同步的，要想在线程安全的情况下访问一个线程不安全的对象，此时必须保证访问这个对象的时候，对于这个类的视图必须是最新且是状态是正常的）,对于抽象方法increment()，对于同步的控制将在子类的实现中进行处理，<strong>我们可以看到在子类实现的方法中添加了synchronized关键字，因为不属于方法签名的一部分，所有这是被允许的</strong><br>store()方法将一个Pair对象添加到了synchronizedArrayList中，所以这个方法是安全的，不需要进行防护<br>PairManager1和PairManager2对increment()的实现不同，一个是对整个方法进行同步控制，一个是对方法的一部分进行同步控，PairMainpulate被创建来测试这两个不同实现，而PairCheck是在另一个任务中执行，为了跟踪可以运行测试的额度，PairChecker在每次成功时都会递增checkcounter<br>每次运行的结果都会不一样，但一般的来说，对于PairChecker的检查频率，PairManager1.increment()没有PairManager2.increment()多（因为前者持有锁的时间比较长，对于getPair()的调用也需要获得锁，因此，相同的时间，它获取锁的次数就少），后者采用的是同步块进行同步，所以对象不加锁的时间更长，这也是宁愿使用同步控制块而不是对整个方法进行同步控制的典型原因，使得其他线程能够更多地访问（在安全的情况下尽可能多）<br>结论就是，不要让一个方法持有锁的时间过长，这样会增加其他的线程访问这个类其他synchronized方法（包含持有锁的方法本身）的等待时间，性能大打折扣<br>解决方案就是，只在方法内部对那些访问线程不安全的类的方法进行同步，对线程安全的类的访问不加同步控制，上面的例子，Pair是非线程安全的类，对它的访问，incrementX()和incrementY()加上synchronized访问控制，对线程安全的synchronizedArrayList的add()方法不加同步控制<br>你也可以使用显示的Lock对象来创建临界区,下面的两个例子简单看下就好<br>//synchronized the entire method<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExplicitPairManager1</span> <span class="keyword">extends</span> <span class="title">PairManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            pair.incrementX();</span><br><span class="line">            pair.incrementY();</span><br><span class="line">            store(getPair());</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>//Use a critical section<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExplicitPairManager2</span> <span class="keyword">extends</span> <span class="title">PairManager</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">           lock.lock();</span><br><span class="line">           pair.incrementX();</span><br><span class="line">           pair.incrementY();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        store(getPair());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="在其他对象上同步"><a href="#在其他对象上同步" class="headerlink" title="在其他对象上同步"></a>在其他对象上同步</h3><p>synchronized块必须给定一个在其上进行同步的对象，并且最合理的方式，使用其方式正在被调用的当前对象，synchronized(this)<br><strong>有时必须在另一个对象上同步，但是如果你要这么做，就必须确保所有相关的任务都是在同一个对象上同步的</strong><br>下面演示了两个任务可以同时进入同一个对象，只要这两个对象上的方法是在不同的锁上同步的即可<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DualSynch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object synObject=<span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span>  <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">"f()"</span>);</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (synObject)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">                System.out.println(<span class="string">"g()"</span>);</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> DualSynch dualSynch=<span class="keyword">new</span> DualSynch();</span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">               dualSynch.f();</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        dualSynch.g();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从输出可以看出，因为对不同的对象进行同步，所有这两个方法的执行是同时进行的，没有任何一一个方法阻塞了另一个方法</p><h3 id="线程本地存储"><a href="#线程本地存储" class="headerlink" title="线程本地存储"></a>线程本地存储</h3><p><strong>防止线程在共享资源上产生冲突的第二种方式是根除对变量的共享</strong>，线程本地存储是一种自动化机制，可以为使用相同变量的每个不同的线程都创建不同的存储，因此如果你有5个线程都要使用变量x所表示的对象，那线程本地存储会产生5个用于x的不同的存储块，主要是它们使得你可以将状态与线程关联起来<br>创建和管理线程本地存储可以由java.lang.ThreadLocal类来实现，如下所示、<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Accessor</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Accessor</span><span class="params">(<span class="keyword">int</span> ident)</span></span>&#123;<span class="keyword">this</span>.id=ident;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">            ThreadLocalVariableHolder.increment();</span><br><span class="line">            System.out.println(<span class="keyword">this</span>);</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"#"</span>+id+<span class="string">":"</span>+</span><br><span class="line">                ThreadLocalVariableHolder.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalVariableHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; value=</span><br><span class="line">            <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;()&#123;</span><br><span class="line">               <span class="keyword">private</span> Random rand=<span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">               <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Integer <span class="title">initialValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">                   <span class="keyword">return</span> rand.nextInt(<span class="number">1000</span>);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</span><br><span class="line">        value.set(value.get()+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> value.get();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> Accessor(i));</span><br><span class="line">        &#125;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);<span class="comment">//run for a while</span></span><br><span class="line">        exec.shutdownNow();<span class="comment">//all Accessors will quit</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output</span></span><br><span class="line"><span class="comment">#0:953</span></span><br><span class="line"><span class="comment">#1:823</span></span><br><span class="line"><span class="comment">#2:834</span></span><br><span class="line"><span class="comment">#3:453</span></span><br><span class="line"><span class="comment">#4:324</span></span><br><span class="line"><span class="comment">#0:954</span></span><br><span class="line"><span class="comment">#1:824</span></span><br><span class="line"><span class="comment">#2:835</span></span><br><span class="line"><span class="comment">#3:454</span></span><br><span class="line"><span class="comment">#4:325</span></span><br><span class="line"><span class="comment">....</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p><p>TheadLocal对象通常作为静态域存储，在创建ThreadLocal时，你只能通过get()和set()方法来访问该对象的内容，其中，get()将返回与其线程相关联的对象的副本，而set()方法会将参数插入到其为线程存储的对象中，并返回存储中原有的对象，上面的输出也说明了，ThreadLocal<integer>对象为每一个线程都创建了不同的存储来保存Integer的值，这些值在线程间是不共享的，只对自己的线程可见</integer></p><h2 id="终结任务"><a href="#终结任务" class="headerlink" title="终结任务"></a>终结任务</h2><p>我们在前面的示例中看到cancel()和isCancel()方法被放在了一个所有任务都可以看到的类中（也就说canceled变量是共享的，通过这个标志来控制线程的终止，任务结束线程终止），对于这个问题来说，这是一种合理的情况，但是，在某些情况下，任务必须更加突然地终止（在之前的例子中，任务是通过判断条件来终止的）<br>下面是一个仿真程序，花园委员会希望了解每天通过多个大门进入公园的总人数，每个大门都有一个十字转门或某种其他形式的计数器，并且任何一个十字转门的计数值递增时，就表示公园中的总人数的共享计数器也会递增</p><h3 id="装饰性花园"><a href="#装饰性花园" class="headerlink" title="装饰性花园"></a>装饰性花园</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Count</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Random rand=<span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">increment</span><span class="params">()</span></span>&#123;<span class="comment">//因为Count是共享资源，所以对它读写要同步</span></span><br><span class="line">        <span class="keyword">int</span> temp=count;</span><br><span class="line">        <span class="keyword">if</span>(rand.nextBoolean())&#123; <span class="comment">//yield half the time</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (count=++temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>&#123;<span class="comment">//同步读取，这样避免获得count变量的中间状态</span></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Entrance</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Count count=<span class="keyword">new</span> Count();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Entrance&gt; enterances=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span>  <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> canceled=<span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">concel</span><span class="params">()</span></span>&#123;canceled=<span class="keyword">true</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Entrance</span><span class="params">(<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id=d;</span><br><span class="line">        enterances.add(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!canceled)&#123;</span><br><span class="line">        <span class="comment">//这里Thinking in java的作者对于number加synchronized是有必要的,因为它创建了5个任务实体交给线程去执行，也就是说每个线程与一个任务相关联，它只执行和它相关联的任务，所以就对每个Runnable（既Entrance）没有产生竞争，产生竞争的是Count，而不是任务</span></span><br><span class="line">        可以先看main()方法中创建线程的方式就可以明了 </span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">                ++number;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>+<span class="string">"   Total: "</span>+count.increment());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"sleep interrupted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Stoping "</span>+<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>&#123;<span class="comment">//加synchronized是没有必要的</span></span><br><span class="line">        <span class="keyword">return</span>  number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Entrance"</span>+id+<span class="string">":"</span>+getValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getTotalCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count.value();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sumEntrances</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Entrance enterance:enterances)&#123;</span><br><span class="line">            sum+=enterance.getValue();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrnametalGargen</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">    <span class="comment">//这里是为每一个线程都创建一个任务实体，也就是说每一个线程去驱动任务实体中的run方法，</span></span><br><span class="line">    <span class="comment">//对于每一个任务实体来说，它不是共享的，因此也就不会产生竞争，像下面这样，</span></span><br><span class="line">    <span class="comment">//就会产生竞争，对任务实体来说，对它的读写才要进行同步</span></span><br><span class="line">    <span class="comment">//            Entrance entrance=new Entrance();</span></span><br><span class="line">    <span class="comment">//            exec.execute(entrance)</span></span><br><span class="line">          exec.execute(<span class="keyword">new</span> Entrance(i));</span><br><span class="line">        &#125;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        Entrance.concel();<span class="comment">//将标志位canceled设为true，使各线程结束运行</span></span><br><span class="line"></span><br><span class="line">        exec.shutdown();</span><br><span class="line">        <span class="comment">//TimeUnit.SECONDS.sleep(1);我在这里可以使主线程再休眠1秒，这样1秒后线程池里就不在有等待终结的线程了（理论上是这样的）</span></span><br><span class="line">        <span class="keyword">if</span>(!exec.awaitTermination(<span class="number">250</span>,TimeUnit.MILLISECONDS))&#123;<span class="comment">//250是设置的一个超时时间，我在上面可以多加1秒的时间</span></span><br><span class="line">            System.out.println(<span class="string">"Some tasks ware not terminated!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Total"</span>+Entrance.getTotalCount());</span><br><span class="line">        System.out.println(<span class="string">"Sum of Entrance:"</span>+Entrance.sumEntrances());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用单个Count对象来跟着花园参观者的主总计值，并且将其当作Entrance类中的一个静态域进行存储，Count.increment()和Count.value()都是synchronized的，用来控制对Count的访问，increment()方法使用了Random对象，目的是在从把count读取到temp中，到递增temp并将其存储回count的这段时间里，大约一般的时间产生让步，如果你讲synchronized关键字注释掉，那么程序就会崩溃，因为多个任务将同时访问并修改count（yield()会使问题更快地发生），所有这里对count的操作要是synchronized修饰，即要同步<br>每个Entrance任务都维护着一个本地值number，它包含了通过某个特定入口进入的参观者的数量，这提供了对count对象的双重检查，以确保其记录的参观者数量是正确的，Entrance.run()只是递增number和count对象，然后休眠100毫秒<br>因为Entrance.canceled是一个volatile（保证同步）布尔标志，而它只会被读取和赋值（也就是说这些操作是原子性的）（不会与其他线程域组合在一起读取），所有不需要对其进的访问，就可以安全地操作它，如果你对诸如此类的情况有疑问的话，那么最好总是使用synchronized<br>这个程序在以稳定的方式关闭所有事物方面还有一些小麻烦，其部分原因是为了说明在终止多线程程序时你必须相当小心，而另一部分原因是为了演示interrupt()的值，稍后会学到这个知识<br>在三秒之后，main()向Entrance发送static cancel()消息，然后调用exec对象的shutdown()方法，之后调用exec上的awaitTermination()方法，ExecutorService.awaitTermination()等待每个任务结束，如果所有的任务在超时时间到达之前全部结束，则返回true，否则返回fasle,表示不是所有任务都已经结束，尽管这会导致每个任务都会退出run()，并因此作为任务而终止，但是Entrance对象仍然有效，因为在构造器中，每个Entrance都存储在被称为entrances的静态List<entrance>中，因此，宿命Entrances()仍旧可以工作于这些有效的Entrance对象上（这给了我们启示，要想任务对象在任务结束后仍旧有效，可以用一个引用能够引用到它，这样才不会被垃圾回收机制回收掉）</entrance></p><h3 id="在阻塞时终结"><a href="#在阻塞时终结" class="headerlink" title="在阻塞时终结"></a>在阻塞时终结</h3><p>前面的示例中的Entrance.run()在其循环中包含了对sleep的调用，我们知道，sleep()最终将唤醒，上面的示例，当线程“醒来时”，又重新从while开始处检查canceled的标志，以决定是否跳出循环，结束任务，但是，<strong>sleep()的一种情况，它使任务从执行状态变为阻塞状态，而有时你必须终止被阻塞的任务</strong></p><h4 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h4><p>一个线程可以处于一下四种状态之一：</p><ol><li>新建（new）：当下线程被创建时，它只会短暂地处于这种状态，此时它已经分配了必须的系统资源，并执行了初始化，此刻线程已经有资格获得CPU时间了，之后调度器将把这个线程转变为可运行状态或阻塞</li><li>就绪（Runnbale）:在这种状态下，只要调度器把时间片分配给线程，线程就可以运行，也就是说，在任意时刻，线程可以运行也可以不运行，只要调度器能分配时间片给线程，它就可以运行，这不同于死亡或阻塞状态</li><li>阻塞（Blocked）:线程能够运行，但有某个条件阻止它的运行，当线程处于阻塞状态时，调度器将忽略线程，不会分配线程任何CPU时间，直到线程重新进入就绪状态，它才有可能执行操作</li><li>死亡（Dead）：处于死亡或终止状态的线程将不再是可调度的，并且再也不会得到CPU时间，它的任务已经结束，或不再是可运行的，任务死亡的通常方式是从run()返回，但是任务的线程还可以被中断<h4 id="进入阻塞状态"><a href="#进入阻塞状态" class="headerlink" title="进入阻塞状态"></a>进入阻塞状态</h4>一个任务进入阻塞状态，可能有如下原因：</li><li>通过调用sleep(milliseconds)使任务进入休眠状态，在这这种情况下，任务在指定的时间内不会运行</li><li>你通过调用wait()是线程挂起，直到线程得到notify()或者notifyAll()消息（或者在java SE5的java.util.concurent类库中等价的signal()或signalAll()消息），线程才会进入就绪状态</li><li>任务在等待某个输入/输出完成</li><li>任务试图在某个对象上调用其同步控制方法，但是对象锁不可用，因为另一个任务已经获取了这个锁<br>在较早的代码中可能会看到suspend()和resume()来阻塞和唤醒线程，但是在现代java中这些方法已经 被废止了（因为可能导致死锁），所以不再讨论，stop()方法也废止了，不需要去研究<br>我们来看看我们的问题：有时你希望能够终止处于阻塞状态的任务。如果对于处于阻塞状态的任务，你不能等待其达到代码中可以检查其状态值这一点，因而决定让他主动地终止，那么你就必须强制这个任务跳出阻塞状态</li></ol><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>正如你所想象的，在Runnable.run()的方法内部打断它，与等待该方法到达对cancel标志（之前的示例）的测试，或者到达程序员准备好离开该方法的其他地方相比，要棘手一些，当你打断被阻塞的任务时，可能需要清理资源，正因为这一点，在任务的run()方法中间打断，更像是抛出的异常，因此在java线程的这种类型的异常中断中用到异常（这是为什么我们在调用一些使得线程阻塞的方法时总是要捕获异常，以防止线程会在阻塞状态期间被打断之后进行后续资源的清理工作），为了以这种方式终止任务，返回众所周知的良好状态，你必须仔细考虑代码的执行路径，并仔细编写catch子句以争取清除所有事物<br><strong>Thread类包含interrupt()方法，因此你可以终止被阻塞的任务，这个方法将设置线程的中断状态，如果一个线程已经被阻塞，或者试图执行一个阻塞操作，那么设置这个线程的中断状态将抛出InterruptedException</strong>（这里也就明白了，异常并不一定要在阻塞那里被抛出，当已经处于阻塞状态时，中断任务（调用Thread类的interrupt()），会创建异常对象，这些异常对象除了异常信息外，其实虚拟机还初始化了很多关于这个异常的信息，这个异常对象会被包好它的类的异常处理器所捕获到，注意，我们编写的catch语句其实就是在给这个类创建异常处理器而已，剩下的事情编译器会帮我们做），<strong>当抛出异常或者该任务调用Thread.interrupted()时，中断状态将被复位</strong>。正如将会看到的，Thread.interrupted()提供了离开run()循环而不抛出异常的第二种方式<br>为了调用Thread.interrupt()，你必须持有Thread对象，但是新的concurrent类库似乎在避免多Thread对象的直接操作，转而尽量通过Executor来执行所有操作，如果你在Excutor上调用shutdownNow(),那么它将发送一个interrupt()调用给它启动的所有线程，这么做是有意义的，因为当你完成工程中的某一个部分或者整个程序时，通常会希望同时关闭某个特定Executor的所有任务，然而，你有时也希望只中断某个单一任务，如果使用Executor，那么通过调用submit()而不是execute()来启动任务，就可以持有该任务的上下文，summit将返回一个泛型Future&lt;?&gt;,其中有一个为修饰的参数，因此你永远都不会在其上调用get()——持有这个Future的关键是在于你可以在其上调用cancel()，并因此可以使用它来中断某个特定任务，如果你将true传递给cancel()，那么它就会拥有在该线程上调用interrupt()以停止这个线程的权限，因此，cancel()是一种中断由Executor启动的单个线程的方式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.sql.Time;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="comment">//休眠状态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SleepBlocked</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"InterruptedException"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Exiting SleepBlocked.run()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//I/O阻塞</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IOBlocked</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> InputStream in;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IOBlocked</span><span class="params">(InputStream is)</span></span>&#123;in=is;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Waiting for Read():"</span>);</span><br><span class="line">            in.read();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                System.out.println(<span class="string">"Interrupted from blocked I/O"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Exiting IOBlocked.run()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同步阻塞</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SynchronizedBlocked</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;<span class="comment">//never release lock</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SynchronizedBlocked</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;<span class="comment">//匿名线程获得对象锁</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                f();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"trying to call f()"</span>);</span><br><span class="line">        f();</span><br><span class="line">        System.out.println(<span class="string">"Exiting SynchronizedBlocked.run()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interrupting</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Runnable r)</span><span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        Future&lt;?&gt; f=exec.submit(r);</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">"Interrupting"</span>+r.getClass().getName());</span><br><span class="line">        f.cancel(<span class="keyword">true</span>);<span class="comment">//interrupts if running</span></span><br><span class="line">        System.out.println(<span class="string">"Interrupt sent to "</span>+r.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        test(<span class="keyword">new</span> SleepBlocked());</span><br><span class="line">        test(<span class="keyword">new</span> IOBlocked(System.in));</span><br><span class="line">        test(<span class="keyword">new</span> SynchronizedBlocked());</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">"Aborting with System exit(0)"</span>);</span><br><span class="line">        System.exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的每个任务表示了三种不同类型的阻塞，这个程序证明I/O和在synchronized块上的等待是不可中断的，但是浏览代码，可以发现——无论是I/O还是尝试调用synchronzied,都是不需要任何InterruptedException处理器<br>上面的代码有一些注意的，前两个代码很简单，但是为了演示SynchronizedBlocked,我们在任务构造器中创建一个匿名的线程调用f()获得对象锁（这个线程必须区别于为SynchronizedBlocked驱动run()的线程，因为同一个线程可以多次获得某个对象的锁）<br><strong>从输出中可以看到，你能够中断对sleep()的调用（或者任何要求抛出InterruptedException的调用），但是你不能中断正在尝试获得synchronized锁或者试图执行I/O操作的线程</strong>，这一点令人烦恼，特别是在创建执行I/O的任务时，因为这意外这I/O具有锁住你的多线程程序的可能，特别是在基于Web的程序，这更是关乎利害<br>对于这类问题，有一个略显笨拙但确实行之有效的解决方案，即关闭任务在其上发生阻塞的底层资源<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloseResource</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        ServerSocket server=<span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</span><br><span class="line">        InputStream socketInput=<span class="keyword">new</span> Socket(<span class="string">"localhost"</span>,<span class="number">8080</span>).getInputStream();</span><br><span class="line">        exec.execute(<span class="keyword">new</span> IOBlocked(socketInput));</span><br><span class="line">        exec.execute(<span class="keyword">new</span> IOBlocked(System.in));</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">"Shutting down all thread"</span>);</span><br><span class="line">        exec.shutdownNow();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"Closing"</span>+socketInput.getClass().getName());</span><br><span class="line">        socketInput.close();<span class="comment">//Releases blocked thread</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"Colsing"</span>+System.in.getClass().getName());</span><br><span class="line">        System.in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>运行上面程序，可以得知，在shutdownNow()被调用之后已经在两个输入流上调用close()之前的延迟强调的是：一旦底层资源被关闭任务将被解除阻塞</strong><br><strong>幸运的是，java SE5新添加的各种nio类提供了更加人性化的I/O中断，被阻塞的nio通道会自动地相应中断</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousCloseException;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ClosedByInterruptException;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.ServerCloneException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NIOBlocked</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SocketChannel sc;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NIOBlocked</span><span class="params">(SocketChannel sc)</span></span>&#123;<span class="keyword">this</span>.sc=sc;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Writing for read() in "</span>+<span class="keyword">this</span>);</span><br><span class="line">            sc.read(ByteBuffer.allocate(<span class="number">1</span>));</span><br><span class="line">        &#125;<span class="keyword">catch</span>(ClosedByInterruptException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"closedByInterruptException"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (AsynchronousCloseException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"AsynchronousCloseException"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Exiting NIOBlocked.run()"</span>+<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOinterruption</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        ServerSocket server=<span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</span><br><span class="line">        InetSocketAddress isa=<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>,<span class="number">8080</span>);</span><br><span class="line">        SocketChannel sc1=SocketChannel.open(isa);</span><br><span class="line">        SocketChannel sc2=SocketChannel.open(isa);</span><br><span class="line">        Future&lt;?&gt; f=exec.submit(<span class="keyword">new</span> NIOBlocked(sc1));</span><br><span class="line">        exec.execute(<span class="keyword">new</span> NIOBlocked(sc2));</span><br><span class="line">        exec.shutdown();<span class="comment">//无法关闭I/O阻塞的线程</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//produce an interrupt via cancel</span></span><br><span class="line">        f.cancel(<span class="keyword">true</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//release the block by closing the channel</span></span><br><span class="line">        sc2.close();<span class="comment">//你也可以通过关闭底层资源释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="被互斥所阻塞"><a href="#被互斥所阻塞" class="headerlink" title="被互斥所阻塞"></a>被互斥所阻塞</h4><p><strong>就像之前在不可中断的I/O中所观察的那样，无论在任何时候，只要任务以不可中断的方式被阻塞了，那么都有潜在的会锁住程序的可能</strong><br>java SE5并发类库中添加了一个特性，即在ReentrantLock上阻塞的任务具备可以被中断的能力，这与在synchronized方法或者临界区上阻塞的任务完全不同<br>与I/O调用不同，interrupt()可以打断被互斥所阻塞的调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockedMutex</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlockedMutex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();<span class="comment">//总是持有锁不释放</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//this will never be available to a second task</span></span><br><span class="line">            lock.lockInterruptibly();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Interrupted form lock acquisition in f()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blocked2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    BlockedMutex blocked=<span class="keyword">new</span>  BlockedMutex();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"waiting for f() in BlockedMutex"</span>);</span><br><span class="line">        blocked.f();</span><br><span class="line">        System.out.println(<span class="string">"Broken out of blocked call"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interrupting2</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">      Thread t=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Blocked2());</span><br><span class="line">      t.start();</span><br><span class="line">       TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">       System.out.println(<span class="string">"Issuing t.interrupt"</span>);</span><br><span class="line">       t.interrupt();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="检查中断"><a href="#检查中断" class="headerlink" title="检查中断"></a>检查中断</h3><h2 id="线程之间的协作"><a href="#线程之间的协作" class="headerlink" title="线程之间的协作"></a>线程之间的协作</h2><h3 id="wait-和notifyAll"><a href="#wait-和notifyAll" class="headerlink" title="wait()和notifyAll()"></a>wait()和notifyAll()</h3><h3 id="notify-和notifyAll"><a href="#notify-和notifyAll" class="headerlink" title="notify()和notifyAll()"></a>notify()和notifyAll()</h3><h3 id="生产者与消费者"><a href="#生产者与消费者" class="headerlink" title="生产者与消费者"></a>生产者与消费者</h3><h3 id="生产者与消费者队列"><a href="#生产者与消费者队列" class="headerlink" title="生产者与消费者队列"></a>生产者与消费者队列</h3><h3 id="线程之间使用管道进行输入-输出"><a href="#线程之间使用管道进行输入-输出" class="headerlink" title="线程之间使用管道进行输入/输出"></a>线程之间使用管道进行输入/输出</h3><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本的线程机制&quot;&gt;&lt;a href=&quot;#基本的线程机制&quot; class=&quot;headerlink&quot; title=&quot;基本的线程机制&quot;&gt;&lt;/a&gt;基本的线程机制&lt;/h2&gt;&lt;p&gt;并发编程使得我们可以将程序划分为多个分离，独立运行的任务，通过使用多线程机制，这些独立任务（也被称为
      
    
    </summary>
    
      <category term="学习心得" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>注解</title>
    <link href="http://yoursite.com/2018/10/19/%E6%B3%A8%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/10/19/注解/</id>
    <published>2018-10-19T14:08:07.000Z</published>
    <updated>2018-10-19T14:08:07.915Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="学习心得" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>枚举类型</title>
    <link href="http://yoursite.com/2018/10/19/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2018/10/19/枚举类型/</id>
    <published>2018-10-19T14:07:39.000Z</published>
    <updated>2018-10-26T19:05:02.647Z</updated>
    
    <content type="html"><![CDATA[<p><strong>关键字enum可以将一组具名的值的有限集合创建为一种新的类型，而这些具名的值可以作为常规的程序组件使用，这是一种非常有用的功能</strong></p><h2 id="基本的enum特性"><a href="#基本的enum特性" class="headerlink" title="基本的enum特性"></a>基本的enum特性</h2><p>调用values生成一个enum实例的数组，而且该数组中的元素严格保持其在enum中声明时的顺序<br>创建enum时，编译器就为你生成一个相关的类，这个类继承自java.lang.Enum，下面演示了Enum提供的一些功能<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Shrubbery&#123;GROUND,GRAELING,HANGING&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Shrubbery s:Shrubbery.values())&#123;</span><br><span class="line">            System.out.println(s+<span class="string">" ordinal: "</span>+s.ordinal());</span><br><span class="line">            System.out.println(s.compareTo(Shrubbery.GRAELING)+<span class="string">" "</span>);</span><br><span class="line">            System.out.println(s.equals(Shrubbery.GRAELING));</span><br><span class="line">            System.out.println(s==Shrubbery.GRAELING);</span><br><span class="line">            System.out.println(s.getDeclaringClass());</span><br><span class="line">            System.out.println(s.name());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(String s:<span class="string">"HANGING CRAWLING GROUND"</span>.split(<span class="string">" "</span>))&#123;</span><br><span class="line">            Shrubbery shrub=Shrubbery.valueOf(s);</span><br><span class="line">            System.out.println(shrub);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ordinal()方法返回一个int值，这是每个enum实例在声明时的次序，从0开始，编译器自动为你提供equals()和hashCode()，它还实现了Comparable接口。所以它具有compareTo()方法，同时，它还实现了Serializable接口<br>如果在enum实例上调用getDeclaringClass()，我们就知道其所属的enum类<br>name()方法返回enum实例声明时的名字，这与使用toString()方法效果相同。valueOf()是在Enum类中定义的static方法，它根据给定的名字返回相应的enum实例，如果不存在给定名字则会抛出异常</p><h3 id="将静态导入用于enum"><a href="#将静态导入用于enum" class="headerlink" title="将静态导入用于enum"></a>将静态导入用于enum</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.enumerated;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Spiciness &#123;</span><br><span class="line">    NOT,MILD,MEDIUM,HOT,FLAMING</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> xyz.egbertday.enumerated;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> xyz.egbertday.enumerated.Spiciness.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Burrito</span> </span>&#123;</span><br><span class="line">    Spiciness degree;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Burrito</span><span class="params">(Spiciness degree)</span></span>&#123;<span class="keyword">this</span>.degree=degree;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">"Burrito is"</span>+degree;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Burrito(NOT));</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Burrito(MEDIUM));</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Burrito(HOT));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">~~~使用<span class="keyword">import</span> <span class="keyword">static</span> 能够将<span class="keyword">enum</span>实例的标识符带入到当前的命名空间，所有无需再使用<span class="keyword">enum</span>类型来修饰<span class="keyword">enum</span>实例，这是一个好方法吗？或者还是显示地修饰<span class="keyword">enum</span>实例更好，这样看代码的复杂程度，哪一种方式都OK</span><br><span class="line">## 向enum中添加新方法 ##</span><br><span class="line">除了不能继承一个<span class="keyword">enum</span>之外，我们基本上可以将<span class="keyword">enum</span>看做是一个常规的类，也就是说，我们可以向<span class="keyword">enum</span>中添加方法，<span class="keyword">enum</span>甚至可以有main()方法</span><br><span class="line">一般来说，我们希望每个枚举实例都能返回对自身的描述，而不仅仅只是默认的toString()实现，这只能返回枚举实例的名字，为此，你可以提供一个构造器，专门负责处理这个额外的信息，然后添加一个方法，返回这个描述的信息，看下面的示例</span><br><span class="line">~~~java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> OzWith &#123;</span><br><span class="line">    WEST(<span class="string">"Miss Gulch aka"</span>),</span><br><span class="line">    NORTH(<span class="string">"Glnda"</span>),</span><br><span class="line">    EAST(<span class="string">"Wicked"</span>),</span><br><span class="line">    SOUTH(<span class="string">"Good by interface"</span>);<span class="comment">//自定义方法时，分号不要忘记</span></span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">OzWith</span><span class="params">(String description)</span></span>&#123;/即使不刻意声明构造器为<span class="keyword">private</span>，它的可访问性也不会发生改变</span><br><span class="line">        <span class="keyword">this</span>.description=description;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  description;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(OzWith oz:OzWith.values())&#123;</span><br><span class="line">            System.out.println(oz+oz.getDescription());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，如果你打算定义自己的方法的时候，那么必须在enum实例序列的最后添加一个分号，同时java要求你必须先定义enum实例，如果在enum实例之前定义的任何方法或属性，那么在编译器就会得到错误信息<br>可以说enum的构造器和方法和普通的类没什么区别，因为除了有少些的限制之外，enum就是一个普通的类，虽然，在这个例子中，我们刻意的将enum的构造器声明为private，但对于它的可访问性并没有什么变化，因为（即使我们不声明为private）,我们只能在enum定义的内部使用其构造器创建enum实例，一旦enum的定义结束，编译器就不允许我们再使用其构造器来创建任何得实例了，可是我们也不能使用public来修饰构造器，直接什么都不写就可以了</p><h3 id="覆盖enum的方法"><a href="#覆盖enum的方法" class="headerlink" title="覆盖enum的方法"></a>覆盖enum的方法</h3><p>覆盖enum默认具有的方法和普通的类没什么区别</p><h2 id="switch语句中的enume"><a href="#switch语句中的enume" class="headerlink" title="switch语句中的enume"></a>switch语句中的enume</h2><p>在Switch中使用enum，是enum提供的一项非常便利的功能，一般来说，在switch中只能使用整数值，而枚举类型天生就具备整数值的次序，并且可以通过ordinal()方法取得其次序（显然编译器以及帮我们做了类似的工作），因此我们可以在switch语句中使用enum，一般来说，我们必须要使用enum类型来修饰一个enum实例，但在case语句中却不必如此<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Signal&#123;RED,YELLOW,GRREN&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrafficLight</span> </span>&#123;</span><br><span class="line">    Signal signal=Signal.RED;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(Signal signal)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (signal)&#123;</span><br><span class="line">            <span class="keyword">case</span> RED: <span class="keyword">this</span>.signal=Signal.GRREN;</span><br><span class="line">            <span class="keyword">case</span> GRREN:<span class="keyword">this</span>.signal=Signal.YELLOW;</span><br><span class="line">            <span class="keyword">case</span> YELLOW:<span class="keyword">this</span>.signal=Signal.RED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="values的神秘之处"><a href="#values的神秘之处" class="headerlink" title="values的神秘之处"></a>values的神秘之处</h2><p>前面提到，编译器为你创建的enum类都继承自Enum类，然而，如果你研究一下Enum类就会发现，它并没有values()方法，难道存在着“隐匿”的方法，我们利用反射机制编写一个简单的程序<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Explore&#123;HERE,THERE&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reflection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;String&gt; <span class="title">analyze</span><span class="params">(Class&lt;?&gt; enumClass)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"------------analyzing-----"</span>+enumClass+<span class="string">"---------"</span>);</span><br><span class="line">        System.out.println(<span class="string">"interface"</span>);</span><br><span class="line">        <span class="keyword">for</span>(java.lang.reflect.Type t:enumClass.getGenericInterfaces())&#123;</span><br><span class="line">            System.out.println(t);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Base"</span>+enumClass.getSuperclass());</span><br><span class="line">        System.out.println(<span class="string">"methods"</span>);</span><br><span class="line">        Set&lt;String&gt; methods=<span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Method m:enumClass.getMethods())&#123;</span><br><span class="line">           methods.add(m.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(methods);</span><br><span class="line">        <span class="keyword">return</span> methods;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">           Set&lt;String&gt; exploreMethods=analyze(Explore.class);</span><br><span class="line">           Set&lt;String&gt; enumMethods=analyze(Enum.class);</span><br><span class="line">           System.out.println(<span class="string">"Explore.containsAll(Enum)?"</span>+</span><br><span class="line">           exploreMethods.containsAll(enumMethods));</span><br><span class="line">           System.out.println(<span class="string">"Explore.removeAll(Enum):"</span>);</span><br><span class="line">           exploreMethods.removeAll(enumMethods);</span><br><span class="line">           System.out.println(exploreMethods);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行程序结果可知，Enum类没有values()方法，而是编译器在创建enum类时自动添加的一个static方法，还可以看出了，在创建enum类的时候，编译器还为其添加了valueOf()方法，这能令人疑惑，Enum类不是已经有valueOf()方法了吗？不过Enum的valueOf()方法需要两个参数，而这个新增的方法只有一个参数，其方法签名不同，根本就是两个不同的方法，可以javap 反编译看出编译器将enum标记为final类，所有无法继承enum，其中还有static的初始化语句，其实就是初始化enum类型的实例的，其实例的的标识符具名，且被修饰为static final 因此我们也就知道，enum定义的enum实例其实就是enum类型的常量，其依附在enum类型下而已<br>由于values()是编译器插入到enum定义上的static方法，所有向上转型为Enum时，就不能再调用values()方法了（因为Enum没有这个方法），不过Class中有一个getEnumConstants()方法，所有即使Enum接口中没有values()方法，我们依然可以通过Class对象取得所有的enum实例</p><h2 id="实现而非继承"><a href="#实现而非继承" class="headerlink" title="实现而非继承"></a>实现而非继承</h2><p>我们已经知道了，所有的enum都继承自java.lang.Enum类，由于java不支持多重继承，所以我们的enum就不能再继承其他的类了</p><h2 id="随机选取"><a href="#随机选取" class="headerlink" title="随机选取"></a>随机选取</h2><p>由于接下来的许多示例都需要从enum实例中继续随机选择，我们利用泛型，从而使这个公共更一般化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Enums</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand=<span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Enum&lt;T&gt;&gt; <span class="function">T <span class="title">random</span><span class="params">(Class&lt;T&gt; ec)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> random(ec.getEnumConstants());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">random</span><span class="params">(T[] values)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> values[rand.nextInt(values.length)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="使用接口组织枚举"><a href="#使用接口组织枚举" class="headerlink" title="使用接口组织枚举"></a>使用接口组织枚举</h2><p>方法从enum自称子类有时很令人沮丧，这种需求有时源于我们希望扩展员enum中的元素，有时是因为我们希望使用某个子类将一个enum中的元素进行分组<br>在一个接口的内部，创建实现接口的枚举，以此将元素进行分组，可以达到将枚举元素分组的目的，假设你希望用enum表示不同类别的事物，同时还希望每个enum元素依然是Food类型，就可以这样实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> Apptizer implements Food&#123;SALAD,SOUP,SPRING_ROLLS&#125;</span><br><span class="line">    <span class="keyword">enum</span> MianCourse implements  Food&#123;LASANGE,BURRITO,PAD_THAI,LENTILS&#125;</span><br><span class="line">    <span class="keyword">enum</span> Dessert implements  Food&#123;TIRAMISU,GELATO,FRUIT&#125;</span><br><span class="line">    <span class="keyword">enum</span> Coffee implements Food&#123;BLACK_COFFEE,DECAF_COFFEE,ESPRESSO&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对enum而言，实现接口是其子类化的唯一办法，所以嵌入在Food中的每个enum都实现了Food接口，这样所有的enum实例也都是Food类型的了<br>Food，我们知道接口中除了方法之外的任何成员的是static final的，所有也知道，这些Enum类型是嵌套在Food接口中的，因此，如果你想引用嵌套接口内某个enum类型的实例时，应该这样写 Food.Apptizer.SALAD，或者在使用静态导入之后，写成Apptizer.SALAD<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> xyz.egbertday.enumerated.Food.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeOfFood</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Food food = Apptizer.SALAD;</span><br><span class="line">        food =MainCourse.LASANGE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然而，当你需要与一大堆类型打交道时，接口就不如enum好用了，例如，<strong>如果你想创建一个“枚举的枚举”</strong>，那么就可以创建一个新的enum，然后用其实例包装Food中的每个enum类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Course &#123;</span><br><span class="line">    APPETIZER(Food.Apptizer.class),</span><br><span class="line">    MAINCOUSER(Food.MainCourse.class),</span><br><span class="line">    DESSERT(Food.Dessert.class),</span><br><span class="line">    COFFEE(Food.Coffee.class);</span><br><span class="line">    <span class="keyword">private</span> Food[] values;</span><br><span class="line">    Course(Class&lt;? extends Food&gt; kind)&#123;</span><br><span class="line">        values=kind.getEnumConstants();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">randomSelection</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Enums.random(values);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是通过每个Course实例中随机地选择一个Food，我们便能生成一份菜单<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Meal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(Course course:Course.values())&#123;</span><br><span class="line">                Food food=course.randomSelection();<span class="comment">//重点在这里</span></span><br><span class="line">                System.out.println(food);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"------------------"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>另一种组织枚举实例的方式，但其也有其他的一些限制，就是将一个enum嵌套在一个enum内，就像这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SecurityCatagory &#123;</span><br><span class="line">    STOCK(Security.Stock.class),BOND(Security.Bond.class);</span><br><span class="line">    Security[] values;</span><br><span class="line">    SecurityCatagory(Class&lt;? extends Security&gt; kind)&#123;</span><br><span class="line">        values=kind.getEnumConstants();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Security</span></span>&#123;</span><br><span class="line">        <span class="keyword">enum</span> Stock implements  Security&#123;SHORT,LONG,MARGIN&#125;</span><br><span class="line">        <span class="keyword">enum</span> Bond implements  Security&#123;MUNICAPAL,JUNK&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Security <span class="title">randomSelection</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Enums.random(values);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            SecurityCatagory catagory=Enums.random(SecurityCatagory.class);</span><br><span class="line">            System.out.println(catagory+<span class="string">":"</span>+</span><br><span class="line">            catagory.randomSelection());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Security接口的作用就是将其所包含的enum组合成一个公共类型，这一点是有必要的</strong>，然后SecurityCatagory才能将Security中的enum作为其构造器的参数使用，以起到组织的作用</p><h2 id="使用EnumSet替代标志"><a href="#使用EnumSet替代标志" class="headerlink" title="使用EnumSet替代标志"></a>使用EnumSet替代标志</h2><p>Set是一种集合，只能向其中添加不重复的对象，<strong>当然，enum也要求其成员都是唯一的，所以enum看起来也具有集合的行为，不过，由于不能从enum中删除或者添加元素，所有它只能算作不太有用的集合</strong>，Java SE5引入了EnumSet，是为了通过enum创建一种替代品，以替代传统的基于int的“位标志”，这种标志可以用来表示某种“开/关”信息，不过，使用这种标志，我们会最终操作的只是一些bit，而不是这些bit想要表达的概念，因此很容易写出令人难以理解的代码<br>EnumSet的设计充分考虑到了速度因素，就其内部而言，它（可能）就是将一个long值作为比特向量，所以EnumSet非常快速高效，使用EnumSet的优点是，它在说明一个二进制位是否存在时，具有更好的表达能力，并且无须担心性能<br>EnumSet中的元素必须来自一个enum，下面的enum表示一座大楼中，警报传感器的安放位置<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> AlarmPoints &#123;</span><br><span class="line">    START1,START2,LOBBY,OFFICE1,OFFICE2,OFFICE3,</span><br><span class="line">    OFFICE4,BATHROOM,UTILITY,KITCHEN</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后我们用EnumSet来跟着警报器的状态<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumSets</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        EnumSet&lt;AlarmPoints&gt; points=EnumSet.noneOf(AlarmPoints.class);<span class="comment">//empty set</span></span><br><span class="line">        points.add(BATHROOM);</span><br><span class="line">        System.out.println(points);</span><br><span class="line">        points.addAll(EnumSet.of(START1,START2,KITCHEN));</span><br><span class="line">        System.out.println(points);</span><br><span class="line">        points=EnumSet.allOf(AlarmPoints.class);</span><br><span class="line">        points.removeAll(EnumSet.of(START1, START2,KITCHEN));</span><br><span class="line">        System.out.println(points);</span><br><span class="line">        points.removeAll(EnumSet.range(OFFICE1,OFFICE4));</span><br><span class="line">        System.out.println(points);</span><br><span class="line">        points=EnumSet.complementOf(points);</span><br><span class="line">        System.out.println(points);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们从上面的这个例子也能看到EnumSet的一些用法，查看EnumSet的有关文档能看到多个of()的重载版本，有接受2-5个参数这样的重载版本，这里也能看到EnumSet对性能的追求<br><strong>EnumSet的基础是long</strong>,一个long值有64位，而一个enum实例只需要一位bit表示其是否存在，也就是说，在不超过一个long值的表达式的情况下，你的EnumSet可以应用与最多不超过64个元素的enum，如果超过了会怎么样？通过代码分析（这里不写），可以得出结论，EnumSet会扩容到多于一个long值<br>我们来分析下EnumSet是什么吧，很简单，EnumSet是一种类型，这种类型可以存储一个long值，这个long值上的bit可以是0或1，0表示相应enum实例不存在,1表示相应的enum实例存在，EnumSet对象间接拥有了enum实例一样，这种通过位来表示相应enum实例是否存在的方式，给了我们增删enum实例（因为Enum类型一旦建立之后，enum示例数组不能再改变了）的一个解决方案，注意，底层的enum实例并没有改变<br>我们知道了EnumSet的底层机制，也就明白了向EnumSet重复调用add()方法放入同一个enum实例将会被忽略，EnumSet的输出顺序决定于enum定义时的顺序</p><h2 id="使用EnumMap"><a href="#使用EnumMap" class="headerlink" title="使用EnumMap"></a>使用EnumMap</h2><p><strong>EnumMap是一种特殊的Map，它要求其中的键（key）必须来自一个enum，由于enum本身的限制，所以EnumMap在内部可由数组实现</strong>，因此EnumMap的速度很快，我们可以放心地使用enum实例在EnumMap中进行查找操作，不过我们只能将enum的实例来调用put()方法，其他操作也使用一般的Map差不多<br>下面的例子演示了命令设计模式的用法，一般来说，命令模式首先需要一个只有单一方法的接口，然后该接口实现具有不同的行为的多个子类，接下来程序员就可以构造命令对象，并在需要的时候使用它们了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> xyz.egbertday.enumerated.AlarmPoints.*;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Command</span></span>&#123;<span class="function"><span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumMaps</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        EnumMap&lt;AlarmPoints,Command&gt; em=<span class="keyword">new</span> EnumMap&lt;AlarmPoints, Command&gt;(AlarmPoints.class);</span><br><span class="line">        em.put(KITCHEN,<span class="keyword">new</span> Command()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"kitchen fire!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        em.put(BATHROOM,<span class="keyword">new</span> Command()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Bathroom alert!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;AlarmPoints,Command&gt; entry:em.entrySet())&#123;</span><br><span class="line">            System.out.println(entry.getKey());</span><br><span class="line">            entry.getValue().action();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            em.get(UTILITY).action();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的例子最后的部分说明。enum的每个实例作为一个键，总是存在的，但是，如果你没有为这个键调用put（）方法来存入相应的值的化，其对应的值就是null，与常量相关的方法有个优点就是EnumMap允许程序员改变值对象，而常量相关的方法在编译期就被固定了</p><h2 id="常量相关的方法"><a href="#常量相关的方法" class="headerlink" title="常量相关的方法"></a>常量相关的方法</h2><p><strong>java的enum有个非常有趣的特性，即它允许程序员为enum实例编写方法，从而为每个enum实例赋予各自不同的行为，要实现常量相关的方法，你需要为enum定义一个或多个abstract方法，然后为每个enum实例实现该抽象方法</strong><br>下面的例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ConsatantSpecificMethod &#123;</span><br><span class="line">    DATE_TIME&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function">String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> DateFormat.getDateInstance().format(<span class="keyword">new</span> Date());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    CLASSPATH&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function">String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> System.getenv(<span class="string">"CLASSPATH"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    VERSION&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function">String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> System.getProperty(<span class="string">"java.version"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> String <span class="title">getInfo</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(ConsatantSpecificMethod c:ConsatantSpecificMethod.values())&#123;</span><br><span class="line">            System.out.println(c.getInfo());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过相应的enum实例，我们可以调用其上的方法，这通常也被称为表驱动的代码<br>在面向对象的程序设计中，不同的行为与不同的类相关联，而通过常量相关的方法，每个enum实例都可以具备自己独特的方法，这时候说明每个enum实例就像是一个独特的类（实际上就是的，这个类继承自它所在的enum类）在上面的例子中，每个enum实例被当成了其“超类”ConstantSpecificMethod来使用，在调用getInfo()方法时，体现了多态的行为<br>然而，enum实例与类的相似之处也仅限与此了，我们不能真的将enum实例作为一个类型来使用，也就是说你不能这样来使用enum实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> LikeClass&#123;</span><br><span class="line">  WINKEN,BLINKEN</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(LikeClass.WINKEN instance)</span><span class="comment">//错误的</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> f（LikeClass instance）<span class="comment">//正确</span></span></span><br></pre></td></tr></table></figure></p><p>我们分析下编译器生成的代码能够知道这是正常的，enum元素实际上都是LikeClass类型的一个static final实例<br>同时由于它们是static实例，无法访问外部类的非static元素或方法，所有对于内部的enum的实例来说，其行为与一般的内部类并不相同（也就是说在enum类型内部定义的enum实例内部类是不能访问其外围类的非static成员的）<br>除了实现abstract方法以外，程序员是否可以覆盖常量相关的方法呢？答案是肯定的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> OverrideConstantSpecific &#123;</span><br><span class="line">    NUT,BOLT,WASHER&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Override Method"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"default behavior"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(OverrideConstantSpecific o:OverrideConstantSpecific.values())&#123;</span><br><span class="line">            o.f();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="使用enum的职责链"><a href="#使用enum的职责链" class="headerlink" title="使用enum的职责链"></a>使用enum的职责链</h3><p>在职责链（Chain of Responsibility）设计模式中，程序员以多种不同的方式来解决一个问题，然后将它们链接在一起，所以，当一个请求到来时，它遍历这个连，直到链中的某个解决方法能够处理该请求<br>通过常量相关的方法，我们很容易可以实现一个简单的职责链<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> xyz.egbertday.enumerated.Mail.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mail</span> </span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> GeneraliDelivery&#123;YES,NO1,NO2,NO3,NO4,NO5&#125;</span><br><span class="line">    <span class="keyword">enum</span> Scannablity&#123;UNSCANNABLE,YES1,YES2,YES3,YES4,YES5&#125;</span><br><span class="line">    <span class="keyword">enum</span> Readablity&#123;ILLEGIBLE,YES1,YES2,YES3,YES4&#125;</span><br><span class="line">    <span class="keyword">enum</span> Address&#123;INCORRECT,OK1,OK2,OK3,OK4,OK5,OK6&#125;</span><br><span class="line">    <span class="keyword">enum</span> ReturnAddress&#123;MISSING,OK1,OK2,OK3,OK4,OK5&#125;</span><br><span class="line">    GeneraliDelivery generaliDelivery;</span><br><span class="line">    Scannablity scannablity;</span><br><span class="line">    Readablity readablity;</span><br><span class="line">    Address address;</span><br><span class="line">    ReturnAddress returnAddress;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span> counter =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> id =counter++;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="string">"Mail"</span>+id; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">details</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> toString()+<span class="keyword">this</span>.generaliDelivery+</span><br><span class="line">                <span class="keyword">this</span>.scannablity+<span class="keyword">this</span>.readablity+</span><br><span class="line">                <span class="keyword">this</span>.address+<span class="keyword">this</span>.address;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Mail <span class="title">randomMail</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Mail mail=<span class="keyword">new</span> Mail();</span><br><span class="line">        mail.generaliDelivery=Enums.random(GeneraliDelivery.class);</span><br><span class="line">        mail.scannablity=Enums.random(Scannablity.class);</span><br><span class="line">        mail.readablity=Enums.random(Readablity.class);</span><br><span class="line">        mail.address=Enums.random(Address.class);</span><br><span class="line">        mail.returnAddress=Enums.random(ReturnAddress.class);</span><br><span class="line">        <span class="keyword">return</span> mail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Iterable&lt;Mail&gt; <span class="title">generator</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Iterable&lt;Mail&gt;()&#123;</span><br><span class="line">            <span class="keyword">int</span> n=count;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Iterator&lt;Mail&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;Mail&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> n--&gt;<span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Mail <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> randomMail();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PostOffice</span> </span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> MailHandler&#123;</span><br><span class="line">        GENERAL_DELIVERY&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">boolean</span> <span class="title">handle</span><span class="params">(Mail mail)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">switch</span>(mail.generaliDelivery)&#123;</span><br><span class="line">                    <span class="keyword">case</span> YES:</span><br><span class="line">                        System.out.println(<span class="string">"Using general delivery for"</span>+mail);</span><br><span class="line">                        <span class="keyword">return</span>  <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">default</span>:<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        MACHINE_SCAN&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">boolean</span> <span class="title">handle</span><span class="params">(Mail mail)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">switch</span> (mail.scannablity)&#123;</span><br><span class="line">                    <span class="keyword">case</span> UNSCANNABLE:<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">switch</span> (mail.address)&#123;</span><br><span class="line">                            <span class="keyword">case</span> INCORRECT:<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">default</span>:</span><br><span class="line">                                System.out.println(<span class="string">"Delivering"</span>+mail+<span class="string">"automaticaly"</span>);</span><br><span class="line">                                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        VISUAL_INSPECTION&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">boolean</span> <span class="title">handle</span><span class="params">(Mail mail)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">switch</span> (mail.readablity)&#123;</span><br><span class="line">                    <span class="keyword">case</span> ILLEGIBLE: <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        System.out.println(<span class="string">"Delivering "</span>+mail+<span class="string">"normally"</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        RETURN_TO_SENDER&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">boolean</span> <span class="title">handle</span><span class="params">(Mail mail)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">switch</span> (mail.returnAddress)&#123;</span><br><span class="line">                    <span class="keyword">case</span> MISSING:<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        System.out.println(<span class="string">"Returning "</span>+mail+<span class="string">" to sender"</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">handle</span><span class="params">(Mail mail)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Mail mail)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(MailHandler handler:MailHandler.values())&#123;</span><br><span class="line">            <span class="keyword">if</span>(handler.handle(mail))&#123;</span><br><span class="line">                <span class="keyword">return</span>;<span class="comment">//当不通过这里返回的时候,表明mail是个dead letter</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"this is a dead letter"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mian</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Mail mail:Mail.generator(<span class="number">10</span>))&#123;</span><br><span class="line">            System.out.println(mail.details());</span><br><span class="line">            handle(mail);</span><br><span class="line">            System.out.println(<span class="string">"*************"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的例子也会简单，随机生成mail对象，使用enum来实现职责链模式具有天生的优势，第一是enum.values()生成的数组是按照声明的顺序排序的，最重要的是每个enum实例都具有不同的行为（常量相关的方法）</p><h3 id="使用enum的状态机"><a href="#使用enum的状态机" class="headerlink" title="使用enum的状态机"></a>使用enum的状态机</h3><p>枚举类型非常适合用来创建状态机，一个专题可以具有有限个特定的状态，它通常根据输入，从一个状态转移到另一个状态，不过也可能存在瞬时状态（transient states）,而一旦任务执行结束，状态机就会立刻离开瞬时状态<br>每个状态都具有某些可接受的输入，不同的输入会使状态机从当前状态转移到不同的新状态，由于enum对其实例有严格限制，非常适合用来表现不同状态和输入，一般而言，每个状态都具有一些相关的输出<br>自动售货机是个很好的转态机的例子，首先，我们用一个enum定义各种输入<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> xyz.egbertday.enumerated.Input.*;</span><br><span class="line"><span class="keyword">enum</span> Category&#123;</span><br><span class="line">    MONEY(NICKEL,DIME,QUARTER,DOLLAR),</span><br><span class="line">    ITEM_SELECTION(TOOTHPASTE,CHIPS,SODA,SOAP),</span><br><span class="line">    QUIT_TRANSACTION(ABORT_TRANSACTION),</span><br><span class="line">    SHUT_DOWN(STOP);</span><br><span class="line">    <span class="keyword">private</span> Input[] values;</span><br><span class="line">    Category(Input... types)&#123;</span><br><span class="line">        values=types;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> EnumMap&lt;Input,Category&gt; categories=<span class="keyword">new</span> EnumMap&lt;&gt;(Input.class);</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Category category:Category.values())&#123;</span><br><span class="line">            <span class="keyword">for</span> (Input type:category.values)&#123;</span><br><span class="line">                categories.put(type,category);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Category <span class="title">categorize</span><span class="params">(Input input)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> categories.get(input);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VendingMachine</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> State state=State.RESTING;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> amount=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Input selection=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">enum</span> StateDuration&#123;TRANSIENT&#125;<span class="comment">//tagging enum</span></span><br><span class="line">    <span class="keyword">enum</span> State&#123;</span><br><span class="line">        RESTING&#123;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">(Input input)</span></span>&#123;</span><br><span class="line">                <span class="keyword">switch</span>(Category.categorize(input))&#123;</span><br><span class="line">                    <span class="keyword">case</span> MONEY:</span><br><span class="line">                        amount+=input.amount();</span><br><span class="line">                        state=ADDING_MONEY;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> SHUT_DOWN:</span><br><span class="line">                        state=TERMINAL;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        ADDING_MONEY&#123;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">(Input input)</span></span>&#123;</span><br><span class="line">                <span class="keyword">switch</span> (Category.categorize(input))&#123;</span><br><span class="line">                    <span class="keyword">case</span> MONEY:</span><br><span class="line">                        amount+=input.amount();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> ITEM_SELECTION:</span><br><span class="line">                        selection=input;</span><br><span class="line">                        <span class="keyword">if</span>(amount&lt;selection.amount())&#123;</span><br><span class="line">                            System.out.println(<span class="string">"Insufgficient money for "</span>+selection);</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            state=DISPENSING;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> QUIT_TRANSACTION:</span><br><span class="line">                        state=GIVING_CHANGE;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> SHUT_DOWN:</span><br><span class="line">                        state=TERMINAL;</span><br><span class="line">                     <span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        DISPENSING&#123;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">()</span></span>&#123;</span><br><span class="line">               System.out.println(<span class="string">"here is your "</span>+selection);</span><br><span class="line">               amount-=selection.amount();</span><br><span class="line">               state=GIVING_CHANGE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line">        GIVING_CHANGE&#123;</span><br><span class="line">             <span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                 <span class="keyword">if</span> (amount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                     System.out.println(<span class="string">"your change is:"</span> + amount);</span><br><span class="line">                     amount = <span class="number">0</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">                 state=RESTING;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        TERMINAL&#123;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>&#123;System.out.println(<span class="string">"Halted"</span>);&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> isTransient=<span class="keyword">false</span>;</span><br><span class="line">        State()&#123;&#125;</span><br><span class="line">        State(StateDuration trans)&#123; isTransient=<span class="keyword">true</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">(Input input)</span></span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">""</span> +</span><br><span class="line">                    <span class="string">"only call next() for StateDuration.non-Transient states"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">""</span> +</span><br><span class="line">                    <span class="string">"Only call next() for state Duration.transient states"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>&#123;System.out.println(amount);&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Generator&lt;Input&gt; gen)</span></span>&#123;</span><br><span class="line">         <span class="keyword">while</span>(state!=State.TERMINAL)&#123;</span><br><span class="line">             state.next(gen.next());</span><br><span class="line">             <span class="keyword">while</span>(state.isTransient)&#123;</span><br><span class="line">                 state.next();</span><br><span class="line">             &#125;</span><br><span class="line">             state.output();</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       Generator&lt;Input&gt; gen=<span class="keyword">new</span> RandomInputGenerator();</span><br><span class="line">       <span class="keyword">if</span>(args.length==<span class="number">1</span>)&#123;</span><br><span class="line">           gen=<span class="keyword">new</span> FileInputGenerator(args[<span class="number">0</span>]);</span><br><span class="line">       &#125;</span><br><span class="line">       run(gen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomInputGenerator</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">Input</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Input <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Input.randomSelection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileInputGenerator</span> <span class="keyword">implements</span>  <span class="title">Generator</span>&lt;<span class="title">Input</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Iterator&lt;String&gt; input;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileInputGenerator</span><span class="params">(String fileName)</span></span>&#123;</span><br><span class="line">        input=<span class="keyword">new</span> TextFile(fileName,<span class="string">";"</span>).iterator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Input <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!input.hasNext())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Enum.valueOf(Input.class,input.next().trim());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的售货机例子并不难，耐心看下去，很简单<br>这种设计有一个缺陷，他要求enum State实例访问的VendingMachin属性必须声明为static，这意味着，你只能有一个Vendingmachine实例,不过我们考虑一下实际（嵌入式java）应用，这也许不是什么大问题</p><h2 id="多路分发"><a href="#多路分发" class="headerlink" title="多路分发"></a>多路分发</h2><p>当你声明a.plus(b)时，你并不知道a或b的确切类型，那你如何能让它们正确交互呢？<br>你可能从未思考这个问题的答案，Java只支持单路分发，也就是说，如果要执行的操作包含了不止一个类型位置的对象时，那么java的的动态绑定机制只能处理其中一个的类型，这就无法解决我们上面提到的问题，所以你必须自己来判断其他的类型，从而实现自己的动态绑定行为<br>解决上面的办法就是多路分发（在上面那个例子中，只有两个分发，一般称之为两路分发）。<br>多态只能发生在方法调用时，所有，如果想使用两路分发，那么就必须有两个方法调用，第一个方法调用决定第一额未知类型，第二个方法调用第二个位置的类型，要利用多路分发，程序员必须能够为每一个类型提供一个实际的方法调用，如果你要处理两个不同的类型体系，就要为每个类型体现执行一个方法调用，一般而言，程序员需要设定好的某种配置，以便一个方法调用能够引出更多的方法调用，从而能够在这个过程中处理多种类型，为了达到这种效果，我们需要与多个犯法一同工作，因为每个分发都需要一个方法调用<br>下面是个石头剪刀布的游戏<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Outcome&#123;WIN,LOSE,DRAW&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Item</span></span>&#123;</span><br><span class="line">    <span class="function">Outcome <span class="title">compare</span><span class="params">(Item it)</span></span>;</span><br><span class="line">    <span class="function">Outcome <span class="title">eval</span><span class="params">(Paper p)</span></span>;</span><br><span class="line">    <span class="function">Outcome <span class="title">eval</span><span class="params">(Scissor s)</span></span>;</span><br><span class="line">    <span class="function">Outcome <span class="title">eval</span><span class="params">(Rock r)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Paper</span> <span class="keyword">implements</span> <span class="title">Item</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">compare</span><span class="params">(Item it)</span> </span>&#123; <span class="keyword">return</span> it.eval(<span class="keyword">this</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Paper p)</span> </span>&#123; <span class="keyword">return</span> DRAW; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Scissor s)</span> </span>&#123; <span class="keyword">return</span> LOSE; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Rock r)</span> </span>&#123; <span class="keyword">return</span> WIN; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scissor</span>  <span class="keyword">implements</span> <span class="title">Item</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">compare</span><span class="params">(Item it)</span> </span>&#123; <span class="keyword">return</span> it.eval(<span class="keyword">this</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Paper p)</span> </span>&#123; <span class="keyword">return</span> WIN; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Scissor s)</span> </span>&#123; <span class="keyword">return</span> DRAW;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Rock r)</span> </span>&#123; <span class="keyword">return</span> LOSE; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rock</span> <span class="keyword">implements</span> <span class="title">Item</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">compare</span><span class="params">(Item it)</span> </span>&#123; <span class="keyword">return</span> it.eval(<span class="keyword">this</span>); &#125;<span class="comment">//第二次分发</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Paper p)</span> </span>&#123; <span class="keyword">return</span> LOSE; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Scissor s)</span> </span>&#123; <span class="keyword">return</span> WIN ; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Rock r)</span> </span>&#123; <span class="keyword">return</span> DRAW; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoShamBo1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE=<span class="number">20</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand=<span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Item <span class="title">newItem</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (rand.nextInt(<span class="number">3</span>))&#123;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:<span class="keyword">return</span> <span class="keyword">new</span> Paper();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:<span class="keyword">return</span>  <span class="keyword">new</span> Scissor();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:<span class="keyword">return</span> <span class="keyword">new</span> Rock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">macth</span><span class="params">(Item a,Item b)</span></span>&#123;</span><br><span class="line">        System.out.println(</span><br><span class="line">           a+<span class="string">"VS"</span>+b+<span class="string">":"</span>+a.compare(b)<span class="comment">//第一次分发</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;SIZE;i++)&#123;</span><br><span class="line">            macth(newItem(),newItem());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Item是这几种类型的接口，会被用作多路分发，RoShamBo1.match()有两个Item参数，通过调用Item.compare()方法开始两路分发，要判定a的类型，分发机制会在a的实际类型的compara()内部起到分发的作用，compara()方法同eval()来为另一个类型实现第二次分发</strong>，将自身(this)作为参数调用eval()，就能调用重载过的eval()方法，这能够保留第一次分发的类型信息，当第二次分发完成时，你就能够知道两个Item对象的具体类型了<br>要配置好多路分发需要很多的工序，不过要记住，它的好处在于方法调用时的优雅的语法，这就避免了在一个方法中判断多个对象的类型的丑陋代码，你只需要说“嘿，你们两个，我不在会你们是什么类型，请你们自己交流！”</p><h3 id="使用enum分发"><a href="#使用enum分发" class="headerlink" title="使用enum分发"></a>使用enum分发</h3><p>我们不能直接将RoShamBo1.java翻译为基于enum的版本，因为enum实例不是类型，我没在RoShamBol通过实现接口来对类型划分可以做到，但是enum不可以，因为每个enum实例都是相应的enum类型啊，它们的类型一致，怎么能实现分发呢？不过我们还有很多方法可以实现多路分发，并从enum中获益<br><strong>一种实现多路分发的方法是使用构造器初始化每个enum实例，并以“一组”结果作为参数，这两者放在一起，形成了类似查询表的结构</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Competitor</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">Outcome <span class="title">compete</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoShamBo</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Competitor&lt;T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">match</span><span class="params">(T a,T b)</span></span>&#123;</span><br><span class="line">        System.out.println(</span><br><span class="line">           a+<span class="string">"vs"</span>+b+a.compete(b)<span class="comment">//第一次分发</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Enum&lt;T&gt; &amp; Competitor&lt;T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">(Class&lt;T&gt; type,<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            match(Enums.random(type),Enums.random(type));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RoShamBo2 implements Competitor&lt;RoShamBo2&gt; &#123;</span><br><span class="line">    PAPER(DRAW,LOSE,WIN),</span><br><span class="line">    SCISSORS(WIN,DRAW,LOSE),</span><br><span class="line">    ROCK(LOSE,WIN,DRAW);</span><br><span class="line">    <span class="keyword">private</span> Outcome vPaper,vScissors,vRock;</span><br><span class="line">    RoShamBo2(Outcome paper,Outcome sciccors,Outcome rock)&#123;</span><br><span class="line">        vPaper=paper;</span><br><span class="line">        vScissors=sciccors;</span><br><span class="line">        vRock=rock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">compete</span><span class="params">(RoShamBo2 roShamBo2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (roShamBo2)&#123;<span class="comment">//使用switch实现第二次分发</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">case</span> PAPER: <span class="keyword">return</span> vPaper;</span><br><span class="line">            <span class="keyword">case</span> SCISSORS:;<span class="keyword">return</span> vScissors;</span><br><span class="line">            <span class="keyword">case</span> ROCK:<span class="keyword">return</span> vRock;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args)</span></span>&#123;</span><br><span class="line">        RoShamBo.play(RoShamBo2.class,<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的例子更加短小，直接，容易理解，注意，这里我们仍然使用了两路分发来判断两个对象的类型，在RoShamBo1两次分发都是通过实际的方法调用实现，而在这个例子中，只有第一次分发是实际的方法调用，第二次分发使用的是switch，不过这样是安全的，因为enum限制了switch语句的选择分支</p><h3 id="使用常量相关的方法"><a href="#使用常量相关的方法" class="headerlink" title="使用常量相关的方法"></a>使用常量相关的方法</h3><p><strong>常量相关的方法允许我们为每个enum实例提供方法不同的实现，这使得常量相关的方法似乎是实现多路分发的完美解决方案，不过，通过这种方式，enum实例虽然可以具有不同的行为，但他们仍然不是类型，不能将其作为方法签名中的参数类型来使用，最好的办法是将enum用在switch语句中</strong></p><h3 id="使用EnumMap分发"><a href="#使用EnumMap分发" class="headerlink" title="使用EnumMap分发"></a>使用EnumMap分发</h3><p>使用EnumMap能够实现“真正的”两路分发，EnumMap是为Enum专门设计的一种性能非常好的特殊的Map,由于我们的目的是摸索出两种不同未知的类型，<strong>所以可以用EnumMap的EnumMap来实现两路分发</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.EnumMap;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> xyz.egbertday.enumerated.Outcome.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RoShamBo5 implements Competitor&lt;RoShamBo5&gt;&#123;</span><br><span class="line">    PAPER,SCISSORS,ROCK;</span><br><span class="line">    <span class="keyword">static</span> EnumMap&lt;RoShamBo5,EnumMap&lt;RoShamBo5,Outcome&gt;&gt; table=<span class="keyword">new</span> EnumMap&lt;&gt;(RoShamBo5.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(RoShamBo5 it:RoShamBo5.values())&#123;</span><br><span class="line">            table.put(it,<span class="keyword">new</span> EnumMap&lt;RoShamBo5, Outcome&gt;(RoShamBo5.class));</span><br><span class="line">        &#125;</span><br><span class="line">        initRow(PAPER,DRAW,LOSE,WIN);</span><br><span class="line">        initRow(SCISSORS,WIN,DRAW,LOSE);</span><br><span class="line">        initRow(ROCK,LOSE,WIN,DRAW);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initRow</span><span class="params">(RoShamBo5 it,Outcome vPaper,Outcome vScissors,Outcome vRock)</span></span>&#123;</span><br><span class="line">        EnumMap&lt;RoShamBo5,Outcome&gt; row=RoShamBo5.table.get(it);</span><br><span class="line">        row.put(RoShamBo5.PAPER,vPaper);</span><br><span class="line">        row.put(RoShamBo5.SCISSORS,vScissors);</span><br><span class="line">        row.put(RoShamBo5.ROCK,vRock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">compete</span><span class="params">(RoShamBo5 roShamBo5)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> table.get(<span class="keyword">this</span>).get(roShamBo5);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        RoShamBo.play(RoShamBo5.class,<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;关键字enum可以将一组具名的值的有限集合创建为一种新的类型，而这些具名的值可以作为常规的程序组件使用，这是一种非常有用的功能&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;基本的enum特性&quot;&gt;&lt;a href=&quot;#基本的enum特性&quot; class=&quot;heade
      
    
    </summary>
    
      <category term="学习心得" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java I/O系统</title>
    <link href="http://yoursite.com/2018/10/19/Java-I-O%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2018/10/19/Java-I-O系统/</id>
    <published>2018-10-19T14:06:30.000Z</published>
    <updated>2018-10-25T14:22:55.404Z</updated>
    
    <content type="html"><![CDATA[<p>创建一个好的输入/输出(I/O)系统是一项困难的事情，挑战似乎来自于要涵盖所有的可能性，不仅存在各种I/O源端和想要与之通信的接收器（文件，控制台，网络链接等），而且还需要以各种不同的方式与它们进行通信（顺序，随机缓存，缓冲，二进制，按行，按字等）<br>自从Java 1.0版本以来，java的I/O类库发生了明显改变，在原本面向字节的类中添加了面向字符和基于Unicode的类，在JDK1.4中，添加了nio类（对于“新I/O”来说，这是一个从现在起我们将会使用多年的名称，即使它们在JDK1.4就被引用了）添加进来是为了改善性能和功能， 因此，在充分理解Java I/O系统以便正确运用它们之前，我们需要学习相当数量的类，另外，很有必要理解I/O类型的演化过程</p><h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><p>File是一个实用类库工具，它可以帮助我们处理文件目录问题<br>File(文件)类的名字有一定的误导性，我们可能以为它指代的是文件，实际上并非如此，它既能表示一个特定文件的名称，又能代表一个目录下的一组文件的名称，实际上，FilePath（文件路径）这个名称可能更适合它</p><h3 id="目录列表器"><a href="#目录列表器" class="headerlink" title="目录列表器"></a>目录列表器</h3><p>假如我们想要查看一个目录列表，可以用两种方式来使用File对象，如果我们调用不带参数的list()方法，便可以获得此File对象包含的全部列表，然而，如果我们想要获得一个受限列表，例如，想要获得所有扩展名为.java的文件，那么我们就要使用到“目录过滤器”，这个类会告诉我们怎样显示符合条件的File对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      String[] fileNames;</span><br><span class="line">      File path=<span class="keyword">new</span> File(<span class="string">"."</span>);</span><br><span class="line">      <span class="keyword">if</span>(args.length==<span class="number">0</span>)&#123;</span><br><span class="line">          fileNames=path.list();</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          fileNames=path.list(<span class="keyword">new</span> DirFilter(args[<span class="number">0</span>]));</span><br><span class="line">      &#125;</span><br><span class="line">        Arrays.sort(fileNames,String.CASE_INSENSITIVE_ORDER);</span><br><span class="line">      <span class="keyword">for</span>(String fileName:fileNames)&#123;</span><br><span class="line">          System.out.println(fileName);</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DirFilter</span> <span class="keyword">implements</span> <span class="title">FilenameFilter</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String regex;</span><br><span class="line">    Pattern pattern=Pattern.compile(regex);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DirFilter</span><span class="params">(String regex)</span></span>&#123;regex=regex;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pattern.matcher(name).matches();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>DirFile这个类存在的唯一原因就是提供accept()方法给List()方法使用，使用list()可回调accept()，进而选择以决定那些文件被包含在列表中，因此，这种结构也常常被称作回调</strong>，更具体的说，这是一个策略模式的例子，因为list()实现了基本功能，而按照FilenamFilter的形式提供这个策略，以便完善list()在提供服务是所需的算法，因为list()接受FilenameFilter对象作为参数，这意味着我们可以 传递实现了FilenameFilter接口的任何类的对象</p><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>这个例子使用匿名内部类进行改写，首先创建一个filter()方法，它会返回一个指向FilenameFilter的引用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirList2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FilenameFilter <span class="title">filter</span><span class="params">(<span class="keyword">final</span> String regex)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FilenameFilter() &#123;</span><br><span class="line">            Pattern pattern=Pattern.compile(regex);</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> pattern.matcher(name).matches();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String[] fileNames;</span><br><span class="line">        File path=<span class="keyword">new</span> File(<span class="string">"."</span>);</span><br><span class="line">        <span class="keyword">if</span>(args.length==<span class="number">0</span>)&#123;</span><br><span class="line">            fileNames=path.list();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            fileNames = path.list(filter(args[<span class="number">0</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>注意传递给filter的参数必须是final的，这个在匿名内部类是必需的，这样它才能使用来自该类范围之外的对象</strong><br>这个设计有所改进，因为现在FilenameFilter类紧密地和DirFilter2绑定到一起，然而，我们可以进一步修改该方法，定义一个作为list()参数的匿名内部类，这样程序会变得更小<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirList3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span></span>&#123;<span class="comment">//传递给匿名内部类的参数使用final修饰</span></span><br><span class="line">        String[] fileNames;</span><br><span class="line">        File path= <span class="keyword">new</span> File(<span class="string">"."</span>);</span><br><span class="line">        <span class="keyword">if</span>(args.length==<span class="number">0</span>)&#123;</span><br><span class="line">            fileNames=path.list();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            fileNames=path.list(<span class="keyword">new</span> FilenameFilter() &#123;</span><br><span class="line">                Pattern pattern=Pattern.compile(args[<span class="number">0</span>]);</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> pattern.matcher(name).matches();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(String fileName:fileNames)&#123;</span><br><span class="line">            System.out.println(fileName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="目录实用工具"><a href="#目录实用工具" class="headerlink" title="目录实用工具"></a>目录实用工具</h3><p>程序设计中的一项常见的任务就是在文件集上执行操作，这些文件要么在本地目录中，要么遍布于整个目录树中，如果你有一种工具能够为你产生这个文件集，那么它会非常有用，下面的实用工具类就是通过使用list()方法产生由本地目录中的文件构成的File对象数组，或者通过使用walk()方法产生给目录下的由整个目录树中所有的文件构成的List<file>（File文件比对象更有用，因为File对象包含更多信息），下面的这些文件时基于你的正则表达式被选中的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Directory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> File[] local(File dir,<span class="keyword">final</span> String regex)&#123;</span><br><span class="line">        <span class="keyword">return</span> dir.listFiles(<span class="keyword">new</span> FilenameFilter() &#123;</span><br><span class="line">            Pattern pattern=Pattern.compile(regex);</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> pattern.matcher(name).matches();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> File[] local(String path,String regex)&#123;</span><br><span class="line">        <span class="keyword">return</span> local(<span class="keyword">new</span> File(path),regex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeInfo</span> <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">File</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> List&lt;File&gt; files =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">public</span> List&lt;File&gt; dirs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="meta">@NotNull</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Iterator&lt;File&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> files.iterator();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">(TreeInfo other)</span></span>&#123;</span><br><span class="line">            files.addAll(other.files);</span><br><span class="line">            dirs.addAll(other.dirs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"dirs"</span>+PPrint.pformat(dirs)+<span class="string">"\n\nfiles"</span>+PPrint.pformat(files);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeInfo <span class="title">walk</span><span class="params">(File start,String regex)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  recurseDirs(start,regex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeInfo <span class="title">walk</span><span class="params">(String path,String regex)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  recurseDirs(<span class="keyword">new</span> File(path),regex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeInfo <span class="title">walk</span><span class="params">(File start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> recurseDirs(start,<span class="string">".*"</span>);<span class="comment">//Everything</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeInfo <span class="title">walk</span><span class="params">(String startPath)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  recurseDirs(<span class="keyword">new</span> File(startPath),<span class="string">".*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> TreeInfo <span class="title">recurseDirs</span><span class="params">(File startDir,String regex)</span></span>&#123;</span><br><span class="line">        TreeInfo result = <span class="keyword">new</span> TreeInfo();</span><br><span class="line">        <span class="keyword">for</span>(File item:startDir.listFiles())&#123;</span><br><span class="line">            <span class="keyword">if</span>(item.isDirectory())&#123;</span><br><span class="line">                result.dirs.add(item);</span><br><span class="line">                recurseDirs(item,regex);<span class="comment">//递归调用</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(item.getName().matches(regex))&#123;</span><br><span class="line">                    result.files.add(item);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></file></p><p>上面的代码实现了收集一个目录数的信息，这里使用listFile()产生File数组，这个方法还可以接收一个目录FilenameFilter，我们得到File数组之后，对File数组遍历判断File是目录还是文件，若是目录则递归执行这个方法<br>我们还可以更进一步，创建一个工具，它可以在目录中穿行，并且根据Stratagy对象来处理这些目录中的文件（这是策略模式的另一个示例）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessFile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(File file)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line">    <span class="keyword">private</span> String ext;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProcessFile</span><span class="params">(Strategy strategy,String ext)</span></span>&#123;</span><br><span class="line">        strategy=strategy;</span><br><span class="line">        ext=ext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(args.length==<span class="number">0</span>)&#123;</span><br><span class="line">               processDirectoryTree(<span class="keyword">new</span> File(<span class="string">"."</span>));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(String arg:args)&#123;</span><br><span class="line">                    File fileArg=<span class="keyword">new</span> File(arg);</span><br><span class="line">                    <span class="keyword">if</span>(fileArg.isDirectory())&#123;</span><br><span class="line">                        processDirectoryTree(fileArg);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">if</span>(!arg.endsWith(<span class="string">"."</span>+ext))&#123;</span><br><span class="line">                            arg+=<span class="string">"."</span>+ext;</span><br><span class="line">                            strategy.process(<span class="keyword">new</span> File(arg).getCanonicalFile());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processDirectoryTree</span><span class="params">(File root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(File file:Directory.walk(root.getAbsolutePath(),<span class="string">".*\\."</span>+ext))&#123;</span><br><span class="line">            strategy.process(file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       <span class="keyword">new</span> ProcessFile(<span class="keyword">new</span> ProcessFile.Strategy()&#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">               System.out.println(file.getName());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,<span class="string">"java"</span>).start(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="目录的检查和创建"><a href="#目录的检查和创建" class="headerlink" title="目录的检查和创建"></a>目录的检查和创建</h3><p>File类不仅仅只是代表存在的文件或目录，也可以用File对象来创建新的目录或尚不存在的整个目录路径，我们还可以查看文件的特性（如大小，最后修改日期，读/写），检查某个File对象代表的是文件还是目录，并可以删除文件，下面的示例展示了File类的一些其他的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fileData</span><span class="params">(File f)</span></span>&#123;</span><br><span class="line">        System.out.println(</span><br><span class="line">                <span class="string">"Absolate path"</span>+f.getAbsolutePath()+</span><br><span class="line">                 <span class="string">"\n Can read:"</span>+f.canRead()+</span><br><span class="line">                 <span class="string">"\n Can write"</span>+f.canWrite()+</span><br><span class="line">                 <span class="string">"\n getName"</span>+f.getName()+</span><br><span class="line">                <span class="string">"\n getPath"</span>+f.getPath()+</span><br><span class="line">                 <span class="string">"\n getParent"</span>+f.getParent()+</span><br><span class="line">                 <span class="string">"\n length"</span>+f.length()+</span><br><span class="line">                 <span class="string">"\n lastModified"</span>+f.lastModified()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args.length&lt;<span class="number">1</span>)</span><br><span class="line">            usage();</span><br><span class="line">        <span class="keyword">if</span> (args[<span class="number">0</span>].equals(<span class="string">"-r"</span>))&#123;</span><br><span class="line">            <span class="keyword">if</span>(args.length!=<span class="number">3</span>)</span><br><span class="line">                usage();</span><br><span class="line">            File old=<span class="keyword">new</span> File(args[<span class="number">1</span>]);</span><br><span class="line">            File rname=<span class="keyword">new</span> File(args[<span class="number">2</span>]);</span><br><span class="line">            old.renameTo(rname);</span><br><span class="line">            fileData(old);</span><br><span class="line">            fileData(rname);</span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">//exit main</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> del=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(args[<span class="number">0</span>].equals(<span class="string">"-d"</span>))&#123;</span><br><span class="line">            count++;</span><br><span class="line">            del=<span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">while</span>(++count &lt; args.length)&#123;</span><br><span class="line">            File f=<span class="keyword">new</span> File(args[count]);</span><br><span class="line">            <span class="keyword">if</span>(f.exists())&#123;</span><br><span class="line">                System.out.println(f+<span class="string">" exsits"</span>);</span><br><span class="line">                <span class="keyword">if</span> (del)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"deleting..."</span>+f);</span><br><span class="line">                    f.delete();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(!del)&#123;</span><br><span class="line">                    f.mkdir();</span><br><span class="line">                    System.out.println(<span class="string">"Create"</span>+f);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            fileData(f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>renameTo()，用来将一个文件重命名（或移动）到由参数所指示的另一个完全不同的新路径（也就是另一个File对象），</p><h2 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h2><p><strong>编程语言的I/O类库中经常使用流这个概念，它代表任何又能及产出数据的数据源对象或者有能力接收数据的接收端对象，流屏蔽了实际的I/O设备中处理数据的细节</strong><br>java类库的I/O类分为输入和输出两部分，可以在java的JDK文档里的层次结构中查看到，<strong>通过继承，任何自InputStreanm或Reader派生而来的类都含有名字为read的基本方法</strong>，用于读取单个字节或者字节数组，同样，任何自OutputStream或Writer派生而来的类都包含有名为write()的基本方法，用于写单个字节或者字节数组，但是，我们通常不会用到这些方法，它们之所以存在是因为别的类可以使用它们，以便提供更有用的接口，因此，我们还少使用单一的类来创建流对象，而是通过叠加多个对象来提供期望的功能，这就是装饰器设计模式，java的流类库让人困惑的一点就是：创建单一的结果流却需要创建多个对象<br>按照这些类的功能对它们进行分类，在java1.0中，类库的设计者首先限定与输入有关的所有类都应该从InputStream继承，而与输出有关的类都应该从OutputStream继承</p><h3 id="InputStream类型"><a href="#InputStream类型" class="headerlink" title="InputStream类型"></a>InputStream类型</h3><p>InputStream的作用就是用来表示那些从不同数据源产生输入的类，这些数据源包括</p><ol><li>字节数组</li><li>String对象</li><li>文件</li><li>“管道”</li><li>一个由其他种类的流组成的序列，以便我们可以将它们收集合并到一个流内</li><li>其他数据源，如Internet连接等</li></ol><p><strong>每一种数据源都有相应的InputStream</strong>，另外，FilterInputStream也属于一种InputStream，为“装饰器”类提供基类，其中“装饰器”可以把有用的属性和接口与输入流连接在一起<br>|：InputStream类型：|</p><table><thead><tr><th></th><th>:类:</th><th>：功能：</th><th>：构造器参数/如何使用：</th></tr></thead><tbody><tr><td>ByteArrayInputStream</td><td>允许将内存的缓冲区当作InputStream使用</td><td>缓冲区，字节将从中取出<br>作为一种数据源：将其与FilterInputStrea对象相连以提供有用的接口</td></tr><tr><td>StringInputStream</td><td>将String转换成InputStream</td><td>字符串，底层实现实际使用StringBuffer<br>作为一种数据源：将其与FilterInputStream对象相连以提供有用的接口</td></tr><tr><td>FileInputStream</td><td>用于从文件中读取信息</td><td>字符串：表示文件名，文件或FileDescriptor对象<br>作为一种数据源：将其与FilterInputStream对象相连以提供有用的接口</td></tr><tr><td>PipedInputStream</td><td>产生用于写入相关PipedInputStream的数据，实现“管道化”概念</td><td>PipedOutputStream<br>作为多线程中数据源：将其与FilterInputStream对象相连以提供有用的接口</td></tr><tr><td>SequenceInputStream</td><td>将两个或多个InputStream对象转换成单一的InputStream</td><td>两个InputStream对象或一个容纳InputStream对象的容器Enumation<br>作为一种数据源，将其与FilterInputStream对象相连以提供有用的接口</td></tr><tr><td>FilterInputStream</td><td>抽象类，作为“装饰器”的接口，其中“装饰器”为其他的类提供有用的功能</td><td>详情查看实现FilterInputStream的类</td></tr></tbody></table><h3 id="OutputStream类型"><a href="#OutputStream类型" class="headerlink" title="OutputStream类型"></a>OutputStream类型</h3><p>该类别决定了输出所要去往的目标：字节数组（但不是String，不过你当然可以用字节数组自己创建），文件或管道<br>另外，FilterOutputStream为“装饰器”类提供了一个基类，“装饰器”类把属性或者有用的接口与输出流连接了起来<br>|：OutputStream类型：|</p><table><thead><tr><th></th><th>：类：</th><th>：功能：</th><th>：构造器参数/如何使用：</th></tr></thead><tbody><tr><td>ByteArrayOutoputStream</td><td>在内存中创建缓冲区，所有送往“流”的数据都要放置在此缓冲区内</td><td>缓冲区初始化尺寸（可选的）<br>用于指定数据的目的地：将其与FilterOutputStream对象相连以提供有用接口</td></tr><tr><td>FileOutputStream</td><td>用于将信息写至文件</td><td>字符串，表示文件名，文件或者FileDiscriptor<br>指定数据的目的地：将其与FilterOutputStream对象相连以提供有用接口</td></tr><tr><td>PipeOutputStream</td><td>任何写入其中的信息都会自动作为相关PipedInputStream的输出，实现”管道化”概念</td><td>PidedInputStream<br>指定用于多线程的数据的目的地：将其与FilterOutStream对象相连以提供有用的接口</td></tr><tr><td>FilterOutputStream</td><td>抽象类，作为“装饰器”的接口，其中“装饰器”为其他OutputStream提供有用的功能</td><td></td></tr></tbody></table><h2 id="添加属性和有用的接口"><a href="#添加属性和有用的接口" class="headerlink" title="添加属性和有用的接口"></a>添加属性和有用的接口</h2><p><strong>java的I/O类库需要多种不同功能的组合，这正是装饰器模式的理由所在</strong>，这也正是java I/O类库中存在filter（过滤器）类的原因所在，抽象类filter是所有装饰器类的基类，装饰器必须具有和它所装饰的对象相同的接口，但也可以扩展接口，而这种情况只发生在个别的filter类中<br>装饰器的一个缺点，在编写代码的时候，它给了我们很大的灵活性（因为我们很容易混合和匹配属性），但是它同时也增加了代码的复杂性，Java I/O类库操作不便的原因在于:我们必须创建很多类——“核心”I/O类型加上所有的装饰器，才能得到我们所需要单个I/O对象<br>FilterInputStream和FilterOutputStream是用来提供装饰器类接口以控制特定输入流和输出流的两个类，它们的名字不是很直观，它们是直接子I/O类库中的InputStream和OutPutStream派生而来，这两个类是装饰器的必要条件（以便能为所有正在被修饰的对象提供通用的接口）</p><h3 id="通过FilterInputStream和InputStream读取数据"><a href="#通过FilterInputStream和InputStream读取数据" class="headerlink" title="通过FilterInputStream和InputStream读取数据"></a>通过FilterInputStream和InputStream读取数据</h3><p>FilterInputStream类能够完成两件完全不同的事情，其中，DataInputStream允许我们读取不同的基本类型数据以及String对象（所有方法都以“read”开头，例如readByte(),readFloat()等等）搭配相应的DataOutPutStream，我们可以通过数据“流”将基本类型的数据从一个地方迁移到另一个地方<br>其他FilterInputStream类则在内部修改InputStream的行为方式：是否缓冲，是否保留它所读过的行（允许我们查询行数或设置行数），以及是否把单一字符推回输入流等等，最后两个类看起来就像是为了创建一个编译器（它们被添加进来可能是为了对“用java构建编译器”实验提供支持），因此我们在一般的编程不会用到它们<br>|:FilterInputStream:|</p><table><thead><tr><th></th><th>：类：</th><th>：功能：</th><th>：构造器参数/如何使用：</th></tr></thead><tbody><tr><td>DataInputStream</td><td>与DataOutputStream搭配使用，因此我们可以按照可移植方式从流读取基本数据类型（int,cahr,long等）</td><td>InputStream<br>包含用于读取基本类型数据的全部接口</td></tr><tr><td>BufferInputStream</td><td>使用它可以防止每次读取都得进行实际写操作，代表“使用缓冲区”</td><td>InputStream<br>本质上不提供接口，只不过是向进程中添加缓冲区所必需的，与接口对象搭配</td></tr><tr><td>LineNubmberInputStream</td><td>跟踪输入流中的行为，可调用getLineNumber()和setLineNumber(int)</td><td>InputStream<br>仅增加了行号，因此可能要与接口对象搭配使用</td></tr><tr><td>PushbackInputStream</td><td>具有“能弹出一个字节的缓冲区”，因此可以将读到的最后一个字符回退</td><td>InputStream<br>通常作为编译器的扫描器，之所以包含在内是因为java编译器的需要，我们可能永远不会用到</td></tr></tbody></table><h3 id="通过FilterOutputStream和OutputStream写入数据"><a href="#通过FilterOutputStream和OutputStream写入数据" class="headerlink" title="通过FilterOutputStream和OutputStream写入数据"></a>通过FilterOutputStream和OutputStream写入数据</h3><p>与DataInputStream对应的是DateOutPut，它可以将各种基本类型数据以及String对象格式化输出到“流”中，这样以来，任何在机器上的人任何DataInputStream都能读取它们，所有方法都是以“write”开头，例如writeByte().writeFloat()等<br>PrintStream最初的目的便是为了可以以可视化格式打印所有的基本类型以及String对象，这和DataOutputStream不同，后者的目的是将数据元素置入“流”中，使得DataInputStream能够可移植地重构它们<br>PrintStream内有两个重要的方法：print(),println(),对它们进行重载，以便可打印出各种数据类型，print()和println()之间的差异，后者是在操作完毕后添加一个换行符<br>PrintStream可能会有一些问题，因为它们捕捉了所有的IOExceptions（因此，我们必须使用checkError()自行检测错误状态，如果出现错误它返回true），另外，PrintStrea也未完全国际化，不能以平台无关的方式处理换行动作（这些问题在printWriter得到了解决）<br>BuferredOutputStream是一个修改过的OutputStream，它对数据流使用缓冲技术，因此当每次向流写入时，不必每次都进行实际的物理写动作，所以在进行输出时，我们可能更经常的使用它</p><p>|:FilterOutputStream:|</p><table><thead><tr><th></th><th>：类：</th><th>：功能：</th><th>：构造器参数/如何使用：</th></tr></thead><tbody><tr><td>DataOutputStream</td><td>与DataInputStream搭配使用，因此可以按照可移植方式向流中写入基本类型数据（int char long等）</td><td>OutputStream<br></td></tr></tbody></table><p>包含用于写入基本类型数据的全部接口<br>PrintStream|用于产生格式化输出，其中DataOutStream处理数据的存储，PrintStream处理显示|OutputStream<br>可以用boolean值指示是否在每次换行时清空缓冲区（可选的）应该是对OutputStream对象的“final”封装，可能会经常使用它<br>BufferedOutputStream|使用它以避免每次发送数据时都要进行实际的写操作，代表“使用缓冲区”可以调用flush()清空缓冲区|OutputStream可以指定缓冲区大小（可选）<br>本质上并不提供接口，只不过是向进程中添加缓冲区所必需的，与接口对象搭配</p><h2 id="Reader和Writer"><a href="#Reader和Writer" class="headerlink" title="Reader和Writer"></a>Reader和Writer</h2><p>java1.1对基本的I/O流类型进行了重大的修改，当我们初次看到Reader和Writer类时，可能会认为这两个类时取代InputStream和OutputStream的类，但实际上并不是如此，尽管员I/O类库中的一些类已经被废弃，但是InputStream和OutputStream在以面向字节形式的I/O中仍可以提供极其有价值的功能，Reader和Writer则提供兼容Unicode与面向字符的I/O功能，另外：</p><ol><li>java1.1向InputStream和OutputStream继承结构中添加了一些新类，所有显然这两个类时不会被取代的</li><li>有时我们必须要把来自于“字节”层次结构中的类和“字符”层次结构中的类结合起来使用，为了实现这个目的，就要使用“适配器（adapter）”类：InputStreamReader可以将InputStream转换为Reader，而OutStreamWriter可以把OutputStream转换为Writer<br>设计Reader和Writer继承层次结构主要是为了国际化，老的I/O流继承层次结构仅支持8位字节流，并且不能很好地处理16位的Unicode字符，由于Unicode用于字符国际化（java本身的char也是16位的Unicode），所以添加Reader和Writer继承层次结构是为了在所以的I/O操作中都支持Unicode，另外，新类库的设计使得它的操作比旧类库更快<h3 id="数据的来源和去处"><a href="#数据的来源和去处" class="headerlink" title="数据的来源和去处"></a>数据的来源和去处</h3>几乎所有原始的java I/O流类都有相应的Reader和Writer类来提供天然的Unicode操作<br>然而在某些场合，面向字节的InputStream和OutputStream才是正确的解决方案，特别是，java.util,zip类库就是面向字节的而不是面向字符的，因此，最明智的做法是尽量尝试使用Reader和Writer，一旦程序代码无法编译成功，我们就会发现自己不得不使用面向字节的类型<br>下面展示了两个继承结构中，信息的来源和去处（即数据物理上来自哪里及去向哪里）之间的对应关系</li></ol><table><thead><tr><th></th><th>来源与去处：java 1.0类</th><th>相应的java 1.1类</th></tr></thead><tbody><tr><td>InputStream</td><td>Reader<br>适配器：InputStreamReader</td></tr><tr><td>OutputStream</td><td>Writer<br>适配器：OutputStreamWriter</td></tr><tr><td>FileInputStream</td><td>FileReader</td></tr><tr><td>FileOutoutStream</td><td>FileWriter</td></tr><tr><td>StringBufferInputStream（已废弃）</td><td>StringReader</td></tr><tr><td>无相应的类</td><td>StringWriter</td></tr><tr><td>ByteArrayInputStream</td><td>CharArrayReader</td></tr><tr><td>ByteArrayOutputStream</td><td>CharArrayWriter</td></tr><tr><td>PipedInputStream</td><td>PipedReader</td></tr><tr><td>PipedOutputStream</td><td>PipedWriter</td></tr></tbody></table><h3 id="更改流的行为"><a href="#更改流的行为" class="headerlink" title="更改流的行为"></a>更改流的行为</h3><p>对于InputStream和OutPutStream来说，我们会使用FilterInputStream和FilterOutputStream的装饰器子类来“修改”流，以满足特殊需要。Reader和Writer的类继承层次结构继续沿用相同的思想——但是并不完全相同<br>下表，相对于前一个表格来说，左右之间的对应关系的近似程度更加粗略一些，造成这种差别的主要原因是因为类的组织形式的不同，：尽管BufferedOutputStream是FilterOutputStream的子类，但是BufferedEriter并不是FilterWriter的子类（尽管FilterWriter是抽象类，但是它没有任何子类，把它放在这里也只是把它作为一个占位符，或仅仅让我们不会对它所在的地方产生疑惑），然而这些类的接口却十分相似</p><table><thead><tr><th></th><th>过滤器： java 1.0类</th><th>相应的 Java 1.1类</th></tr></thead><tbody><tr><td>FilterInputStream</td><td>FilterReader</td></tr><tr><td>FilterOutputStream</td><td>FilterWriter(抽象类，没有子类)</td></tr><tr><td>BufferedInputStream</td><td>BufferedRaeder(也有readLine())</td></tr><tr><td>BufferdeOutStream</td><td>BufferedWriter</td></tr><tr><td>DataInputStream</td><td>使用DateInputStream（除了当需要使用readLIne()时以外，这时应该使用BufferReader）</td></tr><tr><td>PrintStream</td><td>PrintWriter</td></tr><tr><td>LineNumberInputStream(已弃用)</td><td>LineNumberReader</td></tr><tr><td>StreamTokenizer</td><td>StreamTokenizer（使用接受Reader的构造器）</td></tr><tr><td>PushBackInputStream</td><td>PushBackReader</td></tr></tbody></table><p>有一点很清楚，无论何时使用readLine(),都不应该使用DataInputStream(这会遭到编译器的强烈反对)，而应该使用BufferedReader,除了这一点，DataInputStream仍是I/O的首先成员</p><p>为了更容易过渡到使用PrintWriter,它提供了既能接受Writer对象又能接受任何OutputStream对象的构造器，PrintWriter的格式化接口实际上与PrintStream相同<br>在java Se5中添加了PrintWriter构造器，以简化在将输出写入时的文件创建过程<br>有一种PrintWriter构造器还有一个选项，就是“自动执行清空”选项，如果构造器设置此选项，即每个println()执行之后，便会自动清空</p><h3 id="未发生变化的类"><a href="#未发生变化的类" class="headerlink" title="未发生变化的类"></a>未发生变化的类</h3><p>有一些类在java1.0和java 1.1之间则未做改变</p><h2 id="以下这些java1-0类在java1-1中没有相应类"><a href="#以下这些java1-0类在java1-1中没有相应类" class="headerlink" title="|以下这些java1.0类在java1.1中没有相应类|"></a>|以下这些java1.0类在java1.1中没有相应类|</h2><p>|DataOutStream|<br>|File|<br>RandomAccessFile|<br>SequenceInputStream|</p><h2 id="自我独立的类：RandomAccessFile"><a href="#自我独立的类：RandomAccessFile" class="headerlink" title="自我独立的类：RandomAccessFile"></a>自我独立的类：RandomAccessFile</h2><p>RandomAccessFile适用于由大小已知的记录组成的文件，所以我们可以使用seek()将记录从一处转移到另一处，然后读取或者修改记录，文件中记录的大小不一定相同，只要我们能够确定那些记录有多大以及它们在文件中的位置即可<br>RandomAccessFile不是InputStream或者OutputStream继承层次结构的一部分，除了实现DataInput和DateOutput（DataInputStream和DataOutputStream也实现了这两个接口）两个接口之外，他和这两个继承层次没什么关联，它甚至不使用InputStream和OutputStream类中已有的功能，它是完全独立的类，从头开始编写其所有的方法（大多是本地方法）这么做是因为RandomAccessFile拥有和别的I/O类型本质的不同的行为，因为我们可以在文件内向前或者向后移动，在任何情况下，它都是自我独立的，直接从Object继承<br>从本质上来说，RandomAccessFile的工作方式类似于把DataInputStream和DataOutputStream组合起来，还添加了一些地方，例如getFilePointer(),seek(),length()，另外，其构造器还接受第二个参数用来指示我们只是“随即读”（r）还是“既读又写”（rw）</p><h2 id="I-O流的典型用法"><a href="#I-O流的典型用法" class="headerlink" title="I/O流的典型用法"></a>I/O流的典型用法</h2><h3 id="缓冲输入文件"><a href="#缓冲输入文件" class="headerlink" title="缓冲输入文件"></a>缓冲输入文件</h3><p>如果想要打开一个文件用于字符输入，可以使用以String或File对象作为文件名的FileInputReader，为了提高速度，我们希望对那个文件可以缓冲，那么我们将所产生的引用传给一个BuffredReader构造器，由于BufferedReader也提供readLine()方法，所以这是我们最终的对象和进行读取的接口，当readLine()返回null的时候，你就达到了文件的结尾<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedInputFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">read</span> <span class="params">(String fileName)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        BufferedReader br=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(fileName));</span><br><span class="line">        String s;</span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>((s=br.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            sb.append(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.out.println(read(<span class="string">"BufferedInputFlie.java"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="从内存输入"><a href="#从内存输入" class="headerlink" title="从内存输入"></a>从内存输入</h3><p>下面的示例，从BufferedInputFile.read()读入的String结果被用来创建一个StringReader，然后调用read()每次读取一个字符，并将它发送到控制台<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryInput</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        StringReader in=<span class="keyword">new</span> StringReader(BufferedInputFile.read(<span class="string">"MemoryInput.java"</span>));</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">        <span class="keyword">while</span>((c=in.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>)c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~</span><br></pre></td></tr></table></figure></p><h3 id="格式化的内存输入"><a href="#格式化的内存输入" class="headerlink" title="格式化的内存输入"></a>格式化的内存输入</h3><p>要读取格式化数据，可以使用DataInputStream,它是一个面向字节的I/O类（不是面向字符的），因此我们必须使用InputStream类而不是Reader类，当然我们可以用InputStream以字节的形式读取任何数据（例如一个文件），不过，在这里我们使用的是字符串<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FormattedMemoryInput</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DataInputStream in = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">                    <span class="keyword">new</span> ByteArrayInputStream(</span><br><span class="line">                            BufferedInputFile.read(<span class="string">"FormattedMemoryInput.java"</span>).getBytes()</span><br><span class="line">                    ));</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                System.out.println((<span class="keyword">char</span>)in.readByte());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.err.println(<span class="string">"end of stream"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果我们一次一个字节地读取字符，那么任何字节的值都是合法的结果，因此返回值不能用来检测输入是否结束，相反，我们可以使用available()方法查看还有多少个可供存取的字符，下面这个例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEOF</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        DataInputStream in=<span class="keyword">new</span> DataInputStream(</span><br><span class="line">                <span class="keyword">new</span> ByteArrayInputStream(</span><br><span class="line">                        BufferedInputFile.read(<span class="string">"TestEOF.java"</span>).getBytes()</span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">while</span>(in.available()!=<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>) (in.read()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>注意，available()的工作方式会随着所读取的媒介类型的不同而有所不同</strong>，字面意思就是在没有阻塞的情况下所能读取的字节数，对于文件，这意味着整个文件，但是对于不同的类型的流，可能就不是这样，所以要谨慎使用<br>我们也可以通过捕获异常来检测输入的末尾，就像前一个例子，但是，使用异常进行流控制，被认为是对异常特性的错误使用</p><h3 id="基本的文件输出"><a href="#基本的文件输出" class="headerlink" title="基本的文件输出"></a>基本的文件输出</h3><p>FileWriter可以向文件写入数据，首先，创建一个与指定文件连接的FileWriter，通常我们会使用BufferedWriter将其包装起来用以缓冲输出（尝试移除此包装来感受对性能的影响——缓冲往往能够显著地添加I/O操作的性能），在本例，为了提供格式化机制，它被装饰成了PrintWriter，按照这种方式创建的数据文件可作为普通文本文件读取<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicFileOutput</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String file=<span class="string">"BasicFileOutput.out"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        BufferedReader in=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> StringReader(</span><br><span class="line">                <span class="keyword">new</span> BufferedInputFile().read(<span class="string">"BasicFileOutput.java"</span>)</span><br><span class="line">        ));</span><br><span class="line">        PrintWriter out=<span class="keyword">new</span> PrintWriter(</span><br><span class="line">          <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(file))</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">int</span> linecount=<span class="number">1</span>;</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span>((line=in.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            out.print(linecount++ +<span class="string">":"</span>+line);</span><br><span class="line">        &#125;</span><br><span class="line">        out.close();<span class="comment">//关闭流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个例子中当文本写入文件时，行号就会增加，注意并未使用到LineNumberInputStream，因为这个类没有太大帮助，所以我们没必要使用它<br>一旦读完输入数据流，readLine()就会返回null,<strong>我们可以看到要为out显示调用close()，如果我们不为所有的输出文件调用close()，就会发现缓冲区内容不会被刷新清空，那么它们也就不完整</strong></p><h4 id="文本文件输出的快捷方式"><a href="#文本文件输出的快捷方式" class="headerlink" title="文本文件输出的快捷方式"></a>文本文件输出的快捷方式</h4><p><strong>Java Se5在PrintWriter中添加了一个辅助构造器，使得你不必在每次希望创建文本文件并向其中写入时，都要执行后面所有的装饰工作</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PrintWriter out=<span class="keyword">new</span> PrintWriter(String fileName)</span><br></pre></td></tr></table></figure></p><p>你仍然使用了缓冲，只是你不必自己去实现，遗憾的是，其他常见的写入任务都没有这样的快捷方式，但是我们可以创建工具类来使得使用流变得更为简单</p><h3 id="存储和恢复数据"><a href="#存储和恢复数据" class="headerlink" title="存储和恢复数据"></a>存储和恢复数据</h3><p>PrintWriter可以对数据进行格式化，以便人们的阅读，但是为了输出可供另一个“流”恢复的数据，我们需要用到DataOutputStream写入数据和DataInputStream恢复数据，当然，这些流可以是任何形式，注意DataOutoutStream和DataInputStream是面向字节的，因此要使用InputStream和OutputStream<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StoringAndRecoveringData</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        DataOutputStream out=<span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> BufferedOutputStream(</span><br><span class="line">                <span class="keyword">new</span> FileOutputStream(<span class="string">"Data.txt"</span>)</span><br><span class="line">        ));</span><br><span class="line">        out.writeDouble(<span class="number">3.14159</span>);</span><br><span class="line">        out.writeUTF(<span class="string">"this is a Pi"</span>);</span><br><span class="line">        out.writeDouble(<span class="number">1.41413</span>);</span><br><span class="line">        out.writeUTF(<span class="string">"Square of pi"</span>);</span><br><span class="line">        out.close();</span><br><span class="line">        DataInputStream in=<span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                <span class="keyword">new</span> FileInputStream(<span class="string">"Data.txt"</span>)</span><br><span class="line">        ));</span><br><span class="line">        System.out.println(in.readDouble());</span><br><span class="line">        System.out.println(in.readUTF());</span><br><span class="line">        System.out.println(in.readDouble());</span><br><span class="line">        System.out.println(in.readUTF());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>如果我们使用DataOutputStream写入数据，Java保证我们可以使用DataInputStream准确地读取数据——无论读和写数据的平台多么不同</strong>这是有价值的，人们曾加花费大量的精力处理特定平台的数据问题，只要两个平台上都有Java，这个问题就不会再发生<br>当我们使用DataOutputStream时，写字符串并且让DataInputStream能够恢复它的唯一可靠的做法就是使用UTF-8编码，在上面的示例中是通过writeUTF()和readUTF()实现的，UTF-8是一种多字节格式，其编码长度更加实际使用的字符集会有所变化，UTF-8将ASCII字符编码成单一字节的形式，而非ASCII字符则编码成两个或三个字节，例如汉字字符，另外字符串的长度存储在UTF-8字符串的前两个字节中（所有也就能知道字符串最长能够保存的字符长度了），但是，writeUTF()和readUTF()使用的是适合于Java的变体，因此我们用一个非java的程序取用writeUTF()所写的字符串时，必须编写一些特殊代码才能正确读取字符串<br>有了DataOutputStream的各种write()方法，我们就可以将字符串和其他数据类型混合，并且可以很容易地使用DataInputStream来恢复它<br>但是为了保证所有的读方法都能够正常工作，我们必须知道流中数据所在的位置和类型，因为极有可能将保存的double数据当成char或者其他类型读取，这会产生问题，有两个解决办法</p><ol><li>为文件中的数据采用固定的格式，这种方式我们就能够确定每个位置上的数据类型是什么了</li><li>将数据的信息保存在文件中，以便能够对其进行解析以确定数据的存放位置<br>但是，对象化和XML可能是最容易存储和读取复杂数据结构的方式<h3 id="读写随机访问文件"><a href="#读写随机访问文件" class="headerlink" title="读写随机访问文件"></a>读写随机访问文件</h3>使用RandomAccessFile，类似组合使用了DataInputStream和DataOutStream(因为它实现了相同的接口：DataInput和DataOutput),并且我们还可以看到使用seek()可以在文件中到处移动，并修改文件中的某个值<br>在使用RandomAccessFile时，你必须知道文件的排版，这样才能正确地操作它，RandomAccessFile拥有读取基本类型和UTF-8字符串的各自具体方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingRandomAccessFile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String file=<span class="string">"rtest.txt"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        RandomAccessFile rf=<span class="keyword">new</span> RandomAccessFile(file,<span class="string">"r"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Value"</span>+i+<span class="string">":"</span>+rf.readDouble());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(rf.readUTF());</span><br><span class="line">        rf.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        RandomAccessFile rf=<span class="keyword">new</span> RandomAccessFile(file,<span class="string">"rw"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">            rf.writeDouble(i*<span class="number">1.414</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        rf.writeUTF(<span class="string">"end of the file"</span>);</span><br><span class="line">        rf.close();</span><br><span class="line">        display();</span><br><span class="line">        rf=<span class="keyword">new</span> RandomAccessFile(file,<span class="string">"w"</span>);</span><br><span class="line">        rf.seek(<span class="number">5</span>*<span class="number">8</span>);</span><br><span class="line">        rf.writeDouble(<span class="number">47.00001</span>);</span><br><span class="line">        rf.close();</span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="管道流"><a href="#管道流" class="headerlink" title="管道流"></a>管道流</h3><p>PipedInputStream,PipedOutputStream,PipedReader和PipedWriter管道流，它们的价值主要用于任务之间的通信</p><h2 id="文件读写的工具"><a href="#文件读写的工具" class="headerlink" title="文件读写的工具"></a>文件读写的工具</h2><p>一个很常见的程序化任务就是读取文件到内存，修改，然后再写出，Java I/O类库的问题之一就是：它需要编写相当多的代码去执行这些常用的操作——没有任何基本的帮助功能可以为我们做这一切，更糟糕的是，装饰器会使得要记住如何打开文件变成意见相当困难的事，因此，在我们的类库中添加帮助类就显得相当有意义，这样就很容易地为我们完成这些基本任务，Java Se5在PrintWriter中添加了方便的构造器，因此你可以很方便地打来一个文件进行写入操作，但是，还有很多其他的常见操作是你需要反复执行的，这就使得消除与这些任务相关联的重复代码就显得很有意义<br>我们看下面的一个示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextFile</span> <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">read</span><span class="params">(String fileName)</span></span>&#123;</span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BufferedReader br = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                    <span class="keyword">new</span> FileReader(fileName)</span><br><span class="line">            );</span><br><span class="line">           <span class="keyword">try</span>&#123;</span><br><span class="line">               String s;</span><br><span class="line">               <span class="keyword">while</span>((s=br.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                   sb.append(s);</span><br><span class="line">                   sb.append(<span class="string">"\n"</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">               br.close();</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String fileName,String text)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> File(fileName).getAbsoluteFile());</span><br><span class="line">            out.write(text);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TextFile</span><span class="params">(String fileName,String splitter)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(Arrays.asList(read(fileName).split(splitter)));</span><br><span class="line">        <span class="comment">//正则表达式 split()经常产生一个空字符在第一个位置</span></span><br><span class="line">        <span class="keyword">if</span>(get(<span class="number">0</span>)==<span class="string">""</span>)</span><br><span class="line">            remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TextFile</span><span class="params">(String fileName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(fileName,<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">write</span><span class="params">(String fileName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> File(fileName).getAbsoluteFile());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (String item : <span class="keyword">this</span>) &#123;</span><br><span class="line">                    out.print(item);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                out.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String file=read(<span class="string">"TextFile.java"</span>);</span><br><span class="line">        write(<span class="string">"test.txt"</span>,file);</span><br><span class="line">        TextFile text=<span class="keyword">new</span> TextFile(<span class="string">"test.txt"</span>);</span><br><span class="line">        text.write(<span class="string">"text2.txt"</span>);</span><br><span class="line">        TreeSet&lt;String&gt; words=<span class="keyword">new</span> TreeSet&lt;String&gt;(<span class="keyword">new</span> TextFile(<span class="string">"TextFile.java"</span>,<span class="string">"\n"</span>));</span><br><span class="line">        System.out.println(words.headSet(<span class="string">"a"</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="读取二进制文件"><a href="#读取二进制文件" class="headerlink" title="读取二进制文件"></a>读取二进制文件</h3><p>这个工具与TextFile类似，因为它简化了读取二进制文件的过程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryFile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] read(File file)<span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        BufferedInputStream in=<span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                <span class="keyword">new</span> FileInputStream(file)</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[in.available()];</span><br><span class="line">            in.read(data);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            in.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] read(String file)<span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> read(<span class="keyword">new</span> File(file));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="标准I-O"><a href="#标准I-O" class="headerlink" title="标准I/O"></a>标准I/O</h2><p>标准I/O这个术语参考的是Unix中“程序所使用的单一信息流”这个概念（在window及其他的操作系统中，也有相似形式的实现）程序的所有输入都可以来自于与标准输入，它的所有输出也可以发送到标准输出，以及所有的错误信息都可以发送到标准错误，<strong>标准I/O的意义在于：我们可以很容易地把程序串联起来，一个程序的标准输出可以成为另一个程序的标准输入</strong></p><h3 id="从标准输入中读取"><a href="#从标准输入中读取" class="headerlink" title="从标准输入中读取"></a>从标准输入中读取</h3><p>按照标准I/O模型，java提供了System.io,System.out.System.err,其中System.out，System.err已经事先被包装成PrintStream对象，System.in却是一个未经加工的InputStream,这意味尽管可以立即使用System.out和System.err，但是在读取System.in之前必须对其包装<br>通常我们会使用readLine()一次一行地读取输入，为此，我们将System.in包装成BufferedReader,这里需要使用InputStreamReader把System.in转换成Reader（适配器模式），下面的例子会直接回显你输入的每一行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Echo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        InputStreamReader inr=<span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line">        BufferedReader br=<span class="keyword">new</span> BufferedReader(inr);</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span>((s=br.readLine())!=<span class="keyword">null</span> &amp;&amp; s.length()!=<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//ctrl+z终止程序运行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="将System-out转换成PrintWriter"><a href="#将System-out转换成PrintWriter" class="headerlink" title="将System.out转换成PrintWriter"></a>将System.out转换成PrintWriter</h3><p>System.out是一个PrintStrem，而PrintStream是一个OutputStream，而PrintWriter可以接受一个OutputStream作为参数的构造器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeSystemOut</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        PrintWriter out =<span class="keyword">new</span> PrintWriter(System.out,<span class="keyword">true</span>);</span><br><span class="line">        out.println(<span class="string">"hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>重要的是构造器的第二个参数，将其设置成true，以便开启自动清空功能，否则，你可能看不到输出</p><h3 id="标准I-O的重定向"><a href="#标准I-O的重定向" class="headerlink" title="标准I/O的重定向"></a>标准I/O的重定向</h3><p><strong>java的System类提供了一些简单的静态方法调用，以允许我们对标准输入，输出，和错误I/O流进行重定向</strong><br>setIn(InputStream)<br>setOut(PrintStream)<br>setErr(printStream)<br>（使用场景之一）如果我们突然开始在显示器上创建大量输出，而这些输出滚动的太快以至于无法阅读时，重定向输出就显得极为有用，对于我们向重复测试某个特定用户的输入序列的命令行程序来说重定向输入就很有价值，下面演示了这个方法的使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Redirecting</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        PrintStream console=System.out;</span><br><span class="line">        BufferedInputStream in=<span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"Redirecting.java"</span>));</span><br><span class="line">        PrintStream out=<span class="keyword">new</span> PrintStream(<span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"test.out"</span>)));</span><br><span class="line">        System.setIn(in);</span><br><span class="line">        System.setOut(out);</span><br><span class="line">        System.setErr(out);</span><br><span class="line">        BufferedReader br= <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));<span class="comment">//这里就是上面的in变量</span></span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span>((s=br.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(s);<span class="comment">//将数据写入标准输出，标准输出已经被重新设置过了</span></span><br><span class="line">        &#125;</span><br><span class="line">        out.close();</span><br><span class="line">        System.setOut(console);<span class="comment">//在将原来的标准输出改回来</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的程序很有意思，首先我们先将原来的标准输出的引用用一个引用保存起来留待后面重新设置回来，System的标准输入输出的set方法可以改变成员原来的流，我们从这里也能看到一些事情，标准输入输出在java类库中的设计主要是为了和操作系统进行交互的（我的理解）</p><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>你经常会需要在java内部执行操作系统上的其他程序，并且要控制这些程序的输入和输出，Java类库提供了执行这些操作的类<br>一项常见的任务是运行程序，并将产生的输出发送到控制台<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OSExcuteException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OSExcuteException</span><span class="params">(String why)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(why);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OSExecute</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">command</span><span class="params">(String command)</span><span class="keyword">throws</span> OSExcuteException</span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> err=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Process process=<span class="keyword">new</span> ProcessBuilder(command.split(<span class="string">" "</span>)).start();</span><br><span class="line">            BufferedReader result=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(process.getOutputStream()));</span><br><span class="line">            String s;</span><br><span class="line">            <span class="keyword">while</span>((s=result.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">            BufferedReader errors=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(process.getErrorStream()));</span><br><span class="line">            <span class="keyword">while</span> ((s=errors.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">                err=<span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!command.startsWith(<span class="string">"CMD /C"</span>))&#123;</span><br><span class="line">                command(<span class="string">"CMD /C"</span>+command);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OSExcuteException(<span class="string">"Errors excuting:"</span>+command);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">~~~为了捕获程序执行时产生的标准输出流，你需要调用getOutputStream()，这是因为InputStream是我们可以从中读取信息的流</span><br><span class="line">~~~java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OsExecuteDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            OSExecute.command(<span class="string">"javap OsExecuteDemo"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="新I-O"><a href="#新I-O" class="headerlink" title="新I/O"></a>新I/O</h2><p>JDK1.4的java.nio.*包中引入了新的java I/O类库，其目的是为了提高速度，实际上，旧的I/O包已经使用nio重新实现过，以便充分利用这种速度提高，因此，即使我们不显式地使用nio编写代码，也能从中收益，速度的提高在文件I/O和网络I/O中都可能发生，我们这里只研究前者<br>速度的提高来自于所使用的结构更接近于操作系统执行I/O的方式，通道和缓冲器，<strong>我们可以把它们想像成一个“煤矿”，通道是一个包含数据（煤层）的矿藏，而缓冲器则是派送到矿藏的卡车</strong>，卡车载满煤炭而归，我们再从卡车上获取煤炭<strong>，也就是说，我们并没有直接和通道交互，我们只和缓冲器交互</strong>，并把缓冲区派送到通道，通道要么从缓冲器获取数据，要么向缓冲器发送数据<br><strong>唯一直接与通道打交道的缓冲区是ByteBuffer</strong>,也就是说，可以存储未加工字节的缓冲器，当我们查询JDK文档中的java.nio.ByteBuffer时，<strong>会发现它是相当基础的类，通过告知分配多少存储空间来创建一个ByteBuffer对象，并且还有一个方法选择集，用于以原始的自己形式或基本数据类型输出和读取数据，但是没有办法输出或读取对象，即使是字符串也不行</strong>，这种处理当然很低级，但是，因为这是大多数操作系统中更有效的映射<br>旧I/O类库中有三个类被修改了，用以产生FileChannel，这三个类便是FileOutputStream，FileInputStrea,RandomAccessFile，注意这些是字节操纵流，与底层的nio一致，Reader和Writer这种字符模式不能用以产生通道，但是java.io.channels,Channels类提供了实用方法，用以在通道中产生Reader和Writer<br>下面的代码演示了使用FileChannel和ByteBuffer的方式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetChannel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BSIZE=<span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        FileChannel fc=<span class="keyword">new</span> FileOutputStream(<span class="string">"data.txt"</span>).getChannel();</span><br><span class="line">        fc.write(ByteBuffer.wrap(<span class="string">"Somen text"</span>.getBytes()));</span><br><span class="line">        fc.close();</span><br><span class="line"></span><br><span class="line">        fc=<span class="keyword">new</span> RandomAccessFile(<span class="string">"data.txt"</span>,<span class="string">"rw"</span>).getChannel();</span><br><span class="line">        fc.position(fc.size());<span class="comment">//move to the end</span></span><br><span class="line">        fc.write(ByteBuffer.wrap(<span class="string">"Some more"</span>.getBytes()));</span><br><span class="line">        fc.close();</span><br><span class="line">        fc=<span class="keyword">new</span> FileInputStream(<span class="string">"data.txt"</span>).getChannel();</span><br><span class="line">        ByteBuffer bf=ByteBuffer.allocate(BSIZE);</span><br><span class="line">        fc.read(bf);</span><br><span class="line">        bf.flip();</span><br><span class="line">        <span class="keyword">while</span>(bf.hasRemaining())&#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>) bf.get());<span class="comment">//从ByteBuffer每次只读取一个字节</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>getChannel()产生一个FileChannel，可以向它传送一个用于读写的ByteBuffer<br>将数据存放于ByteBuffer的方法之一是，使用一种“put”方法直接对它们进行填充，填入一个或多个字节，或基本数据类型的值，不过，也可以向上面的例子中那样使用wrap()方法将已存在的字节数组“包装”到ByteBuffer,但如此，就不在复制底层的数组，而是把它作为所产生的ByteBuffer的存储器，我们称之为数组支持的ByteBuffer<br>allocate()是为ByteBuffer分配空间的，可以使用allocationDirect()以产生一个与操作系统更高耦合的“直接”缓冲器，但是，这种分配开销更大，并且其具体实现也随着操作系统的不同而不同，因此我们可以看看程序实际运行时获得直接缓冲器是否可以使我们在速度上获得优势<br><strong>一旦调用了read()来告知FileChannel向ByteBuffer存储字节，就必须调用缓冲器上的flip(),让缓冲器做好让别人读取字节的准备</strong>，如果我们打算使用缓冲器执行进一步的操作，我们也必须调用clear()来为每一个read()做好准备，下面是这些注意要点的示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelCopy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BSIZE=<span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args.length!=<span class="number">2</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"arguments i:sourcefile,destfile"</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        FileChannel in=<span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]).getChannel(),</span><br><span class="line">                    out=<span class="keyword">new</span> FileOutputStream(args[<span class="number">1</span>]).getChannel();</span><br><span class="line">        ByteBuffer buf=ByteBuffer.allocate(BSIZE);</span><br><span class="line">        <span class="keyword">while</span>(in.read(buf)!=-<span class="number">1</span>)&#123;</span><br><span class="line">            buf.flip();<span class="comment">//prepare for writing</span></span><br><span class="line">            out.write(buf);</span><br><span class="line">            buf.clear();<span class="comment">//prepare to reading</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上面的代码中可以看到，但FileChannel.read()返回“-1”的时候，表示我们已经达到了输入的末尾，每次read()操作之后，就会将数据输入到缓冲器中，flip()则是准备缓冲器以便它的信息可以由write()提取，write()操作之后，信息仍在缓冲器中，接着clear()操作则对所有的内部指针重新安排，以便缓冲器在另一个read()操作期间能够做好接收数据的准备<br>然而上面的那个程序并不是处理此类操作的理想方式，特殊的方法transferTo()和transferFrom()则允许我们将一个通道和另一个通道直接相连，看下面的简单示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferTo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args.length!=<span class="number">2</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"arguments i:sourcefile,destfile"</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        FileChannel in= <span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]).getChannel(),</span><br><span class="line">                out=<span class="keyword">new</span> FileOutputStream(args[<span class="number">1</span>]).getChannel();</span><br><span class="line">        in.transferTo(<span class="number">0</span>,in.size(),out);</span><br><span class="line">        <span class="comment">//or out.transferFrom(in,0，in.size());</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="转换数据"><a href="#转换数据" class="headerlink" title="转换数据"></a>转换数据</h3><p>回过头来看到GetChannel的程序就会发现，为了输出文件的信息，我们必须每次只读取一个字节的数据，然后将每个Byte类型强制转换成char类型，这种方式太过原始了——我们查看java.nio。CharBuffer这个类，将会发现它有一个toString（）方法时这样定义的“返回一个包含缓冲器中所有字符的字符串”，既然ByteBuffer可以看做是具有asCharBuffer()方法的CharBuffer，那么为什么不用它呢？看下面这个例子，如输出语句的第一行所见，这种方式并不能解决问题<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferToText</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  BSIZE=<span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        FileChannel fc=<span class="keyword">new</span> FileOutputStream(<span class="string">"data2.text"</span>).getChannel();</span><br><span class="line">        fc.write(ByteBuffer.wrap(<span class="string">"some text"</span>.getBytes()));</span><br><span class="line">        fc.close();</span><br><span class="line">        fc=<span class="keyword">new</span> FileInputStream(<span class="string">"data2.text"</span>).getChannel();</span><br><span class="line">        ByteBuffer buff=ByteBuffer.allocate(BSIZE);</span><br><span class="line">        fc.read(buff);</span><br><span class="line">        buff.flip();</span><br><span class="line">        <span class="comment">//doesn't work</span></span><br><span class="line">        System.out.println(buff.asCharBuffer());</span><br><span class="line">        <span class="comment">//decode using this.system default charset</span></span><br><span class="line">        buff.rewind();<span class="comment">//</span></span><br><span class="line">        String encoding=System.getProperty(<span class="string">"file.encoding"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Decoded using"</span>+encoding+ Charset.forName(encoding).decode(buff));</span><br><span class="line">        <span class="comment">//or wo could encode with something that will print</span></span><br><span class="line">        fc=<span class="keyword">new</span> FileOutputStream(<span class="string">"data2.text"</span>).getChannel();</span><br><span class="line">        fc.write(ByteBuffer.wrap(<span class="string">"Some text"</span>.getBytes(<span class="string">"UTF-16BE"</span>)));</span><br><span class="line">        fc.close();</span><br><span class="line">        <span class="comment">//now try read again</span></span><br><span class="line">        fc=<span class="keyword">new</span> FileInputStream(<span class="string">"data2.text"</span>).getChannel();</span><br><span class="line">        buff.clear();</span><br><span class="line">        fc.read(buff);</span><br><span class="line">        buff.flip();</span><br><span class="line">        System.out.println(buff.asCharBuffer());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ues a CharBuffer  to write through</span></span><br><span class="line">        fc=<span class="keyword">new</span> FileOutputStream(<span class="string">"data2.text"</span>).getChannel();</span><br><span class="line">        buff=ByteBuffer.allocate(<span class="number">24</span>);<span class="comment">//more than needed</span></span><br><span class="line">        buff.asCharBuffer().put(<span class="string">"some text"</span>);</span><br><span class="line">        fc.write(buff);</span><br><span class="line">        fc.close();</span><br><span class="line">        <span class="comment">//read an display</span></span><br><span class="line">        fc=<span class="keyword">new</span> FileInputStream(<span class="string">"data.text"</span>).getChannel();</span><br><span class="line">        buff.clear();</span><br><span class="line">        fc.read(buff);</span><br><span class="line">        buff.flip();</span><br><span class="line">        System.out.println(buff.asCharBuffer());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>缓冲器容纳的是普通的字节，为了把它们转换成字符，我们要么在输入它们的时候对其进行编码（这样，它们的输出才具有意义），要么在将其从缓冲器输出时对它们进行解码，可以使用java.nio.charset.Charset类实现这些功能，该类提供了把数据编码成各种不同类型的字符集的工具<br>如果我们想要对缓冲器调用rewind()方法（调用这个方法是为了返回数据开始的地方），接着使用平台的默认字符集对数据进行decode()，那么作为结果的CharBuffer可以很好地输出打印到控制台，可以使用System.getProperty(“file.encoding”)发现默认字符集，它会产生代表字符集名称的字符串，把该字符串传送给Charset.forName()用以产生Charset对象，可以用它对字符串进行解码<br>另一个选择是在读该文件的时候，使用能够产生可打印的输出的字符集进行encode()，正如在BufferToText.java中看到的那样，这里，UTF-16BE可以把文本写进文件中，当读取时，我们只需把它转换成CharBuffer，就会产生所期望的文本、<br>最后，让我们看看若是通过CharBuffer向ByteBugffer写入，会发生什么情况，注意我们为ByteBuffer分配了24个字节，既然一个字符需要两个字节，那么一个ByteBuffer足可以容纳12个字符，，但是“some text”只要9个字符，剩余的内容为零的字节仍然由它的tString()所产生的CharBuffer的表示中<br>这样来理解，当我们将数据转换为Byte数组的时候，我们实际上是将这些字符串通过系统默认的方式来进行解码的，当然我们再拿到这些数据的时候，也要以相应的字符集来解码才能得到正确的结果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AvailableCharSets</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SortedMap&lt;String,Charset&gt; charSets=Charset.availableCharsets();</span><br><span class="line">        Iterator&lt;String&gt; it=charSets.keySet().iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            String csName=it.next();</span><br><span class="line">            System.out.print(csName);</span><br><span class="line">            Iterator aliases=charSets.get(csName).aliases().iterator();</span><br><span class="line">            <span class="keyword">if</span>(aliases.hasNext())&#123;</span><br><span class="line">                System.out.print(<span class="string">":"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(aliases.hasNext())&#123;</span><br><span class="line">                System.out.print(aliases.next());<span class="comment">//在这里也说明了迭代器的指针只有在next()方法调用之后才会发生变化</span></span><br><span class="line">                <span class="keyword">if</span>(aliases.hasNext())&#123;</span><br><span class="line">                    System.out.print(<span class="string">", "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码输出的就是java支持的字符集有哪些，关键的代码是Charset.availableCharsets()方法，返回一个Map&lt;String,Charset&gt;关联数组;</p><h3 id="获取基本类型"><a href="#获取基本类型" class="headerlink" title="获取基本类型"></a>获取基本类型</h3><p>虽然ByteBuffer只能保存字节类型的数据，但是它具有可以从其所容纳的字节中产生出不同的基本类型值的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BSIZE=<span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ByteBuffer bb=ByteBuffer.allocate(BSIZE);</span><br><span class="line">        <span class="comment">//allocation automatically zeroes the ByteBuffer;</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i++&lt;bb.limit())&#123;</span><br><span class="line">            <span class="keyword">if</span>(bb.get()!=<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.print(<span class="string">"nozero"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">"i="</span>+i);</span><br><span class="line">        bb.rewind();</span><br><span class="line">        <span class="comment">//store and read char array</span></span><br><span class="line">        bb.asCharBuffer().put(<span class="string">"howdy"</span>);</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="keyword">while</span>((c= bb.getChar())!=<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.print(c+<span class="string">"  "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        bb.rewind();</span><br><span class="line">        <span class="comment">//store and read a short</span></span><br><span class="line">        bb.asShortBuffer().put((<span class="keyword">short</span>)<span class="number">41411</span>);</span><br><span class="line">        System.out.print(bb.getShort());</span><br><span class="line">        bb.rewind();</span><br><span class="line">        <span class="comment">//store and read a int;</span></span><br><span class="line">        bb.asIntBuffer().put(<span class="number">193972342</span>);</span><br><span class="line">        System.out.print(bb.getInt());</span><br><span class="line">        <span class="comment">//.......................</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在分配一个ByteBuffer之后，可以通过检测它的值来查看缓冲器的分配方式是否将其内容自动清零——它确实是这样做了<br><strong>向缓冲器插入基本类型数据的最简单的方法是：利用asCharBuffer()，asShortBuffer()等获得该缓冲器的一个视图</strong>，然后利用试图的put()方法，取出数据是调用相应的get()方法即可</p><h3 id="视图缓冲器"><a href="#视图缓冲器" class="headerlink" title="视图缓冲器"></a>视图缓冲器</h3><p><strong>视图缓冲器（view buffer）可以让我们通过某个特定的基本数据类型的视窗查看其底层的ByteBuffer,ByteBuffer依然是实际存储数据的地方</strong>，对视图的修改都会映射成为对ByteBuffer中数据的修改，这使得我们可以很方便地向ByteBuffer插入数据，试图还允许我们从ByteBuffer一次一个地（与ByteBuffer所支持的方法相同）或者成批地（放入数组中）读取基本类型值，下面这个例子，通过IntBuffer操作ByteBuffer中的int型视图<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntBufferDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BSIZE=<span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ByteBuffer bb= ByteBuffer.allocate(BSIZE);</span><br><span class="line">        IntBuffer ib=bb.asIntBuffer();</span><br><span class="line">        ib.put(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">11</span>,<span class="number">42</span>,<span class="number">33</span>,<span class="number">45</span>,<span class="number">25</span>,<span class="number">24</span>,<span class="number">4354</span>,<span class="number">34</span>&#125;);</span><br><span class="line">        <span class="comment">//absolute location read and write</span></span><br><span class="line">        System.out.print(ib.get(<span class="number">3</span>));</span><br><span class="line">        ib.put(<span class="number">3</span>,<span class="number">1811</span>);</span><br><span class="line">        ib.flip();</span><br><span class="line">        <span class="keyword">while</span>(ib.hasRemaining())&#123;</span><br><span class="line">            <span class="keyword">int</span> i=ib.get();</span><br><span class="line">            System.out.print(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一旦底层的ByteBuffer通过视图缓冲器填满了整数或者其他的基本类型时，就可以直接被写到通道中了，正像从通道中读取那样容易，然后使用视图缓冲器可以把任何数据都转换成某一特定的基本类型，下面的例子，通过在同一个ByteBuffer上建立不同的视图缓冲器，将同一字节序列翻译成了short,int,float和double类型的数据<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewBuffer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ByteBuffer bb= ByteBuffer.wrap(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="string">'a'</span>&#125;);</span><br><span class="line">        bb.rewind();</span><br><span class="line">        System.out.print(<span class="string">"Byte buffer"</span>);</span><br><span class="line">        <span class="keyword">while</span>(bb.hasRemaining())&#123;</span><br><span class="line">            System.out.print(bb.position()+<span class="string">"-&gt;"</span>+bb.get());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        CharBuffer cb=((ByteBuffer)(bb.rewind())).asCharBuffer();</span><br><span class="line">        System.out.print(<span class="string">"Char Buffer"</span>);</span><br><span class="line">        <span class="keyword">while</span>(cb.hasRemaining())&#123;</span><br><span class="line">            System.out.print(cb.position()+<span class="string">"-&gt;"</span>+cb.get());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//...................</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>###$ 字节存放次序 ####<br>不同的机器可能会使得不同的字节排序方法来存储数据，“big endian”(高位优先)将最重要的字节存放在地址最低的存储单元，而“little endian”（低位优先），则是将最重要的字节放在地址最高的存储器单元，当存储量大于1个字节的时候，就要考虑字节的顺序问题了，ByteBuffer是以高位优先的形式存储数据的，并且数据在网上传送时也常常使用高位优先的形式，我们也可以使用ByteOrder.GIG_ENDISN或ByteOrder.LITTLE_EBDIAN的order()方法改变ByteBuffer的字节排序方式</p><h3 id="用缓冲器操纵数据"><a href="#用缓冲器操纵数据" class="headerlink" title="用缓冲器操纵数据"></a>用缓冲器操纵数据</h3><p>我们怎么把字节数组写到文件中去的呢？我们可以使用ByteBuffer.warp()方法将数组包装起来，然后用getChannel方法在fileOutputStream上打开一个通道，接着将来自于ByteBuffer的数据写到FileChannel中<br>注意，<strong>ByteBuffer是将数据移进移出的唯一方式</strong>，并且我们只能创建一个独立的基本类型缓冲器，或者使用“as”方法从ByteBuffer中获得，也就是说，我们不能把基本类型的缓冲器转换为ByteBuffer，然而，由于我们可以经由视图缓冲器将基本类型数据移进移出ByteBuffer，所以这也不是什么真正的限制了</p><h3 id="缓冲器的细节"><a href="#缓冲器的细节" class="headerlink" title="缓冲器的细节"></a>缓冲器的细节</h3><p>**Buffer由数据和可以高效地访问及操纵这些数据的四个索引组成，这四个索引是：mark(标记)，position（位置），limit（界限）和capacity（容量），下面是用于设置和复位索引以及查询它们值的方法</p><table><thead><tr><th></th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>capacity()</td><td>返回缓冲区容量</td></tr><tr><td>clear()</td><td>清空缓冲区，将position设为0，limit设置为容量，我们可以调用此方法复写缓冲区</td></tr><tr><td>flip()</td><td>将limit设置诶position，position设置为0，此方法用于准备从缓冲区读写已经写入的数据</td></tr><tr><td>limit()</td><td>返回limit的值</td></tr><tr><td>limit(int lim)</td><td>设置limit的值</td></tr><tr><td>mark()</td><td>将mark设置为position</td></tr><tr><td>position()</td><td>返回position的值</td></tr><tr><td>position(int pos)</td><td>设置position</td></tr><tr><td>ramaining()</td><td>返回（limit-position）</td></tr><tr><td>hasRemaining()</td><td>若有介于position和limit之间的元素，则返回true</td></tr></tbody></table><p>在缓冲器中插入和提取数据的方法会更新这些索引，用于反映所发生的变化<br>下面的示例用了一个很简单的算法（交换相邻字符），以对CharBuffer中的字符进行编码(scramble)和译码(unscramble)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingBuffers</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">symmetricScramble</span><span class="params">(CharBuffer buff)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(buff.hasRemaining())&#123;</span><br><span class="line">            <span class="keyword">char</span> c1=buff.get();</span><br><span class="line">            <span class="keyword">char</span> c2=buff.get();</span><br><span class="line">            buff.reset();</span><br><span class="line">            buff.put(c2).put(c1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] data=<span class="string">"UsingBuffers"</span>.toCharArray();</span><br><span class="line">        ByteBuffer bb=ByteBuffer.allocate(data.length*<span class="number">2</span>);</span><br><span class="line">        CharBuffer cb=bb.asCharBuffer();</span><br><span class="line">        cb.put(data);</span><br><span class="line">        System.out.print(cb.rewind());</span><br><span class="line">        symmetricScramble(cb);</span><br><span class="line">        System.out.print(cb.rewind());</span><br><span class="line">        symmetricScramble(cb);</span><br><span class="line">        System.out.print(cb.rewind());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果了解到Buffer类（ByteBuffer,CharBuffer等）的内存及索引控制机制，那么对于Buffer类的读写问题变的很简单，首先当我们创建Buffer类时，pos指针为0，lim指针和cap指针指向最后一个元素，<strong>进行相对的get()和put()方法调用是，pos指针会发生变化，注意，如果调用绝对的get()和put()方法pos指针不会发生变化</strong>，当我们开始循环迭代的时候，mar指针会记下当前的pos指针所在的位置，这个mar本来就是作为标记存在的，<strong>当调用reset()方法的时候，pos将会改变为mar的值</strong>，还有一点需要注意的是，<strong>如果打印缓冲器，只能打印limit和position之间的内容，因此如果要显示缓冲器的全部内容，必须使用rewind()把position设置成缓冲器开始位置</strong></p><h3 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h3><p>内存映射文件允许我们创建和修改那些因为太大而不能放入内存的文件，有了内存映射文件，我们就可以假定整个文件都放在了内存中，而且可以完全把它当作非常大的数组来访问，这种方法极大地简化了用于修改文件的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LargeMeppedFiles</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> length=<span class="number">0x8FFFFFF</span>;<span class="comment">//128M</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        MappedByteBuffer out=<span class="keyword">new</span> RandomAccessFile(<span class="string">"test.dat"</span>,<span class="string">"rw"</span>).getChannel().map(</span><br><span class="line">                FileChannel.MapMode.READ_WRITE,<span class="number">0</span>,length</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            out.put((<span class="keyword">byte</span>)<span class="string">'x'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Finished writing"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=length/<span class="number">2</span>;i&lt;length/<span class="number">2</span>+<span class="number">6</span>;i++)&#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>)out.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们通过通道调用map()产生MappedByteBuffer,这是一种特殊类型的直接缓冲器，<strong>注意，我们必须指定映射文件最初的位置和映射区域的长度，这意味着我们可以映射某个大文件的较小部分</strong><br>MppedByteBuffer由ByteBuffer继承而来，因此它具有ByteBuffer的所有方法，这里我们仅仅展示了简单的get()和set()方法，但是我们同样可以是asCharBuffer()等这样的方法</p><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>尽管“旧”的I/O流在用nio实现后性能有所提高，但是“映射文件访问”往往可以更加显著地加快速度<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MappedIO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> numofInts=<span class="number">4000000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> numofubuffInts=<span class="number">2000000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Tester</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Tester</span><span class="params">(String name)</span></span>&#123;name=name;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(name+<span class="string">":"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> start=System.nanoTime();</span><br><span class="line">                test();</span><br><span class="line">                <span class="keyword">long</span> end=System.nanoTime();</span><br><span class="line">                System.out.format(<span class="string">"%.2f\n"</span>,(end-start)/<span class="number">1.0e9</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span><span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//测试组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Tester[] tests=&#123;</span><br><span class="line">      <span class="keyword">new</span> Tester(<span class="string">"Stream Write"</span>)&#123;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">              DataOutputStream dos=<span class="keyword">new</span> DataOutputStream(</span><br><span class="line">                <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(</span><br><span class="line">                        <span class="keyword">new</span> File(<span class="string">"temp.tmp"</span>)</span><br><span class="line">                ))</span><br><span class="line">              );</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; ,</span><br><span class="line">      <span class="keyword">new</span> Tester(<span class="string">"Mapped write"</span>)&#123;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">              FileChannel fc=<span class="keyword">new</span> RandomAccessFile(<span class="string">"temp.tmp"</span>,<span class="string">"rw"</span>).getChannel();</span><br><span class="line">              IntBuffer buff=fc.map(FileChannel.MapMode.READ_WRITE,<span class="number">0</span>,numofInts).asIntBuffer();</span><br><span class="line">              <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numofInts;i++)&#123;</span><br><span class="line">                  buff.put(i);</span><br><span class="line">              &#125;</span><br><span class="line">              fc.close();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; ,</span><br><span class="line">      <span class="keyword">new</span> Tester(<span class="string">"Stream read"</span>)&#123;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">              DataInputStream in=<span class="keyword">new</span> DataInputStream(</span><br><span class="line">                      <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                              <span class="keyword">new</span> FileInputStream(<span class="string">"temp.tmp"</span>)));</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numofInts;i++)&#123;</span><br><span class="line">              in.readInt();</span><br><span class="line">          &#125;</span><br><span class="line">          in.close();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">new</span> Tester(<span class="string">"Mapped read"</span>)&#123;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">              FileChannel fc=<span class="keyword">new</span> FileInputStream(<span class="string">"temp.tmp"</span>).getChannel();</span><br><span class="line">              IntBuffer buff=fc.map(FileChannel.MapMode.READ_ONLY,<span class="number">0</span>,fc.size()).asIntBuffer();</span><br><span class="line">              <span class="keyword">while</span>(buff.hasRemaining())&#123;</span><br><span class="line">                  buff.get();</span><br><span class="line">              &#125;</span><br><span class="line">              fc.close();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">new</span> Tester(<span class="string">"Stream Read/Write"</span>)&#123;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">             RandomAccessFile raf=<span class="keyword">new</span> RandomAccessFile(<span class="string">"temp.tmp"</span>,<span class="string">"rw"</span>);</span><br><span class="line">             raf.writeInt(<span class="number">1</span>);</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numofubuffInts;i++)&#123;</span><br><span class="line">                 raf.seek(raf.length()-<span class="number">4</span>);</span><br><span class="line">                 raf.writeInt(raf.readInt());</span><br><span class="line">             &#125;</span><br><span class="line">             raf.close();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">new</span> Tester(<span class="string">"Mapped Read/write"</span>)&#123;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">              FileChannel fc=<span class="keyword">new</span> RandomAccessFile(<span class="string">"temp.tmp"</span>,<span class="string">"rw"</span>).getChannel();</span><br><span class="line">              IntBuffer buff=fc.map(FileChannel.MapMode.READ_WRITE,<span class="number">0</span>,fc.size()).asIntBuffer();</span><br><span class="line">              <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numofubuffInts;i++)&#123;</span><br><span class="line">                  buff.put(buff.get(i-<span class="number">1</span>));</span><br><span class="line">              &#125;</span><br><span class="line">              fc.close();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Tester tester:tests)&#123;</span><br><span class="line">            tester.runTest();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行上述代码结果会发现“映射写”似乎要使用FileOutputSream。但是映射文件的所有输出使用RandomAccessFile性能更好<br>我们一般建议使用映射进行文件的读写性能更好，即使建立这样的代码代价会稍大</p><h3 id="文件加锁"><a href="#文件加锁" class="headerlink" title="文件加锁"></a>文件加锁</h3><p><strong>文件加锁机制，它允许我们同步访问作为共享资源的文件</strong>，不过，竞争同一文件的两个线程可能在不同的java虚拟机上，或者一个是java进程，另一个是操作系统的其他本地进程，<strong>文件锁对其他的操作系统进程是可见的，因为java的文件加锁直接映射到了本地操作系统的加锁工具</strong><br>下面是一个关于文件加锁的简单例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileLocking</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        FileOutputStream fos=<span class="keyword">new</span> FileOutputStream(<span class="string">"file.txt"</span>);</span><br><span class="line">        FileLock fl=fos.getChannel().tryLock();</span><br><span class="line">        <span class="keyword">if</span>(fl!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"locked file"</span>);</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">            fl.release();</span><br><span class="line">            System.out.println(<span class="string">"Release Lock"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过对FileChannel调用tryLock()或lock()，就可以获得整个文件的FileLock（SocketChannel,DatagramChannel和ServerSocketChannel不需要加锁，因为它们是从单进程实体继承而来，我们通常不再两个进程之间共享网络socket）<br>tryLock()是非阻塞的，它设法获取锁，但是如果不能获得（当其他一些进程以及持有相同的锁，并且不共享时），它将直接返回<br>lock()是阻塞式的，它要阻塞进程直至获得锁可以获得<br>也可以使用下面的方法对文件的一部分上锁<br>    tryLock(long position,long size,boolean shared)<br>或<br>    lock(long position,long size,boolean shared)<br>其中的加锁区域有size-position决定，第三个参数指定是否是共享锁<br>无参数的加锁方式将根据文件的尺寸的变化而变化，但是具有固定尺寸的锁不随文件尺寸的变化而变化，也就是说，如果你获得了某一区域上的锁，当文件增大超出position+size时，那么超出的部分不会被锁定，无参数的加锁是对整个文件加锁，即使文件增大也是如此<br>对独占锁或者共享锁的支持必须由底层的操作系统提供，如果操作系统不支持共享锁并为每一请求都创建一个锁，那么它就会使用独占锁，锁的类型（独占或者共享）可以通过FileLock.isShared()进行查询</p><h4 id="对映射文件的部分加锁"><a href="#对映射文件的部分加锁" class="headerlink" title="对映射文件的部分加锁"></a>对映射文件的部分加锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockingMappedFiles</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LENGTH=<span class="number">0x8FFFFFF</span>;<span class="comment">//128M</span></span><br><span class="line">    <span class="keyword">static</span> FileChannel fc;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        fc=<span class="keyword">new</span> RandomAccessFile(<span class="string">"text.dat"</span>,<span class="string">"rw"</span>).getChannel();</span><br><span class="line">        MappedByteBuffer out=fc.map(FileChannel.MapMode.READ_WRITE,<span class="number">0</span>,LENGTH);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;LENGTH;i++)&#123;</span><br><span class="line">            out.put((<span class="keyword">byte</span>) <span class="string">'x'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> LockAndModify(out,<span class="number">0</span>,LENGTH/<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">new</span> LockAndModify(out, LENGTH/<span class="number">2</span>,LENGTH/<span class="number">2</span>+LENGTH/<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LockAndModify</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> ByteBuffer buff;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> start,end;</span><br><span class="line">        LockAndModify(ByteBuffer buff,<span class="keyword">int</span> start,<span class="keyword">int</span> end)&#123;</span><br><span class="line">            <span class="keyword">this</span>.buff=buff;</span><br><span class="line">            <span class="keyword">this</span>.start=start;</span><br><span class="line">            buff.limit(end);</span><br><span class="line">            buff.position(start);</span><br><span class="line">            <span class="keyword">this</span>.buff=buff.slice();</span><br><span class="line">            start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                FileLock fl = fc.lock(start, end, <span class="keyword">false</span>);</span><br><span class="line">                System.out.println(<span class="string">"locked"</span>+start+<span class="string">"to"</span>+end);</span><br><span class="line">                <span class="keyword">while</span>(buff.position()&lt;buff.limit()-<span class="number">1</span>)&#123;</span><br><span class="line">                    buff.put((<span class="keyword">byte</span>)(buff.get()+<span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                fl.release();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><p>java I/O类型支持读写压缩格式的数据流，你可以使用它们对其他I/O类进行封装，以提供压缩功能<br>这些类都不是从Reader和Writer类派生而来，而是属于InputStream和OtputStream继承层次结构的一部分，这样做是因为压缩类库是按字节方式而不是字符方式处理的，不过有时我们可能需要被迫要混合使用着两种类型的数据流（注意我们可以使用InputStreamReader和OutputStreamWriter在两种类型之间方便地进行转换）</p><table><thead><tr><th></th><th>压缩类</th><th>功能</th></tr></thead><tbody><tr><td>CheckedInputStream</td><td>getCheckSum()为任何InputStream产生效验和（不仅是解压缩）</td></tr><tr><td>CheckedOutputStream</td><td>getCheckSum()为任何OutputStream产生效验和（不仅是压缩）</td></tr><tr><td>DeflaterOutputStream</td><td>压缩类的基类</td></tr><tr><td>ZipOutputStream</td><td>一个DeflaterOutputStream，用于将数据压缩成Zip文件格式</td></tr><tr><td>GZIPOutputStream</td><td>一个DeflaterOutputStream，用于将数据压缩成GZip文件格式</td></tr><tr><td>InflaterInputStream</td><td>解压缩类的基类</td></tr><tr><td>ZipInputStream</td><td>一个InflaterInputStream，用于解压缩Zip文件格式的数据</td></tr><tr><td>GZIPInputStream</td><td>一个InflaterInputStream，用于解压缩GZip文件格式的数据</td></tr></tbody></table><h3 id="用GZIP进行简单压缩"><a href="#用GZIP进行简单压缩" class="headerlink" title="用GZIP进行简单压缩"></a>用GZIP进行简单压缩</h3><p>GZIP接口非常简单，如果我们只想对单个数据流（而不是一系列互异数据）进行压缩，那么它可能是比较合适的选择，下面是对单个文件进行压缩的例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GZIPCompress</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args.length==<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(</span><br><span class="line">                    <span class="string">"usage:\nGIZPcompress file\n"</span>+</span><br><span class="line">                     <span class="string">"\tUses GZIP compression to compress"</span>+</span><br><span class="line">                     <span class="string">"the file to test.gz"</span></span><br><span class="line">            );</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        BufferedReader in=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"args[0]"</span>));</span><br><span class="line">        BufferedOutputStream out=<span class="keyword">new</span> BufferedOutputStream(</span><br><span class="line">                <span class="keyword">new</span> GZIPOutputStream(</span><br><span class="line">                        <span class="keyword">new</span> FileOutputStream(<span class="string">"test.gz"</span>)</span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">        <span class="keyword">while</span>((c=in.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            out.write(c);</span><br><span class="line">        &#125;</span><br><span class="line">        in.close();</span><br><span class="line">        out.close();</span><br><span class="line">        System.out.println(<span class="string">"reading file"</span>);</span><br><span class="line"></span><br><span class="line">        BufferedReader in2=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(</span><br><span class="line">                <span class="keyword">new</span> GZIPInputStream(</span><br><span class="line">                        <span class="keyword">new</span> FileInputStream(<span class="string">"test.gz"</span>))));</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span>((s=in2.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>压缩类的使用非常直观，直接将输出流封装成GZIPOutputStream或ZIPOutputStream，并将输入流封装成GZIPInputStream或ZIPINputStream即可，其他的操作就是通常的I/O读写</p><h3 id="用Zip进行多文件保存"><a href="#用Zip进行多文件保存" class="headerlink" title="用Zip进行多文件保存"></a>用Zip进行多文件保存</h3><p>支持Zip格式的Java库更加全面，利用该库可以方便地保存多个文件，它甚至有一个独立的类，使得读取Zip文件更加方便，这个类库使用标准Zip格式，所有能与当前那些可通过因特网下载的压缩工具很好地协作，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZIpCompress</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        FileOutputStream f =<span class="keyword">new</span> FileOutputStream(<span class="string">"test.zip"</span>);</span><br><span class="line">        CheckedOutputStream csum=<span class="keyword">new</span> CheckedOutputStream(f,<span class="keyword">new</span> Adler32());</span><br><span class="line">        ZipOutputStream zos=<span class="keyword">new</span> ZipOutputStream(csum);</span><br><span class="line">        BufferedOutputStream out=<span class="keyword">new</span> BufferedOutputStream(zos);</span><br><span class="line">        zos.setComment(<span class="string">"A test of java Zipping"</span>);</span><br><span class="line">        <span class="keyword">for</span>(String arg:args)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Writing file"</span>+arg);</span><br><span class="line">            BufferedReader in=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(arg));</span><br><span class="line">            zos.putNextEntry(<span class="keyword">new</span> ZipEntry(arg));</span><br><span class="line">            <span class="keyword">int</span> c;</span><br><span class="line">            <span class="keyword">while</span>((c=in.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">                out.write(c);</span><br><span class="line">            &#125;</span><br><span class="line">            in.close();</span><br><span class="line">            out.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        out.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Checksum"</span>+csum.getChecksum().getValue());</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"Reading file"</span>);</span><br><span class="line">        FileInputStream fi=<span class="keyword">new</span> FileInputStream(<span class="string">"text.zip"</span>);</span><br><span class="line">        CheckedInputStream csum1=<span class="keyword">new</span> CheckedInputStream(fi,<span class="keyword">new</span> Adler32());</span><br><span class="line">        ZipInputStream in2=<span class="keyword">new</span> ZipInputStream(csum1);</span><br><span class="line">        BufferedInputStream bis=<span class="keyword">new</span> BufferedInputStream(in2);</span><br><span class="line">        ZipEntry ze;</span><br><span class="line">        <span class="keyword">while</span>((ze=in2.getNextEntry())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           System.out.println(<span class="string">"Reading file"</span>+ze);</span><br><span class="line">           <span class="keyword">int</span> x;</span><br><span class="line">           <span class="keyword">while</span>((x=bis.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">               System.out.println(x);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(args.length==<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Checksum"</span>+csum1.getChecksum().getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        bis.close();</span><br><span class="line">        ZipFile zf=<span class="keyword">new</span> ZipFile(<span class="string">"test.zip"</span>);</span><br><span class="line">        Enumeration e=zf.entries();</span><br><span class="line">        <span class="keyword">while</span>(e.hasMoreElements())&#123;</span><br><span class="line">            ZipEntry ze2=(ZipEntry) e.nextElement();</span><br><span class="line">            System.out.println(<span class="string">"File"</span>+ze2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码有几个注意的地方，使用Checksum类来计算和校验文件的校验和的方法，共有两种Checksum类型，Adler32(更快)和CRC32(慢一些，但更准确)<br>对于每个呀加人压缩档案的文件，必须调用PutNextEntry()，并将其传递给一个ZipEntry对象,ZipEntry对象包含一个功能很广泛的接口，允许你获取和设置Zip文件内该特定项上所有可利用的数据，包括：名字，压缩的和未压缩的文件大小，日期，CRC校验和，额外字段数据，注解，压缩方法以及它是否是一个目录入口等等，然后尽管Zip格式提供了设置密码的方式，但是java的Zip类库不提供这些方法的支持<br>为了能够解压缩文件，ZipInputStream提供了getNextEntry()方法返回下一个ZipEntry（如果存在的话），解压缩文件有个更简便的方法，使用ZipFile对象读取文件，该对象有一个entries()方法用来向ZipEntries返回一个Enumeration<br>为了读取校验和，必须拥有对与之相关联的Checksum的访问权限，在这里保留了CheckedOutputStream和CheckedInputStream对象的引用，但是，也可以值保留一个执行Checksum对象的引用<br>Zip流中有个令人困惑的方法setComment()，我们可以在写文件时写注释，但没有任何方法恢复ZipInpuStream内的注释，似乎只能通过ZipEntry才能以逐条方式完全支持注释的获取</p><h3 id="java档案文件"><a href="#java档案文件" class="headerlink" title="java档案文件"></a>java档案文件</h3><p>Zip格式也被应用于JAR(java ARchive java文档文件)文件格式中在，这种文件格式就像Zip一样，可以将一组文件压缩到单一压缩文件中<br>jar文件是跨平台的，jar文件非常有用，一次请求可以获取多个文件，因为压缩的原因使得传输时间也变得更短，而且还可以在每个条目上添加数字签名<br><strong>一个jar文件由一组压缩文件构成，同时还有一张描述所有文件的“文件清单”</strong>（可以自行创建文件清单，也可以由jar程序自动生成），在jdk文档中可以找到与Jar文件清单更多的资料<br>我们看下在命令行中如何使用jar程序</p><p>jar [options] destination [manifest] inputfile(s)<br>其中option只是一个字母集合（不必输入任何“-”或者其他任何标识符），以下是这些选项字符在Unix和Linux系统中的tar文件也具有相同的意义<br>|选项|功能说明|<br>——-|——–<br>c|创建一个新的或空的压缩文档<br>f|列出目录表<br>x|解压所有文件<br>x file|解压该文件<br>f|意指：“我打算指定一个文件名”，如果没有用这个选项，jar假设所有的输入都来自于标准输入<br>或者在创建一个文件时，输出对象也假设为标准输出<br>m|表示第一个参数将是用户自建的清单文件的名字<br>v|产生详细输出，描述jar所做的工作<br>O|只存储文件，不压缩文件（用来创建一个可放在类路径的Jar文档）<br>M|不自动创建文件清单</p><p>如果压缩到Jar文件的众多文件中包含多个子目录，那么该子目录会自动被添加到Jar文件中，且包括该子目录的所有子目录，路径信息也会被保留</p><h2 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h2><p>当你创建对象的时候，只要你需要，它就一致存在，但是在程序终止时，无论如何它都不会继续存在，尽管这么做是有意义的，但是仍然在某些情况下，如果对象能够在程序不运行的情况下继续存在并保存其信息，那就非常有用，当下次程序运行时，该对象被重建并拥有信息与上次运行它时的信息是相同的（当然，我们可以通过将信息写入文件或数据库达到同样的目的）<br>java的对象序列化将那些实现了Serializabel接口的对象转换成一个字节序列，并能够在以后将这个字节序列完全恢复为原来的对象，这一过程甚至可以通过网络进行，这意味着序列化能够自动弥补不同操作系统之间的差异，也就是说，可以在运行window系统的计算机上创建对象，将其序列化，通过网络将它发送给一台运行Unix系统的计算机，然后在那里准确地重新组装，而却不必担心数据在不同的机器上表示会不同<br>对象的序列化很有趣，因为利用它可以实现轻量级持久性，“持久性”意味着一个对象的生命周期不取决与程序是否正在执行，通过将一个持久化对象写入磁盘，然后在重新调用程序是恢复该对象，就能实现持久化的效果<br>对象必须在程序中显式地序列化（seialize）和反序列化还原（deserialize）（更严格的持久化机制，例如Hibernate或者MyBatis）<br>对象的序列化概念加入到语言中是为了支持两种主要特性<br>一是java的远程方法调用（Remote method invocation RMI）<strong>它使存活在其他计算机上的对象使用起来就像是存活于本机上一样，当向远程对象发送消息时，需要通过对象序列化来传输参数和返回值</strong><br>再者，对java Beans设计来说，对象的序列化也是必需，使用一个Bean时，一般情况下是在设计阶段对它的状态信息进行配置，这种状态信息必须保存下来，并在程序启动时进行后期恢复，这种具体工作也是由对象序列化完成的<br>只要对象实现类Serializable标记接口，对象的序列化就很简单，查看API可以看到标准类库中很多对象都实现了这个接口<br>如何序列化一个对象？<br>首先要创建某种OutpuStream，将其封在在ObjectOutputStream对象中，这时调用writeObject()即可将对象序列化，并将其发送给OutputStream（对象序列化是基于字节的，因要使用InputStream和OutputStream继承层次结构）将一个序列还原为一个对象，和往常一样，需要将InputStream封装到一个ObjectInputStream内，调用readObject()方法，获得一个指向根类Object的引用，所以必须向下转型才能设置它们<br>对象序列化特别“聪明”的地方是它不仅保存了对象的“全景图”，而且能追踪对象内所包含的所有引用，并保存那些对象，接着又能对对象内的每个这样的引用进行追踪，依此类推，这种情况被称为“对象网”<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Data</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n=n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> Integer.toString(n);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worm</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand= <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="keyword">private</span>  Data[] datas=<span class="keyword">new</span> Data[]&#123;</span><br><span class="line">           <span class="keyword">new</span> Data(rand.nextInt()),</span><br><span class="line">           <span class="keyword">new</span> Data(rand.nextInt()),</span><br><span class="line">           <span class="keyword">new</span> Data(rand.nextInt())</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">private</span> Worm next;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> c;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Worm</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">char</span> x)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"constructor:"</span>+i);</span><br><span class="line">        c=x;</span><br><span class="line">        <span class="keyword">if</span>(--i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">           next=<span class="keyword">new</span> Worm(i,(<span class="keyword">char</span>)(x+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Worm</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Default constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuilder result=<span class="keyword">new</span> StringBuilder(<span class="string">":"</span>);</span><br><span class="line">        result.append(c);</span><br><span class="line">        result.append(<span class="string">"("</span>);</span><br><span class="line">        <span class="keyword">for</span>(Data data:datas)&#123;</span><br><span class="line">            result.append(data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            result.append(next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException,ClassNotFoundException</span>&#123;</span><br><span class="line">        Worm w=<span class="keyword">new</span> Worm(<span class="number">6</span>,<span class="string">'a'</span>);</span><br><span class="line">        System.out.println(<span class="string">"w="</span>+w);</span><br><span class="line">        ObjectOutputStream out=<span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"worm.out"</span>));</span><br><span class="line">        out.writeObject(<span class="string">"Worm strorage\n"</span>);</span><br><span class="line">        out.writeObject(w);</span><br><span class="line">        out.close();</span><br><span class="line">        ObjectInputStream in=<span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span>  FileInputStream(<span class="string">"worm.out"</span>));</span><br><span class="line">        String s=(String) in.readObject();</span><br><span class="line">        Worm w2=(Worm)in.readObject();</span><br><span class="line">        System.out.println(s+<span class="string">"w2+"</span>+w2);</span><br><span class="line">        ByteArrayOutputStream bout=<span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream out2=<span class="keyword">new</span> ObjectOutputStream(bout);</span><br><span class="line">        out2.writeObject(<span class="string">"Worm storage\n"</span>);</span><br><span class="line">        out2.writeObject(w);</span><br><span class="line">        out.flush();</span><br><span class="line">        ObjectInputStream in2=<span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">                <span class="keyword">new</span> ByteArrayInputStream(bout.toByteArray()));</span><br><span class="line">        s=(String)in2.readObject();</span><br><span class="line">        Worm w3=(Worm)in2.readObject();</span><br><span class="line">        System.out.println(s+<span class="string">"w="</span>+w3);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行此程序可以看到，被还原的对象确实包含了原对象的所有链接（对象内的所有对象引用数组即下潜到最后一个对象（可以称为对象网或对象树））<br>对象的还原过程没有调用任何构造器，整个对象都是通过从InputStream中取得数据恢复而来的</p><h3 id="寻找类"><a href="#寻找类" class="headerlink" title="寻找类"></a>寻找类</h3><p>将一个对象从它的序列化状态中恢复出来，有那些工作是必须的呢？假如我们将一个对象序列化，并通过网络将其作为文件传送给另一台计算机，那么，另一台计算机上的程序可以只利用该文件内容来还原这个对象吗？答案是no<br>原因也很容易理解，对象的序列化数据中一点会有保留其类型的信息，所有在进行反序列化的时候吗，输出流一定会去获取这个对象序列化的类型信息，当知道了对象的类型之后，虚拟机将会在本地寻找其.class文件加载该Class,如果已经加载或能够在类路径下找到（找到之后加载），接下来的反序列化将会很容易的进行，但是如果找不到，就会抛出ClassNotFoundException异常，所有如果进行可靠的反序列化一定要在类路径下能找到该对象的字节码文件</p><h3 id="序列化的控制"><a href="#序列化的控制" class="headerlink" title="序列化的控制"></a>序列化的控制</h3><p>序列化可以进行更加细粒度的控制，例如，出于安全的考虑，你不希望对象的某一部分被序列化，或者一个对象被还原以后，某个子对象需要重新创建，从而不比将该子对象序列化<br>Externalizable接口——代替实现Serializable接口——来对序列化过程进行控制，这个Externalizable接口继承了Sericalizbale接口，同时也添加了两个方法，writeExternal()和readExternal()方法，这两个方法会在序列化和反序列化还原的过程中被自动调用以便执行一些特殊操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blip1</span> <span class="keyword">implements</span> <span class="title">Externalizable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Blip1</span><span class="params">()</span></span>&#123;<span class="comment">//构造器不是public</span></span><br><span class="line">        System.out.println(<span class="string">"Blip1 Constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Blip1.writeExternal"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Blip1.readExternal"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blip2</span> <span class="keyword">implements</span> <span class="title">Externalizable</span></span>&#123;</span><br><span class="line">    Blip2()&#123;</span><br><span class="line">        System.out.println(<span class="string">"Blip2 Constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Blip2 writeExrternal"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Blip2.readExternal"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Blips</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException,ClassNotFoundException</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"constructing Objeects:"</span>);</span><br><span class="line">        Blip1 b1=<span class="keyword">new</span> Blip1();</span><br><span class="line">        Blip2 b2=<span class="keyword">new</span> Blip2();</span><br><span class="line"></span><br><span class="line">        ObjectOutputStream out=<span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">                <span class="keyword">new</span> FileOutputStream(<span class="string">"Bilps.out"</span>));</span><br><span class="line">        System.out.println(<span class="string">"saving Objects"</span>);</span><br><span class="line">        out.writeObject(b1);</span><br><span class="line">        out.writeObject(b2);</span><br><span class="line">        out.close();</span><br><span class="line"></span><br><span class="line">        ObjectInputStream in=<span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">                <span class="keyword">new</span> FileInputStream(<span class="string">"Blips.out"</span>));</span><br><span class="line">        System.out.println(<span class="string">"recovering b1"</span>);</span><br><span class="line">        b1=(Blip1)in.readObject();</span><br><span class="line">        <span class="comment">//System.out.println("recovering b2");</span></span><br><span class="line">        <span class="comment">//b2=(Blip2)in.readObject();//因为Blip2的构造器不是公共的所以在恢复对象时会发发生异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的例子很简单，Blip1和Blip2都实现了Externalizable接口，并通过ObjectOutputStream和ObjectInputStream读写<br>关于Externalizable接口有一些需要注意的地方，当我们通过readObject恢复对象的时候，与Sericalizabel最大的不同是，对于Serializable对象，对象是完全以它的存储的二进制为基础来构造的，而不调用构造器，而对于一个EXternalizable对象，所有默认的构造器都会被调用（包括在字段定义是的初始化），然后才调用readExternalizabel(),必须注意一点的是——所有默认的构造器都会被调用，才能使Externalizable对象产生正确的行为，<br>看看上面的代码，Blip2和Blip1最大的不同是Blip2的构造器不是public的，因此在readObject()方法时，因为要调用Blip2的构造器，所以对于ObjectOutStream是没有访问权的，这里也能猜到，对对象构造器访问的代码一定会在readObject()方法的内部被调用了，这也能说明为什么Blips和Blip2同包，访问Blip2的构造器也会抛出异常，因为访问者是ObjectOutputStream而不是Blips，所以要想正确的被反序列（当然要反序列化，不然为什么要对对象进行序列化呢？ 哈哈）实现Externalizable接口的类的构造器一定要是public“公共的”<br>关于实现了Externalizable接口的对象是如何实现的序列化的，看看下面的一个示例就很清楚了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Blip3</span> <span class="keyword">implements</span> <span class="title">Externalizable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">private</span> String s;<span class="comment">//no Initialization</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Blip3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Blip3 constructor"</span>);</span><br><span class="line">        <span class="comment">//s,i not initialized</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Blip3</span><span class="params">(String x,<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Blip3(String x,int a)"</span>);</span><br><span class="line">        s=x;</span><br><span class="line">        i=a;</span><br><span class="line">        <span class="comment">//s &amp; i only  initialized in non-default constructor</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> s+i;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Blip3.writeExternal"</span>);</span><br><span class="line">        out.writeObject(s);</span><br><span class="line">        out.writeObject(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Blip3.readExternal"</span>);</span><br><span class="line">        s=(String) in.readObject();</span><br><span class="line">        i=(Integer)in.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException,ClassNotFoundException</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Constructing Objects:"</span>);</span><br><span class="line">        Blip3 b3=<span class="keyword">new</span> Blip3(<span class="string">"A String"</span>,<span class="number">47</span>);</span><br><span class="line">        System.out.println(b3);</span><br><span class="line">        ObjectOutputStream out=<span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">                <span class="keyword">new</span> FileOutputStream(<span class="string">"Blip3.out"</span>));</span><br><span class="line">        System.out.println(<span class="string">"Saving Objects"</span>);</span><br><span class="line">        out.writeObject(b3);</span><br><span class="line">        out.close();</span><br><span class="line">        ObjectInputStream in=<span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">                <span class="keyword">new</span> FileInputStream(<span class="string">"Blip3.out"</span>));</span><br><span class="line">        System.out.println(<span class="string">"recovering Objects"</span>);</span><br><span class="line">        b3=(Blip3) in.readObject();</span><br><span class="line">        System.out.println(b3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上面的示例中我们能够看到，实现了Externalizable接口的对象是如何实现序列化和反序列化的，当我们调用writeObject()方法的时候，ObjectOutputStream记录了对象的类型信息，之后调用writeExternal()方法，在writeExternal，我们可以任意的将关于对象的属性信息记录在ObjectOutputStream中（也就是说对象信息的保存可以个性化定制），这样关于这个对象的所有应该知道的信息，我们都保存了下来，当我们调用readObjetc()方法进行反序列化的时候，首先查看这个对象的类型信息，加载—&gt;调用默认构造器（创建实例对象）—&gt;调用readExternal（对象的属性进行初始化）<br>从这里我们也可以看出使用Externalizabel接口和Serializable接口的序列化和反序列化机制是不同的</p><h3 id="transient-瞬时-关键字"><a href="#transient-瞬时-关键字" class="headerlink" title="transient(瞬时)关键字"></a>transient(瞬时)关键字</h3><p>当我们对序列化进行控制时，可能某个特定子对象不想让java的序列化机制自动保存与恢复，如果子对象表示的是我们不希望将其序列化的敏感信息，即使对象中的这些信息是private属性，一经序列化处理，人们就可以通过读取文件或者拦截网络传输的方式来访问它<br>有一种办法可以防止对象的敏感信息部分被序列化，就是将类实现问Extrenalizable,如前面所示，这样一来，（没有任何东西可以自动序列化），并且可以在writeExternal()内部只对所需部分进行显式地初始化<br>然而，如果我们正在操作的是一个Serializable对象，那么所有序列化操作都会自动进行，为了能够予以控制，可以用transient“瞬时”关键字逐个字段地关闭序列化，它的意思是：“不用麻烦你保存或恢复数据——我自己会处理”，其实transients关键字的特性实现只是给了编译器或者虚拟机一个提示，由虚拟机来去实现忽略子对象的序列化而已<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Login</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Date date=<span class="keyword">new</span> Date();</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String password;<span class="comment">//添加了关键字transient</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Login</span><span class="params">(String name,String pwd)</span></span>&#123;</span><br><span class="line">        username=name;</span><br><span class="line">        password=pwd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"login info:\n"</span>+<span class="string">"username:"</span>+username+<span class="string">"\n"</span>+</span><br><span class="line">                <span class="string">"date:"</span>+date+<span class="string">"\n"</span>+</span><br><span class="line">                <span class="string">"password:"</span>+password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException,ClassNotFoundException,InterruptedException</span>&#123;</span><br><span class="line">        Login a=<span class="keyword">new</span> Login(<span class="string">"Hulk"</span>,<span class="string">"myliitepony"</span>);</span><br><span class="line">        System.out.println(<span class="string">"login a="</span>+a);</span><br><span class="line">        ObjectOutputStream out=<span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">                <span class="keyword">new</span> FileOutputStream(<span class="string">"login.out"</span>));</span><br><span class="line">        out.writeObject(a);</span><br><span class="line">        out.close();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        ObjectInputStream in=<span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">                <span class="keyword">new</span> FileInputStream(<span class="string">"login.out"</span>));</span><br><span class="line">        a=(Login) in.readObject();</span><br><span class="line">        System.out.println(<span class="string">"recovering Object at"</span>+<span class="keyword">new</span> Date());</span><br><span class="line">        System.out.println(<span class="string">"login a="</span>+a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>简单例子，password由关键字transient修饰</p><h3 id="Externalizable的替代方案"><a href="#Externalizable的替代方案" class="headerlink" title="Externalizable的替代方案"></a>Externalizable的替代方案</h3><p>如果不是坚持要使用Externalizable的话，那么还有一种方法，我们可以实现Serialzable接口，然后添加（注意是“添加”而非“覆盖”或“实现”）名为writeObject()和ReadObject()的方法，这样一旦对象被序列化或者反序列化还原，就会自动地分别调用这两个方法，也是就是说，只要提供了这两个方法，就会使用它们而不是默认的序列化机制<br><strong>这些方法必须要有正确的方法签名</strong><br>    private void writeObject(ObjectOutpuStream stream)<br>    private void readObject(ObjectInputStream stream)<br>上面的这些方法很令人疑惑，首先这些方法被声明为private，也就是说这些方法是有这个类的其他成员来调用的，但是实际上我们并没有从这个类的其他方法中调用它们，而是ObjectOutputStream和ObjectInoutStream的writeObject()和readObject()方法调用了你的对象的writeObject（）和readObject()方法，但是为什么ObjectOuputStream和ObjectInputStream能够访问你类中的private()方法的？我们只能假设这正是序列化神奇的地方（真想骂人啊）<br>所以我个人不推荐这种方式，因为：</p><ol><li>这种方式违背了访问控制权限机制，</li><li>你添加的WriteObject和readObject()方法必须要有正确的方法前面并且是private的（我们无法保证不会犯错，而且错误产生时我们也是毫无察觉的，编译器并不会提醒我们），</li><li>实现Externalizable接口就可以完全达到这个目的了，我们为何要选择这种方式来控制序列化呢？<h3 id="使用“持久性”"><a href="#使用“持久性”" class="headerlink" title="使用“持久性”"></a>使用“持久性”</h3>一个比较诱人的使用序列化技术的想法是：存储程序的一些状态，以便我们随后可以很容易地将程序恢复到当前状态，但是我们能够这样做之前，必须回答几个问题<br>如果我们将两个对象——他们都具有指向第三个对象的引用——进行序列化，会发生什么？当我们从它们的序列化状态恢复这两个对象时，第三个对象会只出现一次吗？<br>如果我们将这两个对象序列化成独立的文件，然后在代码的不同部分对它们进行反序列化还原，又会怎样呢？<br>下面这个例子说明这些问题<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> <span class="keyword">implements</span>  <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> House perferenceHouse;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name,House h)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.perferenceHouse=h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name+<span class="string">"["</span>+<span class="keyword">super</span>.toString()+<span class="string">"],"</span>+perferenceHouse+<span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException,ClassNotFoundException</span>&#123;</span><br><span class="line">        House house=<span class="keyword">new</span> House();</span><br><span class="line">        List&lt;Animal&gt; animals=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        animals.add(<span class="keyword">new</span> Animal(<span class="string">"Boson the dog"</span>,house));</span><br><span class="line">        animals.add(<span class="keyword">new</span> Animal(<span class="string">"Ralph  the hamster"</span>,house));</span><br><span class="line">        animals.add(<span class="keyword">new</span> Animal(<span class="string">"Molly the cat"</span>,house));</span><br><span class="line">        System.out.println(<span class="string">"animals:"</span>+animals);</span><br><span class="line"></span><br><span class="line">        ByteArrayOutputStream buf1=<span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream out1 =<span class="keyword">new</span> ObjectOutputStream(buf1);</span><br><span class="line">        out1.writeObject(animals);</span><br><span class="line">        out1.writeObject(animals);<span class="comment">//write a 2nd set</span></span><br><span class="line"></span><br><span class="line">        ByteArrayOutputStream buf2=<span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream out2=<span class="keyword">new</span> ObjectOutputStream(buf2);</span><br><span class="line">        out2.writeObject(animals);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//now get them back</span></span><br><span class="line">        ObjectInputStream in1=<span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">                <span class="keyword">new</span> ByteArrayInputStream(buf1.toByteArray()));</span><br><span class="line">        ObjectInputStream in2=<span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">                <span class="keyword">new</span> ByteArrayInputStream(buf2.toByteArray()));</span><br><span class="line">        List animals1=(List) in1.readObject(),</span><br><span class="line">             animals2=(List) in1.readObject(),</span><br><span class="line">             animals3=(List) in2.readObject();</span><br><span class="line">        System.out.print(</span><br><span class="line">                <span class="string">"animals1:"</span>+animals1+<span class="string">"\n"</span>+</span><br><span class="line">                <span class="string">"animals2:"</span>+animals2+<span class="string">"\n"</span>+</span><br><span class="line">                 <span class="string">"animals3:"</span>+animals3);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>运行上面的程序我们能够得出这样的结论，当我们在同一个流中写入两个对象时，当取出时，这两个恢复的对象将会指向同样的引用，也就是说对象链接是一样的，但是当我们将对象保存在不同的流时，恢复对象时，这两个对象的对象树保存在不同的内存地址中，两个对象之间没有任何关联<br>（我猜测，在序列化对象时，可能会将对象的内存地址的信息也保存下来，比如对象的引用中就有关于对象内存地址的信息，待序列化对象的引用同样也会有内存地址的信息，因此在反序列化时，会查看序列化中保存的对象内存地址以判断待反序列化对象与其他序列化对象之间的关系，当反序列化之后会进行正确的链接，这就能说明了animals1和animal2的toString返回的信息完全一样（指向同样的内存地址，包括子对象也是如此））<br><strong>如果我们想要保存系统状态，最安全的做法是将其作为“原子”操作进行序列化</strong>，如果我们序列化了某些东西，再去其他的一些工作，再来序列化更多的东西，如此等等，那么将无法安全地保存系统状态，取而代之的是，将构成系统状态的所有对象都置入单一容器内，并在一个操作中将该容器直接写出，然后同样只需一次方法调用，既可以将其恢复（原因是，当我们分步进行序列化的期间，你所保存的对象状态可能已经发生了变化，序列化保存的信息已经“过时了”）</p><h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><p><strong>对象序列化的一个重要的限制就是它只是java的解决方案</strong>只有java程序才能反序列化这种对象，一种更具有操作性的解决方案是将数据转换为xml格式，这可以使其被各种各样的平台和语言使用<br>你可以使用java的标准类库中的javax.xml.*，也可以使用开源的XOM类库，使用方法很简单，就是为对象建立一个文档对象模型（Document）这里是通过节点层次结构来表示对象的信息的，然后将其写入输出流即可，这里不讲</p><h2 id="Preferences"><a href="#Preferences" class="headerlink" title="Preferences"></a>Preferences</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreferencesDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Preferences prefs= Preferences.userNodeForPackage(PreferencesDemo.class);</span><br><span class="line">        prefs.put(<span class="string">"location"</span>,<span class="string">"oz"</span>);</span><br><span class="line">        prefs.put(<span class="string">"Footwear"</span>,<span class="string">"Ruby Slippers"</span>);</span><br><span class="line">        prefs.putInt(<span class="string">"Companions"</span>,<span class="number">4</span>);</span><br><span class="line">        prefs.putBoolean(<span class="string">"Ara there witches"</span>,<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">int</span> usageCount=prefs.getInt(<span class="string">"usageCount"</span>,<span class="number">0</span>);</span><br><span class="line">        usageCount++;</span><br><span class="line">        prefs.putInt(<span class="string">"UsageCount"</span>,usageCount);</span><br><span class="line">        <span class="keyword">for</span>(String key:prefs.keys())&#123;</span><br><span class="line">            System.out.println(key+<span class="string">":"</span>+prefs.get(key,<span class="keyword">null</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//you musy always provide a default value</span></span><br><span class="line">        System.out.println(<span class="string">"how many companions does Derothy havs?"</span></span><br><span class="line">        + prefs.getInt(<span class="string">"Companions"</span>,<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;创建一个好的输入/输出(I/O)系统是一项困难的事情，挑战似乎来自于要涵盖所有的可能性，不仅存在各种I/O源端和想要与之通信的接收器（文件，控制台，网络链接等），而且还需要以各种不同的方式与它们进行通信（顺序，随机缓存，缓冲，二进制，按行，按字等）&lt;br&gt;自从Java 1.
      
    
    </summary>
    
      <category term="学习心得" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>容器深入研究</title>
    <link href="http://yoursite.com/2018/10/19/%E5%AE%B9%E5%99%A8%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6/"/>
    <id>http://yoursite.com/2018/10/19/容器深入研究/</id>
    <published>2018-10-19T14:05:34.000Z</published>
    <updated>2018-10-21T19:30:00.438Z</updated>
    
    <content type="html"><![CDATA[<h2 id="完整的容器分类法"><a href="#完整的容器分类法" class="headerlink" title="完整的容器分类法"></a>完整的容器分类法</h2><h2 id="填充容器"><a href="#填充容器" class="headerlink" title="填充容器"></a>填充容器</h2><p>虽然容器打印问题解决了，容器的填充仍然像Arrays一样面临着同样的问题，就像Arrays一样，相应的Collections类也有一些实用的static方法，其中包括fill(),与Arrays一样，此fill()方法也是只复制同一个对象引用来填充整个容器，并且只对List对象有用，但是所产生的列表可以传递给构造器或addAll()方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringAddress</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String s;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringAddress</span><span class="params">(String s)</span></span>&#123;s=s;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">super</span>.toString()+s;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FillingLists</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;StringAddress&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Collections.nCopies(<span class="number">4</span>, <span class="keyword">new</span> StringAddress(<span class="string">"Hello"</span>)));</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        Collections.fill(list,<span class="keyword">new</span> StringAddress(<span class="string">"world"</span>));</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">~~~上面这个例子展示了用对单个对象的引用来填充Collection的方式，第一种是使用Collections.nCopies()创建传递给构造器的List，这里填充的是ArrayList</span><br><span class="line">StringAddress的toString()调用了它的基类Object的toString()方法，这个方法返回的是该类的名字，后面紧跟着该对象的散列码的十六进制表示（通过hashCode()产生的），从输出中你可以看到所有引用都是指向的同一个对象，这在第二个方法被调用之后也是同样如此，fill()方法的作用有限，因为它只能替换已经在List中存在的元素，而不能添加新的元素</span><br><span class="line">### 一种Generator解决方案 ###</span><br><span class="line">**事实上，所有的Collection子类型都有一个接收另一个Collection对象的构造器，用所接收的Collection对象中的元素来填充新的容器**，为了更好地创建测试数据，我们需要做的是创建接受Generator和quantity数值并将它们当作参数的类</span><br><span class="line">**这个类使用Generator在容器中放置所需要的对象，然后所产生的容器可以传递给任何Collection的构造器**，这个构造器会把其中的数据复制到自身中，addAll()方法是所有Collection子类型的一部分，它也可以用来组装现有的Collection</span><br><span class="line">**泛型便利方法可以减少在使用类时所必需的类型检查**</span><br><span class="line">CollectionData是适配器设计模式的一个实例，它将Generator适配到Collection的构造器上</span><br><span class="line">~~~java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionData</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CollectionData</span><span class="params">(Generator&lt;T&gt; gen,<span class="keyword">int</span> quantity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;quantity;i++) &#123;</span><br><span class="line">           add(gen.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">CollectionData&lt;T&gt; <span class="title">list</span><span class="params">(Generator&lt;T&gt; gen,<span class="keyword">int</span> quantity)</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span>  <span class="keyword">new</span> CollectionData&lt;&gt;(gen,quantity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Map生成器"><a href="#Map生成器" class="headerlink" title="Map生成器"></a>Map生成器</h3><p>我们可以对Map使用相同的方法，但是这需要一个Pair类，因为为了组装Map,每次调用Generator的next()方法都必须产生一个对象对（一个键和一个值）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> K k;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V v;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(K k,V v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.k=k;</span><br><span class="line">        <span class="keyword">this</span>.v=v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>适配器现在可以使用不同的Generator，Iterator和常量值的组合来填充Map初始化对象了,你可以使用单一的Generator&lt;pair&lt;K,V&gt;&gt;,两个分离的Generator，一个Generator和一个常量值，一个Iterable和一个Generator，随你的心情定制<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapData</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapData</span><span class="params">(Generator&lt;Pair&lt;K,V&gt;&gt; gen,<span class="keyword">int</span> qantity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;qantity;i++) &#123;</span><br><span class="line">            put(gen.next().k, gen.next().v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapData</span><span class="params">(Generator&lt;K&gt; genK,Generator&lt;V&gt; genV,<span class="keyword">int</span> quantity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;quantity;i++)&#123;</span><br><span class="line">           put(genK.next(),genV.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapData</span><span class="params">(Generator&lt;K&gt; genK,V value,<span class="keyword">int</span> quantity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;quantity;i++)&#123;</span><br><span class="line">            put(genK.next(),value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapData</span><span class="params">(Iterable&lt;Pair&lt;K,V&gt;&gt; it,<span class="keyword">int</span> quantity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Pair&lt;K,V&gt; pair:it)&#123;</span><br><span class="line">            put(pair.k,pair.v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapData</span><span class="params">(Iterable&lt;K&gt; itK,Generator&lt;V&gt; genV)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(K key:itK)&#123;</span><br><span class="line">            put(key,genV.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="function">MapData&lt;K,V&gt; <span class="title">map</span><span class="params">(Generator&lt;Pair&lt;K,V&gt;&gt; gen,<span class="keyword">int</span> quantity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MapData&lt;&gt;(gen,quantity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="function">MapData&lt;K,V&gt; <span class="title">map</span><span class="params">(Generator&lt;K&gt; genK,Generator&lt;V&gt; genV,<span class="keyword">int</span> quantity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> MapData&lt;&gt;(genK,genV,quantity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="使用Abstrcat类"><a href="#使用Abstrcat类" class="headerlink" title="使用Abstrcat类"></a>使用Abstrcat类</h3><p>对于产生用于容器的测试数据问题，另一种解决方式是创建定制的Collection和Map实现，每个java.util容器都有其自己的Abstract类,它们提供了该容器的部分实现，因此你必须做的只是去实现那些产生想要容器所需的方法，如果所产生的容器是只读的，就像它通常用的测试数据那样，那么你需要提供的方法数量将减到最少<br>尽管在在比例中不是特别需要，但下面的的剞劂方案还是提供了一个机会来演示另一种设计模式：享元。你可以在普通的解决方案中需要过多的对象，后者产生普通对象太占空间时使用享元，享元使得对象的一部分可以被具体化，因此，与对象中的所有事物都包含在对象内部不同，我们可以在更加高效的外部表中查找对象的一部分或者整体（或者同某些其他节省空间的计算来产生对象的一部分或整体）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Countries</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String[][] DATA=&#123;</span><br><span class="line">            &#123;<span class="string">"ANGDAL"</span>,<span class="string">"Luanda"</span>&#125;,&#123;<span class="string">"NIID"</span>,<span class="string">"asdasd"</span>&#125;,&#123;<span class="string">"sdasdasd"</span>,<span class="string">"asdasdasd"</span>&#125;,</span><br><span class="line">            &#123;<span class="string">"asdasdasd"</span>,<span class="string">"adsdfasda"</span>&#125;,&#123;<span class="string">"GUPOOAD"</span>,<span class="string">"sdfsdf"</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyWeightMap</span> <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">String</span>,<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//创建一个嵌套的内部类Entry以提供EntrySet使用</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">String</span>,<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> index;</span><br><span class="line">            Entry(<span class="keyword">int</span> index)&#123;<span class="keyword">this</span>.index=index;&#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> DATA[index][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> DATA[index][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">setValue</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> DATA[index][<span class="number">0</span>].equals(o);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> DATA[index][<span class="number">0</span>].hashCode();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">String</span>,<span class="title">String</span>&gt;&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">            EntrySet(<span class="keyword">int</span> size)&#123;</span><br><span class="line">                <span class="keyword">if</span>(size&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">this</span>.size=<span class="number">0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(size&gt;DATA.length)&#123;</span><br><span class="line">                     <span class="keyword">this</span>.size=DATA.length;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">this</span>.size=size;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Iter</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">String</span>,<span class="title">String</span>&gt;&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">private</span> Entry entry=<span class="keyword">new</span> Entry(-<span class="number">1</span>);</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> entry.index&lt;size-<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> Map.<span class="function">Entry&lt;String, String&gt; <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    entry.index++;</span><br><span class="line">                    <span class="keyword">return</span> entry;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Iter();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Set&lt;Map.Entry&lt;String,String&gt;&gt; entries=<span class="keyword">new</span> EntrySet(DATA.length);</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet() &#123;</span><br><span class="line">            <span class="keyword">return</span> entries;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Map&lt;String,String&gt; <span class="title">select</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FlyWeightMap()&#123;</span><br><span class="line">            <span class="keyword">public</span> Set&lt;Map.Entry&lt;String,String&gt;&gt; entrySet()&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> EntrySet(size);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;String,String&gt; map=<span class="keyword">new</span> FlyWeightMap();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String,String&gt; <span class="title">map</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String,String&gt; <span class="title">capitals</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> select(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> List&lt;String&gt; names=<span class="keyword">new</span> ArrayList&lt;String&gt;(map.keySet());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">names</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> names;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">names</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;String&gt;(select(size).keySet());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>二维数组String DATA是public的，因此可以在其他地方使用，FlyweightMap必须实现entrySet()方法，它需要定制的Set实现和定制的Map.Entry类，这里正是享元的部分，每个Map.Entry对象只存储了它的索引，而不是实际的值和键，当你调用getKey()和getValue()得时候它们会使用该索引来返回恰当的DATA元素，，EntrySet可以确保它的size不会大于DATA<br>你可以在EntrySet.Iterator中看到享元的其他部分实现，与为DATA中的每个数据对都创建Map.Entry对象不同，每个迭代器只有一个Map.Entry,<strong>Entry对象被用作数据的视窗</strong>，它只包含在静态字符串数组的引用，<strong>你每次调用迭代器的next()方法时，Entry中的index都会递增，使其指向下一个元素对，然后从next()返回该Iterator所持有的单一的Entry对象</strong></p><h2 id="Collection的功能方法"><a href="#Collection的功能方法" class="headerlink" title="Collection的功能方法"></a>Collection的功能方法</h2><p>下面列出了可以通过Collection执行的所有操作（不包括从Object继承的方法），因此，它们也是可通过Set和List执行的所有方法（List有额外的功能），Map不是继承自Collection的</p><table><thead><tr><th></th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>boolean add(T)</td><td>确保容器持有具有泛型类型T的参数，如果没有将此参数添加进容器，则返回false（这是“可选”的方法）</td></tr><tr><td>boolean addAll(Collection<t>)</t></td><td>添加参数中的所有元素，只要添加了任意元素就返回true（可选的）</td></tr><tr><td>void clear()</td><td>移除容器中的所有元素（可选）</td></tr><tr><td>boolean contains(T)</td><td>如果容器已经持有具有泛型类型T此参数，则返回true</td></tr><tr><td>Boolean containsAll(Collection<t>)</t></td><td>如果容器持有此参数中的所有元素，则返回true</td></tr><tr><td>boolean isEmpty()</td><td>容器中没有元素返回true</td></tr><tr><td>Iterator<t> iterator()</t></td><td>返回一个Iterator<t>,可以遍历容器中的元素</t></td></tr><tr><td>Boolean remove(Object)</td><td>如果参数在容器内，则移除该元素的一个实例，如果做了移除动作，则返回true（可选）</td></tr><tr><td>Boolean removeAll(Collection&lt;?&gt;)</td><td>移除参数中的所有元素，只要有移除动作发生就返回true（可选）</td></tr><tr><td>Boolean retainAll(Collection&lt;?&gt;)</td><td>只保存参数中的元素（应用集合论的“交集”概念），只要Collection发生了改变就返回true(可选)</td></tr><tr><td>int size()</td><td>返回容器中保存的元素个数</td></tr><tr><td>Object[] toArray()</td><td>返回一个数组，该数组包含容器中的所有元素</td></tr><tr><td><t> T[] toArray(T[] a)</t></td><td>返回一个数组，该数组包含容器中的所有元素，返回结果的运行是类型与，参数数组类型相同，而不是单纯的Object</td></tr></tbody></table><p>注意上面的方法不包括随机访问所选择元素的get()方法，因为Collection包括了Set，而Set是自己维护内部顺序的（这使得随机访问变得没有意义），因此，如果想检查Collection的元素，就必须使用迭代器</p><h2 id="可选操作"><a href="#可选操作" class="headerlink" title="可选操作"></a>可选操作</h2><p>什么是可选操作？就是接口声明的，但是实现类并不一定支持其实现的方法就是可选操作<br>执行各种不同的添加和移除的方法在Collection接口中都是可选操作，这意味着实现类并不一定选需要为这些方法提供功能定义（记住是不一定需要提供功能定义，但是必须提供实现，因为实现接口中声明的方法一定要有实现，实现可以什么都不做，也可以直接抛出一个UnsupportedException异常）<br>这是一种很不寻常的接口定义方式，<strong>接口是面向对象设计中的契约</strong>，它声明了“无论你选择任何实现该接口，我保证你可以向该接口发送这些消息”，但是可选操作违反了这个基本原则，它声明调用某些方法将不会执行任何有意义的行为，相反，它会抛出异常，这看起来好像是编译期的类型安全好像被抛弃了，因为编译期的类型检查就是为了运行期程序的正常执行<br>但是事情并不那么糟糕，如果一个操作是可选的，编译器仍然后要求你只能调用该接口中的方法，这样动态语言不同，<strong>动态语言可以在任何对象上调用任何方法，并且可以在运行时发现某个特定方法是否可以工作</strong>，另外将Collection当作参数接受的大部分方法只会从该Collection中读取，而Collection的读取都是不可选的<br><strong>为什么你会讲方法定义为可选的呢？那是因为这样做可以防止在设计中出现接口爆炸的情况</strong>，容器类型的其他设计看起来总是在描述每个主题的各种变体，而最终患上了令人困惑的接口过剩症，<strong>这种方式可以实现java容器类库的一个重要目标：容器应该是易学易用的（我们假定这样的一种情形，如果我们的Collection方法只声明了较少的方法，那么当我们需要具有某个特性的容器类时，我们必须在类库中添加具有这些特性的接口，这就造成了接口膨胀，而且当我们进行客户端编程的时候，要时刻区分那些容器类都实现了那些接口，这时我们不能仅仅将其向上转型为Collection类型了，因为Collection类型中仅有少量的方法可调用），未获支持的操作是一种特例，可以延迟到需要时才出现，但是，这种方式能够工作</strong><br>而且这种设计留下了一个后门，如果你想要创建新的Collection，但是没有为Collection接口中的所有方法都提供有意义的支持，那么它仍旧适合现有的类库<br>未获支持的异常只有在运行时才能探测到，因此它们表示动态类型检查<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Unsupported</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String msg,List&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">        Collection&lt;String&gt; c=list;</span><br><span class="line">        Collection&lt;String&gt; subList=list.subList(<span class="number">1</span>,<span class="number">8</span>);</span><br><span class="line">        Collection&lt;String&gt; c2=<span class="keyword">new</span> ArrayList&lt;&gt;(subList);</span><br><span class="line">        <span class="keyword">try</span>&#123; c.retainAll(subList); &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"retain"</span>+e); &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">try</span>&#123; c.remove(subList); &#125;<span class="keyword">catch</span>(Exception e)&#123; </span><br><span class="line">            System.out.println(<span class="string">"remove"</span>+e); &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">try</span>&#123; c.clear(); &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"clear"</span>+e); &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span>&#123; c.add(<span class="string">"x"</span>); &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"add"</span>+e); &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">try</span>&#123; c.addAll(c2); &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"addAll"</span>+e); &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">try</span>&#123; list.set(<span class="number">0</span>,<span class="string">"x"</span>); &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"List.set"</span>+e); &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list= Arrays.asList(<span class="string">"A B C D E F G H I "</span>.split(<span class="string">" "</span>));</span><br><span class="line">        test(<span class="string">"modifiable"</span>,<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">        test(<span class="string">"asList"</span>,list);</span><br><span class="line">        test(<span class="string">"unmodifiableList"</span>, Collections.unmodifiableList(<span class="keyword">new</span> ArrayList&lt;&gt;(list))); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最常见的未获支持的操作，都来源于背后由固定尺寸的数据结构支持的容器<br>我们看上面的一个例子。Arrays.asList()返回的容器对象就是以传入的数组对象为其底层的数据结构为基础提供容器的功能，因为我们知道，数组尺寸大小固定，所以对这个容器进行的增删都是未获支持的（容器的增删操作定义了执行这些操作时，容器的size必须改变，因为数组的length不可修改，所有，这样的容器自然不能进行增删操作了，不然就违反了容器原则）<br>但是我们将一个Arrays.asList（）返回的容器作为构造器的参数传递给ArrayList时，却发现了此时可以对这个容器进行增删操作了，这是因为，这样的方式会产生新的尺寸可调的底层数据结构。Collections类的“不可修改” 的方法将容器包装到了一个代理，只要进行任何试图修改容器的操作，这个代理都会产生一个UssupportedOperationException异常<br>最后一个方法set()比较有意思，对于Arrays.asList()返回的容器可以调用的，因为这个操作并不会改变尺寸，只是修改了某个位置元素而已，而对于Collections.unmodifiableLis()返回的容器只读，任何的写操作都不支持<br>最后，如果你要编写一个接受Collection类型的方法，其文档应该指定那些可选操作必须实现</p><h2 id="List的功能方法"><a href="#List的功能方法" class="headerlink" title="List的功能方法"></a>List的功能方法</h2><p>List继承了Collection接口，又添加了本身的一些接口方法，因此每一个实现了List接口的List容器实现都可以调用这些方法，这些方法可以查看api，见名知义，另外要注意的一个实现类LinkedList这个实现类不仅实现了List接口，还实现了其他的接口，所有具有普通List所不具有的特性和方法，如addFrist(),addLast(),removeFrist()等…,具体api请参见Queue接口</p><h2 id="Set和存储顺序"><a href="#Set和存储顺序" class="headerlink" title="Set和存储顺序"></a>Set和存储顺序</h2><table><thead><tr><th></th><th>接口或Set容器实现类</th><th>说明</th></tr></thead><tbody><tr><td>Set(interface)</td><td>放在Set中的每一个元素都必须是唯一的，因为Set不保存重复元素，加入Set的元素必须定义equals()方法以确保对象的唯一性，set与Collection有完全一样的接口，<strong>Set接口不保证维护元素的次序</strong></td></tr><tr><td>HashSet*</td><td>为快速查找设计的Set，存入HashSet的元素必须定义hashCode()</td></tr><tr><td>TreeSet</td><td>保持次序的Set，底层为树结构，使用它可以从Set中提取有序的方法，元素必须实现Comparable接口</td></tr><tr><td>LinkedHashSet</td><td>具有HashSet的查询速度，其内部使用链表维护元素的顺序（插入顺序），于是在使用迭代器遍历Set时，结果会按元素插入的次序显示，也必须定义hashCode()</td></tr></tbody></table><p>在HashSet上打星号，表示如无特殊的要求，这个应该是我们的首选<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SetType</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SetType</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;i=n;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o <span class="keyword">instanceof</span> SetType &amp;&amp; (i==((SetType) o).i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="string">"SetType"</span>+i; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashType</span> <span class="keyword">extends</span> <span class="title">SetType</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashType</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;<span class="keyword">super</span>(n);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hasCode</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeType</span> <span class="keyword">extends</span> <span class="title">SetType</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">TreeType</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeType</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;<span class="keyword">super</span>(n);&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(@NotNull TreeType o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (o.i&lt;i)? -<span class="number">1</span>:((o.i==<span class="number">0</span>)? <span class="number">0</span>:<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypesForSets</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Set&lt;T&gt; <span class="title">fillSet</span><span class="params">(Set&lt;T&gt; set,Class&lt;T&gt;  type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                set.add(type.getConstructor(<span class="keyword">int</span>.class).newInstance(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> set;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(Set&lt;T&gt; set,Class&lt;T&gt; type)</span></span>&#123;</span><br><span class="line">        fillSet(set,type);</span><br><span class="line">        fillSet(set,type);</span><br><span class="line">        fillSet(set,type);</span><br><span class="line">        System.out.println(set);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        test(<span class="keyword">new</span> HashSet&lt;HashType&gt;(),HashType.class);</span><br><span class="line">        test(<span class="keyword">new</span> LinkedHashSet&lt;HashType&gt;(),HashType.class);</span><br><span class="line">        test(<span class="keyword">new</span> TreeSet&lt;TreeType&gt;(),TreeType.class);</span><br><span class="line"></span><br><span class="line">        test(<span class="keyword">new</span> HashSet&lt;SetType&gt;(),SetType.class);</span><br><span class="line">        test(<span class="keyword">new</span> HashSet&lt;TreeType&gt;(),TreeType.class);</span><br><span class="line">        test(<span class="keyword">new</span> LinkedHashSet&lt;TreeType&gt;(),TreeType.class);</span><br><span class="line">        test(<span class="keyword">new</span> LinkedHashSet&lt;SetType&gt;(),SetType.class);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test(<span class="keyword">new</span> TreeSet&lt;HashType&gt;(), HashType.class);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            test(<span class="keyword">new</span> TreeSet&lt;SetType&gt;(),SetType.class);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果我们尝试着将没有恰当地支持必需的操作的类型用于需要这些方法的Set，那么将会有大麻烦，对于没有定义hashCode()的SetType或SetType,如果将它们放置到任何散列实现中都会产生重复值，这样就违背了Set的基本契约，这是相当烦人的，更烦人的是不会有任何的运行时错误，这是因为默认的hashCode()是合法的，即使它不正确<br>如果我们尝试着将没有实现Comparable的对象添加进TreeSet中，这会在运行期抛出异常，因为TreeSet的方法在内部会检测对象是否实现了Comparable</p><h3 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h3><p>SortedSet接口的唯一实现TreeSet,这个接口提供了一些附加的功能</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>comparator()</td><td>返回Comparator，或者返回null,表示以自然方式排序</td></tr><tr><td>T first()</td><td>返回容器的第一个元素</td></tr><tr><td>T last()</td><td>返回容器的最后一个元素</td></tr><tr><td>SortedSet<t> subSet(T fromElement,T toElement)</t></td><td>生成此Set的子集，范围从fromElement(包含)到toElement(不包含)</td></tr><tr><td>SortedSet<t>  headSet(T toElement)</t></td><td>由小于ToElement的元素组成的子集</td></tr><tr><td>SortedSet<t> tailSet(T fromElement</t></td><td>由大于或等于fromElement的元素组成的子集</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sorted</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SortedSet&lt;String&gt; set=<span class="keyword">new</span> TreeSet&lt;String&gt;();</span><br><span class="line">        Collections.addAll(set,<span class="string">"one two three"</span>.split(<span class="string">" "</span>));</span><br><span class="line">        System.out.println(set);</span><br><span class="line">        String low=set.first();</span><br><span class="line">        String high=set.last();</span><br><span class="line">        Iterator&lt;String&gt; it=set.iterator();</span><br><span class="line">        SortedSet&lt;String&gt; toFromSubSet=set.subSet(low,high);</span><br><span class="line">        SortedSet&lt;String&gt; headSubSet=set.headSet(high);</span><br><span class="line">        SortedSet&lt;String&gt; tailSubSet=set.tailSet(low);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>除了并发应用，Queue在java SE5中只有两个实现是LinkedList和PriorityQueue,它们的差异在于排序行为而不是性能<br>下面是涉及Queue实现的大部分操作的基本示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueBehavior</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count =<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(Queue&lt;T&gt; queue, Generator&lt;T&gt; gen)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">            queue.offer(gen.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(queue.peek()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(queue.remove()+<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Gen</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">        String[] s=<span class="string">"one two three four five six "</span>.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> s[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        test(<span class="keyword">new</span> LinkedList&lt;String&gt;(),<span class="keyword">new</span> Gen());</span><br><span class="line">        test(<span class="keyword">new</span> PriorityQueue&lt;String&gt;(),<span class="keyword">new</span> Gen());</span><br><span class="line">        test(<span class="keyword">new</span> ArrayBlockingQueue&lt;String&gt;(count),<span class="keyword">new</span> Gen());</span><br><span class="line">        test(<span class="keyword">new</span> LinkedBlockingQueue&lt;String&gt;(count),<span class="keyword">new</span> Gen());</span><br><span class="line">        test(<span class="keyword">new</span> ConcurrentLinkedQueue&lt;String&gt;(),<span class="keyword">new</span> Gen());</span><br><span class="line">        test(<span class="keyword">new</span> PriorityBlockingQueue&lt;String&gt;(),<span class="keyword">new</span> Gen());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h3><p>优先队列就是从一端插入，从另一端取出，而取出的顺序是按优先级的，所以元素要实现Comparable，我们看下一个简单的toDo列表的问题<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToDolist</span> <span class="keyword">extends</span> <span class="title">PriorityQueue</span>&lt;<span class="title">ToDolist</span>.<span class="title">ToDoItem</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ToDoItem</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ToDoItem</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">char</span> primary;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> secondary;</span><br><span class="line">        <span class="keyword">private</span> String item；</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ToDoItem</span><span class="params">(String item,<span class="keyword">char</span> primary,<span class="keyword">int</span> secondary)</span></span>&#123;</span><br><span class="line">            primary=primary;</span><br><span class="line">            secondary=secondary;</span><br><span class="line">            item=item;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(@NotNull ToDolist.ToDoItem o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(primary&gt;o.primary)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(primary==o.primary)&#123;</span><br><span class="line">                <span class="keyword">if</span>(secondary&gt;o.secondary)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(secondary==o.secondary)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String td,<span class="keyword">char</span> pri,<span class="keyword">int</span> sec)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.add(<span class="keyword">new</span> ToDoItem(td,pri,sec));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ToDolist toDolist=<span class="keyword">new</span> ToDolist();</span><br><span class="line">        toDolist.add(<span class="string">"Empty"</span>,<span class="string">'C'</span>,<span class="number">4</span>);</span><br><span class="line">        toDolist.add(<span class="string">"Feed Dog"</span>,<span class="string">'A'</span>,<span class="number">2</span>);</span><br><span class="line">        toDolist.add(<span class="string">"Empty"</span>,<span class="string">'B'</span>,<span class="number">7</span>);</span><br><span class="line">        toDolist.add(<span class="string">"Empty"</span>,<span class="string">'C'</span>,<span class="number">3</span>);</span><br><span class="line">        toDolist.add(<span class="string">"Empty"</span>,<span class="string">'A'</span>,<span class="number">1</span>);</span><br><span class="line">        toDolist.add(<span class="string">"Empty"</span>,<span class="string">'B'</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(!toDolist.isEmpty())&#123;</span><br><span class="line">            System.out.println(toDolist.remove());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h3><p><strong>双端队列就像是一个队列，但是你可以在任何一端添加或移除元素，在LinkedList中包含了双端队列的方法，但在java标准类库没有任何显式的用于双向队列的接口</strong>，因此你无法将一个LinkedList向上转型到Deque这样的接口（没有这样的接口），但是，你可以使用组合来创建一个Deque，并直接从LinkedList中暴露相关的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Deque</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;T&gt; deque=<span class="keyword">new</span> LinkedList&lt;T&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFrist</span><span class="params">(T item)</span></span>&#123;deque.addFirst(item);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(T item)</span></span>&#123;deque.addLast(item);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFrits</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> deque.getFirst();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span></span>&#123;<span class="keyword">return</span>  deque.getLast();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">removeFrist</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> deque.removeFirst();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">removeLast</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> deque.removeLast();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> deque.size();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> deque.toString();&#125;</span><br><span class="line">    <span class="comment">//other method</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实双端队列在程序中使用的并不是很多，因为我们也很少有需求需要在两端放入元素并取出它们</p><h2 id="理解Map"><a href="#理解Map" class="headerlink" title="理解Map"></a>理解Map</h2><p>映射表（关联数组）的基本思想是它维护键值关联，因此你可以使用键来查找值，标准的java类库包含了Map的几种基本实现。包括HashMap,TreeMap,LinedHashMap,WeakHashMap,ConcurretHashMap,IdentityHashMap,它们都有同样的基本接口Map，但是行为特性各不相同，这表现在效率，键值对的保存及呈现次序，对象的保存周期，映射表如何在多线程程序中工作和如何判定“键”等价性的策略等方面<br>我们先观察关联数组是如何创建的，下面是一个极其简单的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AssociativeArray</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[][] pairs;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">AssociativeArray</span><span class="params">(<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        pairs=<span class="keyword">new</span> Object[length][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key,V value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;=pairs.length)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException();</span><br><span class="line">        &#125;</span><br><span class="line">       pairs[index++]=<span class="keyword">new</span> Object[]&#123;key,value&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pairs[i][<span class="number">0</span>].equals(key))&#123;</span><br><span class="line">                <span class="keyword">return</span> (V)pairs[i][<span class="number">0</span>];</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuilder stb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line">            stb.append(pairs[i][<span class="number">0</span>]);</span><br><span class="line">            stb.append(<span class="string">":"</span>);</span><br><span class="line">            stb.append(pairs[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的例子是个很简单的Map实现，主要实现了put()和get(),而且是以Object数组为底层数据结构，并且不可自动调整尺寸的，这个例子看看就好</p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>性能是映射表中的一个重要问题，当在get()中使用线性搜索时，执行速度会相当地慢，而这正是HashMap提高速度的地方，HashMap使用了特殊的值称作散列码，来取代对键的缓慢搜索，散列码是相对唯一的，，它通过对象的某些信息进行转换而成的，hashCode()是根类Object的方法，因此所有java对象都能产生散列码，HashMap就是使用对象的hashCode()进行快速搜索的，此方法能够显著提高速度<br>我们看下Map的各种实现</p><table><thead><tr><th>实现类</th><th>说明</th></tr></thead><tbody><tr><td>HashMap</td><td>Map是基于散列表的实现（它取代了MaoTable）插入和查询“键值对”的开销是固定的，可以通过构造器设置容量和负载因子，以调整性能</td></tr><tr><td>LinkdHashMap</td><td>类似与HashMap，但是迭代遍历它时，取得“键值对”的顺序是其插入次序，或者是最近最少使用（LRU）的次序，只是比HashMap慢一点，而在迭代访问时反而更快，因为它使用链表维护内部次序</td></tr><tr><td>TreeMap</td><td>基于红黑树的实现，查看“键”或“键值对”时，它们会被排序（次序又Comparable或Comparator决定），TreeMap的特点在于，所得到的结果是经过排序的，TreeMap是唯一的带有SubMap()方法的Map，它可以返回一个子树</td></tr><tr><td>weakHashMap</td><td>弱键（weak key）映射，允许释放映射所指向的对象，这是为了解决某类特殊问题而设计的，如果映射之外没有引用指向某个“键”，则此“键”可以被垃圾回收器回收</td></tr><tr><td>ConcurrentHashMap</td><td>一种线程安全的Map，它不涉及同步加锁，我们将在“并发”中讨论它</td></tr><tr><td>IdentityHashMap</td><td>使用==代替equals()对“键”进行比较的散列映射，专为解决特殊问题而设计的</td></tr></tbody></table><p>对Map中使用的键的要求和对Set中的元素要求是一样的，任何键都要具有equals()方法，如果键被用于散列Map，则对象要有恰当的hashCode(),如果键被用于TreeMap，则它必须要实现Comparable<br>下面是Map接口的可用操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Maps</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printKeys</span><span class="params">(Map&lt;Integer,String&gt; map)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Size="</span>+map.size());</span><br><span class="line">        System.out.println(<span class="string">"Keys"</span>+map.keySet());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Map&lt;Integer,String&gt; map)</span></span>&#123;</span><br><span class="line">        System.out.println(map.getClass().getSimpleName());</span><br><span class="line">        map.putAll(<span class="keyword">new</span> CountringMapData(<span class="number">25</span>));</span><br><span class="line">        printKeys(map);</span><br><span class="line">        System.out.println(<span class="string">"values:"</span>+map.values());</span><br><span class="line">        System.out.println(map.containsKey(<span class="number">11</span>));</span><br><span class="line">        System.out.println(map.get(<span class="number">11</span>));</span><br><span class="line">        System.out.println(map.containsValue(<span class="string">"F0"</span>));</span><br><span class="line">        Iterator&lt;Integer&gt; keyIt=map.keySet().iterator();</span><br><span class="line">        Integer key=keyIt.next();</span><br><span class="line">        map.remove(key);</span><br><span class="line">        printKeys(map);</span><br><span class="line">        map.clear();</span><br><span class="line">        System.out.println(map.isEmpty());</span><br><span class="line">        map.putAll(<span class="keyword">new</span> CountringMapData(<span class="number">25</span>));</span><br><span class="line">        map.keySet().removeAll(map.keySet());</span><br><span class="line">        System.out.println(map.isEmpty());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="SortedMap"><a href="#SortedMap" class="headerlink" title="SortedMap"></a>SortedMap</h3><p>使用SortedMap(TreeMap是现阶段的唯一实现)，可用确保键处于排序状态，这使得它具有额外的功能，这些功能都是由SortedMap的接口提供的<br>Comparator comparator()返回当前Map使用的Comparator，或者返回null<br>T firstKey()返回Map中的第一个元素<br>T lastKey()返回Map中的最后一个元素<br>SortedMap subMap(fromKey,toKey)，SortedMap headMap(toKey) SortedMap tailMap(fromKey) 生成此Map的一个子集</p><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>为了提高速度，LinkedHashSet散列了所有元素，但是在遍历键值对时，却又以元素的插入顺序返回键值对，此外，可以构造器中设定LinkedhashMap，使之采用基于访问最近最少量（LRU）算法，于是没有被访问过的（可被看做需要删除的）元素就会出现在队列的前面，对于需要定期清理元素以节省空间的程序来说，此功能使得程序很容易得以实现，下面的例子演示了LinkedHashMap的这两个特点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMapDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        LinkedHashMap&lt;Integer,String&gt; linkedMap=<span class="keyword">new</span> LinkedHashMap&lt;&gt;(<span class="keyword">new</span> CountringMapData(<span class="number">25</span>));</span><br><span class="line">        System.out.println(linkedMap);</span><br><span class="line">        <span class="comment">//least-recent-used-order</span></span><br><span class="line">        linkedMap=<span class="keyword">new</span> LinkedHashMap&lt;&gt;(<span class="number">16</span>,<span class="number">0.75f</span>,<span class="keyword">true</span>);</span><br><span class="line">        linkedMap.putAll(<span class="keyword">new</span> CountringMapData(<span class="number">25</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">            linkedMap.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(linkedMap);</span><br><span class="line">        linkedMap.get(<span class="number">0</span>);</span><br><span class="line">        System.out.println(linkedMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上面的例子可以看出，可通过设定容器的容量和负载因子来调整容器的性能和行为</p><h2 id="散列和散列码"><a href="#散列和散列码" class="headerlink" title="散列和散列码"></a>散列和散列码</h2><p>使用标准类型的类当作HashMap的键来使用，是很好用的，因为这些类库在设计时，已经重新实现了一个比较恰当的hashCode()和equals()方法，但是如果自己创建的类，就有可能忘记在其中放置必需的方法，这通常会引起很大的错误<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Groundhog</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Groundhog</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;number=number;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">"GroundHog#"</span>+number;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Prediction</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand=<span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">shadow</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> rand.nextDouble()&gt;<span class="number">0.5</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(shadow())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Six more weeks of winter"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Early Spring"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDetecter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Groundhog&gt; <span class="function"><span class="keyword">void</span> <span class="title">detectSpring</span> <span class="params">(Class&lt;T&gt; type)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Constructor&lt;T&gt; ghog=type.getConstructor(<span class="keyword">int</span>.class);</span><br><span class="line">        Map&lt;Groundhog,Prediction&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            map.put(ghog.newInstance(i),<span class="keyword">new</span> Prediction());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        Groundhog gh=<span class="keyword">new</span> Groundhog(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">"looking up prediction for "</span> +gh);</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(gh))&#123;</span><br><span class="line">            System.out.println(map.get(gh));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"not found"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">            detectSpring(Groundhog.class);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的示例很简单，创建一个Map容器，将Groundhog(土拨鼠)与Prediction（天气预报）关联起来，可是这个示例是不工作的，当我们创建一个土拨鼠new Groundhog(3)时，是无法找到这个键的，根本原因是Groundhog继承了Object的hashCode()方法，而它默认是使用的对象的地址计算散列码，因此由Groundhog(3)生成的一个实例的散列码和第二个生成的实例的散列码并不相同，记住一点的是散列码的作用是查找（快速定位）<br>因此你可能会认为只要编写恰当的hashCode()就可以了，但是它仍然无法正常运行，除非你同时覆盖equals()方法，它也是Object的一部分，HashMap使用equals()判断当前的键是否与表中存在的键相同，继承自Object的equals()默认以对象的地址为判断依据<br>正确的equals()方法必须满足下列5个条件</p><ol><li>自反性：对于任意的x x.equals(x)一定返回true</li><li>对称性：任意的x,y 如果x.equals(y)返回true，则y.equals(x)一定返回true;</li><li>传递性：任意的x,y,z, x,equals(y) y.equals(z),则x.equals(z)</li><li>一致性：任意的x,y 如果对象中用于等价比较的信息没有改变，那么无论调用x.equals()多少次，返回的结果应该保持一致</li><li>对于任何不是null的x x.equals(null)返回false</li></ol><p>再次强调，默认的Object.equals()比较的是对象地址，因此，如果要将自己的类作为HashMap的键，一定要同时覆盖hashCode()和equals()</p><h3 id="理解hashCode"><a href="#理解hashCode" class="headerlink" title="理解hashCode()"></a>理解hashCode()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MapEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> K k;</span><br><span class="line">    <span class="keyword">private</span> V v;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapEntry</span><span class="params">(K key,V value)</span></span>&#123;</span><br><span class="line">        k=key;</span><br><span class="line">        v=value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v=value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShowMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;K&gt; listK=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;V&gt; listV=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key,V value)</span></span>&#123;</span><br><span class="line">        V oldValue=get(key);</span><br><span class="line">        <span class="keyword">if</span>(!listK.contains(key))&#123;</span><br><span class="line">            listK.add(key);</span><br><span class="line">            listV.add(value);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            listV.set(listK.indexOf(key),value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span></span>&#123;<span class="comment">//key is type Object not K</span></span><br><span class="line">        <span class="keyword">if</span>(!listK.contains(key))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> listV.get(listK.indexOf(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">        Set&lt;Map.Entry&lt;K, V&gt;&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Iterator&lt;K&gt; itk = listK.iterator();</span><br><span class="line">        Iterator&lt;V&gt; itV = listV.iterator();</span><br><span class="line">        <span class="keyword">while</span> (itk.hasNext()) &#123;</span><br><span class="line">            set.add(<span class="keyword">new</span> MapEntry&lt;K,V&gt;(itk.next(), itV.next()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> set;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">         SlowMap&lt;String,String&gt; m=<span class="keyword">new</span> SlowMap&lt;&gt;();</span><br><span class="line">         m.putAll(Countries.capitals(<span class="number">15</span>));</span><br><span class="line">         System.out.println(m);</span><br><span class="line">         System.out.println(m.entrySet());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面一个例子，最值得注意的问题，我觉得在定义get(Object o)方法的时候，我们期望的是get(K key)但是在这里是不可以的，提示说both motehed have same erasure,这是我感到疑惑的地方，我们知道在同一个类中，方法签名相同是不被允许的，但是这里通过在子类定义与基类中涉及泛型的方法签名相同的方法也是不被允许的，即使它们都被擦除为Object也不可以，这是为什么？<br>上面这个Map的实现并不好，因为<strong>entrySet()方法的调用创建了副本，这样就使得方法调用的效率变低，Map.Entry最好的实现应该是作为窗口通过它我们可以获得键和值，而且我们还应该可以通过这个视图修改底层数据，这些是副本做不到的</strong></p><h3 id="为速度而散列"><a href="#为速度而散列" class="headerlink" title="为速度而散列"></a>为速度而散列</h3><p>上面的例子，效率低的另一个原因是，我们搜索键的时候，使用的是线性查询，这种查询方式非常缓慢<br>散列的价值在于速度，散列使得查询得以快速进行，<strong>由于瓶颈在于查询速度，因此解决方案之一就是保持键的排序状态，然后使用Collection.binarySearch()进行查询</strong><br><strong>散列更进一步，它将键保存在某处，以便能够很快找到，存储一组元素最快的数据结构是数组，所以用它来保存键的信息，请留言，这里说的是键的信息，而不是键本身</strong>，这样有一个问题就是，数组尺寸固定的问题，如果我们希望在Map中保存数量不确定的值，这种问题能解决吗？<br>答案就是：数组不保存键本身，因为一旦保存的是键对象本身的话，那么这个数组位置上能保持的元素也只有一个了，其实很好解决，我们通过键对象获得一个数值，这个数值就是散列码，这个散列码表示数组的下标，通过下标将键值对存在这个数组下标位置上的一个容器，那么问题就解决了，任意数量的元素都能存储在Map中，即使hashCode()冲突也能够在数组索引位置上的容器对象上添加新的元素，解决hashCode冲突问题，<br>总结一下，查询一个值的过程是，计算键的hashCode，通过散列码查询数组，找到相应数组位置上的LinkedList，遍历LinkedList使用equals()判断该取LinkedList中存储的哪个元素，这种Map实现的方式使得每次查询只在少量的数据上进行遍历，效率得到提高</p><h3 id="覆盖hashCode"><a href="#覆盖hashCode" class="headerlink" title="覆盖hashCode()"></a>覆盖hashCode()</h3><p>如果要使得HashMap的执行效率更佳，那在我们向容器当作添加元素的时候，应该使得元素落在容器的槽位更加均衡才好，桶位下标的产生我们没有办法控制，因为这与HashMap对象的容量有关，而容量的改变与容器的充满程度和负载因子有关，hashCode生成的值经过计算才会生成桶位下标<br>设计hashCode的一个最重要的一个因素是，无论何时，对同一个对象调用hashCode()都应该生成相同的值<br>此外，也不应该使hashCode（）依赖于唯一性的对象信息，比如this，这也是我们在创建一个新类时，总会忽略的可怕问题，使得即使对象的信息描述完全相同，Map却依然将其视为不同的对象<br>基于对象的内容生成散列码是正确的选择<br>另外一个重要的影响因素，好的hashCode()应该产生分布均匀的散列码，否则，HashMap中的某些桶位负载过重，效率也不会更好<br>有一些建议，可以参考网上的资料</p><h2 id="选择接口的不同实现"><a href="#选择接口的不同实现" class="headerlink" title="选择接口的不同实现"></a>选择接口的不同实现</h2><p>尽管实际上只有四种容器：List，Set,Map和Queue，但是每种接口都有不止一个版本的实现，如果需要某种接口的功能，如何选择使用哪个实现？<br>容器之间的区别通常归结为由什么在背后“支持”它们，也就是说，所使用的接口是由什么样的数据结构实现的，<br>例如，ArrayList和LinkedList都实现了List接口，ArrayList底层是由数组支持，而LinkedList是由双向链表实现</p><h3 id="对List的选择"><a href="#对List的选择" class="headerlink" title="对List的选择"></a>对List的选择</h3><p>随机访问：ArrayList的随机访问要比LinkedList的随机访问要快，因为ArrayList是基于数组实现的，所以随机查找时，可以直接定位到一个对象的位置，而且随机访问速度不太会受到容器尺寸的影响，但是LinkedList的随机访问并不好，因为它是基于链表实现的，随机访问时要通过链表中的对象线性的查找对象的内存地址，所有性能很差，而且会随着尺寸的增大代价变得更加高昂<br>插入和删除，因为Arraylist的底层数组支持的原因，当向ArrayList插入一个元素时，必须创建空间并将它的所有引用先后移动，这种修改内存数据的行为，非常的耗时，但是ArrayList就比较简单，只需要连接两边的元素即可，这种方式的代价是固定的，不会随着尺寸的改变而改变</p><h3 id="对Set的选择"><a href="#对Set的选择" class="headerlink" title="对Set的选择"></a>对Set的选择</h3><p>HashSet的性能基本上总是比TreeSet好，特别是在添加和查询元素时，而这两个操作也是总重要的操作，TreeSet存在的唯一原因是它可以维持元素的排序状态，只有当需要一个排好序的Set时，才应该用TreeSet，TreeSet的迭代要比HashSet快、</p><h3 id="对Map选择"><a href="#对Map选择" class="headerlink" title="对Map选择"></a>对Map选择</h3><p>HashMap是我们平时应该默认使用的Map，TreeMap和TreeSet一样，是一种创建有序列表的方式，填充完TreeaMap之后，调用keySet()方法获得一个有序列表，LinkedHashSet在插入时比HashMap要慢一点，因为它在维持散列结果的同时也要维持插入顺序，正是由于这个原因，它的迭代速度也更快一些</p><h4 id="HashMap的性能因子"><a href="#HashMap的性能因子" class="headerlink" title="HashMap的性能因子"></a>HashMap的性能因子</h4><p>容量：桶位<br>初始容量：表在创建时所拥有的桶位数，HashMap和HashSet都具有允许你指定初始容量的构造器<br>尺寸：表当前存储的项数<br>负载因子：（尺寸/容量）空表的负载因子是0，半满表是0.5,依次类推，负载因子小的表产生冲突的可能性较小，但是会浪费较多的内存空间，也会使得频繁的扩容（这种是典型的空间换时间），HashMap和HashSet都允许你指定初始的负载因子，当达到该负载因子的水平的时候，容器自动增加其容量（桶位），实现的方式是使容量大致加倍，并重新将现有对象分布到新的桶位上（再散列）（HashMap的默认负载因子是0.75）</p><h2 id="实用方法"><a href="#实用方法" class="headerlink" title="实用方法"></a>实用方法</h2><p>Java中有大量的容器的卓越的使用方法，它们被称为java.util.Collections的静态方法，常用的方法总结如下</p><table><thead><tr><th></th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>checkedCollection(Collection<t> Class<t> type)<br>checkedList(List<t> Class<t> type)<br>checkedSet(Set<t> Class<t> type)<br>checkedMap(Map&lt;K,V&gt;,Class<k> kType,Class<v> vType)</v></k></t></t></t></t></t></t></td><td>产生Collection或者Collection子类型动态类型安全的容器，在不可能使用静态检查版本的时使用这些方法</td></tr><tr><td>max(Collection)<br>mix(Collection)</td><td>返回参数Collection中最大或最小的元素，采用Comparator比较</td></tr><tr><td>indexOfSubList(List source,List target)</td><td>返回target在source中第一次出现的位置，或者找不到返回-1</td></tr><tr><td>lastIndexOfSubList(List source,List target)</td><td>返回target在source中最后一次出现的位置，或者找不到返回-1</td></tr><tr><td>replaceAll(List<t>,T oldVal,T newVal)</t></td><td>使用newVal替换所有的oldVal</td></tr><tr><td>reverse(List)</td><td>逆转所有元素的顺序</td></tr><tr><td>reverseOrder()<br>reverseOrder&lt;Comparator<t>&gt;</t></td><td>返回一个Comparator，第二个版本返回一个反序的比较器</td></tr><tr><td>rotate(List,int distance)</td><td>所有的元素向后移动distance个位置，后面的元素循环移到前面</td></tr><tr><td>suffle(List)<br>suffle(List,Random)</td><td>随机改变元素的顺序</td></tr><tr><td>sort(List)<br> sort&lt;List<t>,Comparator&lt;? super T&gt;&gt;</t></td><td>使用List<t>中的自然排序，第二个方法使用比较器的排序</t></td></tr><tr><td>copy(List&lt;? extends T&gt; dist,List&lt;? super T&gt; src)</td><td>将src中的元素复制到dist</td></tr><tr><td>swap(List,int i,int j)</td><td>交换元素的位置</td></tr><tr><td>fill（List&lt;? super T&gt;,T x）</td><td>用对象x替换所有元素</td></tr><tr><td>nCopies(int n,T x)</td><td>返回大小为n的List<t>,此List不可改变，其中的引用都指向x</t></td></tr><tr><td>disjoint(Collection,Collection)</td><td>当两个集合中没有相同的元素时，返回true</td></tr><tr><td>ferquency(Collection,Object x)</td><td>返回Collection中等于x的元素个数</td></tr><tr><td>unmodifiedCollection(Collection)<br>unmodifiedList(List)<br>unmodifiedSet(Set)<br>unmodifiedMap(Map)</td><td>生成只读容器</td></tr><tr><td>concurrentCollection(Collection)<br>concurrentList(List)<br>concurrentSet(Set)<br>concurentMap(Map)</td><td>生成线程安全的容器</td></tr></tbody></table><h2 id="持有引用"><a href="#持有引用" class="headerlink" title="持有引用"></a>持有引用</h2><p>java.lang.ref类库包含了一组类，这些类为垃圾回收器提供了更大的灵活性，当存在可能耗尽内存的大对象时，这次类显得特别有用，有三个继承自抽线类Reference的类，SoftReferenc ,WeakRefrence,PhantomReference,当垃圾回收器正在考察的对象只能通过某个Reference对象才“可获得的”时候，上述这些类给垃圾回收器提供了不同级别的间接指示<br>对象是可获得的（reachable）是值对象能在程序的某处能够找到，不可获得对象，程序不能再访问它们，对这些对象的回收是安全的<br>如果想继续持有某个对象的引用，希望以后还能访问它们，但是也希望能够允许垃圾回收器在内存不足的时候释放它们，这时就可使用Reference对象<br>以Reference对象作为你和普通引用之间的媒介（代理），另外，一定不能有普通的引用指向这个对象，这样就能达到上述的目的，<strong>普通的引用指没有经过Reference对象包装过的引用</strong>，如果垃圾回收器发现某个对象通过引用是可达的，该对象就不会被释放<br>SoftRefenece，WeakReference，PhantomReference由强到弱排列，对应不同级别的“可获得性”，SoftReference用以实现内存敏感的高速缓存，weakReference是为了实现“规范映射”而设计的，，它不妨碍垃圾回收映射的“键”（或“值”），“规范映射”中对象的实例可以在程序的多处被同时使用，以节省内存空间，PhantomReference用于调度回收器的清理工作，它比Java终止机制更灵活<br>使用SoftReference和WeakReferenc时，可以选择是否将它们放入ReferenceQueue(用作垃圾回收前的清理工作的工具)，而PhantomReference只能依赖于ReferenceQueue<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VeryBig</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE=<span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span>[] la =<span class="keyword">new</span> <span class="keyword">long</span>[SIZE];</span><br><span class="line">    <span class="keyword">private</span> String ident;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VeryBig</span><span class="params">(String s)</span></span>&#123;ident=s;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123; <span class="keyword">return</span>  ident; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Finalizing"</span>+ident );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">References</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReferenceQueue&lt;VeryBig&gt; rf=<span class="keyword">new</span> ReferenceQueue();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Reference&lt;? extends VeryBig&gt; inq=rf.poll();</span><br><span class="line">        <span class="keyword">if</span>(inq!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"In Queue"</span>+inq.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size=<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(args.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            size=<span class="keyword">new</span> Integer(args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LinkedList&lt;SoftReference&lt;VeryBig&gt;&gt; sa=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            sa.add(<span class="keyword">new</span> SoftReference&lt;VeryBig&gt;(<span class="keyword">new</span> VeryBig(<span class="string">"Soft"</span>+i),rf));</span><br><span class="line">            System.out.println(<span class="string">"Just created"</span>+sa.getLast());</span><br><span class="line">            checkQueue();</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedList&lt;WeakReference&lt;VeryBig&gt;&gt; wa=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            wa.add(<span class="keyword">new</span> WeakReference&lt;VeryBig&gt;(<span class="keyword">new</span> VeryBig(<span class="string">"Weak"</span>+i),rf));</span><br><span class="line">            System.out.println(<span class="string">"Just created"</span>+wa.getLast());</span><br><span class="line">            checkQueue();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        SoftReference&lt;VeryBig&gt; s=<span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> VeryBig(<span class="string">"Soft"</span>));</span><br><span class="line">        WeakReference&lt;VeryBig&gt; w=<span class="keyword">new</span> WeakReference&lt;&gt;(<span class="keyword">new</span> VeryBig(<span class="string">"weak"</span>));</span><br><span class="line">        </span><br><span class="line">        System.gc();</span><br><span class="line">        </span><br><span class="line">        LinkedList&lt;PhantomReference&lt;VeryBig&gt;&gt; pa=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            pa.add(<span class="keyword">new</span> PhantomReference&lt;VeryBig&gt;(<span class="keyword">new</span> VeryBig(<span class="string">"Phantom"</span>+i),rf));</span><br><span class="line">            System.out.println(<span class="string">"Just created"</span>+pa.getLast());</span><br><span class="line">            checkQueue();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h3><p>容器类中有一种特殊的Map，即WeakHashMap,它被用来保存WeakReference，它使得规范映射更易于使用，在这种映射中，每个值只保存一份实例以节省存储空间，当程序需要那个“值”的时候，便在映射中查询现有的对象，然后使用它（而不是重新再创建），映射可将值作为其初始化的一部分，不过通常是在需要的时候才生成“值”<br>这是一种节省空间的技术，因为WeakHashMap允许垃圾回收器自动清理键和值，所以它显得十分便利，对于向WeakHashMap添加键和值的操作，则没有什么特殊的要求，映射会自动使用WeakReference包装它们，允许清理元素的触发条件是，不再需要此键，如下所示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Element</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String ident;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Element</span><span class="params">(String id)</span></span>&#123;ident=id;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span>  ident;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> ident.hashCode();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o <span class="keyword">instanceof</span>  Element &amp;&amp; ident==((Element)o).ident;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fianlzie</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Finalizing"</span>+getClass().getSimpleName()+ident);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Element</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Key</span><span class="params">(String id)</span></span>&#123;<span class="keyword">super</span>(id);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Value</span> <span class="keyword">extends</span>  <span class="title">Element</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Value</span><span class="params">(String id)</span></span>&#123;<span class="keyword">super</span>(id);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CanonicalMapping</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size=<span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">if</span>(args.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            size=<span class="keyword">new</span> Integer(args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        Key[]  keys=<span class="keyword">new</span> Key[size];</span><br><span class="line">        WeakHashMap&lt;Key,Value&gt; wm=<span class="keyword">new</span> WeakHashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">           Key k=<span class="keyword">new</span> Key(Integer.toString(i));</span><br><span class="line">           Value v=<span class="keyword">new</span> Value(Integer.toString(i));</span><br><span class="line">           <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">               keys[i]=k;<span class="comment">//save as "real"  reference</span></span><br><span class="line">           &#125;</span><br><span class="line">           wm.put(k,v);</span><br><span class="line">        &#125;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;完整的容器分类法&quot;&gt;&lt;a href=&quot;#完整的容器分类法&quot; class=&quot;headerlink&quot; title=&quot;完整的容器分类法&quot;&gt;&lt;/a&gt;完整的容器分类法&lt;/h2&gt;&lt;h2 id=&quot;填充容器&quot;&gt;&lt;a href=&quot;#填充容器&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="学习心得" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="http://yoursite.com/2018/10/19/%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2018/10/19/数组/</id>
    <published>2018-10-18T17:15:45.000Z</published>
    <updated>2018-10-19T14:00:01.932Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组为什么特殊"><a href="#数组为什么特殊" class="headerlink" title="数组为什么特殊"></a>数组为什么特殊</h2><p>java中有大量的方式可以持有对象，那么，到底是什么使数组变的与众不同？<br><strong>数组与其他种类容器之间的主要区别有三个方面：效率，类型和保存基本类型的能力</strong><br>效率：数组是一种效率最高的存储和随机访问对象引用序列的方式，数组就是一个线性序列，这使得元素访问非常快速，但是为了这种速度所付出的代价就是数组对象的大小被固定，这是一种典型的以空间换时间的取舍，数组的创建使得数组对象本身的存储空间被固定下来，因此，数组不能扩容，但是带来的好处确实，我们随机访问一个元素时非常快，因为虚拟机很容易就能定位到元素的内存地址<br>类型：在泛型之前，其他的容器类在处理对象时，都将它们视为没有具体类型，也就是说，它们将这些对象都当作Java中所有类的根类处理，这种做法在泛型之前是没有问题的，因为我们不应该将一个容器类指定为只能保存特定类型，如果如此的话，我们要创建大量的容器类，还有我们没有预见的容器类，这是不可能的，也是不现实的，因此将所有对象视为Object是合理的，但是这样的处理方式使得我们没有办法在编译期保证类型的正确性，只有在从容器中取出对象时才可能发现插入类型的不正确，泛型容器的出现，使得我们能够将类型检查放在编译期，从而解决了这个问题，数组对象本身对象的结构性天然的使得它具有只能持有类型正确对象的特性，也就是可以实现编译期的类型检查<br>持有基本类型：容器没有办法持有基本类型，这也很容易理解，因为一般基本类型对象的创建是在栈中，除非基本类型作为对象的属性存储在对象的内存空间内，容器类和数组存储结构最大的不同是在于，容器持有的对象并不在容器对象的内存空间中，它必须通过容器对象保存的元素的引用来访问元素对象，这些元素对象必须要被存储在堆中，所有造成了，容器不能持有（管理）基本类型，如果容器要想具有持有基本类型的能力必须通过包装器这种方式，而数组不同，数组的元素就存储在数组内存空间之中，这种特性很容易使得数组具有持有基本类型的能力<br>因为泛型和自动包箱和拆箱的出现，容器可以很容易的持有基本类型了，数组仅存的优点就是效率，可是使用数值又会受到太多的限制，所以一般情况下我们会选择使用容器而不是数组</p><h2 id="数组是第一级对象"><a href="#数组是第一级对象" class="headerlink" title="数组是第一级对象"></a>数组是第一级对象</h2><p>无论使用哪种类型的数组，数组标识符其实只是一个引用，指向堆中创建的一个真实对象，这个（数组）对象用以保存指向其他对象的引用（这里指的是引用数组），如果是基本类型数组，数组对象保存的是基本类型的值<br>只读成员length是数组对象的一部分（事实上，这是唯一yield可以访问的字段或方法），表示此数组对象可以存储多少元素，“[]”语法是访问数组对象元素的唯一方式<br>创建数组方式：</p><ol><li>作为数组初始化语法的一部分隐式创建，如 <code>String[] strs={&quot;hello&quot;,&quot;world&quot;}</code></li><li>使用new关键字显式地创建，如 <code>String[] strs = new String[2]</code>或者<code>String strs=new String[]{&quot;hello&quot;,&quot;world&quot;}</code></li></ol><p>有几个需要注意的地方：</p><ol><li>length只表示数组能够容纳多少个元素，也就是说length是数组大小（主要是用来做下标检查，并且不可变），而不是实际保存的元素的个数</li><li>数组创建时就已经完成了初始化，未被显式赋值的引用被初始化为null,基本类型被初始化为“零值<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><strong>创建多维数组很方便，对于基本类型的多维数组，可以通过使用花括号将每个向量分隔开</strong>，实际上多维数组中是通过每一维数组保存下一维数组对象的引用实现的<br>数组中的每个向量可以具有任意长度（这被称为粗糙数组）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RaggedArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        Random rand=new Random(<span class="number">47</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span>[][][] a=<span class="keyword">new</span> <span class="keyword">int</span>[rand.nextInt(<span class="number">7</span>)][][];<span class="comment">//创建数组时，第一维下标必须要被初始化，</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            a[i]=a[rand.nextInt(<span class="number">5</span>)];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;a[i].length;j++)&#123;</span><br><span class="line">                a[i][j]=<span class="keyword">new</span> <span class="keyword">int</span>[rand.nextInt(<span class="number">5</span>)];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.deepToString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="数组与泛型"><a href="#数组与泛型" class="headerlink" title="数组与泛型"></a>数组与泛型</h2><p>通常数组和泛型不能很好地结合，你不能实例化具有参数化类型的数组<br>    Peel<banana>[] peels=new Peel<banana>[10]//illegal<br><strong>擦除会移除参数类型信息，而数组必须知道它们所持有的确切类型，以强制保证类型安全</strong><br>但是，你可以参数化数组本身的类型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassParameter</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> T[] f(T[] arg)&#123; <span class="keyword">return</span>  arg;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodParameter</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] f(T[] arg)&#123;<span class="keyword">return</span> arg;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParameterizedArrayType</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Integer[] ints=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        Double[] doubles=&#123;<span class="number">1.1</span>,<span class="number">2.2</span>,<span class="number">3.3</span>,<span class="number">4.4</span>,<span class="number">5.5</span>&#125;;</span><br><span class="line">        Integer[] ints2=<span class="keyword">new</span> ClassParameter&lt;Integer&gt;().f(ints);</span><br><span class="line">        Double[] doubles2=<span class="keyword">new</span> ClassParameter&lt;Double&gt;().f(doubles);</span><br><span class="line">        Integer[] ints3=MethodParameter.f(ints);</span><br><span class="line">        Double[] doubles3=MethodParameter.f(doubles);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></banana></banana></p><p>注意，使用参数化方法而不使用参数化类的方便之处：你不必为需要应用的每种不同的类型都使用一个参数去实例化这个类，并且你可以将其定义为静态，当然，你不能总是选择使用参数方法而不是参数化类，但它应该成为首选<br>上面的例子证明了，不能创建泛型数组的这一说法并不准确，诚然，编译器确实不让你实例化泛型数组，但是，它允许你创建对这种数组的引用，例如<br>    List<string> list<br>这条语句可以顺利地通过编译器而不报任何错误，而且，尽管你不能创建实际的持有泛型的数组对象，但是你可以创建非泛型的数组，然后将其转型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayOfGenerics</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt;[] ls;</span><br><span class="line">        List[] la=<span class="keyword">new</span> List[<span class="number">10</span>];</span><br><span class="line">        ls=(List&lt;String&gt;[])la;<span class="comment">//"unchecked" warning</span></span><br><span class="line">        ls[<span class="number">0</span>]=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="comment">//ls[1]=new ArrayList&lt;Integer&gt;();compile-error checking produces an error</span></span><br><span class="line">        Object[] objects=ls;</span><br><span class="line">        <span class="comment">//compiles and runs without complaint</span></span><br><span class="line">        objects[<span class="number">1</span>]=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//howerve if your needs are straightforward it is</span></span><br><span class="line">        <span class="comment">//possible to create an array of generics,albeit("虽然")</span></span><br><span class="line">        <span class="comment">//with an "unchecked" warning</span></span><br><span class="line">        List&lt;BerylliumSphere&gt;[] spheres=(List&lt;BerylliumSphere&gt;[]) <span class="keyword">new</span> List[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;spheres.length;i++)&#123;</span><br><span class="line">   spheres[i]=<span class="keyword">new</span> ArrayList&lt;BerylliumSphere&gt;();</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></string></p><p>一旦拥有了对List<string>[]的引用，你就会看到你将得到某些编译器检查<br><strong>数组是协变类型的</strong>，因此向数组中添加元素，可以是数组声明类型的子类，这样在取出数组时，得到的是引用声明的类型，记住，<strong>引用类型主要是给编译器提供类型信息</strong><br>如果你知道将来不会向上转型，并且需求也相对简单，那么你仍旧可以创建泛型数组，它可以提供基本的编译期类型检查，但是，<strong>事实上，泛型容器总是比泛型数据更好的选择</strong><br>一般而言你会发现泛型在类或者方法的边界很有效，而在类或方法的内部，擦除通常会是泛型变得不适用，例如你不能创建泛型数组，如<code>new T[]</code>是错误的，因为数组的创建一定要确切的类型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayOfGenericType</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T[] array;<span class="comment">//is ok</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayOfGenericType</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="comment">//array=new T[size];  不可以创建泛型数组</span></span><br><span class="line">        <span class="comment">//所有对象的引用在堆中所占据的内存空间大小是一样的，所以我们先创建一个Object</span></span><br><span class="line">        <span class="comment">//的数组，给定size，数组在堆中分配的内存空间确定下来，我们将这个创建的数组</span></span><br><span class="line">        <span class="comment">//使用（T[]）进行转型，需要记住的这只是给了编译器一个转型提示，实际底层数组对象</span></span><br><span class="line">        <span class="comment">//头部保存的对象类型信息任何没有改变，它记录了自己保存的是Object类型的数据，</span></span><br><span class="line">        <span class="comment">//但是数组的引用类型指示了当向这个数组插入对象时进行类型检查需要的信息，以及在运行时</span></span><br><span class="line">        <span class="comment">//从数组中取出数据进行动态的类型转换</span></span><br><span class="line">        array=(T[])<span class="keyword">new</span> Object[size];<span class="comment">//unchecked warning </span></span><br><span class="line">        <span class="comment">//public &lt;U&gt; U[] makeArray()&#123; return; new U[10]&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></string></p><p>擦出再次成为了障碍——本例试图创建的类型以及被擦除了，因而是类型未知的数组，注意，你可以创建Obeject数组，然后将其转型，但是，如果没有@DSupressWarnings注解，你将在编译期得到一个“不受检查”的警告消息，因为这个组没有真正持有或动态检查类型T,也就是说，如果我创建了一个String[]，java在编译器和运行期都会强制我只能将String对象置于改数组中，如果创建的是Object数组，那么我可以将除基本类型之外的任何对象置于该数组</p><h2 id="创建测试数据"><a href="#创建测试数据" class="headerlink" title="创建测试数据"></a>创建测试数据</h2><p>通常，在实验数组和程序时，能够很方便地生成填充了测试数据的数组，将会很有帮助，我们来看看如何利用工具将数值和对象填充进数组</p><h3 id="Arrays-fill"><a href="#Arrays-fill" class="headerlink" title="Arrays.fill()"></a>Arrays.fill()</h3><p>java的标准类库Arrays有一个作用很有限的fill()方法，只能用一个填充各个位置，<strong>而针对对象而言，就是复制同一个引用来填充</strong>，可以填充整个数组，也可以填充数组的某个区域，但是由于只能使用单一的数值来调用Arrays.fill()，因此这个方法并没什么用</p><h3 id="数据生成器"><a href="#数据生成器" class="headerlink" title="数据生成器"></a>数据生成器</h3><p>为了灵活的方式创建更有趣的数组，我们使用Gererator的概念，如果某个工具使用了Generator,那么你就可以通过选择Generator的类型来创建任何类型的数据（这是策略模式的一个实例——每个不同的Generator都表示一个不同的策略）<br>首先创建这些包装器类嵌套在CountingGenerator类中，注意这里的包装器类只是为了区别各种生成器取和java类库包装器相同的名字而已，它们是在CountingGenerator中，且在不同的命名空间下，所以不是同一类型，这点注意，实现Generator<t>接口的next方法就可以了，如下，省写<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountingGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Boolean</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">java</span>.<span class="title">lang</span>.<span class="title">Boolean</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> value=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">public</span> java.lang.<span class="function">Boolean <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> !value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Byte</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">java</span>.<span class="title">lang</span>.<span class="title">Byte</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">byte</span> value=<span class="number">0</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> java.lang.<span class="function">Byte <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">char</span>[] chars=<span class="string">"abcdefghijklmnopqrstuvwlyz"</span>.toCharArray();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Character</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">java</span>.<span class="title">lang</span>.<span class="title">Character</span>&gt;</span>&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">public</span> java.lang.<span class="function">Character <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> chars[(index++)%chars.length];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span>  <span class="title">Generator</span>&lt;<span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> length=<span class="number">7</span>;</span><br><span class="line">        Generator&lt;java.lang.Character&gt; generator=<span class="keyword">new</span> Character();</span><br><span class="line">        <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">char</span>[] chars=<span class="keyword">new</span> <span class="keyword">char</span>[length];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">                chars[i]=generator.next();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Arrays.toString(chars);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></p><p>这些生成器大多都是这样的，实现generator接口的next()方法只是具体的实现不同而已</p><h3 id="从Generator中创建数组"><a href="#从Generator中创建数组" class="headerlink" title="从Generator中创建数组 ###"></a>从Generator中创建数组 ###</h3><p>为了接收Generator并产生数组，我们需要两个转换工具，一个工具使用任意的Generator来产生Object子类型的数组，为了处理基本类型，第二个工具接收任意基本类型的包装器类型数组，并产生相应的基本类型数组<br>我们看下第一个工具的两种选择，第一个使用重载的array方法，该方法接受一个已有的数组，并使用某个Generator填充它，而第二个版本接受一个Class对象（类型标记）,一个Generator和所需的元素数量，然后创建一个新数组，并使用所接收的Generator来填充它，注意这个工具只能阐释Object子类型的数组，而不能产生基本类型数组<br>因为泛型不能用于基本类型，而我们确实需要一个生成器来填充基本类型数组，很简单，先使用生成器生成包装器类型数组，然后通过一个转换器生成基本类型数组，所以我们要创建一个转换器类，里面有重载的转换方法接受不同类型的包装器数组，然后在方法内部创建基本类型数组，依次取出包装器数组的数据赋值即可，很简单，不写了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数组为什么特殊&quot;&gt;&lt;a href=&quot;#数组为什么特殊&quot; class=&quot;headerlink&quot; title=&quot;数组为什么特殊&quot;&gt;&lt;/a&gt;数组为什么特殊&lt;/h2&gt;&lt;p&gt;java中有大量的方式可以持有对象，那么，到底是什么使数组变的与众不同？&lt;br&gt;&lt;strong&gt;数组
      
    
    </summary>
    
      <category term="学习心得" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>泛型</title>
    <link href="http://yoursite.com/2018/10/14/%E6%B3%9B%E5%9E%8B/"/>
    <id>http://yoursite.com/2018/10/14/泛型/</id>
    <published>2018-10-14T11:22:59.000Z</published>
    <updated>2018-10-18T17:04:33.749Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一般的类和方法，只能使用具体的类型，要么是基本类型，那么是自定义的类，如果要编写可以应用与多种类型的代码，这种刻板的限制对代码的束缚就会很大<br>在面向对象语言中，动态算是一种泛化机制，你可以将方法的掺水设为基类，那么该方法就可以接受从这个基类中导出的任何类作为参数，这样的方法也更加通用些，可以应用的地方也更多些，但是考虑到除了final类不能被扩展，其他任何类都可以被扩展，所以这种灵活性大多时候也会有一些性能损耗<br>有时候，拘泥于单继承体系，也会使程序受限太多，如果方法的参数是一个接口，而不是一个类，这种限制就放松了很多，因为任何事实现了该接口的类都能满足该方法，这也包括了暂时还不存在的类，这给了客户端程序员一种选择，他可以选择实现一个接口来满足类或方法的<br>可是有时候，即使使用接口，对程序的约束也还是太强了，因为一旦指明了接口，它就要求你的代码必须使用特定的接口，而我们希望达到的目的是编写更通用的代码，要使代码能够用于“某种不具体的类型”而不是具体的接口或类<br>java SE5的重大变化之一，就是泛型的概念，泛型实现了参数化类型的概念，使代码可以应用于多种类型，“泛型”这个术语的意思就是：“适用于多种类型”，<strong>泛型在编程语言出现时，其最初的目的是希望类或方法能够具备更广泛的表达能力</strong>，如何做到这一点的呢？正是实现通过解耦类和方法与所使用的类型之间的解耦，扫后你将会看到，java中的泛型并没有那么高的追求<br>在学习了java的泛型之后，泛型确实是一个很好的补充，在你创建<strong>参数化类型</strong>的一个实例时，编译器会为你负责转型操作，并确保类型的正确性，这是一个进步<br>但是java中的泛型还没有能够做到像C++那样实现了纯粹的泛型，你不要对java的泛型期望太高，在java中使用一个别人已经建好的泛型类型很容易，但是如果自己创建一个泛型实例，就会遇到很多令人吃惊的事情  </p><h2 id="与C-d的比较"><a href="#与C-d的比较" class="headerlink" title="与C++d的比较"></a>与C++d的比较</h2><p>java的设计灵感来自于C++,那么先了解C++的泛型机制对理解java泛型有些帮助，了解C++魔板的某些方面，有助于你理解泛型的基础，你可以了解java泛型的局限是什么，已经为什么会有这些限制，最终的目的是帮助理解，java泛型的边界在哪里，理解了边界所在，你才会知道某个技术不能做什么，你才能更好地做到所能做的  </p><h2 id="简单泛化"><a href="#简单泛化" class="headerlink" title="简单泛化"></a>简单泛化</h2><p>许多的原因促使了泛型的出现，而最引人注目的一个原因，就是为了创造容器类，我们先来看下一个只能持有单一对象的类，当然这个对象可以明确指定其持有对象的类型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Automobile</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Automobile automobile;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">(Automobile automobile)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.automobile = automobile;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Automobile <span class="title">getAutomobile</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  automobile;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面自定义的容器类Holder，指定了只能存储Automobile这种类型的对象，这个类的可重用性就不怎么样，难道我们要为每一种类型都要创建一个像这样的容器类吗？当然不<br>在java SE5之前我们可以让一个类直接持有Object类型的对象，实际上，我们是使用了关于基类的编程，这要这个类能够应用于这个基类，那么基类的导出类也适用于这个代码，因为导出类本质上也是基类类型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder2</span><span class="params">(Object obj)</span></span>&#123;<span class="keyword">this</span>.obj=obj;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObj</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> obj;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Holder2 holder2=<span class="keyword">new</span> Holder2(<span class="keyword">new</span> Automobile());</span><br><span class="line">        Automobile automobile=(Automobile) holder2.getObj();</span><br><span class="line">        <span class="comment">//特别是这段代码，虽然getObj()返回的实际类型是Automolie类型，我们还是可以做转型操作，编译器才会发现类型转换失败</span></span><br><span class="line">        String s=(String) holder2.getObj();</span><br><span class="line">        holder2.setObj(<span class="string">"Not a Automoblie"</span>);</span><br><span class="line">        String str=(String) holder2.getObj();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~~~在有些情况下，我们确实希望容器具有能持有不同类型的能力，但是，通常情况下，我们希望使用容器来存储一种特定的类型，泛型的主要目的之一就是用来指定容器要持有什么类型的对象，而且由编译器来保证类型的正确性  </span><br><span class="line">因此，与其使用Object，我们更喜欢暂时不指定类型，而是稍后再决定具体使用什么类型，要达到这个目的，需要使用**类型参数**，用尖括号括住，放在类名后面，然后在什么这个类的时候，再用实际的类型替换此类型参数  </span><br><span class="line">~~~java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder3</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder3</span><span class="params">(T a)</span></span>&#123;<span class="keyword">this</span>.a=a;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T a)</span></span>&#123;<span class="keyword">this</span>.a=a;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> a;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Holder3&lt;Automobile&gt; h3=<span class="keyword">new</span> Holder3&lt;&gt;(<span class="keyword">new</span> Automobile());</span><br><span class="line">        Automobile automobile=h3.get();</span><br><span class="line">        <span class="comment">//h3.set(1);</span></span><br><span class="line">        <span class="comment">//h3.set("not a Automoblie");</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当你创建h3对象时，必须指明想要持有什么类型的对象，将其置于尖括号内，然后你就只能在Hold3中存入该类型（或者子类，多态和泛型不冲突，明确指定了泛型类型，那么这个类型的子类型也是该类型，基类与导出类的关系）<br>这就是java泛型的核心概念：告诉编译器想要什么什么类型，然后编译器处理一切   </p><h3 id="一个元祖类库"><a href="#一个元祖类库" class="headerlink" title="一个元祖类库"></a>一个元祖类库</h3><p>仅一次方法调用就返回多个对象，我们经常需要这个功能，可是return只能返回一个对象，因此解决办法就是创建一个对象，用它来持有想要返回的多个对象<br>难道我们每次都要创建这样的一个类，指定它能够保存的类型，所有每次需要保存不同类型的元组时，都要创建保存不同类型的类吗？<br>有了泛型，我们不需要这样做，这样一个类保存两种类型的对象，这个类在创建时才指定它需要用到的类型，同时我们在编译期就能确保类型安全<br>这个概念被称为“元组” ，它是将一组对象直接打包存储于其他的一个单一对象，这个容器对象允许读取其中元素，但是不允许向其中存放新的对象，这和对象就被称为<strong>数据传送对象或者信使 </strong><br>通常，元组可以具有任意长度，同时，元组中的对象可以是任意不同的类型，不过我们希望能够为每一个对象指明类型，并且从容器中读取出来时，能够得到正确的类型，看下下面的二维元组，它能够持有两个对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoTuple</span>&lt;<span class="title">A</span>,<span class="title">B</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> A first;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> B second;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TwoTuple</span><span class="params">(A a,B b)</span></span>&#123;</span><br><span class="line">        first=a;</span><br><span class="line">        second=b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">"("</span>+first+second+<span class="string">")"</span>;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>仔细看上面的代码，我们或许会疑惑，上面的代码违反了java编程的安全性原则，first和second应该被声明为private，然后提供getFirst()和getSecond()子类的访问方法才对，让我们看下这个例子的安全性，客户端程序可以读取fisrt和second，然后随心所欲的使用它们，但是，它们却无法赋值给first和second，因为final声明为你提供了相同的安全性，而且这种格式更简洁明了<br>还有另外一个设计考虑，你确实希望客户端程序员改变first或second所引用的对象，如果是这样的话，就强制程序员另外创建一个新的TwoTuple对象<br>我们可以利用继承机制实现长度更长的元组，下面的例子可以看到，增加类型参数是件很简单的事情<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeTuple</span>&lt;<span class="title">A</span>,<span class="title">B</span>,<span class="title">C</span>&gt; <span class="keyword">extends</span> <span class="title">TwoTuple</span>&lt;<span class="title">A</span>,<span class="title">B</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> C third;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreeTuple</span><span class="params">(A a,B b,C c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(a,b);</span><br><span class="line">        third=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">super</span>.toString()+third;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以看到下面的代码也可以编译通过，这两个代码定义的泛型的导出类是一样的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeTuple</span>&lt;<span class="title">D</span>,<span class="title">E</span>,<span class="title">C</span>&gt; <span class="keyword">extends</span> <span class="title">TwoTuple</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> C third;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreeTuple</span><span class="params">(D a,E b,C c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(a,b);</span><br><span class="line">        third=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">super</span>.toString()+third;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这表明了继承一个泛型类是，基类不一定要添加&lt;A,B&gt;这样的参数类型，导出类添加参数类型即可，实际上我们在定义导出类的泛型类型，而且参数类型只是一个占位符，名称无所谓，只要能够与内部的代码对应就好<br>元组代码测试<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TupleTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TwoTuple&lt;String,Integer&gt; <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span>  <span class="keyword">new</span> TwoTuple&lt;&gt;(<span class="string">"hi"</span>,<span class="number">46</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreeTuple&lt;Automobile,String,Integer&gt; <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span>  <span class="keyword">new</span> ThreeTuple&lt;&gt;(<span class="keyword">new</span> Automobile(),<span class="string">"hi"</span>,<span class="number">46</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      TwoTuple&lt;String,Integer&gt; ttsi=f();</span><br><span class="line">      System.out.print(ttsi);</span><br><span class="line">      ttsi.first=<span class="string">"can't change"</span></span><br><span class="line">      System.out.print(g());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="一个堆栈类"><a href="#一个堆栈类" class="headerlink" title="一个堆栈类"></a>一个堆栈类</h3><p>传统的下推堆栈，在之前的例子，我们是用一个LinkList实现的，LinkedListb本身具备了创建堆栈所需的所有方法<br>现在我们不用LinkedList，来实现自己的内部链式存储机制<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.generics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedStack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">U</span>&gt;</span>&#123;</span><br><span class="line">        U item;</span><br><span class="line">        Node&lt;U&gt; next;</span><br><span class="line">        Node()&#123;</span><br><span class="line">            item=<span class="keyword">null</span>;</span><br><span class="line">            next=<span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node(U item,Node&lt;U&gt; next)&#123;</span><br><span class="line">            <span class="keyword">this</span>.item=item;</span><br><span class="line">            <span class="keyword">this</span>.next=next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> item==<span class="keyword">null</span> &amp;&amp; next==<span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; top =<span class="keyword">new</span> Node&lt;T&gt;();<span class="comment">//哨兵</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T item)</span></span>&#123;</span><br><span class="line">        top=<span class="keyword">new</span> Node&lt;T&gt;(item,top);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        T result = top.item;</span><br><span class="line">        <span class="keyword">if</span>(!top.end())&#123;</span><br><span class="line">            top=top.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        LinkedStack&lt;String&gt; list=<span class="keyword">new</span> LinkedStack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String s:<span class="string">"Phasers on stun!"</span>.split(<span class="string">" "</span>))&#123;</span><br><span class="line">            list.push(s);</span><br><span class="line">        &#125;</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span>((s=list.pop())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到内部类Node也是一个泛型，它拥有自己的参数类型</p><h3 id="RandomList"><a href="#RandomList" class="headerlink" title="RandomList"></a>RandomList</h3><p>作为另一个例子，假设我们需要一个特定类型对象的列表，每次调用其上的select()方法时，它可以随机地选取一个元素，如果我们希望以此构建一个可以应用与各种类型的对象的工具，就需要泛型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;T&gt; storage=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Random random=<span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T item)</span></span>&#123;storage.add(item);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">select</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> storage.get(random.nextInt());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        RandomList&lt;String&gt; rs=<span class="keyword">new</span> RandomList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String s:<span class="string">"the queue broken brown fox"</span>.split(<span class="string">" "</span>))&#123;</span><br><span class="line">            rs.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            System.out.println(rs.select());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>泛型也可以应用于接口，例如生成器，这是一种专门负责创建对象的类，实际上，这是工厂方法设计模式的一种应用，不过，当使用生成器创建新的对象时，它不需要任何参数，而工厂方法需要参数，也就是说，生成器无需额外的信息就知道如何创建对象，<br>一般而言，一个生成器只定义一个方法，该方法用于产生新的对象，在这里就是next()方法<br><code>public interface Generator&lt;T&gt; {    T next();}</code><br>首先我们先创建一个Coffee类及其子类，我们将创建一个生成咖啡的生成器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id =counter++;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName()+id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Latte</span> <span class="keyword">extends</span> <span class="title">Coffee</span></span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mocha</span> <span class="keyword">extends</span>  <span class="title">Coffee</span></span>&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cappuccino</span> <span class="keyword">extends</span> <span class="title">Coffee</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Americano</span> <span class="keyword">extends</span> <span class="title">Coffee</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>在创建一个实现了生成器泛型接口和迭代器的coffee生成器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoffeeGenerator</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">Coffee</span>&gt;,<span class="title">Iterable</span>&lt;<span class="title">Coffee</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class[] types=&#123;Latte.class,Cappuccino.class,Americano.class,Mocha.class&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random random=<span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CoffeeGenerator</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CoffeeGenerator</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;size=a;&#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CoffeeIterator</span> <span class="keyword">implements</span>  <span class="title">Iterator</span>&lt;<span class="title">Coffee</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> counter=<span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> counter&gt;<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Coffee <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            counter--;</span><br><span class="line">            <span class="keyword">return</span> CoffeeGenerator.<span class="keyword">this</span>.next();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Coffee&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CoffeeIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Coffee <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Coffee) types[random.nextInt(types.length)].newInstance();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        CoffeeGenerator gen=<span class="keyword">new</span> CoffeeGenerator();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.out.println(gen.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们再来看下实现Generator泛型接口的另一个实现 Fibonacci数列<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fibonacci</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">next</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> fib(count++); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> fib(n-<span class="number">2</span>)+fib(n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们还想要更近一步，编写一个实现了Itearable的Fibonacci生成器，我们的第一个选择是重写这个类，可是我们并不是总能拥有代码的控制权，并且除非必要，我们也不愿重写代码，我们还有另一种选择，那就是创建一个适配器（adapter）来实现所需要的接口，有很多方法可以实现适配器模式，我们先来看看第一种吧，通过继承实现适配<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FibonacciAdapter</span> <span class="keyword">extends</span> <span class="title">Fibonacci</span> <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FibonacciAdapter</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;<span class="keyword">this</span>.n=n;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Integer&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;Integer&gt;()&#123;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> n&gt;<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                n--;</span><br><span class="line">                <span class="keyword">return</span> FibonacciAdapter.<span class="keyword">this</span>.next();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Integer i:<span class="keyword">new</span> FibonacciAdapter(<span class="number">10</span>))&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>泛型可以应用到整个类上，但同样的也可在类中包含参数化方法，这个方法所在的类可以是泛型类，也可以不是，也就是说，是否用于泛型方法，与其所在的类是否是泛型没有关系<br>一个基本的指导原则是：无论何时，只要你能做到，你就应该尽量使用泛型方法，也就是说，如果使用泛型方法可以取代将整个类泛型话，那么就应该值使用泛型方法，因为它可以使事情更清除明白，<strong>另外，对于一个static的方法而言，无法访问类的类型参数，所以，如果static方法需要使用泛型能力的话，就必须称为泛型方法</strong><br><strong>要定义泛型方法，只需要将泛型参数列表置于返回值之前</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericMothed</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">        System.out.println(x.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        GenericMothed gm=<span class="keyword">new</span> GenericMothed();</span><br><span class="line">        gm.f(<span class="string">""</span>);</span><br><span class="line">        gm.f(<span class="number">1</span>);</span><br><span class="line">        gm.f(<span class="number">1.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的GenericMothed类不是泛型类，尽管这个类和其内部的方法可以被同时参数化，<strong>在使用泛型类时，必须在创建对象的时候指定类型参数的值，而使用泛型方法的时候，通常不必指明参数类，因为编译器会为我们找出具体的类型，这被称为类型参数推断（type argument inference）</strong></p><h3 id="杠杆利用类型参数推断"><a href="#杠杆利用类型参数推断" class="headerlink" title="杠杆利用类型参数推断"></a>杠杆利用类型参数推断</h3><p>以前我们在使用泛型的时候，总是会抱怨需要向程序中添加更多的代码，现在编译器可以使得我们能够省略到对泛型参数列表的重复了，我们看下之前我们的代码的例子<br>    Map&lt;Person,List&lt;? extends Pet&gt;&gt; map=new HashMap&lt;Person,List&lt;? extends Pet&gt;&gt;();<br>现在可以这样写<br>    Map&lt;Person,List&lt;? extends Pet&gt;&gt; map=new HashMap&lt;&gt;();<br>参数类型推断也可以用在泛型方法中  下面的例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">New</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="function">Map&lt;K,V&gt; <span class="title">map</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HashMap&lt;K,V&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">list</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Map&lt;String,Integer&gt; map=New.map();</span><br><span class="line">        List&lt;String&gt; list=New.list();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>类型参数推断避免了重复的泛型参数列表<br>类型参数推断只对赋值有效，其他时候并不起作用，如果将一个泛型方法调用的结果作为参数，传递给另一个方法，这时编译器并不会执行类型推断，在这种情况下，编译器认为，调用泛型方法后，其返回值被赋给列哦一个Object类型的变量，<br>    f(New.map())//does not compile<br>应该这样说，编译器之所以能够进行类型推断的一个基本的条件是，编译器能够获得泛型参数的信息，将泛型方法的返回值直接赋给一个泛型类引用，可以通过这个泛型类引用的类型参数推断出泛型方法的泛型参数，但是如果将泛型方法的返回值直接传递给一个方法，编译器得不到指导  </p><h3 id="显示的类型说明"><a href="#显示的类型说明" class="headerlink" title="显示的类型说明"></a>显示的类型说明</h3><p>在泛型方法中，可以显式地指明类型，不过这种语法比较少见，<strong>要显示地指明类型，必须在点操作符与方法名之间插入尖括号，然后把类型置于尖括号内如果是在定义该方法的类的内部，必须在点操作符之前使用this关键字，如果是使用static的方法，必须在点操作符之前加上类名</strong><br>    f(New.&lt;String,Integer&gt;map());</p><h3 id="可变参数列表与泛型方法"><a href="#可变参数列表与泛型方法" class="headerlink" title="可变参数列表与泛型方法"></a>可变参数列表与泛型方法</h3><p>泛型和可变参数列表能够很好地共存<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericVarargs</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">makeList</span><span class="params">(T... args)</span></span>&#123;</span><br><span class="line">        List&lt;T&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(T item:args)&#123;</span><br><span class="line">            list.add(item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; ls=makeList(<span class="string">"A"</span>);</span><br><span class="line">        System.out.println(ls);</span><br><span class="line">        ls=makeList(<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>);</span><br><span class="line">        ls=makeList(<span class="string">"ABCDRFGHIJKMLNOPQRST"</span>.split(<span class="string">""</span>));</span><br><span class="line">        System.out.println(ls);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="用于Generator的泛型方法"><a href="#用于Generator的泛型方法" class="headerlink" title="用于Generator的泛型方法"></a>用于Generator的泛型方法</h3><p>下面的程序为任何类构造一个Generator，只要该类有没默认的构造器，并且构造器可访问<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicGenerator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; type;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BasicGenerator</span><span class="params">(Class&lt;T&gt; type)</span></span>&#123;</span><br><span class="line">        type=type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> type.newInstance();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Generator&lt;T&gt; <span class="title">create</span><span class="params">(Class&lt;T&gt; type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> BasicGenerator&lt;&gt;( type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面我们创建一个具有默认构造器的类，来测试上面的泛型生成器（generator<t>）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id=count++;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CounterObject</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">id</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> id;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">"CounterObject"</span>+id;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicGenertorDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Generator&lt;CounterObject&gt; gen=BasicGenerator.create(CounterObject.class);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            gen.next();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一个Set实用工具"><a href="#一个Set实用工具" class="headerlink" title="一个Set实用工具"></a>一个Set实用工具</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sets</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Set&lt;T&gt; <span class="title">union</span><span class="params">(Set&lt;T&gt; a,Set&lt;T&gt; b)</span> </span>&#123;</span><br><span class="line">        Set&lt;T&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;(a);</span><br><span class="line">        result.addAll(b);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Set&lt;T&gt; <span class="title">intersection</span><span class="params">(Set&lt;T&gt; a,Set&lt;T&gt; b)</span></span>&#123;</span><br><span class="line">        Set&lt;T&gt; result =<span class="keyword">new</span> HashSet&lt;&gt;(a);</span><br><span class="line">        result.retainAll(b);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Set&lt;T&gt; <span class="title">different</span><span class="params">(Set&lt;T&gt; superSet,Set&lt;T&gt; subSet)</span></span>&#123;</span><br><span class="line">        Set&lt;T&gt; result=<span class="keyword">new</span> HashSet&lt;&gt;(superSet);</span><br><span class="line">        result.removeAll(subSet);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Set&lt;T&gt; <span class="title">complement</span><span class="params">(Set&lt;T&gt; a,Set&lt;T&gt; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> different(union(a,b),intersection(a,b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>泛型还可以应用于内部类和匿名内部类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id =counter++;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Customer</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">"Customer"</span>+id;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Generator&lt;Customer&gt; <span class="title">generator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Generator&lt;Customer&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Customer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Customer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teller</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id=counter++;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Teller</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">"Teller"</span>+id;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Generator&lt;Teller&gt; <span class="title">create</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Generator&lt;Teller&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Teller <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Teller();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="构建复杂模型"><a href="#构建复杂模型" class="headerlink" title="构建复杂模型"></a>构建复杂模型</h2><p>泛型的一个重要好处就是能够简单而安全地创建复杂的模型，例如我们很容易地创建元组列表这样的结构<br>    class TupleList&lt;A,B,C,D&gt; extends List&lt;FourTuple&lt;A,B,C,D&gt;&gt;{}<br>下面这个示例，展示了使用泛型来创建复杂模型是多么简单，即使每个类都作为一个构建块创建，但是其整个还是包含很多部分，在这个例子中，构建一个零售商，它包含走廊，货架和商品<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Product</span><span class="params">(<span class="keyword">int</span> IDNumber,String descr,<span class="keyword">double</span> price)</span></span>&#123;</span><br><span class="line">        id= IDNumber;</span><br><span class="line">        description=descr;</span><br><span class="line">        price=price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id+<span class="string">":"</span>+description+price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">priceChange</span><span class="params">(<span class="keyword">double</span> price)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price=price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Generator&lt;Product&gt; generator=<span class="keyword">new</span> Generator&lt;Product&gt;() &#123;</span><br><span class="line">        <span class="keyword">private</span> Random rand=<span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Product <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Product(rand.nextInt(<span class="number">1000</span>),<span class="string">"Test"</span>,Math.round(rand.nextDouble()*<span class="number">1000</span>)+<span class="number">0.99</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shelf</span> <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">Product</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Shelf</span><span class="params">(<span class="keyword">int</span> nProduct)</span></span>&#123;</span><br><span class="line">        Generators.fill(<span class="keyword">this</span>,Product.generator,nProduct);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Aisle</span> <span class="keyword">extends</span>  <span class="title">ArrayList</span>&lt;<span class="title">Shelf</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Aisle</span><span class="params">(<span class="keyword">int</span> nShives,<span class="keyword">int</span> nProduct)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nShives;i++)&#123;</span><br><span class="line">            add(<span class="keyword">new</span> Shelf(nProduct));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Checkoutstand</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Office</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Store</span> <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">Aisle</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Checkoutstand&gt; checkoutstands= <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Office&gt; offices=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Store</span><span class="params">(<span class="keyword">int</span> nAisles,<span class="keyword">int</span> nShives,<span class="keyword">int</span> nProduct)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nAisles;i++)&#123;</span><br><span class="line">            add(<span class="keyword">new</span> Aisle(nShives,nProduct));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuilder stb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(Aisle aisle:<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(Shelf shelf:aisle)&#123;</span><br><span class="line">                <span class="keyword">for</span>(Product product:shelf)&#123;</span><br><span class="line">                    stb.append(product.toString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="擦除的神秘之处"><a href="#擦除的神秘之处" class="headerlink" title="擦除的神秘之处"></a>擦除的神秘之处</h2><p>当开始真正研究泛型的时候，会发现大量的东西初看起来是没有任何意义的，例如，尽管可以声明ArrayList.class。但是不能声明ArrayList<integer>.class 再看下面的例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErasedTypeEquivalence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Class c1=<span class="keyword">new</span> ArrayList&lt;String&gt;().getClass();</span><br><span class="line">        Class c2=<span class="keyword">new</span> ArrayList&lt;Integer&gt;().getClass();</span><br><span class="line">        System.out.println(c1==c2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></integer></p><p>ArrayList<string>与ArrayList<integer>很容易被认为是不同的类型，不同的类型在行为上肯定不同，比如尝试将一个Integer放入一个ArrayLIst<string>中，但是上面的程序确实认为它们是相同的<br>我们再来看一个例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Frob</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quark</span>&lt;<span class="title">Q</span>&gt;</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LostInformation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Map&lt;String,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Quark&lt;Frob&gt; quark=<span class="keyword">new</span> Quark&lt;&gt;();</span><br><span class="line">        System.out.println(Arrays.toString(list.getClass().getTypeParameters()));</span><br><span class="line">        System.out.println(Arrays.toString(map.getClass().getTypeParameters()));</span><br><span class="line">        System.out.println(Arrays.toString(quark.getClass().getTypeParameters()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*output</span></span><br><span class="line"><span class="comment">[E]</span></span><br><span class="line"><span class="comment">[K,V]</span></span><br><span class="line"><span class="comment">[Q]</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></string></integer></string></p><p>根据JDK文档的描述，<strong><code>Class.getTypeParameters()</code>将“返回一个TypeVariable对象数组”,表示有泛型声明所声明的类型参数…</strong>，这就好像是在暗示你可能发现参数类型的信息，但是，正是正如我们所看到的，我们发现的只是作为参数占位符的标识符，这并非是有用的信息<br>我的理解是，如果在我们第一次创建泛型类的对象的时候，传递给它的构造器一个参数类型，在这个类加载生成Class对象里能够保存这个参数类型的信息就好了，可是我们看到，事实并不是这样<br>因此，残酷的现实是：<br><strong>在泛型代码内部，无法获得任何关于泛型参数类型的信息</strong><br>你可以知道诸如类型参数标记和泛型类型边界这类的信息——你却无法知道用来创建某个特定实例的实际的类型参数<br>java泛型是使用擦除来实现的，这意味着当你在使用泛型时，任何具体的类型信息都被擦除了</p><h3 id="C-的方式"><a href="#C-的方式" class="headerlink" title="C++的方式"></a>C++的方式</h3><p>下面是使用模板的C++示例<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Manipulate</span>&#123;</span></span><br><span class="line"> T obj;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Manipulate(T x)&#123;obj=x;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">mainpulate</span><span class="params">()</span></span>&#123;obj.f();&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasF</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"HasF::f()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  HasF hf;</span><br><span class="line">  manipulate&lt;HasF&gt; manipulate(hf)；</span><br><span class="line">  manipulate.manipulate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*output</span></span><br><span class="line"><span class="comment">HasF::f()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p>Manipulate类存储了一个类型T的对象，有意思的地方是manipulate()方法，它在obj上调用f(),它怎么知道f()方法时为类型参数T而存在的呢？当你实例化一个模板时，C++编译器将会进行检查，因此在Manipulate<hasf>被实例化的那一刻，它看到HasF拥有一个f()方法，否则，就会得到一个编译器错误，这样类型安全就会得到保障<br>我们可以将上面的代码用java的方式重写一次，可是这会出现问题，因此擦除的原因，代码内部并不清楚参数类型是什么？我们就没办法去编写类似obj.f()这样的代码<br>为了能够调用f()，我们必须帮助泛型类，给定泛型类的边界，以表示编译器只能接受遵循这个边界的类型，有可以保证给泛型关于参数类型的信息，<br>在这里我们重用extends这个关键字<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manipulate</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">HasF</span>&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> T obj;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Manipulate</span><span class="params">(T x)</span></span>&#123;obj=x;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">manipulate</span><span class="params">()</span></span>&#123;obj.f();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></hasf></p><p>边界<t extends="" hasf=""> 声明T必须具有类型HasF或者从HasF导出的类，如果情况确实如此，就可以安全地使用obj.f()了<br>我们说泛型参数将擦除到它的第一个边界（它可能会有多个边界），我们还提到了类型参数的擦除，编译器实际上会把类型参数替换为它的擦除，就像上面的例子一样，T擦除到了HasF，就好像在类的声明中用HasF替换了T一样<br>我们有看到了，在上面的一个提过了泛型的例子好像并没有贡献什么好处，只需要很容易地自己去执行擦除，就可以创建没有泛型的类，而且代码也比较泛化，看下一个我们主动执行擦除的例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manipulate</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> HasF obj;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Manipulate</span><span class="params">(HasF x)</span></span>&#123;obj=x;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">manipulate</span><span class="params">()</span></span>&#123;obj.f();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></p><p>这给来哦我们很重要的启示，<strong>只有当你希望使用的类型参数比某个具体类型（以及它所有的子类类型）更加“泛化”的时——也就是说，当你希望代码能够跨越多个类工作时，使用泛型才有所帮助</strong><br><strong>但是</strong>，我们也不要认为<t extends="" hasf="">形式的任何东西都是有缺陷的，例如，如果某个类有一个返回T的方法，那么泛型就会非常有用，因为在使用这个泛型类的时候，泛型参数给了编译器提示，编译器很容易会将T转换为我们使用泛型时指定的参数类型，可以帮助我们很轻松的解决返回值的转型问题  </t></p><h3 id="迁移兼容性"><a href="#迁移兼容性" class="headerlink" title="迁移兼容性"></a>迁移兼容性</h3><p>为了减少潜在的关于擦除的混淆，你必须清楚地认识到这不是一个语言特性，它是java的泛型实现的一种折中，因为泛型不是java语言出现时就有的组成部分，所以这种折中是必须的，虽然它会让你很痛苦<br>擦除减少了泛型的泛化性，泛型在java中仍然有用，但是不如它们本来设想的那么有用，而原因就是擦除<br>在基于擦除的实现中，泛型类型被当作第二类类型处理，即不能在某些重要的上下文环境中使用的类型，<strong>泛型类型只有在静态类型检查期间才出现，在此之后，程序中的所有泛型类型都被擦除，替换为它们的非泛型上界</strong>，例如List<t>这样的类型注解将被擦除为List,而普通的类型变量在未指定边界的情况下将被擦除为Object<br><strong>擦除的核心动机是它使得泛化的客户端可以用非泛化的类库来使用，反之亦然，这经常被称为“迁移兼容性”</strong> 在现实中，即使程序员只编写泛型代码，他们也必须处理在Java SE5之前编写的非泛化类库，这些类库饿作者可能从没想过要泛化它们的代码，或者可能刚刚接触泛型<br><strong>因此java泛化不仅必须支持向后兼容性，即现有的代码和类文件仍旧合法 </strong>（这句话的意思是，在泛化之前出现的类库，那些代码并没有考虑使用泛化的情况，如果我们为了使用泛化，那么就无法使用之前以及创建好的而且很成熟的类库了，为了增加泛化特性，就要抛弃以往已经被实践所验证的代码库，即使是对现有代码库进行修改这样代价也太大了）</t></p><h3 id="擦除的问题"><a href="#擦除的问题" class="headerlink" title="擦除的问题"></a>擦除的问题</h3><p>因此，擦除主要的正当理由是从非泛化代码到泛化代码的转变过程，以及在不随意破坏现有类库的情况下，将泛型融入到java语言，擦除使得现有的非泛型客户端代码能够在不改变的情况下继续使用，直至客户端准备好用泛型重写这些代码，这是一个崇高的动机，因为它不会破坏所有现有的代码<br>擦除的代价是显著的，<strong>泛型不能被显式地被引用至运行时类型的操作之中</strong>，例如转型，instanceOf操作和new表达式，因为所有有关参数的类型信息都丢失了，无论何时，<strong>当你在编写泛型代码的时候，必须时刻提醒自己，你只是看起来好像拥有有关参数的类型信息而已</strong><br>    Foo<cat> foo=new Foo<cat>();<br>class Foo中代码应该知道现在工作于Cat之上，而泛型语法也在强烈地暗示，在整个类的各个地方，类型都在被替换，<strong>但是事实并非如此</strong>，无论何时，当你编写这个代码的时，时刻提醒自己“不，它只是个Object”<br>另外，擦除和迁移兼容性意味着，使用泛型并不是强制的，尽管你可能希望这样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericBasic</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T element;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  T <span class="title">getElement</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> element;&#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setElement</span><span class="params">(T x)</span></span>&#123;element=x;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived1</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">GenericBasic</span>&lt;<span class="title">T</span>&gt;</span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived2</span> <span class="keyword">extends</span> <span class="title">GenericBasic</span></span>&#123;&#125; <span class="comment">//no Warning没有警告</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErasuereAndInheritance</span> </span>&#123;</span><br><span class="line">    Derived2 d2=<span class="keyword">new</span> Derived2();</span><br><span class="line">    Object obj=d2.getElement();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//d2.set(obj) //warning here  在这里警告</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></cat></cat></p><h3 id="边界处的动作"><a href="#边界处的动作" class="headerlink" title="边界处的动作"></a>边界处的动作</h3><p>正因为有了擦除，泛型最令人困惑的方面源于这样一个事实，即可以表示没有任何意义的事物 ，例如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayMaker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; type;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayMaker</span><span class="params">(Class&lt;T&gt; type)</span></span>&#123;type=type;&#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    T[] create(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">return</span> (T[])Array.newInstance(type,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ArrayMaker&lt;String&gt; stringMaker=<span class="keyword">new</span> ArrayMaker&lt;&gt;(String.class);</span><br><span class="line">        String[] stringArray=stringMaker.create(<span class="number">10</span>);</span><br><span class="line">        System.out.println(Arrays.toString(stringArray));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[null,null,null,null,null,null,null,null,null,null]</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p><p>即使type被存储为Class<t>,**擦除也意味着它将被存储为Class,没有任何参数，因此，当你使用它的时候，例如在创建数组时，Array.newInstance()实际上并未拥有kind所蕴含的类型信息，因此它不会产生具体的结果，所以必须转型，这将产生一条令你无法满意的警告<br>注意，对于在泛型中创建数组，使用Array.newInstance()是推荐的方式<br>如果我们要创建一个容器而不是一个数组，情况就有些不同了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListMaker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">create</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//指定了参数类型，实际上就是给了编译器的一个指示，以使得编译期的静态类型检查和转型代码的插入</span></span><br><span class="line">        ListMaker&lt;String&gt; listMaker=<span class="keyword">new</span> ListMaker&lt;T&gt;();</span><br><span class="line">        List&lt;String&gt; list=listMaker.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></p><p>编译器不会给出任何警告，尽管我们知道在create()内部的new ArrayList<t>的T被移除了——在运行时，这个类的内部没有任何<t>,因此看起来毫无意义，但是如果你遵从这种思路，并将这个表达式改为new ArrayList()编译器就会给出警告<br>是否真的毫无意义呢？如果返回list之前，将某些对象放入其中，就像下面这样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilledListMaker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">create</span><span class="params">(T item,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        List&lt;T&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            list.add(item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        FilledListMaker&lt;String&gt; fl=<span class="keyword">new</span> FilledListMaker&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; list=fl.create(<span class="string">"hello"</span>,<span class="number">4</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></t></p><p><strong>即使，编译器无法知道有关create()中的T信息，但是它仍旧可以在编译期确保你放置到result中的对象具有T类型，使其合适ArrayList<t>,因此，即使擦除在方法或者类内部移除了有关实际类型的信息，编译器仍旧可以确保在方法或类中使用的类型的内部一致性</t></strong><br><strong>因为擦除在方法体中移除了类型信息，所以在运行时的问题就是边界，即对象进入和离开方法的地点，这些正是编译器在编译期执行类型检查并插入转型代码的地点</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObj</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> obj;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">(Object obj)</span></span>&#123;obj=obj;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以使用javap-c SimpleHolder反编译这个代码<br>我们再来看下下面的代码，除了类名和添加了类型参数之外，和上面的代码几乎完全一样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericHolder</span> &lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  T <span class="title">getObj</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> obj;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">(T x)</span></span>&#123;obj=x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        GenericHolder&lt;String&gt; gen =<span class="keyword">new</span> GenericHolder&lt;&gt;();</span><br><span class="line">        gen.setObj(<span class="string">"hello"</span>);</span><br><span class="line">        String str=gen.getObj();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们再来反编译上面的代码，可以看出，转型是在调用get()的时候接受检查的，从get()返回之后的转型消失，但是我们还知道传递给set()的值在编译期接收检查<br>从上面的例子，我们可以得出这样的结论，在使用泛型类的时候，指定参数类型信息，其实是给编译器一个指示，通过添加的参数类型信息，编译器在编译过程中，会主动进行类型检查和添加转型代码，但是在运行期，参数类型信息被擦除<br>所以在泛型中的所有动作都发生在边界处——对传递进来的值进行额外的编译期类型检查，并插入对传递出去的值的转型，这有助于我们澄清对擦除的混淆，记住，<strong>边界是发生动作的地方</strong></p><h2 id="擦除的补偿"><a href="#擦除的补偿" class="headerlink" title="擦除的补偿"></a>擦除的补偿</h2><p><strong>擦除丢失了在泛型代码中执行某些操作的能力，任何运行是需要知道确切类型信息的操作都无法工作</strong> 如下例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Erased</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE=<span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Object args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args <span class="keyword">instanceof</span> T)&#123;&#125;<span class="comment">//error</span></span><br><span class="line">        <span class="keyword">new</span> T();<span class="comment">//error</span></span><br><span class="line">        T[] array=<span class="keyword">new</span> T[SIZE];<span class="comment">//error</span></span><br><span class="line">        T[] array=(T) <span class="keyword">new</span> Object[SIZE];<span class="comment">//unckecked warning</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>偶尔可以绕开这些问题，<strong>但是有时必须通过引入类型标签来对擦除进行补偿，这意味着你需要显式地传递你的类型的Class对象，以便你可以在类型表达式中使用它</strong><br>如前面的例子中使用instanceof的尝试失败了，因为其类型信息已经被擦除了，如果引入类型标签，就可以转而使用动态的isInstance();<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassTypeCapture</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; type;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassTypeCapture</span><span class="params">(Class&lt;T&gt; type)</span></span>&#123;type=type;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">f</span><span class="params">(Object arg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  type.isInstance(arg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ClassTypeCapture&lt;String&gt; ct=<span class="keyword">new</span> ClassTypeCapture&lt;&gt;(String.class);</span><br><span class="line">        <span class="keyword">boolean</span> b=ct.f(<span class="string">"hello"</span>);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译器将确保类型标签可以匹配任何泛型参数</p><h3 id="创建类型实例"><a href="#创建类型实例" class="headerlink" title="创建类型实例"></a>创建类型实例</h3><p><strong>在Erased.java中创建一个new T()的尝试将无法实现，部分原因是因为擦除，而另一部分原因是因为编译器不能验证T具有默认（无参）构造器</strong><br>在C++中，这种操作是很自然且直观的因为它在编译期受到检查<br>java中的解决办法是传递一个工厂对象，并用它来创建新的实例，最便利的工厂对象就是Class对象，因此如果使用类型标签，那么你就可以使用new Instance（）来创建这个类型的新对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassAsFactory</span> &lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T x;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassAsFactory</span><span class="params">(Class&lt;T&gt; type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            x = type.newInstance();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstantiateGenericType</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ClassAsFactory&lt;Employee&gt; fe=<span class="keyword">new</span> ClassAsFactory&lt;&gt;(Employee.class);</span><br><span class="line">        System.out.println(<span class="string">"ClassAsFactory&lt;Employee&gt; succeeded"</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ClassAsFactory&lt;Integer&gt; ci=<span class="keyword">new</span> ClassAsFactory&lt;&gt;(Integer.class);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"ClassAsFactory&lt;Integer&gt; failed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这可以编译，但是会因为ClassAsFactory<integer>而失败，因为Integer没有默认构造器，因为这个错误不是在编译器捕获的，所以这种方式使用泛型创建对象并不太好，我们没有尽最大的努力将错误隔绝在编译期，<br>Sun建议使用显式的工厂，并限制其类型，使得只能接受实现了这个工厂的类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">FactoryI</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo2</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T x;</span><br><span class="line">    <span class="keyword">public</span> &lt;F extends FactoryI&lt;T&gt;&gt; Foo2(F factory)&#123;<span class="comment">//这里是重点，确保传递的参数必须是那些可向上转型为FactoryI的的类型</span></span><br><span class="line">        x=factory.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntegerFactory</span> <span class="keyword">implements</span> <span class="title">FactoryI</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;  <span class="comment">//这些类都实现料Factory接口，使得对象的创建得到了保证</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span>  Integer <span class="title">create</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> Integer(<span class="number">0</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">FactoryI</span>&lt;<span class="title">Widget</span>&gt;</span>&#123;  <span class="comment">//Widget.Factory也是实现了FcatoryI的接口</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Widget <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Widget();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryConstraint</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Foo2&lt;Integer&gt;(<span class="keyword">new</span> IntegerFactory());</span><br><span class="line">        <span class="keyword">new</span> Foo2&lt;Widget&gt;(<span class="keyword">new</span> Widget.Factory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></integer></p><p>注意，这确实是传递Class<t>的一种变体，两种方式都传递了工厂对象，Class<t>碰巧是内建的工厂对象，而上面的方式创建了一个显式的工厂对象，但是你却获得了编译器检查<br>另一种方式是模板方法设计模式，在这个示例中，get是模板方法，而create()是在子类中定义的，用来产生子类类型的对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericWithCreate</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> T element;</span><br><span class="line">    GenericWithCreate()&#123;</span><br><span class="line">        element=create();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> T <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Creator</span> <span class="keyword">extends</span> <span class="title">GenericWithCreate</span>&lt;<span class="title">X</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">X <span class="title">create</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> X();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(element.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreatorGeneric</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Creator creator= <span class="keyword">new</span> Creator();<span class="comment">//在创建导出类对象的时候,element就得到了初始化，</span></span><br><span class="line">        creator.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></t></p><h3 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h3><p>Erased.java看到，不能创建泛型数组，一般的解决办法是在任何想要创建泛型数组的地方都使用ArrayList<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListOfGeneric</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; array=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T item)</span></span>&#123;</span><br><span class="line">        array.add(item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> array.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是有时你仍然想要创建泛型类型的数组，<br>数组将会跟着它们的实际类型，而这个类型是在数组被创建时确定的，因此，即使gia已经被转型为Generic<integer>[],但是这个信息只存在与编译器，在运行时，它仍然是Object数组，而这将会引起问题，成功创建泛型数组的唯一方式就是创建一个被擦除类型的新数组，然后对其转型<br>因为有了擦除，数组在运行时类型就只能是Object[],如果我们立即将其转型为T[]，那么在编译器该数组的实际类型就会丢失，而编译器可能会错过某些潜在的错误检查，正因这样，最好是在集合内部使用Object[]，然后当你使用数组元素时，添加一个对T的转型，让我们看下面这个例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericArray2</span> &lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] array;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericArray2</span><span class="params">(<span class="keyword">int</span> sz)</span></span>&#123;</span><br><span class="line">        array=<span class="keyword">new</span> Object[sz];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> index,T item)</span></span>&#123;</span><br><span class="line">        array[index]=item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"Unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;<span class="keyword">return</span> (T)array[index];&#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"Unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> T[] rep()&#123;</span><br><span class="line">        <span class="keyword">return</span> (T[])array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        GenericArray2&lt;Integer&gt; gia=<span class="keyword">new</span> GenericArray2&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            gia.put(i,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.out.println(gia.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Integer[] ia=gia.rep();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></integer></p><p>初看起来没什么太多变化，只是转型挪了地方，如果没有@SuppressWranings注解，你依然会得到unchecked警告，但是，现在的内部表示是Object而不是T[],<strong>当get()被调用的时，它将对象转型为T,这实际上是正确的类型，因此也是安全的，然而，如果你调用rep()，它还是尝试着将Object数组转型为T[],这仍旧不正确的，将在编译器生成警告，在运行时产生异常，因此，没有任何方式可以推翻底层的数组类型，它只能是Object[],</strong>在内部将array当作Object[]而不是T[]处理的优势是，我们不太可能忘记这个数组的运行时类型，从而意外地引入缺陷（尽管大多数也可能是所有这类缺陷都可以在运行时快速地探测到）<br>对于新代码，应该传递一个类型标记，在这种情况下，GenericArray看起来应该像下面这样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericArrayWithToken</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"Unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericArrayWithToken</span><span class="params">(Class&lt;T&gt; type,<span class="keyword">int</span> sz)</span></span>&#123;</span><br><span class="line">        array=(T[]) Array.newInstance(type,sz);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> index,T item)</span></span>&#123;</span><br><span class="line">        array[index]=item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T[] rep()&#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        GenericArrayWithToken&lt;Integer&gt; gia=<span class="keyword">new</span> GenericArrayWithToken&lt;&gt;(Integer.class,<span class="number">10</span>);</span><br><span class="line">        Integer[] ia=gia.rep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>注意，Class<t>被传递到构造器，以便从擦除中恢复，使得我们可创建需要的实际类型的数组</t></strong>，由此，也可以看出，rep()返回的数组被Integer[]捕获在运行期也没有问题，因为数组底层是type类型的元素，数组的创建也是以type为元素类型创建的，所以没有任何问题，所有从这里也可以看出来，数组类型和数组元素类型是不相同的两个概念</p><h2 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h2><p><strong>边界使得你可以在用于泛型的参数类型上设置限制条件，尽管这样使得你可以强制规定泛型可以应用的类型，但是潜在的一个更重要的效果是你可以按照自己的边界类型调用方法</strong><br><strong>因为擦除移除了类型信息，所有，可以用无界泛型参数调用的方法只是那些可以用Object调用的方法，但是，如果能够将这个参数限制为某个参数子集，那么你就可以用这些类型子集来调用方法，为了执行这种限制，java重用了extends关键字</strong>，对你来说有一点很重要，即要理解extends关键字在泛型边界上下文环境中和在普通情况下所具有的意义是完全不同的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">HasColor</span></span>&#123;</span><br><span class="line">    <span class="function">Color <span class="title">getColor</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Colored</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">HasColor</span>&gt;</span>&#123;</span><br><span class="line">    T item;</span><br><span class="line">    Colored(T item)&#123; item=item;&#125;</span><br><span class="line">    <span class="function">T <span class="title">getItem</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item;&#125;</span><br><span class="line">    <span class="function">Color <span class="title">getColor</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item.getColor();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dimnension</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x,y,z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColoredDimension</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Dimnension</span> &amp; <span class="title">HasColor</span>&gt;</span>&#123;</span><br><span class="line">    T item;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ColoredDimension</span><span class="params">(T item)</span></span>&#123;</span><br><span class="line">        item=item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">getItem</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item;&#125;</span><br><span class="line">    <span class="function">Color <span class="title">getColor</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item.getColor() ;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item.x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span></span>&#123;<span class="keyword">return</span>  item.y;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getZ</span><span class="params">()</span></span>&#123;<span class="keyword">return</span>  item.z;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Weight</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">weight</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solid</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Dimnension</span> &amp; <span class="title">HasColor</span> &amp; <span class="title">Weight</span>&gt;</span>&#123;</span><br><span class="line">    T item;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solid</span><span class="params">(T item)</span></span>&#123;</span><br><span class="line">        item=item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">getItem</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item;&#125;</span><br><span class="line">    <span class="function">Color <span class="title">getColor</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item.getColor();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item.x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">weight</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item.weight();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bounded</span> <span class="keyword">extends</span> <span class="title">Dimnension</span> <span class="keyword">implements</span> <span class="title">HasColor</span>,<span class="title">Weight</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Color <span class="title">getColor</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">weight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicBounds</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Solid&lt;Bounded&gt; solid=<span class="keyword">new</span> Solid&lt;&gt;(<span class="keyword">new</span> Bounded());</span><br><span class="line">        solid.getColor();</span><br><span class="line">        solid.weight();</span><br><span class="line">        solid.getX();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面是一个很简单的一个例子，我们创建里一个泛型类，这个泛型类能够接受的类型必须是 <code>extends Diamension &amp; HasColor &amp; Weight</code>的，这种对参数类型进行限定的方式，因为编译器的静态类型检查，我们可以很安全的使用这些基类或接口的方法<br>下面例子，看看如何在继承的每个层次上添加边界限制<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HoldItem</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    T item;</span><br><span class="line">    HoldItem(T item)&#123;</span><br><span class="line">        item=item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Colored2</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">HasColor</span>&gt; <span class="keyword">extends</span> <span class="title">HoldItem</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    Colored2(T item)&#123;<span class="keyword">super</span>(item);&#125;</span><br><span class="line">    <span class="function">Color <span class="title">getColor</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item.getColor();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColoredDimension2</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Dimnension</span> &amp; <span class="title">HasColor</span>&gt; <span class="keyword">extends</span> <span class="title">Colored</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">      ColoredDimension2(T item)&#123;<span class="keyword">super</span>(item);&#125;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item.x;&#125;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span></span>&#123;<span class="keyword">return</span>  item.y;&#125;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getZ</span><span class="params">()</span></span>&#123;<span class="keyword">return</span>  item.z;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solid2</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Dimnension</span> &amp; <span class="title">HasColor</span> &amp; <span class="title">Weight</span>&gt; <span class="keyword">extends</span> <span class="title">ColoredDimension2</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    Solid2(T item)&#123;<span class="keyword">super</span>(item);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">weight</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item.weight();&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritBounds</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Solid2&lt;Bounded&gt; solid2=<span class="keyword">new</span> Solid2&lt;&gt;(<span class="keyword">new</span> Bounded());</span><br><span class="line">        solid2.getColor();</span><br><span class="line">        solid2.getX();</span><br><span class="line">        solid2.weight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>HoldItem持有一个对象，因此这种行为被继承到了Color2中，它也要求其参数与HasColor一致，</strong>或者说参数类型要与HoldItem的参数限定的保存一致，这样才能继承基类那些涉及到限定参数类型的方法</p><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><p>我们首先先看一下数组的一种特殊行为，可以向导出类型的数组赋予基类型的数据引用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CovariantArrays</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Fruit[] fruits=<span class="keyword">new</span> Apple[<span class="number">10</span>];</span><br><span class="line">        fruits[<span class="number">0</span>] = <span class="keyword">new</span> Apple();</span><br><span class="line">        fruits[<span class="number">1</span>] = <span class="keyword">new</span> Jonathan();</span><br><span class="line">        <span class="comment">//runtime type is Apple[],not Fruit[] or Orange[]</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            fruits[<span class="number">0</span>]=<span class="keyword">new</span> Fruit();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123; System.out.println(e);&#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            fruits[<span class="number">0</span>]=<span class="keyword">new</span> Orange();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;System.out.println(e);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>main()第一行创建了一个Apple数组，并将其赋值给一个Fruit数组引用，这是有意义的，因为Apple也是一种Fruit，因此Apple数组应该也是Fruit数组<br><strong>但是，如果实际的数组类型是Apple[],你应该只能往里面放Apple或者Apple的子类型，这在编译器和运行期都可以工作</strong>，但是请注意，编译器允许你将Fruit放置到这个数组，这对于编译器是有意义的，因为它有一个Fruit引用——它有什么理由拒绝将Fruit对象或者任何从Fruit继承出来的对象呢放置到这个数组中呢？因此，编译期，这是允许的，但是，运行时的数组机制知道它处理的是Apple[],因此会向数组中放置异构类型是抛出异常<br>我的理解是这样的，数组和其他的对象是不同的，数组对象中的元素所在的内存空间就在数组对象的内存空间呢，当数组对象创建完成后数组的内存空间，所保存的元素的类型信息就已经定下来了，不能改变，那么这也保证了数组不能保存异构类型的元素<br>实际上，向上转型不适合用在这里，你真正做的是将一个数组赋值给另一个数组，数组行为应当是它可以持有其他对象，这里只是因为我们能够向上转型而已，所有很明显，数组对象可以保留有关它们包含的对象类型的规则，就好像数组对它们持有的对象是有意识的，因此在编译器检查和运行时检查之间，你不能滥用它们<br>对数组的这种滥用并不那么可怕，因为在运行时可以发现你已经插入了不正确的类型，<strong>但是泛型的主要目标之一就是将这种错误检测移到编译期</strong>，因此当我们试图使用泛型容器来替代数组时，会发生什么？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//compile error</span></span><br><span class="line">List&lt;Fruit&gt; fruit=<span class="keyword">new</span> ArrayList&lt;Apple&gt;()</span><br></pre></td></tr></table></figure></p><p>尽管你在第一次阅读这段代码时会认为：“不能讲一个Apple容器赋值给一个Fruit容器”，别忘了，<strong>泛型不仅和容器相关正确的说法是：“不能把一个涉及Apple的泛型赋给一个设计Fruit的泛型</strong>”，如果就像在数组中的情况一样，编译器对代码的了解足够多，可以确定所涉及的容器，那么它可能留有一些余地，但是它不知道任何有关这方面的信息，因此它拒绝向上转型，<strong>实际上，这里也不是向上转型—</strong>—Apple的List不是Fruit的List，Apple的List将持有Apple和Apple的子类型，而Fruit的List将持有任何类型的Fruit,诚然，这包括Apple，一个Apple的List，它仍然是Fruit的List，Apple的List在类型上不等价于Fruit的List,即使Apple是一种Fruit类型，我们还记得运行时类型信息讲过的<code>Class&lt;Number&gt; Nclass=Integer.class</code>会引发编译错误也是这个原因<br><strong>真正的问题是我们在谈容器的类型，而不是容器持有的类型</strong>，与数组不同，泛型没没有内建的协变类型，这是因为数组在语言上是完全定义的，因为可以内建了编译期和运行时的检查，但是，<strong>在使用泛型时，编译器和运行时系统都不知道你想用类型做些什么，以及应该采用什么样的规则</strong><br>但是有时你想要在两个类型之间建立某种类型的向上转型关系，这正是通配符所允许的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericAndCovariance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;? extends Fruit&gt; fruit=<span class="keyword">new</span> ArrayList&lt;Apple&gt;();</span><br><span class="line">        <span class="comment">//fruit.add(new Apple())编译错误</span></span><br><span class="line">        <span class="comment">//fruit.add(new Fruit());</span></span><br><span class="line">        <span class="comment">//fruit.add(new Object());</span></span><br><span class="line">        fruit.add(<span class="keyword">null</span>);<span class="comment">//legal but uninstersting</span></span><br><span class="line">        <span class="comment">// we know that it returns at least Fruit;</span></span><br><span class="line">        Fruit f = fruit.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>fruit类型现在是List&lt;? extends Fruit&gt;,你可以将其读作“具有任何从Fruit继承的类型的列表”，<strong>但是实际上， 并不意味着这个List将持有任何类型的Fruit</strong>，<strong>通配符引用的是明确的类型</strong>，<strong>因此它意味着“某种fruit引用没有指定的具体类型</strong>”，因此这个被赋值的List必须持有诸如Fruit或Apple这样的某种指定类型，但是为了向上转型为fruit，这个类型是什么并没有人关心<br>如果唯一的限制是这个List要持有某种具体的Fruit或Fruit的子类型，但是你实际上并不关系它是什么，那么你能用这样的List做什么呢？如果不知道List持有什么类型，那么你怎样才能安全地向其中添加对象呢？你不能，除非编译器而不是运行时系统可以阻止这种操作的发生（也就是说只有编译器阻止向其中添加对象，你添加对象的行为才是安全的，这也是为什么我们不能向List&lt;? extends Fruit&gt;这种类型的对象添加对象的原因，一切都是为了类型安全，我们无法容忍在添加之后，运行时才发现问题的这种情况的发生）<br>你可能认为，事情变得有点走极端了，因为现在你甚至不能向刚刚声明过将持有Apple对象的List中放置一个Apple对象了，是的，编译器并不知道这一点，List&lt;? extends Fruit&gt;可以合法地指向一个List<orange>,一旦指向这种类型的向上转型，你就会丢失掉向其中传递任何对象的能力，甚至Object也不行<br>一方面，如果你调用一个返回Fruit的方法，则是安全的，因为你知道在这个List中的任何对象都至少具有Fruit类型，因此编译器允许这么做 </orange></p><h3 id="编译器有多聪明"><a href="#编译器有多聪明" class="headerlink" title="编译器有多聪明"></a>编译器有多聪明</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompileIntelligence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;? extends Fruit&gt; fruits=<span class="keyword">new</span> ArrayList&lt;Apple&gt;();</span><br><span class="line">        Apple a=(Apple)fruits.get(<span class="number">0</span>);</span><br><span class="line">        fruits.contains(<span class="keyword">new</span> Apple());<span class="comment">//argument is "Object"</span></span><br><span class="line">        fruits.indexOf(<span class="keyword">new</span> Apple()); <span class="comment">//argument is "Object"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以看到，对contains()和indexOf()的调用，这两个方法都接受Apple对象作为参数，而这些调用都可以正常执行，这是否意味着编译器实际上将检查代码，以查看是否有某个特定的方法修改了它的对象？<br>通过查看ArrayList文档，我们发现，编译器并没有那么充满，尽管add()方法接受一个具有泛型参数类型的参数，但是contains()和indexOf()将接受一个Object类型的参数，因此当你指向一个ArrayList&lt;? extends Fruit&gt;时，add()的参数就变成了“？extends Fruit”(我在编辑add()方法的时候，确实IDE会提醒这个方法的参数是“？ extends Fruit”，这里的意思是：这个方法接受Fruit类型及其子类型的参数，从这个描述中看，编译器也不确定，接受的是哪个确切的类型，因为编译器对参数类型的信息了解的并不多，为了类型安全（编译期的静态类型检查），编译器拒绝接受任何类型的参数)<br>在使用contains()和indexOf()时，参数类型是Object，因此不涉及任何通配符，而编译器也将允许这个调用，这意味这个将由泛型类的设计来决定哪些调用是“安全”的，并使用Object类型作为其参数类型，<strong>为了在类型中使用了通配符的情况下禁止这类调用，我们需要在参数列表中使用类型参数</strong><br>我们来做个总结，当我们使用类似&lt;? extends Fruit&gt;这样的类型参数时，泛型类中那些在方法列表中不涉及类型参数的方法可以正常调用，而在参数列表中使用了类型参数的方法将会被编译器禁止调用<br>看下面是一个很简单的例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T item;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">(T item)</span></span>&#123;</span><br><span class="line">        item=item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T item)</span></span>&#123;item=item;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.equals(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Holder&lt;Apple&gt; apple=<span class="keyword">new</span> Holder&lt;&gt;(<span class="keyword">new</span> Apple);</span><br><span class="line">        Apple d=apple.get();</span><br><span class="line">        apple.set(<span class="keyword">new</span> Apple());</span><br><span class="line">        Holder&lt;? extends Fruit&gt; fruit=apple;</span><br><span class="line">        Fruit p=fruit.get();</span><br><span class="line">        d=(Apple) fruit.get();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Orange o = (Orange) fruit.get();<span class="comment">//可以，但是运行时类型转换异常</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//fruit.set(new Orange()); 参数列表中涉及到类型参数的方法不能调用</span></span><br><span class="line">        <span class="comment">//fruit.set(new Apple());</span></span><br><span class="line">        System.out.println(fruit.equals(d));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="逆变"><a href="#逆变" class="headerlink" title="逆变"></a>逆变</h3><p><strong>还可以走另外一条路，即使用超类型通配符，这里，可以声明通配符是由某个特定类的任意基类来界定，方法是指定&lt;? super MyClass&gt;，甚至或者使用类型参数&lt;? extends T&gt;</strong>（尽管你不能对泛型参数给出一个超类型边界，即不能声明<t super="" myclass="">）,<strong>这使得你可以安全地传递一个类型对象到泛型类型中</strong> 看下面一个例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperTypeWildcards</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeTo</span><span class="params">(List&lt;? <span class="keyword">super</span> Apple&gt; apples)</span></span>&#123;</span><br><span class="line">        apples.add(<span class="keyword">new</span> Apple());</span><br><span class="line">        apples.add(<span class="keyword">new</span> Jonathan());</span><br><span class="line">        <span class="comment">//apples.add(new Fruit()); //error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></p><p>从这例子看出&lt;? super Apple&gt;表明参数类型被指定为Apple的基类，因此泛型类的那些方法的参数列表就变为&lt;? super Apple&gt;，方法接受的类型是Apple的基类，Apple是下界，这样向这些方法传递Apple及其子类型是安全的，（Apple的基类都能接受，Apple及Apple的子类型更是不在话下）</p><p>因此你可能根据如何能够向一个泛型类型“写入”(传递给一个方法)，以及如何能够从一个泛型类型中“读取”（从一个方法中返回），来这手思考子类型边界&lt;? extends MyClass&gt;和超类型边界(&lt;? super MyClass&gt;)<br>超类型边界放松了在可以向方法传递参数上所作的限制<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericWriting</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">writeExact</span><span class="params">(List&lt;T&gt; list,T item)</span></span>&#123;</span><br><span class="line">        list.add(item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">writeWithSuperWildcard</span><span class="params">(List&lt;? <span class="keyword">super</span> T&gt; list,T item)</span></span>&#123;</span><br><span class="line">        list.add(item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> List&lt;Apple&gt; apples= <span class="keyword">new</span> ArrayList&lt;Apple&gt;();</span><br><span class="line">    <span class="keyword">static</span> List&lt;Fruit&gt; fruit =<span class="keyword">new</span> ArrayList&lt;Fruit&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        writeExact(apples,<span class="keyword">new</span> Apple());</span><br><span class="line">        writeExact(fruit,<span class="keyword">new</span> Apple());<span class="comment">//为什么，没有编译错误？</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        writeWithSuperWildcard(apples,<span class="keyword">new</span> Apple());</span><br><span class="line">        writeWithSuperWildcard(fruit,<span class="keyword">new</span> Apple());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        f1();</span><br><span class="line">        f2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在《编程思想》中，writeExact(fruit，new Apple())中指明这种方式有编译错误，found Fruit required Apple,但是为什么，我在编译器中没有发现任何编译错误的提示呢？难道是java之后的版本支持了向List<fruit>类型的引用，传递Apple?<br>回来再研究这个问题<br>下面的例子，作为对协变和通配符的一个复习<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericReading</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">readExact</span><span class="params">(List&lt;T&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> List&lt;Apple&gt; apples=Arrays.asList(<span class="keyword">new</span> Apple());</span><br><span class="line">    <span class="keyword">static</span> List&lt;Fruit&gt; fruits=Arrays.asList(<span class="keyword">new</span> Fruit());</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">     Apple a=readExact(apples);</span><br><span class="line">     Fruit f=readExact(fruits);</span><br><span class="line">     f=readExact(apples);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Reader</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">        <span class="function">T <span class="title">readExact</span><span class="params">(List&lt;T&gt; list)</span></span>&#123; <span class="keyword">return</span> list.get(<span class="number">0</span>);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Reader&lt;Fruit&gt; fruitReader=<span class="keyword">new</span> Reader&lt;&gt;();</span><br><span class="line">        Fruit f=fruitReader.readExact(fruits);</span><br><span class="line">        <span class="comment">//error raedFruit(List&lt;Fruit&gt;) cannot be applied to (Lisy&lt;Apple&gt;)</span></span><br><span class="line">        <span class="comment">//Fruit a=fruitReader.readExact(apples);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CovariantReader</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function">T <span class="title">readCovariant</span><span class="params">(List&lt;? extends T&gt; list)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        CovariantReader&lt;Fruit&gt; convariantRead=<span class="keyword">new</span> CovariantReader&lt;&gt;();</span><br><span class="line">        Fruit f=convariantRead.readCovariant(apples);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        f1();f2();f3()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></fruit></p><p>第1个方法readExact()使用了精确类型，因此如果使用了这个没有任何通配符的精确类型，就可以向List中写入和读取这个精确类型，另外，对于返回值，静态的泛型方法readExact()可以有效地“适应”每个方法调用，并能从List<apple>中返回一个Apple，从List<fruit>，返回一个Fruit,就像f1()看到的那样，因此，如果可以摆脱静态泛型方法，那么当只是读取时，就不需要协变类型了<br>但是，如果有个泛型类，那么当你创建这个类的实例时，要为这个类确定参数，就像在f2()中看到的那样，fruitReader实例可以从List<fruit>中读取一个Fruit，因为这就是它的确切类型，但是List<apple>还应该产生一个Fruit对象，而fruitReader不允许这么做<br>为了修正这个问题。CovariantReader.readCovariant()方法将接受List&lt;? extends T&gt;,因此，从这个列表读取一个T是安全的（你知道在这个列表中的所有对象至少是一个T，并且可能是从T导出的某种对象），在f3()中，你可以看到现在可以从List<apple><br>中读取Fruit了</apple></apple></fruit></fruit></apple></p><h3 id="无界通配符"><a href="#无界通配符" class="headerlink" title="无界通配符"></a>无界通配符</h3><p>无界通配符&lt;?&gt;看起来意味着“任何事物”，因此使用无界通配符好像等价于使用原生类型，事实上，编译器初看起来是支持这种判断的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnboundWildcards1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> List list1;</span><br><span class="line">    <span class="keyword">static</span> List&lt;?&gt; list2;</span><br><span class="line">    <span class="keyword">static</span> List&lt;? extends Object&gt; list3;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign1</span><span class="params">(List list)</span></span>&#123;</span><br><span class="line">        list1=list;</span><br><span class="line">        list2=list;</span><br><span class="line">        <span class="comment">//list3=list; warning:unchecked coversion</span></span><br><span class="line">        <span class="comment">//found List,Required: List&lt;? extends Object&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign2</span><span class="params">(List&lt;?&gt; list)</span></span>&#123;</span><br><span class="line">        list1=list;</span><br><span class="line">        list2=list;</span><br><span class="line">        list3=list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign3</span><span class="params">(List&lt;? extends Object&gt; list)</span></span>&#123;</span><br><span class="line">        list1=list;</span><br><span class="line">        list2=list;</span><br><span class="line">        list3=list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assign1(<span class="keyword">new</span> ArrayList());</span><br><span class="line">        assign2(<span class="keyword">new</span> ArrayList());</span><br><span class="line">        <span class="comment">//assign3(new ArrayList()); warning unchecked conversion found ArrayList Required:list&lt;? extends Object&gt;</span></span><br><span class="line">        assign1(<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">        assign2(<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">        assign3(<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">        List&lt;?&gt; wildList=<span class="keyword">new</span> ArrayList();</span><br><span class="line">        wildList=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        assign1(wildList);</span><br><span class="line">        assign2(wildList);</span><br><span class="line">        assign3(wildList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有很多情况都和你在这里看到的情况类似，即编译器很少关心使用的原生类型还是&lt;?&gt;。在这种情况中，&lt;?&gt;可以被认为是一种装饰，但是它仍旧是有价值的，<strong>因为实际上，它是在声明：我想要java的泛型来编写这段代码，我在这里并不是要用原生类型，但是在当前这种情况下，泛型参数可以持有任何类型</strong><br>下面一个示例展示了无界通配符的一个重要应用，<strong>当你在处理多个泛型参数时，有时允许一个参数可以是任何类型，因此为其他参数确定某种特定类型的这种能力很重要</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Unboundwildcards2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Map map1；</span><br><span class="line">    <span class="keyword">static</span> Map&lt;?,?&gt; map2;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;String,?&gt; map3;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign1</span><span class="params">(Map map)</span></span>&#123;</span><br><span class="line">        map1=map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign2</span><span class="params">(Map&lt;?,?&gt; map)</span></span>&#123;map2=map;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign3</span><span class="params">(Map&lt;String,?&gt; map)</span></span>&#123;map3=map;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        assign1(<span class="keyword">new</span> HashMap());</span><br><span class="line">        assign2(<span class="keyword">new</span> HashMap());</span><br><span class="line">        <span class="comment">//assign3(new HashMap());//warning</span></span><br><span class="line">        assign1(<span class="keyword">new</span> HashMap&lt;String,Integer&gt;());</span><br><span class="line">        assign2(<span class="keyword">new</span> HashMap&lt;String,Integer&gt;());</span><br><span class="line">        assign3(<span class="keyword">new</span> HashMap&lt;String,Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是，当你拥有的是全部的无界通配符时，就像在Map&lt;?,?&gt;中看到的那样，编译器看起来即无法将其与原生Map区分开了，另外，UnboundWildcard1.java展示了编译器处理List&lt;?&gt;和List&lt;? extends Object&gt;时是不同的<br>令人困惑的是，编译器并非总是关注像List&lt;?&gt;和List之间的这种差异，因此它们看起来就像是相同的事物，因为，事实上，由于泛型参数将擦除到它的第一边界，因此List&lt;?&gt;看起来等价于List<object>，而实际上也是List<object>——除非这些语句都不为真，List世家上表示“持有任何Object类型的原生List”，而List&lt;?&gt;表示“具有某种特定类型的非元素List,只是我们不知道那种类型是什么”<br>编译器何时才会关注原生类型和涉及无界通配符的类型之间的差异呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wildcards</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rawArgs</span><span class="params">(Holder holder,Object args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//holder.set(args);//warning unchecked call to set(T) as a member of the raw Holder</span></span><br><span class="line">       <span class="comment">// holder.set(new Wildcards());//simple warning</span></span><br><span class="line">        Object obj=holder.get();</span><br><span class="line">        <span class="comment">//can't do this; don't have any T</span></span><br><span class="line">        <span class="comment">//T t=holder.get();</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unboundedArgs</span><span class="params">(Holder&lt;?&gt; holder,Object args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//holder.set(args);error注意这里是直接错误而不是警告</span></span><br><span class="line">        <span class="comment">//set(captre of ?) in Holder&lt;capture of ?&gt;</span></span><br><span class="line">        <span class="comment">//can't do this; don't have any T</span></span><br><span class="line">        <span class="comment">//T t=holder.get();</span></span><br><span class="line">        <span class="comment">//ok but type information has been lost</span></span><br><span class="line">        Object obj=holder.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">exact1</span><span class="params">(Holder&lt;T&gt; holder)</span></span>&#123;</span><br><span class="line">        T t= holder.get();</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">exact2</span><span class="params">(Holder&lt;T&gt; holder,T args)</span></span>&#123;</span><br><span class="line">        holder.set(args);</span><br><span class="line">        T t = holder.get();</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">wildSubType</span><span class="params">(Holder&lt;? extends T&gt; holder,T args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//holder.set(args); error</span></span><br><span class="line">        T t= holder.get();</span><br><span class="line">        <span class="keyword">return</span>  t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">wildSupType</span><span class="params">(Holder&lt;? <span class="keyword">super</span> T&gt; holder,T args)</span></span>&#123;</span><br><span class="line">        holder.set(args);</span><br><span class="line">        <span class="comment">//T t=holder.get();error</span></span><br><span class="line">        Object obj=holder.get();<span class="comment">//but type information has been lost</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Holder raw =<span class="keyword">new</span> Holder&lt;Long&gt;();</span><br><span class="line">        <span class="comment">//or</span></span><br><span class="line">        raw=<span class="keyword">new</span> Holder();</span><br><span class="line">        Holder&lt;Long&gt; qualified=<span class="keyword">new</span> Holder&lt;&gt;();</span><br><span class="line">        Holder&lt;?&gt; unbounded=<span class="keyword">new</span> Holder&lt;Long&gt;();</span><br><span class="line">        Holder&lt;? extends Long&gt; bounded=<span class="keyword">new</span> Holder&lt;Long&gt;();</span><br><span class="line">        Long lng=<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">        rawArgs(raw,lng);</span><br><span class="line">        rawArgs(qualified,lng);</span><br><span class="line">        rawArgs(unbounded,lng);</span><br><span class="line">        rawArgs(bounded,lng);</span><br><span class="line"></span><br><span class="line">        unboundedArgs(raw,lng);</span><br><span class="line">        unboundedArgs(qualified,lng);</span><br><span class="line">        unboundedArgs(unbounded,lng);</span><br><span class="line">        unboundedArgs(bounded,lng);</span><br><span class="line"></span><br><span class="line">        Object r1=exact1(raw);<span class="comment">//warnning</span></span><br><span class="line">        Long r2 =exact1(qualified);</span><br><span class="line">        Object r3=exact1(unbounded);<span class="comment">//Must return Object</span></span><br><span class="line">        Long r4=exact1(bounded);</span><br><span class="line"></span><br><span class="line">        Long r5=exact2(raw,lng)<span class="comment">//warning</span></span><br><span class="line">        Long r6 =exact2(qualified,lng);</span><br><span class="line">        <span class="comment">//Long r7 = exact2(unbounded,lng);//Error</span></span><br><span class="line">        <span class="comment">//Long r8=exact2(bounded,lng);//error</span></span><br><span class="line">        <span class="comment">//exact2(Holder&lt;T&gt;,T) cannot be applied</span></span><br><span class="line">        <span class="comment">//to (Holder&lt;capture of ? extends Long&gt;,Long)</span></span><br><span class="line"></span><br><span class="line">        Long r9=wildSubType(raw,lng);<span class="comment">//warnings</span></span><br><span class="line">        <span class="comment">//unchecked conversion form Holder to Holder&lt;? extends Long&gt;</span></span><br><span class="line">        <span class="comment">//unchecked method invocation:</span></span><br><span class="line">        <span class="comment">//wildSubType(Holder&lt;? extends T&gt;,T) is applied to (Holder,Long)</span></span><br><span class="line"></span><br><span class="line">        Long r10=wildSubType(qualified,lng);</span><br><span class="line">        <span class="comment">//ok but can only return Object</span></span><br><span class="line">        Object r11=wildSubType(unbounded,lng);</span><br><span class="line">        Long r12=wildSubType(bounded,lng);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//wildSubType(raw,lng);warnnings</span></span><br><span class="line">        <span class="comment">//unchecked conversion from Holder to Holder&lt;? super Long&gt;</span></span><br><span class="line">        <span class="comment">//nchecked method invocation;</span></span><br><span class="line">        <span class="comment">//wildSupType(Holder&lt;? super T&gt;,T) is applied to (Holder,Long)</span></span><br><span class="line"></span><br><span class="line">        wildSupType(qualified,lng);</span><br><span class="line">        <span class="comment">//wildSupType(unbounded,lng);//error</span></span><br><span class="line">        <span class="comment">//wildSuType(Holder&lt;? super T&gt;,T) cannot be applied to (Holder&lt;Capture of ?&gt;,Long)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//wildSupType(bounded,lng);error</span></span><br><span class="line">        <span class="comment">//wildSpType(Holder&lt;? super T&gt;,T)cannot be applied to (Holder&lt;capture of ? extends Long&gt;,Long )</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></object></object></p><p>在rawArgs()中，编译器知道Holder是一个泛型类型，因此即使它在这里表示成一个原生类型，编译器仍然知道向set()传递一个Obeject是不安全的，由于它是原生类型，你可以将任何类型的对象传递给set()，而这个对象将被向上转型为Object，因此无论何时，<strong>只要使用了原生类型，都会放弃编译器检查</strong>，对get()的调用说明了相同的问题，没有任何T类型的睇相，因此结果只能是一个Object<br>人们很自然会开始考虑原生类型Holder和Holder&lt;?&gt;是大致相同的事物，但是unboundArg()强调了它们的不同——它揭示了相同的问题，但是它将这些问题作为错误而不是警告报告，<strong>因为原生Holder将持有任何类型的组合，而Holder&lt;?&gt;将持有具有某种具体类型的同构集合，因此不能只是向其中传递Object</strong><br>在exact1()和exact2()中，你可以看到使用了确切的泛型类型——没有任何通配符，你将看到，exact2和exact1()有不同的限制，因为它有额外的参数<br>在wildSubType()中，在Holder类型上的限制被放松为包括持有任何扩展子T的对象的Holder，这还是意味着如果T是Fruit，那么Holder可以是Holder<apple>,这是合法的，为了防止将Orange()放置到Holder<apple>中，对set()的调用（或者任何接受这个类型参数的方法的调用）都是不允许的，但是，你仍旧知道任何来自Holder&lt;? extends Fruit&gt;的对象至少都是Fruit的，因此get()(任何参数列表不涉及类型参数的方法)的调用都是允许的<br>wildSupType()展示了超类型通配符，因此set()可以接受T,因为任何可以工作于基类的对象都可以多态地作用于导出类（这里就是T），但是尝试着调用get()是没用的，因此由Holder持有的类型可以是任何超类型，因此唯一安全的类型即使Object,但是这样具体的类型信息就会丢失<br>这个例子还展示了对于unbounded()中使用无界通配符能够做什么不能做什么所做出的限制，对于迁移兼容性，rawArgs()将接受所有Holder的不同变体，而不会产生警告，unboundedArgs()方法也可以接受相同的所有类型，尽管如前所示，它在方法体内部处理这些类型的方式并不相同<br><strong>如果向接受“确切”泛型类型（没有通配符）的方法产地一个原生Holder引用，就会得到一个警告，因为确切的参数期望得到在原生类型中并不存在的信息</strong>如果向exact1()传递一个无界引用，就不会有任何可以确定返回类型的类型信息<br>可以看到，exact2()具有更多的限制，因为它希望精确地得到一个Holder<t>，已经一个具有T类型的参数，正因如此，它将产生错误或者警告，除非提供确切的参数，有时，这样做很好，但是如果它过于受限，那么就可以使用通配符，这取决与是否想要从泛型参数中返回类型确定返回值（就像在wildSubType中看到的那样），或者是否想要向泛型参数传递类型确定的参数（就像在wildSupType()中看到的那样）<br>因此使用确切类型来替代通配符的好处是，可以用泛型参数来做更多事，但是使用通配符使得你必须接受范围更宽的参数化类型作为参数，因此，必须逐个情况地权衡利弊，找到更适合你的方法</t></apple></apple></p><h3 id="捕获转换"><a href="#捕获转换" class="headerlink" title="捕获转换"></a>捕获转换</h3><p><strong>有一种情况特别需要使用&lt;?&gt;而不是原生类型，如果像一个使用&lt;?&gt;的方法传递原生类型，那么对与编译器来说，可能会推断出实际的参数类型，使得这个方法可以回转并调用另一个使用这个确切类型的方法</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CaptureConversion</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(Holder&lt;T&gt; holdedr)</span></span>&#123;</span><br><span class="line">        T t=holdedr.get();</span><br><span class="line">        System.out.println(t.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">(Holder&lt;?&gt; holder)</span></span>&#123;</span><br><span class="line">        f1(holder);<span class="comment">//call with capture type</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Holder raw = <span class="keyword">new</span> Holder&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//f1(raw);//warnings</span></span><br><span class="line">        f2(raw);<span class="comment">//no warning</span></span><br><span class="line">        Holder rawBasic=<span class="keyword">new</span> Holder();</span><br><span class="line">        rawBasic.set(<span class="keyword">new</span> Object());<span class="comment">//warning</span></span><br><span class="line">        f2(rawBasic);<span class="comment">//no warning</span></span><br><span class="line">        Holder&lt;?&gt; wildcarded=<span class="keyword">new</span> Holder&lt;Double&gt;();</span><br><span class="line">        f2(wildcarded);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output</span></span><br><span class="line"><span class="comment">Integer</span></span><br><span class="line"><span class="comment">Object</span></span><br><span class="line"><span class="comment">Double</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p><p>f1()的参数类型都是确切的，没有通配符或边界，在f2()中，Holder参数是一个无界通配符，因此它看起来是未知的，但是，在f2()中，f1()被调用，而f1()需要一个已知参数，<strong>这里发生的是，参数类型在调用f2()的过程中被捕获，因此它可以在对f1()的调用中被使用</strong><br>你可能想知道，这项技术是否可以用于写入，但是这要求要在床底Holder&lt;?&gt;同时传递以恶搞具体类型，捕获站好只有在这样的情况下才能工作：即在方法内部，你需要使用确切的类型  </p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="任何基本类型都不能作为类型参数"><a href="#任何基本类型都不能作为类型参数" class="headerlink" title="任何基本类型都不能作为类型参数"></a>任何基本类型都不能作为类型参数</h3><h3 id="实现参数化接口"><a href="#实现参数化接口" class="headerlink" title="实现参数化接口"></a>实现参数化接口</h3><p>一个类不能实现一个泛型接口的两种变体，由于擦除的影响，这两个变体会成为相同的接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Payable</span>&lt;<span class="title">T</span>&gt;</span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Payable</span>&lt;<span class="title">Employee</span>&gt;</span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hourly</span> <span class="keyword">extends</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Payable</span>&lt;<span class="title">Hourly</span>&gt;</span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>Hourly不能编译成功，因为擦除会将Payable<eployee>和Payable<hourly>简化成相同的类Payable</hourly></eployee></p><h3 id="转型和警告"><a href="#转型和警告" class="headerlink" title="转型和警告"></a>转型和警告</h3><p>使用带有泛型参数的转型或instanceof不会产生任何效果，下面的容器在内部将各个值存储为Object，并在获取这些值时，再将它们转型回T<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FixedSizeStack</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Object[] storage;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FixedSizeStack</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">       storage=<span class="keyword">new</span> Object[size]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T item)</span></span>&#123;storage[index++]=item;&#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> (T)storage[index--];&#125;<span class="comment">//重点在这一行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericCast</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE=<span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        FixedSizeStack&lt;String&gt; strings=<span class="keyword">new</span> FixedSizeStack&lt;&gt;(SIZE);</span><br><span class="line">        <span class="keyword">for</span>(String str:<span class="string">"A B C D E F G H I J"</span>.split(<span class="string">" "</span>))&#123;</span><br><span class="line">            strings.push(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;SIZE;i++)&#123;</span><br><span class="line">            String s=strings.pop();</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果没有@SuppressWranings注解，编译将会产生“unchecked cast”警告,<strong>由于擦除的影响，编译器无法知道这个转型是否是安全的，并且pop()方法实际上没有执行任何转型，这是因为，T被擦除到它的第一个边界，默认情况下是Object，因此pop()实际上只是将Object转型为Object</strong><br><strong>有时，泛型没有消除对转型的需要，就会产生编译器警告，而这个警告是不恰当的，例如</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NeedCasting</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]));</span><br><span class="line">        List&lt;Widget&gt; shape=(List&lt;Widget&gt;)in.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>readObject()无法知道它正在读取的是什么，因此它返回的是必须转型的对象，但是当注释点@SuppressWranings注解，并编译这个程序的时，就会出现下面的警告<br>Note:NeedCasting,java uses unchecked or unsafe operations<br>Note:Recompile with —Xlint:unchecked for detail<br>如果遵循这条指示，使用—Xlint：unchecked来重新编译<br>NeedCasting.java:12: warning:[unckecked] unchecked cast<br>found :java.lang.Object<br>required: java.util.List<widget><br>   List<shape> shapes=(List<widget>)in.readObject();<br>你会被强制要求转型，但是又被告知不应该转型，为了解决这个问题，必须使用在java SE5中引入的新的转型形式，既通过泛型类来转型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NeedCasting</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]));</span><br><span class="line">        <span class="comment">//List&lt;Widget&gt; lw1=List&lt;Widget&gt;.class.cast(in.readObject());</span></span><br><span class="line">        List&lt;Widget&gt; lw2=List.class.cast(in.readObject());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></widget></shape></widget></p><p>这里是相当奇怪的</p><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>下面的程序是不能编译的，即使编译它是一种合理的尝试<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseList</span>&lt;<span class="title">W</span>,<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(List&lt;T&gt; v)</span></span>&#123;&#125;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(List&lt;W&gt; v)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于擦除的影响，重载方法将产生相同的类型签名</p><h3 id="基类劫持了接口"><a href="#基类劫持了接口" class="headerlink" title="基类劫持了接口"></a>基类劫持了接口</h3><p>假设你有一个Pet类，它可以与其他的Pet类对象进行比较（实现了Comparable接口）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparablePet</span>  <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ComparablePet</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(@NotNull ComparablePet o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对可以与ComparablePet的子类比较的类型进行窄化是有意义的，例如，一个Cat对象就只能与其他Cat对象进行比较<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">ComparablePet</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Cat</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(@NotNull Cat o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>遗憾的是上面代码错误，一旦为Comparable确定了ComparablePet参数，那么其他任何实现类都不能与ComparablePet之外的任何对象比较<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hamster</span> <span class="keyword">extends</span> <span class="title">ComparablePet</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ComparablePet</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(ComparablePet args)</span></span>&#123;<span class="keyword">return</span>  <span class="number">1</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Hasmter说明再次实现ComparablePet中的接口是可能的，只要它们精确地相同，包括参数类型在内</p><h2 id="自限定的类型"><a href="#自限定的类型" class="headerlink" title="自限定的类型"></a>自限定的类型</h2><p>在java中，经常出现一个令人费解的惯用法<br>class SelfBound&lt;T extends SelfBound<t>&gt;<br>这就像是两面镜子彼此看着对方产生的炫目感，是一种无限循环，SelfBound接受泛型参数T，而T由一个边界类限定，这个边界就是拥有T作为参数的ShefBound</t></p><h3 id="古怪的循环泛型"><a href="#古怪的循环泛型" class="headerlink" title="古怪的循环泛型"></a>古怪的循环泛型</h3><p>我们先从简单的版本入手<br><strong>不能直接继承一个泛型参数，但是，可以继承在其自己的定义中使用这个泛型参数的类</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericType</span>&lt;<span class="title">T</span>&gt;</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuriouslyRecurringGeneric</span> <span class="keyword">extends</span> <span class="title">GenericType</span>&lt;<span class="title">CuriouslyRecurringGeneric</span>&gt;</span>&#123; &#125;</span><br></pre></td></tr></table></figure></p><p>上面的例子可以称为“古怪的循环”，<strong>“古怪的循环”是指类相当古怪地出现在自己的基类中这一事实</strong><br>为了理解其含义，努力地大声说“<strong>我正在创建一个新类吗，这个类继承子一个泛型类型，这个泛型类型的接受我的类的名字作为其参数</strong>”，当给出导出类的名字时，<strong>这个泛型基类能够实现什么呢？好吧，java中的泛型关乎参数和返回类型，因此它能够产生使用导出类作为参数和返回类型的积累，它还能将导出类用作其域类型，甚至那些将其擦除为Object的类型</strong><br>下面是一个普通的泛型类,它的方法将接受和产生具有参数类型的对象，还有一个方法将在其存储的域上执行操作（尽管只在这个域上执行Object操作）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicHolder</span> &lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T item;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setItem</span><span class="params">(T item)</span></span>&#123;item=item;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getItem</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(item.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面这个示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubType</span> <span class="keyword">extends</span> <span class="title">BasicHolder</span>&lt;<span class="title">SubType</span>&gt;</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CRWithBasicHolder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">      SubType subType1=<span class="keyword">new</span> SubType();</span><br><span class="line">      SubType subType2=<span class="keyword">new</span> SubType();</span><br><span class="line">      subType1.setItem(subType2);</span><br><span class="line">      SubType subType3=subType1.getItem();</span><br><span class="line">      subType1.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>新类SubType接受的参数和返回的值具有SubType类型而不仅仅是基类Basicholder的类型，这就是CRG(古怪的循环)的本质，<strong>基类用导出类替代其参数</strong>，<strong>这意味着泛型基类变成了一种其所有导出类的公共功能的模版，但是这些功能对于其所有参数和返回值，将使用导出类型，也就是说，在产生的类中将使用确切类型而不是其基类型</strong>，因此，在SubType中，传递给set()的参数和从get()返回的类型都是确切的SubType</p><h3 id="自限定"><a href="#自限定" class="headerlink" title="自限定"></a>自限定</h3><p>BasicHolder可以使用任何类型作为其泛型参数，就像下面看到的那样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Other</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicOther</span> <span class="keyword">extends</span> <span class="title">BasicHolder</span>&lt;<span class="title">Other</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        BasicOther b=<span class="keyword">new</span> BasicOther();</span><br><span class="line">        b.setItem(<span class="keyword">new</span> Other());</span><br><span class="line">        Other o=b.getItem();</span><br><span class="line">        b.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>自限定将采取额外的步骤，强制泛型当作其自己的边界参数来使用</strong><br>观察所产生的类可以如何使用以及不可以如何使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelfBounded</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&gt;</span>&#123;</span><br><span class="line">    T element;</span><br><span class="line">    <span class="function">SelfBounded&lt;T&gt; <span class="title">set</span><span class="params">(T arg)</span></span>&#123;</span><br><span class="line">        element=arg;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">A</span>&gt;</span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">A</span>&gt;</span>&#123;&#125;<span class="comment">//also ok</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">C</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">C <span class="title">setAndGet</span><span class="params">(C arg)</span></span>&#123;</span><br><span class="line">        set(arg);</span><br><span class="line">        <span class="keyword">return</span> get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//class E extends SelfBounded&lt;D&gt;&#123;&#125;can't do this</span></span><br><span class="line"><span class="comment">//compile error : Type parameter D is not within its bound</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//also you can do this ,so you can't force the idiom</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelfBounding</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        A a =<span class="keyword">new</span> A();</span><br><span class="line">        a.set(<span class="keyword">new</span> A());</span><br><span class="line">        a=a.set(<span class="keyword">new</span> A()).get();</span><br><span class="line">        a=a.get();</span><br><span class="line"></span><br><span class="line">        C c=<span class="keyword">new</span> C();</span><br><span class="line">        c=c.setAndGet(<span class="keyword">new</span> C());</span><br><span class="line"></span><br><span class="line">        B b=<span class="keyword">new</span> B();</span><br><span class="line">        b.set(<span class="keyword">new</span> A());</span><br><span class="line">        A ba=b.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>自限定所做的，就是要求在继承关系中，像下面这样使用这个类</strong><br>    class A extends SelfBounded<a>{}<br><strong>这会强制要求将正在定义的类当作参数传递给基类</strong><br>从基类的类型参数的表达式也能看的出来</a></p><p>&lt;T extends SelfBounded<t>&gt; T表示类型参数，这个参数的类型是其自身类型的导出类<br>自限定的参数有何意义呢？它可以保证类型参数必须与正在被定义的类相同<br>正如你从B类的定义所看到的，还可以从另一个SelfBounded参数的SelfBounded中导出，尽管A类看到的用法是最主要的用法<br>对定义E的尝试说明不能使用不是SelfBounded的类型参数<br>遗憾的是，F可以编译，不会有任何警告，这是比较奇怪的吗？这也说明了自限定惯用法不是可强制执行的，如果它确实很重要，可以要求一个外部工具来确保不会使用原生类型来替代参数化类型<br>注意，可以移除自限定这个限制，这样所有的类仍旧可以编译的，但是E也因此可编译成功<br>其实自限定类型的目的就是限定导出类在继承基类的时候，必须将参数类型替换为导出类（只要是基类的导出类都可以，一般我们惯用的是新建的这个导出类自身来替代参数类型而已，一次泛型类的自限定对于继承自它的类来说，没什么一样，自限定最大的功效就是强制而已）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A2</span> <span class="keyword">extends</span> <span class="title">NotSelfBounded</span>&lt;<span class="title">A</span>&gt;</span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span> <span class="keyword">extends</span> <span class="title">NotSelfBounded</span>&lt;<span class="title">A2</span>&gt;</span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C2</span> <span class="keyword">extends</span> <span class="title">NotSelfBounded</span>&lt;<span class="title">C2</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">C2 <span class="title">getAndSet</span><span class="params">(C2 arg)</span></span>&#123; set(arg);<span class="keyword">return</span> get(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E2</span> <span class="keyword">extends</span> <span class="title">NotSelfBounded</span>&lt;<span class="title">D2</span>&gt;</span>&#123;&#125;<span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotSelfBounded</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T element;</span><br><span class="line">    <span class="function">NotSelfBounded&lt;T&gt; <span class="title">set</span><span class="params">(T arg)</span></span>&#123;</span><br><span class="line">        element=arg;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> element;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></p><p>这里E2能够编译，即使D2不在NotSelfBounded继承关系中，因此得出结论：<strong>自限定限制只能强制作用于继承关系</strong>。<br>自限定也可以用在泛型方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelfBoundedMethods</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T extends SelfBounded&lt;T&gt;&gt; <span class="function">T <span class="title">f</span><span class="params">(T arg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arg.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        A a=f(<span class="keyword">new</span> A());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="参数协变"><a href="#参数协变" class="headerlink" title="参数协变"></a>参数协变</h3><p>自限定类型的价值是它可以产生协变参数类型——方法参数类型会随着子类而变化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">OrdinaryGetter</span></span>&#123;</span><br><span class="line">    <span class="function">Base <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">DerivedGetter</span> <span class="keyword">extends</span> <span class="title">OrdinaryGetter</span></span>&#123;</span><br><span class="line">    <span class="function">Derived <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CovariantReturnType</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(DerivedGetter d)</span></span>&#123;</span><br><span class="line">        Derived d2=d.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>DerivedGetter中的get()方法覆盖了OrderinaryGetter中的get()方法，并返回一个从OrderinaryGetter.get()返回类型中导出的类型，尽管这是很合理的，导出类方法应该能够返回比它覆盖的基类方法更具体的类型，但是这在java之前的版本中是不合法的<br>自限定泛型实际上将产生确切的导出类型作为其返回值，就像在get()中看到的那样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GenericGetter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">GenericGetter</span>&lt;<span class="title">T</span>&gt;&gt;</span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Getter</span> <span class="keyword">extends</span> <span class="title">GenericGetter</span>&lt;<span class="title">Getter</span>&gt;</span>&#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsAndGetter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(Getter g)</span></span>&#123;</span><br><span class="line">        Getter result=g.get();</span><br><span class="line">        GenericGetter gg=g.get();<span class="comment">//also the base type</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在非泛代码中，参数类型不能随子类型发生变化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrdinarySetter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Base base)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"OrdinarySetter.set(Base)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedSetter</span> <span class="keyword">extends</span> <span class="title">OrdinarySetter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Derived derived)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"DerivedSetter.set(Derived)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderinaryArguments</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Base base=<span class="keyword">new</span> Base();</span><br><span class="line">        Derived derived=<span class="keyword">new</span> Derived();</span><br><span class="line">        DerivedSetter ds=<span class="keyword">new</span> DerivedSetter();</span><br><span class="line">        ds.set(derived);</span><br><span class="line">        ds.set(base);<span class="comment">//这是重载，不是覆盖，overloade，not overridden</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">DerivedSetter.set(Derived)</span></span><br><span class="line"><span class="comment">OrdinarySetter,set(Base)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p><p>set(Derived)和set(Base)都是合法的，因此DerivdeSetter.set(Derived)方法没有覆盖OrdinarySetter.set(Base)方法，而是重载了它，基类版本的代码依然是可用的<br>但是，在使用自限定类型时，在导出类中只有一个方法，并且这个方法接受导出类而不是基类型为参数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SelfBoundSetter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SelfBoundSetter</span>&lt;<span class="title">T</span>&gt;&gt;</span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">set</span><span class="params">(T arg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Setter</span> <span class="keyword">extends</span> <span class="title">SelfBoundSetter</span>&lt;<span class="title">Setter</span>&gt;</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelfBoundingAndConvariantArguments</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testA</span><span class="params">(Setter s1,Setter s2,SelfBoundSetter sb3)</span></span>&#123;</span><br><span class="line">        s1.set(s2);</span><br><span class="line">        <span class="comment">//s1.set(sb3);  set(Setter) in SelfBoundSetter&lt;Setter&gt;</span></span><br><span class="line">        <span class="comment">//cannot be applied to SelfBoundSetter</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>上面这个例子可以看出，编译器不能识别将基类当作参数传递给setter()的尝试，因为没有任何方法具有这样的签名</strong><br>如果不使用自限定类型，普通的继承机制就会介入，而你将能够重载，就像在非泛型的情况下一样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericSetter</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(T arg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"GenericSetter.set(Base)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedGs</span> <span class="keyword">extends</span> <span class="title">GenericSetter</span>&lt;<span class="title">Base</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Derived derived)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"DerivedGs.set(Derived)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlainGenericInheritance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Base base=<span class="keyword">new</span> Base();</span><br><span class="line">        Derived derived=<span class="keyword">new</span> Derived();</span><br><span class="line">        DerivedGs derivedGs=<span class="keyword">new</span> DerivedGs();</span><br><span class="line">        derivedGs.set(base);</span><br><span class="line">        derivedGs.set(derived);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">GenericSetter.set(Base)</span></span><br><span class="line"><span class="comment">DerivedGs.set(Derived)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p><h2 id="动态类型安全"><a href="#动态类型安全" class="headerlink" title="动态类型安全"></a>动态类型安全</h2><p>因为可以向java SE5之前的代码传递容器，所以旧式代码仍旧有可能破坏你的容器（这句话的意思，向你的容器插入不正确的类型）,java SE5的java.util.Collections中有一组便利的工具，可以解决在这种情况下的类型检查问题，它们是，静态方法checkedCollection(),checkedList(),checkedMap(),checkedSet(),checkedSortedMap()和checkedSortedSet(),这些方法每一个都将会希望动态检查的容器作为第一第一个参数接受，并将你希望强制要求的类型作为第二个参数接受<br>受检查的容器，在你试图插入类型不正确的对象时抛出ClassCastException，这与泛型之前的（原生）容器形成对比，对于后者来说，当你将对象从容器中取出的时候，才会通知你出现了问题，而且你也不知道问题是什么时候造成的，受检查的容器与其不同，当向这个容器插入不良对象的时候我们就立刻知道问题发生了<br>用受检查的容器来看看“将猫插入狗列表中”这个问题，这里oldStyleMethod代表遗留代码，因为它接受原生容器List，而@SuppressWarnings注解对这些遗留代码是必需的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pet</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span>  <span class="title">Pet</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span>  <span class="title">Pet</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckedList</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">oldStyleMethod</span><span class="params">(List probablyDogs)</span></span>&#123;</span><br><span class="line">        probablyDogs.add(<span class="keyword">new</span> Cat());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;Dog&gt; dogs1=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        oldStyleMethod(dogs1);<span class="comment">//Quietyly accepts a Cat//不会抛出异常 也不会警告，因为遗留代码使用了原生类型作为参数</span></span><br><span class="line">        List&lt;Dog&gt; dogs2= Collections.checkedList(<span class="keyword">new</span> ArrayList&lt;Dog&gt;(),Dog.class);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oldStyleMethod(dogs2);<span class="comment">//抛出异常</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//derived Type work fine</span></span><br><span class="line">        List&lt;Pet&gt;  pets=Collections.checkedList(<span class="keyword">new</span> ArrayList&lt;Pet&gt;(),Pet.class);</span><br><span class="line">        pets.add(<span class="keyword">new</span> Dog());</span><br><span class="line">        pets.add(<span class="keyword">new</span> Cat());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行这个程序，会发现向dog1插入Cat没有任何问题，如果问题出现也只会在以后从容器中取出时才会发现，因为遗留代码使用了原生类型而不是泛型类型，向dog2插入一个Cat会立马抛出异常</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>由于擦除的影响，将泛型应用于异常是非常受限的。catch语句不能捕获泛型类型的异常，因为在编译期和运行期都必须知道异常的确切类型，泛型类也不呢个直接或间接继承自Throwable(这将进一步阻止你去定义一个不能捕获的泛型异常)<br>但是，类型参数可能会在一个方法的throws子句中用到，这使得你可以编写随检查型异常的类型而发生变化的泛型代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Processor</span>&lt;<span class="title">T</span>,<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Exception</span>&gt;</span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;T&gt; resultCollector)</span><span class="keyword">throws</span> E</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProcessRuuner</span>&lt;<span class="title">T</span>,<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Exception</span>&gt; <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">Processor</span>&lt;<span class="title">T</span>,<span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">processAll</span><span class="params">()</span><span class="keyword">throws</span> E</span>&#123;</span><br><span class="line">        List&lt;T&gt; resultCollector=<span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Processor&lt;T,E&gt; p:<span class="keyword">this</span>)&#123;</span><br><span class="line">            p.process(resultCollector); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  resultCollector;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Failure1</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Processor1</span> <span class="keyword">implements</span> <span class="title">Processor</span>&lt;<span class="title">String</span>,<span class="title">Failure1</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;String&gt; resultCollector)</span> <span class="keyword">throws</span> Failure1 </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count--&gt;<span class="number">1</span>)</span><br><span class="line">            resultCollector.add(<span class="string">"hep!"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            resultCollector.add(<span class="string">"Ho!"</span>);</span><br><span class="line">        <span class="keyword">if</span>(count&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Failure1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Failuer2</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Processor2</span> <span class="keyword">implements</span>  <span class="title">Processor</span>&lt;<span class="title">Integer</span>,<span class="title">Failuer2</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;Integer&gt; resultCollector)</span> <span class="keyword">throws</span> Failuer2 </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count-- == <span class="number">0</span>)</span><br><span class="line">            resultCollector.add(<span class="number">11</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            resultCollector.add(<span class="number">47</span>);</span><br><span class="line">        <span class="keyword">if</span>(count&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Failuer2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowGenericException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ProcessRuuner&lt;String,Failure1&gt; runner1=<span class="keyword">new</span> ProcessRuuner&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            runner1.add(<span class="keyword">new</span> Processor1());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(runner1.processAll());</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Failure1 e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ProcessRuuner&lt;Integer,Failuer2&gt; runner2 = <span class="keyword">new</span> ProcessRuuner&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            runner2.add(<span class="keyword">new</span> Processor2());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(runner2.processAll());</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Failuer2 e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码是很简单的，虽然看起来很长，说明了异常也可以参数化</p><h2 id="混型"><a href="#混型" class="headerlink" title="混型"></a>混型</h2><p>混型（混合的类型，使得这个类型可以混合多个类的能力）随着时间的推移好像拥有无数的含义，<strong>但是其最基本的概念是混合多个类型的能力，以产生一个可以表示混型中所有类型的类</strong>，这往往是你最后的手段，它使得组装多个类型变得简单易行</p><h3 id="C-中的混型"><a href="#C-中的混型" class="headerlink" title="C++中的混型"></a>C++中的混型</h3><p>代码不写了，C++中，使用多重继承的最大理由，就是为了使用混型，但是对于混型来说，更有趣，更优雅的方式是使用参数化类型，因为混型就是继承子其类型参数的类，在C++中，可以很容易的创建混型，因为C++能够记住模版参数的类型</p><h3 id="与接口混合"><a href="#与接口混合" class="headerlink" title="与接口混合"></a>与接口混合</h3><p>在java中，最常见的解决方案就是使用接口来产生混型的效果,类似这样的吧<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">C</span></span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span></span>;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">C</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mix</span> <span class="keyword">extends</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">B</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><h3 id="使用装饰器模式"><a href="#使用装饰器模式" class="headerlink" title="使用装饰器模式"></a>使用装饰器模式</h3><p>当你观察混型的使用方式时，你会发现混型概念好像与装饰器模式关系很近，装饰器常用于满足各种可能的组合，而直接子类化会产生过多的类，因此是不实际的<br><strong>装饰器模式使用了分层对象来动态透明地向单个对象添加责任，装饰器是指包装在最初的对象周围的所有对象都具有的基本接口</strong>，某些事物是可装饰的，可以通过是其他类包装在这个可装饰对象的四周，来将功能分层，这使得对装饰器的使用是透明的——无论对象是否被装饰，你都拥有一个可以向对象发送的公共接口集，装饰器也可以添加新的方法，但是正如你所见的，这将是受限的<br><strong>装饰器是使用组合和形式化结构（可装饰物/装饰器层次结构）来实现的</strong>，而混型是基于继承的，因此可以将基于参数化类型的混型当作是一种泛型装饰器机制，这种机制不需要装饰器设计模式的继承结构<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Processor</span>&lt;<span class="title">T</span>,<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Exception</span>&gt;</span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;T&gt; resultCollector)</span><span class="keyword">throws</span> E</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProcessRuuner</span>&lt;<span class="title">T</span>,<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Exception</span>&gt; <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">Processor</span>&lt;<span class="title">T</span>,<span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">processAll</span><span class="params">()</span><span class="keyword">throws</span> E</span>&#123;</span><br><span class="line">        List&lt;T&gt; resultCollector=<span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Processor&lt;T,E&gt; p:<span class="keyword">this</span>)&#123;</span><br><span class="line">            p.process(resultCollector); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  resultCollector;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Failure1</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Processor1</span> <span class="keyword">implements</span> <span class="title">Processor</span>&lt;<span class="title">String</span>,<span class="title">Failure1</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;String&gt; resultCollector)</span> <span class="keyword">throws</span> Failure1 </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count--&gt;<span class="number">1</span>)</span><br><span class="line">            resultCollector.add(<span class="string">"hep!"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            resultCollector.add(<span class="string">"Ho!"</span>);</span><br><span class="line">        <span class="keyword">if</span>(count&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Failure1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Failuer2</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Processor2</span> <span class="keyword">implements</span>  <span class="title">Processor</span>&lt;<span class="title">Integer</span>,<span class="title">Failuer2</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;Integer&gt; resultCollector)</span> <span class="keyword">throws</span> Failuer2 </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count-- == <span class="number">0</span>)</span><br><span class="line">            resultCollector.add(<span class="number">11</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            resultCollector.add(<span class="number">47</span>);</span><br><span class="line">        <span class="keyword">if</span>(count&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Failuer2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowGenericException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ProcessRuuner&lt;String,Failure1&gt; runner1=<span class="keyword">new</span> ProcessRuuner&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            runner1.add(<span class="keyword">new</span> Processor1());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(runner1.processAll());</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Failure1 e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ProcessRuuner&lt;Integer,Failuer2&gt; runner2 = <span class="keyword">new</span> ProcessRuuner&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            runner2.add(<span class="keyword">new</span> Processor2());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(runner2.processAll());</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Failuer2 e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>产生自泛型的类包含所有感兴趣的方法，<strong>但是由使用装饰器所产生的对象类型是最后被装饰的类型，也就是说，尽管可以添加多个层，但是最后一层才是实际的类型，因此只有最后一层的方法时可视的</strong>，而混型的类型是所有被混合到一起的类型，因此对于装饰器来说，其明显的缺陷就是它只能有效地工作于装饰器中的一层（最后一层），而混型方法显然会更自然一些，因此，装饰器只是对由混型提出的问题的一种局限的解决方案</p><h3 id="与动态代理混合"><a href="#与动态代理混合" class="headerlink" title="与动态代理混合"></a>与动态代理混合</h3><p><strong>可以使用动态代理来创建一种比装饰器更贴近混型模型的机制，通过使用动态代理，所产生的类的动态类型将会是已经混入的组合类型</strong><br>由于动态代理的限制，每个被混入的类都必须是某个接口的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MixinProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">    Map&lt;String,Object&gt; delegatesByMethod;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mixin</span><span class="params">(TwoTuple&lt;Object,Class&lt;?&gt;&gt;... pairs)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(TwoTuple&lt;Object,Class&lt;?&gt;&gt; pair:pairs)&#123;</span><br><span class="line">          <span class="keyword">for</span>(Method method:pair.second.getMethods())&#123;</span><br><span class="line">              String methodName=method.getName();</span><br><span class="line">              <span class="comment">//the first inferface in the map</span></span><br><span class="line">              <span class="comment">//implements the method</span></span><br><span class="line">              <span class="keyword">if</span>(!delegatesByMethod.containsKey(methodName))&#123;</span><br><span class="line">                  delegatesByMethod.put(methodName,pair.first);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        String methodName=method.getName();</span><br><span class="line">        Object delegate=delegatesByMethod.get(methodName);</span><br><span class="line">        <span class="keyword">return</span> method.invoke(delegate,args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newInstance</span><span class="params">(TwoTuple... pairs)</span></span>&#123;</span><br><span class="line">        Class[] interfaces=<span class="keyword">new</span> Class[pairs.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pairs.length;i++)&#123;</span><br><span class="line">            interfaces[i]=(Class) pairs[i].second</span><br><span class="line">        &#125;</span><br><span class="line">        ClassLoader c1=pairs[<span class="number">0</span>].first.getClass().getClassLoader();</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(c1,interfaces,<span class="keyword">new</span> MixinProxy(pairs));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyMixin</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Object mixin=MixinProxy.newInstance(</span><br><span class="line">                tuple(<span class="keyword">new</span> BasicImp(),Basic.class),tuple(<span class="keyword">new</span> TimeStampedImp(),TimeStamped.class),</span><br><span class="line">                tuple(<span class="keyword">new</span> SerialNumberedImp(),SerialNumbered.class));</span><br><span class="line">        Basic b=(Basic)mixin;<span class="comment">//重点在这里</span></span><br><span class="line">        TimeStamped t=(TimeStamped)mixin;</span><br><span class="line">        SerialNumbered s=(SerialNumbered)mixin;</span><br><span class="line">        b.set(<span class="string">"Hello"</span>);</span><br><span class="line">        b.get();</span><br><span class="line">        t.getStamp();<span class="comment">//重点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为只有动态类型而不是静态类型才包含所有的混入类型，因此这种方式依然不如C++的方式好，因为可以在具有这些类型的对象上调用方法之前，你必须被强制要求向下转型到恰当的类型，但是，它明显更接近于真正的混型</p><h2 id="潜在类型机制"><a href="#潜在类型机制" class="headerlink" title="潜在类型机制"></a>潜在类型机制</h2><p>泛型的理想就是能够编写尽可能泛化代码，为了实现这一点，我们需要各种途径来放松带我们代码将要作用的类型所做的限制，同时不丢失静态类型检查的好处，然后，我们就可以编写出无需修改就可以应用于更多情况的代码，即更加“泛化”的代码<br>java泛型看起来是向这一方向迈进了一步，但你编写或使用只是持有对象的泛型时，这些代码可以引用于任何类型，后者，换个角度，“持有器”泛型能够声明：“我不关心你是什么类型”，如果代码不关心它将要作用的类型，那么这种代码就可以真正地被用在任何地方，并因此而相当地泛化<br>还是正如你所看到的那样，<strong>当要在泛型类型上执行操作（即调用Object方法之外的操作）时，就会产生问题，因为擦除要求指定可能会用到的泛型参数的边界，以安全地调用代码中的泛型对象上的具体方法，这是对“泛化”概念 的一种很明显地限制，因为限制了你的泛型类型，使它们继承自特定的类，或者实现特定的接口，在某些情况下，你最终可能会使用普通类或普通接口，因为限定边界的泛型可能会和指定类和接口没有任何区别</strong><br>某些编程语言提供了一种解决方案称为潜在类型机制或结构化参数机制，而更古怪的术语称为“鸭子类型机制”，鸭子理论非常有名，如果“它走起来像鸭子，叫起来像鸭子，那你你就可以将它当作鸭子看待”<br>泛型代码典型地将在泛型类型上调用少量的代码，而且潜在类型机制的语言只要求实现某个方法的子集，而不是某个特定的接口，从而方式了这种限制（并且产生了更加泛化的代码），正由于此，<strong>潜在类型机制使得你可以横跨多个类继承结构，调用不属于某个公共接口的方法，因此，实际上一段代码可以声明：“我不关心你是什么类型，只要你可以speck()和sit()即可</strong>”由于不要求具体类型，因此代码更加泛化<br>潜在类型机制是一种代码组织和复用机制，有了它编写出的代码相对没有它编写出的代码，能够更容易复用，代码组织和复用是所有计算机编程的基本手段，编写一次，多次使用，并在一个位置上保存代码，因为我并未被要求去命名我的代码要操作于其上的确切接口<br><strong>两种支持潜在类型机制的语言实例是Python和C++，Python是动态类型语言（实际上所有的类型检查都发生在运行时），而C++是静态类型语言（类型检查发生在编译期），因此潜在类型机制不要求静态类型还是动态类型检查</strong><br>我们下Python和C++的代码吧，即使你没有学过这两门语言，你也能理解下面代码的概念</p><h2 id="对缺乏潜在类型安全机制的补偿"><a href="#对缺乏潜在类型安全机制的补偿" class="headerlink" title="对缺乏潜在类型安全机制的补偿"></a>对缺乏潜在类型安全机制的补偿</h2><p>尽管java不支持潜在类型机制，但是这并不意味着有界泛型代码不能在不同的类型层次结构之间应用，也就是说，我们仍旧可以创建真正的泛型代码，但是这需要付出一些额外的努力</p><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>下面的profrom就是用了潜在类型机制<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mime</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walkAgainstTheWind</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span></span>&#123;System.out.println(<span class="string">"pretending to sit"</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushInvisibleWalls</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">"Mime"</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartDog</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;System.out.println(<span class="string">"Woof"</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span></span>&#123;System.out.println(<span class="string">"Sitting"</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reproduct</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommunicateReflectively</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">perform</span><span class="params">(Object specker)</span></span>&#123;</span><br><span class="line">        Class&lt;?&gt; spkr=specker.getClass();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Method m = spkr.getMethod(<span class="string">"speak"</span>);</span><br><span class="line">                m.invoke(specker);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                System.out.println(specker + <span class="string">" cannot speak"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Method m = spkr.getMethod(<span class="string">"sit"</span>);</span><br><span class="line">                m.invoke(specker);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                System.out.println(specker + <span class="string">"cannot sit"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(specker.toString(),e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LatentReflection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        CommunicateReflectively.perform(<span class="keyword">new</span> Mime());</span><br><span class="line">        CommunicateReflectively.perform(<span class="keyword">new</span> SmartDog());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的例子，类完全啊彼此分离的，没有任何公共基类（除了Object）或接口,通过反射，CommunicateReflectively.perform()能够动态地确定所需要的方法是否可用并调用它们，它甚至能够处理Mime只具有一个必须的方法这一事实，并能够部分实现其目标</p><h3 id="将一个方法应用于序列"><a href="#将一个方法应用于序列" class="headerlink" title="将一个方法应用于序列"></a>将一个方法应用于序列</h3><p><strong>反射提供了一些有趣的可能性，但是它将所有的类型检查都转移到了运行时，因此在许多情况下并不是我们所希望的，如果能够实现编译器类型检查，这通常更符合要求</strong>，但是有可能实现编译器类型检查和潜在类型机制吗？<br>我们看一个说明这个问题的示例，假设想要创建一个apply()方法，它能够将任何方法应用于谋而序列的所有对象，这是接口看起来并不适合的情况，因为你想要将任何方法应用到一个对象集合，而接口对于描述“任何方法”存在过多的限制，任何用java来实现这个需求呢？<br>最初，我们可以用反射来解决这个问题，由于有JavaSE5的可变参数，这种方法被证明是优雅的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apply</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T ,S extends Iterable&lt;? extends T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(S seq, Method f, Object... args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (T t : seq) &#123;</span><br><span class="line">                f.invoke(t, args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">()</span></span>&#123;System.out.println(<span class="keyword">this</span>+<span class="string">"rotate"</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reSize</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;System.out.println(<span class="keyword">this</span>+<span class="string">"resize"</span>+size);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilledList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">FilledList</span><span class="params">(Class&lt;? extends T&gt; type,<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">              add(type.newInstance());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplyTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        List&lt;Shape&gt;  shapes=<span class="keyword">new</span> FilledList&lt;&gt;(Shape.class,<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            shapes.add(<span class="keyword">new</span> Shape());</span><br><span class="line">        &#125;</span><br><span class="line">        Apply.apply(shapes, Shape.class.getMethod(<span class="string">"rotate()"</span>));</span><br><span class="line">        Apply.apply(shapes,Shape.class.getMethod(<span class="string">"reSize"</span>, <span class="keyword">int</span>.class),<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Square&gt; squares=<span class="keyword">new</span> FilledList&lt;&gt;(Square.class,<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            squares.add(<span class="keyword">new</span> Square());</span><br><span class="line">        &#125;</span><br><span class="line">        Apply.apply(squares,Square.class.getMethod(<span class="string">"retate"</span>));</span><br><span class="line">        Apply.apply(squares,Square.class.getMethod(<span class="string">"reSize"</span>, <span class="keyword">int</span>.class),<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        Apply.apply(<span class="keyword">new</span> FilledList&lt;Shape&gt;(Shape.class,<span class="number">10</span>),Shape.class.getMethod(<span class="string">"retate"</span>));</span><br><span class="line">        Apply.apply(<span class="keyword">new</span> FilledList&lt;Shape&gt;(Square.class,<span class="number">10</span>),Square.class.getMethod(<span class="string">"retate"</span>));</span><br><span class="line">        SimpleQueue&lt;Shape&gt; shapeQ=<span class="keyword">new</span> SimpleQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            shapeQ.add(<span class="keyword">new</span> Shape());</span><br><span class="line">            shapeQ.add(<span class="keyword">new</span> Square());</span><br><span class="line">        &#125;</span><br><span class="line">        Apply.apply(shapeQ,Shape.class.getMethod(<span class="string">"retate"</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们运气很好，因为碰巧在Java中内建了一个由Java容器类库使用的Iterable接口，因此，apply()方法可以接受任何实现了Iterable接口的事物，实际上，它还接受其他任何事物，只要能够使得这些事物是Iterable的就可以了<br>注意，我们必须要使用边界和通配符，以便是Apply和FilledList在所需要的情况下都可以使用，<br><strong>FilledList表示有些进退两难的情况，为了使用某种类型，它必须要有默认的构造器，但是java没有任何方式可以在编译器断言这件事，因此变成了一个运行时问题，确保编译器检查的有个常见的建议是定义一个工厂接口</strong>，它有一个可以生产对象的方法，然后FilledList接受这个接口而不是这个类型标记的“原生工厂（Class对象）”，<strong>但是，大部分的类都是在不了解你的接口的情况下创建的，因此也就没有实现这个接口</strong>，稍后，我们展示一种使用适配器的解决办法<br>使用类型标记是一种合理的折中，错误在运行时报告，所有你要有把握，这些错误将在开发过程的早期出现<br>注意，使用类型标记是java文献推荐的技术，但是也有很多人强烈推荐使用工厂方法让错误在编译器就被发现<br>尽管java解决方案被证明很优雅，但是我们必须知道使用反射（尽管反射在最近的版本中以及明显的改善）可能比非反射的实现要慢一些，因为大多数动作都是在运行时发生的，但是这不应该成为你使用这个解决方案的脚本，至少可以将其作为一种马上就能想到的解决方案  </p><h3 id="当你并未碰巧拥有正确的接口时"><a href="#当你并未碰巧拥有正确的接口时" class="headerlink" title="当你并未碰巧拥有正确的接口时"></a>当你并未碰巧拥有正确的接口时</h3><p>我们看到上面的例子，Iterable接口是内建，我们很容易创建容器并使用它，但是如果不存在刚好适合你的需求的接口呢？<br>看下面一个例子，让我们泛化FilledList中的思想，创建一个参数化的方法fill(),它接受一个序列<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fill</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(Collection&lt;T&gt; collection, Class&lt;? extends T&gt; type, <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                collection.add(type.newInstance());</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Contract</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id =counter++;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getSimpleName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TitleTransfer</span> <span class="keyword">extends</span> <span class="title">Contract</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FillTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       List&lt;Contract&gt; contracts=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       Fill.fill(contracts,Contract.class,<span class="number">3</span>);</span><br><span class="line">       Fill.fill(contracts,TitleTransfer.class,<span class="number">2</span>);</span><br><span class="line">       <span class="keyword">for</span>(Contract c:contracts)&#123;</span><br><span class="line">           System.out.println(c);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//don't work fill()is not generic enough;</span></span><br><span class="line">       <span class="comment">//SimpleQueue&lt;Contract&gt; simpleQueue=new SimpleQueue&lt;&gt;();</span></span><br><span class="line">       <span class="comment">//Fill.fill(simpleQueue,Contract.class,3);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们使用java编写代码时，会陷入问题之中，因为没有任何像前面实例的Iterable接口那样的“Addable”便利接口，因此你不能说：“可以在任何事物上调用add()”,而必须说：“可以在Collection的子类型上调用add()”,这样产生的代码就不是特别泛化，因为它必须被限制为只能工作于Collection的实现，如果我试图使用没有实现Collection的类，那么我的泛化代码将不能工作<br>上面的情况中，因为java设计着（可以理解地）没有预见对“Addable()”接口的需要，所有我们被现在在Collection的继承层次结构之内，即便SimpleQueue有个add()方法，它也不能工作，因此这样的代码不是特别泛化，有了潜在类型机制，情况就会不同了</p><h3 id="用适配器仿真潜在类型机制"><a href="#用适配器仿真潜在类型机制" class="headerlink" title="用适配器仿真潜在类型机制"></a>用适配器仿真潜在类型机制</h3><p>java泛型并不是没有潜在类型机制，而我们需要使用潜在类型机制这样的东西去编写能够跨类边界应用的代码（也就是“泛化”代码），存在某种方式可以绕过这项限制吗？<br>潜在类型机制将在这里实现什么？它意味着你可以编写代码声明：“我不关心我在这里使用的类型，只要它们具有这些方法即可”，<strong>实际上，潜在类型机制创建了一个包含所需方法的隐式接口</strong>，因此它遵循这样的规则，如果我们手工编写了所需的接口（因为java并没有为我们做这些事），那么它就应该能够解决问题<br><strong>从我们拥有的接口中编写代码来产生我们需要的接口，这就是适配器设计模式的一个典型示例</strong>，我们可以使用适配器来适配已有的接口，以产生想要的接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Addable</span>&lt;<span class="title">T</span>&gt;</span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(T item)</span></span>;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fill2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(Addable&lt;T&gt; addable,Class&lt;? extends T&gt; type,<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                addable.add(type.newInstance());</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载的fill()的类型参数Generator&lt;T&gt; 确保了编译期的类型安全，所以将错误阻止在编译期，在运行时不会抛出</span></span><br><span class="line">    <span class="comment">//任何错误，这种方式比使用类型标记更安全</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(Addable&lt;T&gt; addable,Generator&lt;T&gt; generator,<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            addable.add(generator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//to adapter a base Type,you must use composition</span></span><br><span class="line"><span class="comment">//make any Collection Addable using composition</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddableCollectionAdapter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Addable</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Collection&lt;T&gt; c;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AddableCollectionAdapter</span><span class="params">(Collection&lt;T&gt; c)</span></span>&#123; c=c;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T item)</span></span>&#123; c.add(item); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//a Helper to capture the type automatically</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Addable&lt;T&gt; <span class="title">collectionAdapetr</span><span class="params">(Collection&lt;T&gt; c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AddableCollectionAdapter&lt;T&gt;(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//to adapt a specific type,you can use inheritance</span></span><br><span class="line"><span class="comment">//make a SimpleQueue Addable using inheritance</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddableSimpleQueue</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">SimpleQueue</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Addable</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T item)</span></span>&#123; <span class="keyword">super</span>.add(item);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fill2Test</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       List&lt;Coffee&gt; coffees=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       Fill2.fill(<span class="keyword">new</span> AddableCollectionAdapter&lt;&gt;(coffees),Coffee.class,<span class="number">3</span>);</span><br><span class="line">       Fill2.fill(Adapter.collectionAdapetr(coffees),Coffee.class,<span class="number">3</span>);</span><br><span class="line">       Fill2.fill(Adapter.collectionAdapetr(coffees),Latte.class,<span class="number">3</span>);</span><br><span class="line">       <span class="keyword">for</span>(Coffee coffee:coffees)&#123;</span><br><span class="line">           System.out.println(coffee);</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(<span class="string">"-------------------------------------------------------"</span>);</span><br><span class="line">       AddableSimpleQueue&lt;Coffee&gt; coffeeQueue=<span class="keyword">new</span> AddableSimpleQueue&lt;&gt;();</span><br><span class="line">       Fill2.fill(coffeeQueue,Coffee.class,<span class="number">3</span>);</span><br><span class="line">       Fill2.fill(coffeeQueue,Latte.class,<span class="number">3</span>);</span><br><span class="line">       <span class="keyword">for</span>(Coffee coffee:coffeeQueue)&#123;</span><br><span class="line">           System.out.println(coffee);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Fill2对Collection的要求与Fill不同，它只需要实现了Addable的对象，而Addable已经为Fill编写了——它是我希望编译器帮我创建的潜在类型的一种体现<br>在这个版本中，我还<strong>添加了一个重载的fill,它接受一个Generateor而不是类型标记，Generator在编译器是类型安全的，编译器将确保传递的是正确的Generator,因此不会抛出任何异常</strong><br>第一个适配器，AddableCollectionAdapter，可以工作与基类Collection，这意味着Collection的任何实现都可以使用，这个版本直接存储Collection引用，并使用它来实现Add();<br>如果一个具体类型而不是继承结构的基类，那么当使用继承来创建适配器时，你可以稍微少写一些代码，但是这个适配器只适用于为特定的类型适配所需的接口，这种适配器称为“预适配器”，也就是预先定义好的适配器，之间创建使用即可，而第一种适配器需要传递需要适配的接口才能创建，这就是两种适配器设计模式的不同</p><h2 id="将函数对象作为策略"><a href="#将函数对象作为策略" class="headerlink" title="将函数对象作为策略"></a>将函数对象作为策略</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Combiner</span>&lt;<span class="title">T</span>&gt;</span>&#123; <span class="function">T <span class="title">combine</span><span class="params">(T x, T y)</span></span>;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UnaryFunction</span>&lt;<span class="title">R</span>,<span class="title">T</span>&gt;</span>&#123; <span class="function">R <span class="title">function</span><span class="params">(T x)</span></span>;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Collector</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">UnaryFunction</span>&lt;<span class="title">T</span>,<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">result</span><span class="params">()</span></span>;<span class="comment">//extract result of collecting parameter</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UnaryPredicate</span>&lt;<span class="title">T</span>&gt;</span>&#123; <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T x)</span></span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Functional</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">reduce</span><span class="params">(Iterable&lt;T&gt; seq,Combiner&lt;T&gt; combiner)</span></span>&#123;</span><br><span class="line">        Iterator&lt;T&gt; it=seq.iterator();</span><br><span class="line">        <span class="keyword">if</span>(it.hasNext())&#123;</span><br><span class="line">            T result=it.next();</span><br><span class="line">            <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">                result=combiner.combine(result,it.next());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Collector&lt;T&gt; <span class="title">forEach</span><span class="params">(Iterable&lt;T&gt; seq,Collector&lt;T&gt; func)</span></span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(T item:seq)&#123;</span><br><span class="line">           func.function(item);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> func;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;R,T&gt; <span class="function">List&lt;R&gt; <span class="title">transform</span><span class="params">(Iterable&lt;T&gt; seq,UnaryFunction&lt;R,T&gt; func)</span></span>&#123;</span><br><span class="line">        List&lt;R&gt; result=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(T t:seq)&#123;</span><br><span class="line">            result.add(func.function(t));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">filter</span><span class="params">(Iterable&lt;T&gt; seq, UnaryPredicate&lt;T&gt; pred)</span></span>&#123;</span><br><span class="line">        List&lt;T&gt; result =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(T t:seq)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pred.test(t))&#123;</span><br><span class="line">                result.add(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerAdder</span> <span class="keyword">implements</span> <span class="title">Combiner</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">combine</span><span class="params">(Integer a,Integer b)</span></span>&#123;<span class="keyword">return</span> a + b;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerSubtracter</span> <span class="keyword">implements</span>  <span class="title">Combiner</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">combine</span><span class="params">(Integer a, Integer b)</span></span>&#123;<span class="keyword">return</span> a-b;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BigDecimalAdder</span> <span class="keyword">implements</span> <span class="title">Combiner</span>&lt;<span class="title">BigDecimal</span>&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> BigDecimal <span class="title">combine</span><span class="params">(BigDecimal x,BigDecimal y)</span></span>&#123;<span class="keyword">return</span> x.add(y);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BigIntegerAdder</span> <span class="keyword">implements</span> <span class="title">Combiner</span>&lt;<span class="title">BigInteger</span>&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> BigInteger <span class="title">combine</span><span class="params">(BigInteger x,BigInteger y)</span></span>&#123;<span class="keyword">return</span> x.add(y);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">GreaterThan</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; <span class="keyword">implements</span> <span class="title">UnaryPredicate</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> T bound;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">GreaterThan</span><span class="params">(T bound)</span></span>&#123; bound=bound;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T item)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> item.compareTo(bound)&gt;<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiplyingInteger</span> <span class="keyword">implements</span> <span class="title">Collector</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer val=<span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">function</span><span class="params">(Integer x)</span></span>&#123;</span><br><span class="line">            val*=x;</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">result</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; l1= Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>);</span><br><span class="line">       </span><br><span class="line">        Integer addResult=reduce(l1,<span class="keyword">new</span> IntegerAdder());</span><br><span class="line">        Integer substractResult=reduce(l1,<span class="keyword">new</span> IntegerSubtracter());</span><br><span class="line">        List&lt;Integer&gt; listResult=filter(l1,<span class="keyword">new</span> GreaterThan&lt;Integer&gt;(<span class="number">4</span>));</span><br><span class="line">        forEach(l1,<span class="keyword">new</span> MultiplyingInteger()).result();</span><br><span class="line">        <span class="comment">//省略不写</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>策略模式可以产生非常优雅得的代码，因为它将“变化的事物”完全隔离到一个函数对象<strong>，函数对象就是在某种程度上行为像函数的对象——一般地，会有一个相关的方法，函数对象的价值就在于，与普通的方法不同，它们可以传递出去，并且还可以拥有在多个调用之间持久化的状态，当然可以用类中的任何方法来实现与此相似的工作，但是（与使用任何设计模式一样）函数对象主要是由其目的来区别的</strong>这里的，目的即使要创建某种事物，使它的行为就像一个可以传递出去的单个方法一样，这样，它就和策略模式紧耦合了，有时甚至无法区分<br>其实各种设计模式之间的界限真的很模糊，有时很难区分，有时靠设计目的区分，所以没有绝对的模式</p><h2 id="总结：转型真的如此之糟吗？"><a href="#总结：转型真的如此之糟吗？" class="headerlink" title="总结：转型真的如此之糟吗？"></a>总结：转型真的如此之糟吗？</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;一般的类和方法，只能使用具体的类型，要么是基本类型，那么是自定义的类，如果要编写可以应用与多种类型的代码，这种刻板的限制对代码的束缚就会很大
      
    
    </summary>
    
      <category term="学习心得" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>类型信息</title>
    <link href="http://yoursite.com/2018/10/12/%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF/"/>
    <id>http://yoursite.com/2018/10/12/类型信息/</id>
    <published>2018-10-12T05:21:23.000Z</published>
    <updated>2018-10-12T17:52:21.559Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>运行时类型信息（runtime Type information）使得你可以在程序运行时发现和使用类型信息<br>它使你从只能在编译期执行面向类型的操作的禁锢中解脱出来<br>java是如何让我们在运行时识别对象和类的信息的，主要有两种方式，一种是“传统的”RTTI，它假定我么不能在编译时已经知道了所有的类型，另一种是“反射”机制，它允许我们在运行时发现和使用类的信息  </p><h2 id="为什么需要RTTI"><a href="#为什么需要RTTI" class="headerlink" title="为什么需要RTTI"></a>为什么需要RTTI</h2><p>我们看一下多态的例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123; System.out.print(<span class="keyword">this</span>+<span class="string">".draw()"</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cricle</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">"Cricle"</span>;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">"Square"</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shapes</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;Shape&gt; shapeList= Arrays.asList(<span class="keyword">new</span> Cricle(),<span class="keyword">new</span> Square());</span><br><span class="line">        <span class="keyword">for</span>(Shape shape:shapeList)&#123;</span><br><span class="line">            shape.draw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个例子中，当把Shape对象放在List<shape>列表时会向上转型，但向上转型为Shape的时候，也丢失了Shape对象的具体的类型，对于列表而言，它们只是Shape类型的对象（我们这样思考一个问题，为什么我们在编程的时候，没有使用具有的引用类型，而是向上转型为更加通用的类型引用，诚然，我们可以使用更具体的类型来表示对象类型，拥有更多的方法可以操作这个类型，但是我们却没有办法写更适用的代码，每一个代码片段都与特定类型相关联，耦合度太高，我们要将类型向上转型为它的基类，这样拥有同样的接口，但是却丢失了关于这个对象具体类型的信息，<strong>注意，我们说的丢失了具体类型的信息指的是在编译期，在编译期，我们会将它的对象类型当作基类看待，实际上，对象本身的类型信息并没有丢失，我们可以在程序运行的时候重新拿到本来属于它的身份（类型信息）</strong>，这就是运行时类型信息的全部解释）<br>当从列表中取出元素时，这种容器——实际上将它所有的事物都当成Object持有——会自动将结果转型回Shape的，在java中所有的类型转换都是在运行是进行正确的检查，这也是RTTI名字的含义，在这个例子中，RTTI类型转换的并不彻底，Object被转型为Shape，而不是转换成Cricle，Square这种更具体的类型，这是因为我们只知道这个List<shape>保存的是Shape，将由容器和Java泛型机制保证这一点，而在运行时，由类型转换确保这一点</shape></shape></p><h2 id="Class对象"><a href="#Class对象" class="headerlink" title="Class对象"></a>Class对象</h2><p>要理解RTTI在java中的工作原理，首先必须知道类型信息在运行时是如何表示的，这项工作是被称为Class对象的特殊对象完成的，它包含了与类相关的信息， Class对象就是用来创建类的所有“常规”对象的，java使用Class对象来执行其RTTI，即使你正在执行类型转换这样的工作<br>类是程序的一部分，每个类都是一个Class对象，换言之，每当编写并且编译一个新类，就会产生一个Class对象（更恰当的说，是保存在一个同名的.class文件中，这个.class文件保存在关于这个类的一切信息，我们可以将这个.class文件看作对象，这和类加载之后在内存中创建的Class对象没有太大的分别，最大的区别也许就是存储位置的不同）为了生成这个类的对象，运行这个程序的Java虚拟机（JVM)将使用被称为“类加载器”的子系统<br>所有的类都是在第一次被使用时，动态加载到JVM中的，当程序创建第一个对类的静态成员的引用时，就会加载这个类，这额证明了构造器也是静态方法，虽然在它之前没有static关键字，因此，java程序在它开始之前并非完全加载，其各个部分都是在必需时才加载的，如果尚未加载，默认的类加载器就会根据类名查找.class文件，而这个类的字节码文件就被加载，它会接受验证，以确保其没有被破坏，并且不包含不良的Java代码<br>（从我的理解来看，程序是对象与对象之间通讯，而Class掌握着生成这些对象和怎样通讯的所有知识，我们编写程序就是编写这些类，类由虚拟机加载，并且通过虚拟机创建对象，互相在对象之间传递消息，那么虚拟机是什么？虚拟机是程序，是代码运行的平台，我们编写的类都是程序的构件，以供虚拟机使用）<br>一旦某个类的Class对象被载入内存，它就被用来创建这个类的所有对象</p><pre><code>Class Class.forName(String className);</code></pre><p>上面的方法是Class类的一个静态方法，返回一个Class对象的引用，如果你有某个对象的引用，也可以使用Object的getClass()方法，得到一个Class对象的引用，对forName()的调用就是为了产生副作用，其实更准确的说，forName()方法的调用是为了加载某个类，所有，如果这个类还没有被加载，那么就加载它，在加载的过程中，类的static子句开始执行<br>记住，所有的Class对象都是Class类，这听起来感觉很奇怪，我们知道类的所有信息都是在.class文件保存着，类加载器子系统通过这些文件会在内存空间创建相应的Class对象，其实这些对象和普通的对象的共同点就是对象，只不过这个Class对象拥有着这个类型信息，而其他对象拥有着属性数据，那么这些Class对象之间肯定有着某种共性，而这种共性就是它们都是Class类型<br>我们得到了Class对象的引用，就可以操作它以获得它的数据（类型信息）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getName()</span><br><span class="line">getSimpleName()</span><br><span class="line">getCanonicalName()</span><br><span class="line">getInterfaces()</span><br><span class="line">isInterface()</span><br><span class="line">getSuperClass()</span><br><span class="line">newInstance()</span><br></pre></td></tr></table></figure></p><p>Class对象的newInstance()方法是实现“虚拟构造器”的一种途径，虚拟构造器允许你声明“我不知道你的确切类型”，但是啊无论如何要正确地创建你自己，<strong>比如up是一个Class引用，在编译期不具备任何更进一步的类型信息，当你创建新实例时，会得到一个Object对象</strong>，但是这个引用指向一个确切的类型，当然你可以发送Object能够接受的信息之外的任何消息之前，你必须更多的了解它，并进行某种转型，另外，使用newInstance()必须带有默认的构造器  </p><h3 id="类字面常量"><a href="#类字面常量" class="headerlink" title="类字面常量"></a>类字面常量</h3><p>java提供了另一种方法来生成对Class对象的引用，即使用类字面量常量 例如<br>    FancyToy.class<br>这样做不仅更简单，而且也更安全，因为它在编译时就会受到检查（因此不需要置于try语句块中），并且它根除了forName()方法的调用，所有也更高效<br>建议使用“.class”的形式，以保持与普通类的一致性<br>注意，有一点很有趣，使用“.class”来创建对Class对象的引用时，不会自动地初始化Class对象，为了使用类而做的准备工作实际上包含三个步骤</p><ol><li>加载：这是类加载器执行的，该步骤将查找字节码，并从这些字节码中创建一个Class对象</li><li>链接：在链接阶段将验证类中的字节码，为静态域分配存储空间，并且如果必需的话，将解析这个类对其他类的所有引用</li><li>初始化：如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块<br>初始化被延迟到了对静态方法（构造器隐式地是静态的）或非常数静态方法进行首次引用是才执行<br>初始化有效地实现了尽可能的“惰性”，仅使用.class语法来获得对类的引用不会引发初始化，和是和forName()不同的  <h3 id="泛化的Class引用"><a href="#泛化的Class引用" class="headerlink" title="泛化的Class引用"></a>泛化的Class引用</h3>Class引用总是指向某一个Class对象，它可以制造类的实例，并包含可作用与这些实例的所有方法代码，它还包括了该类的静态成员。因此。Class引用表示的就是指向它所指对象的确切类型，而该对象表示Class类的一个对象<br>如何将它的类型变得更具体，而<strong>这是通过允许你对Class引用所指向的Class对象的类型进行限定而实现的</strong>，这里使用了泛型语法，比如<br> Class<integer> classRef=int.class;<br>你也许会认为，下面的代码也是正确的<br> Class<number> classRef=int.class;<br>但是它是无法工作的，虽然Number是Integer的基类，但是Integer的Class对象不是Number的Class对象的子类，这个例子的正确做法是<br> Class&lt;? extends Number&gt; classRef=int.class;<br>当你使用泛型语法的时候将会发生一件有趣的事情，newInstance()将会返回该对象的确切的类型，而不是基本的Object,如下：<h3 id="新的转型语法"><a href="#新的转型语法" class="headerlink" title="新的转型语法"></a>新的转型语法</h3>Class引用的转型语法 cast()  不过我们很少使用<h2 id="类型转换前先做检查"><a href="#类型转换前先做检查" class="headerlink" title="类型转换前先做检查"></a>类型转换前先做检查</h2>目前我们已知的RTTI形式包括</number></integer></li><li>传统的类型转换 如“(Shape)” 由RTTI确保类型转换的正确性，如果执行了一个错误的转换，就会抛出一个ClassCastException</li><li>代表对象的类型的Class对象，通过查询Class对象可以获取运行时所需的信息</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;运行时类型信息（runtime Type information）使得你可以在程序运行时发现和使用类型信息&lt;br&gt;它使你从只能在编译期执行面
      
    
    </summary>
    
      <category term="学习心得" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>字符串</title>
    <link href="http://yoursite.com/2018/10/11/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://yoursite.com/2018/10/11/字符串/</id>
    <published>2018-10-11T11:14:03.000Z</published>
    <updated>2018-10-12T05:20:29.109Z</updated>
    
    <content type="html"><![CDATA[<h2 id="不可变String"><a href="#不可变String" class="headerlink" title="不可变String"></a>不可变String</h2><p>&emsp;&emsp;String对象是不可变的，查看JDK文档，会发现，String类中每一个看起来会修改String值的方法，实际上都是创建了一个全新的String对象，以包含修改后的字符串内容，而最初的String对象纹丝未动，当吧String对象作为方法的参数时，都会复制一份引用，而该引用所指的对象其实一直待在单一的物理位置上，从未动过<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Immutable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">upcase</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String q=<span class="string">"howdy"</span>;</span><br><span class="line">        System.out.print(q);<span class="comment">//howdy</span></span><br><span class="line">        String qq=upcase(q);</span><br><span class="line">        System.out.print(qq);<span class="comment">//HOWDY</span></span><br><span class="line">        System.out.print(q);<span class="comment">//howdy</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;上例upcase()返回的引用已经指向了一个新的对象了，而原本的q则还在原地<br>&emsp;&emsp;String的这种行为方式其实正是我们想要的，难道我们真的希望upcase()改变参数的行为吗？参数是为该方法提供信息的，而不是先让该方法改变自己的</p><h2 id="重载“-”与StringBuilder"><a href="#重载“-”与StringBuilder" class="headerlink" title="重载“+”与StringBuilder"></a>重载“+”与StringBuilder</h2><p>&emsp;&emsp;String对象的不可变性带来了效率的问题，为String对象重载的“+”操作符就是一个例子，重载的意思是，一个操作符在应用于不同的类上，被赋予老特殊的含义<br>&emsp;&emsp;我们经常使用“+”操作进行字符串的拼接，可是由于String对象的不可变性，我们猜想每一次的连接操作都会产生一个新的String对象，若是进行多次的拼接操作，会有大量的中间String对象产生，会造成内存资源的浪费和垃圾回收器的负担，比如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String concatStr=<span class="string">"asdad"</span>+<span class="string">"asdas"</span>+<span class="string">"sfadfdf"</span>+<span class="string">"asdasd"</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;但是当我们使用javap，对上述代码jinx反编译的时候，就会看到，在进行字符拼接的时候，编译器帮我们做了优化，首先new StringBuilder对象，通过append()方法拼接，使用toString()返回一个字符串对象，编译器以及帮我们的源码进行了优化，那么是否我们就确信编译器优化，而毫无考虑的就到处使用“+”操作符进行字符串的拼接操作呢？我们在看一个例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(String str:StringArr[])&#123;</span><br><span class="line">    s+=str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">for</span>(String str:StringArr)&#123;</span><br><span class="line">   sb.append(str);</span><br><span class="line">&#125;</span><br><span class="line">sb.toString();</span><br></pre></td></tr></table></figure></p><p>我们在进行javap进行反编译，可知在上面的第一个例子，每次循环内都要创建new StringBuilder(),而第二个例子只创建一次，那么这个例子就可以说明什么时候应该使用StringBuilder来对字符串进行拼接操作了<br>StringBuilder提供了丰富而全面的方法，包括insert(),replace(),subString()甚至reverse(),但是最常用的还是append()a,toString()，还有delete()<br>Stringbuilder是Java SE5引入的，在这之前java用的是StringBuffer,后者是线程安全的，因此开销也会大些  </p><h2 id="无意识的递归"><a href="#无意识的递归" class="headerlink" title="无意识的递归"></a>无意识的递归</h2><p>我们一般经常都会调用一个对象的toString()方法，比如容器的打印，实际上也会调用每个元素的toString()方法，若我们想要打印对象的内存地址怎么办呢？下面是一个对象，重新定义了toString()方法，并且打印自己的内存地址<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InfiniteRecursion</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"asdasdas"</span>+<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的定义是对的吗？完全错误，如果我们调用这个对象的toString()方法就会导致递归，因为我们对this也执行了toString()调用，没完没了，正确的方法如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="string">"asdasdas"</span>+<span class="keyword">super</span>.toString();</span><br></pre></td></tr></table></figure></p><p>因为这样会调用基类的toString方法，就避免了递归</p><h2 id="String上的操作"><a href="#String上的操作" class="headerlink" title="String上的操作"></a>String上的操作</h2><p>下面是String对象具备的一些基本操作  </p><table><thead><tr><th>方法</th><th>参数，重载版本</th><th>应用</th></tr></thead><tbody><tr><td>构造器</td><td>重载版本：默认版本，String，StringBuilder<br>StringBuffer char数组，byte数组</td><td>创建String对象</td></tr><tr><td>length()</td><td></td><td>String中字符的个数</td></tr><tr><td>charAt()</td><td>int索引</td><td>取得String中该索引位置上的char</td></tr><tr><td>getChars(),getBytes()</td><td>要复制部分的起点和终点的索引，<br>复制的目标数组，目标数组，目标数组的起始索引</td><td>复制char或byte到一个目标数组中</td></tr><tr><td>toCharArray()</td><td></td><td>生成一个char[]</td></tr><tr><td>equals(),equalsIgnoreCase()</td><td>与之进行比较的String</td><td>比较两个String的内容是否相同</td></tr><tr><td>compareTo()</td><td>与之进行比较的String</td><td>按词典顺序比较String的内容，比较结果为负数，零，正数，注意，大小写不等价</td></tr><tr><td>contains()</td><td>要搜索的CharSequence</td><td>如果该String对象包含参数的内容，则返回true</td></tr><tr><td>containEquals()</td><td>与之进行比较的CharSequence或StringBuffer</td><td>如果该String与参数的内容一致，则返回true</td></tr><tr><td>equealsIgnoreCase()</td><td>与之进行比较的String</td><td>忽略大小写的比较相等性</td></tr><tr><td>regionMatcher()</td><td>该String的索引偏移量，另一个String及其索引偏移量，<br>要比较的长度，重载版本增加了“忽略大小写”功能</td><td>返回boolean结果，已表明所比较区域是否相等</td></tr><tr><td>StartsWith()</td><td>可能的起始String，重载版本在参数中增加了偏移量</td><td>返回值为boolean值</td></tr><tr><td>endsWith()</td><td>该String可能的后缀String</td><td>返回boolean值</td></tr><tr><td>indexOf(),lastIndexOf()</td><td>重载版本包括：char，char与起始索引，<br>String，String与起始索引</td><td>如果该String并不包含此参数，就返回-1<br>否则返回此参数在String中的起始索引，lastIndexOf()是从后向前搜索</td></tr><tr><td>subString()(subSequence())</td><td>重载版本：起始索引;起始索引+终点索引</td><td>返回一个新的String，以包含参数指定的字符串</td></tr><tr><td>concat()</td><td>要连接的字符串</td><td>返回一个新的String对象，内容为原始String连接上参数String</td></tr><tr><td>replace()</td><td>要替换掉的字符，用来进行替换的新字符。<br>也可以用一个CharSequence来替换另一个CharSequence</td><td>返回替换字符后的新String对象<br>如果，没有替换发生，则返回原始的String对象</td></tr><tr><td>toLowerCase(),toUpCase()</td><td></td><td>将字符的大小写改变，返回一个新的字符串</td></tr><tr><td>trim()</td><td></td><td>将字符串两端的空白字符删除</td></tr><tr><td>valueOf()</td><td>重载版本：Object;char[];char[],偏移量，与字符个数；<br>boolean；char;int;lang;float;double</td><td>返回一个表示参数内容的String</td></tr><tr><td>intern()</td><td></td><td>为每个唯一的字符序列生成一个且仅生成一个String引用  </td></tr></tbody></table><h2 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h2><p>在长久的等待之后，java SE5终于推出了C语言中printf()风格的格式化输出</p><h3 id="System-out-format"><a href="#System-out-format" class="headerlink" title="System.out.format"></a>System.out.format</h3><p>java SE5引入的format()方法可用于PrintStream或PrintWriter对象，format()方法模仿C语言的printf()，它只需要一个简单的格式化字符串和一串的参数就可，语法如下.以System.out为例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.format(<span class="string">"Row 1:[%d %f]\n"</span>,x,y);</span><br></pre></td></tr></table></figure></p><h3 id="Formatter类"><a href="#Formatter类" class="headerlink" title="Formatter类"></a>Formatter类</h3><p>在java中，所有新的格式化功能都由java.util.Formatter类处理,可以将Formatter看作一个翻译机，它将你的格式化字符串与数据翻译成需要的结果，当你创建一个Formatter对象的时候，可以向其构造器传递一些信息，告诉它最终的结果将向哪里输出  </p><h3 id="格式化说明符"><a href="#格式化说明符" class="headerlink" title="格式化说明符"></a>格式化说明符</h3><p>在插入数据时，如果想要控制空格与对齐，你需要更精细复杂的格式修饰符，一下是其抽象的语法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[argument_index$][flags][width].[precision]conversion</span><br></pre></td></tr></table></figure></p><p>最常用的是width控制一个域的最小尺寸，数据是右对齐的，可以添加“-”标志来控制对其方向<br>不是所有类型的元素都能用precision，而且不同类型的元素使用precision代表的含义也不相同<br>Formatter转换（conversion）<br>下面包含了最常用的类型转换   </p><table><thead><tr><th></th><th>：类型转换：</th></tr></thead><tbody><tr><td>d</td><td>整数型（十进制）</td></tr><tr><td>c</td><td>unicode字符</td></tr><tr><td>b</td><td>Boolean值</td></tr><tr><td>s</td><td>String</td></tr><tr><td>f</td><td>浮点数（十进制）</td></tr><tr><td>e</td><td>浮点数（科学计数）</td></tr><tr><td>x</td><td>整数（十六进制）</td></tr><tr><td>h</td><td>散列码</td></tr><tr><td>%</td><td>字符“%”</td></tr></tbody></table><h3 id="String-format"><a href="#String-format" class="headerlink" title="String.format()"></a>String.format()</h3><p>java SE5也参考了C的sprintf()的方法，以生成格式化的String对象，String.format()是一个static方法，它接受与Formatter.format()相同的参数，但返回一个String对象，当你只使用formatter()方法一次的时候，String.format()是个不错的选择，语法 类似如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String result = String.format(<span class="string">"(t%d,q%d) %s"</span>,transcationID,queryID,message);</span><br></pre></td></tr></table></figure></p><p>其实在String.format()内部，它是创建一个Formatter对象，然后将你的参数传递给它，不过与其自己做这些事情，不如使用便捷的String.format()代码更清晰易读</p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式是一种强大而灵活的文本处理工具，<strong>使用正则表达式，我们能够以编程的方式，构造复杂的文本，并对输入的字符串进行搜索，一旦找到匹配这些模式的部分，你就能够随心所欲地对它们进行处理</strong>，正则表达式提供了一种完全通用的方式，能够解决各种字符串处理相关的问题，匹配，选择，编辑以及验证</p><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>在其他的语言中,\\表示“我想要在表达式中插入一个普通的反斜线，请不要给他任何特殊的意义，而在java中，\\的意思是”我要插入正则表达式的反斜线，”，所以其后的字符具有一个特殊的意义，你想插入一个普通的反斜线，则应该这样\\\\”<br>应用正则表达式最简单的途径，就是利用String类内建的matches()方法<br>String还有一个非常有用的正则表达式工具——split()方法，其功能是“将字符串从正则表达式匹配的地方切开”，split()还有一个重载的版本，它允许你限制字符串分割的次数<br>如果只是需要使用一次正则表达式，那么上面的方法是很方便的吗，但是如果你想对一个正则表达式反复复用，那么非String类型的正则表达式具备更加的性能和功能</p><h3 id="创建正则表达式"><a href="#创建正则表达式" class="headerlink" title="创建正则表达式"></a>创建正则表达式</h3><hr><table><thead><tr><th></th><th>字符</th></tr></thead><tbody><tr><td>B</td><td>指定字符B</td></tr><tr><td>\xhh</td><td>十六进制值为0xhh的字符</td></tr><tr><td>\uhhhh</td><td>十六进制表示为oxhhhh的Unicode字符</td></tr><tr><td>\n</td><td>换行符</td></tr><tr><td>\t</td><td>制表符</td></tr><tr><td>\r</td><td>回车</td></tr><tr><td>\f</td><td>换页</td></tr><tr><td>\e</td><td>转义（Escape）</td></tr></tbody></table><table><thead><tr><th></th><th>字符类</th></tr></thead><tbody><tr><td>.</td><td>任意字符</td></tr><tr><td>[abc]</td><td>包含a,b，c的任何字符（和a</td><td>b</td><td>c作用相同）</td></tr><tr><td>[^abc]</td><td>除了a,b,c之外的任意字符（否定）</td></tr><tr><td>[a-zA-Z]</td><td>从a到或从A到Z的任何一个字符</td></tr><tr><td>[abc[hij]]</td><td>任意a,b,c,h.i,j的字符（与a</td><td>b</td><td>c</td><td>h</td><td>i</td><td>j的作用相同）</td></tr><tr><td>[a-z&amp;&amp;[hij]]</td><td>任意h,i,j（交集）</td></tr><tr><td>\s</td><td>空白符（空格，tab,换行，换页或回车）</td></tr><tr><td>\S</td><td>非空白符</td></tr><tr><td>\d</td><td>数字[0-9]</td></tr><tr><td>\D</td><td>非数字[^0-9]</td></tr><tr><td>\w</td><td>词字符[a-zA-Z0-9]</td></tr><tr><td>\w</td><td>非词字符[^\w]</td></tr></tbody></table><table><thead><tr><th></th><th>逻辑操作符</th></tr></thead><tbody><tr><td>XY</td><td>Y紧跟在X后面</td></tr><tr><td>X</td><td>Y</td><td>X或Y</td></tr><tr><td>(X)</td><td>捕获组（capturing group）可以在表达式中引用\i第一i个捕获组</td></tr></tbody></table><table><thead><tr><th></th><th>边界匹配符</th></tr></thead><tbody><tr><td>^</td><td>一行的起始</td></tr><tr><td>$</td><td>一行的结束</td></tr><tr><td>\b</td><td>非词的边界</td></tr><tr><td>\B</td><td>词的边界</td></tr><tr><td>\G</td><td>前一个匹配的结束</td></tr></tbody></table><h3 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h3><p>量词描述了一个模式吸收输入文本的方式：</p><ul><li>贪婪型：量词总是贪婪的，除非有其他的选项被设置，贪婪表达式会为所有可能的模式发现尽可能多的匹配，导致此问题的一个典型理由就是假定我们的模式仅能匹配第一个可能的字符组，如果它是贪婪的，那么它就会继续往下匹配  </li><li>勉强型：用问好来指定，这个量词匹配满足模式所需最少字符数，因此也称做懒惰的，最少匹配的，非贪婪的，或不贪婪的  </li><li>占有型：目前，这种类型的量词只有java语言中才可用，并且也更高级，当正则表达式被应用于字符串时，它会产生相当多的状态，以便在匹配失败时可以回溯，而“占有的”量词并不保存这些中间状态，因此它们可以防止回溯，它们常常用于防止正则表达式失控，因此可以使正则表达式执行起来更有效  </li></ul><table><thead><tr><th></th><th>贪婪型</th><th>勉强型</th><th>占有型</th><th>如何匹配</th></tr></thead><tbody><tr><td>X?</td><td>X??</td><td>x?+</td><td>一个或零个X</td></tr><tr><td>X*</td><td>X*?</td><td>X*+</td><td>零个或者多个X</td></tr><tr><td>X+</td><td>X+?</td><td>X++</td><td>一个或者多个X</td></tr><tr><td>X{n}</td><td>X{n}?</td><td>X{n}+</td><td>恰好n次</td></tr><tr><td>X{n,}</td><td>X{n,}?</td><td>X{n,}+</td><td>至少n次</td></tr><tr><td>X{n,m}</td><td>X{n,m}?</td><td>X{n,m}+</td><td>X至少n次，最多m次</td></tr></tbody></table><p>要非常注意的是表达式X必须要用圆括号括起来，以便它能按照我们期望的效果去执行，例如 abc+和（abc）+,前面的表示表示匹配ab，后面跟随1个或者多个c，而(abc)+表示匹配一个或者多个abc<br>接口CharSequence从CharBuffer,String,StringBuffer,StringBuilder类之中抽象出了字符序列的一般化定义<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CharSequenece</span></span>&#123;</span><br><span class="line">  charAt();</span><br><span class="line">  length();</span><br><span class="line">  subSequence(<span class="keyword">int</span> start,<span class="keyword">int</span> end);</span><br><span class="line">  toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因此，这些类都实现了接口，多数正则表达式操作都接受CharSequence类型的参数  </p><h3 id="Pattern和Matcher"><a href="#Pattern和Matcher" class="headerlink" title="Pattern和Matcher"></a>Pattern和Matcher</h3><p>比起功能有限的String，我们更愿意构造功能强大的正则表达式对象，只需要导入java.util.regex包，然后用static Pattern.compile()方法来编译你的正则表达式即可，它会根据你的String类型的正则表达式生成一个Pattern对象，接下来，把你想要检索的字符串传入Pattern对象的matcher()方法会生成一个Matcher对象，它有很多功能可用，例如它的replaceAll()方法能够将所有匹配的部分替换成你传入的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRegularExpression</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            System.out.print(<span class="string">"args's count is not right"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String arg:args)&#123;</span><br><span class="line">            Pattern p = Pattern.compile(arg);</span><br><span class="line">            Matcher m = p.matcher(<span class="string">"args[0]"</span>);</span><br><span class="line">            <span class="keyword">while</span>(m.find())&#123;</span><br><span class="line">                System.out.print(m.group()+m.start()+m.end());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Pattern变量表示编译后的正则表达式，我们可以使用编译后的Pattern对象的matcher()方法，加上一个输入字符串，从而共同构造一个Matcher对象，同时Pattern类还提供了一个静态方法<br>    static boolean matcher(String regex,CharSequence input)<br>编译后的Pattern对象还提供了split()方法，它从匹配的regex的地方分割字符串，返回分割后的字符串的一个String数组<br>通过调用Pattern.matcher()方法，我们得到一个Matcher对象，使用Matcher上的方法，我们能够判断各种不同类型的匹配是否成功<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">lookingAt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">find</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> start)</span></span></span><br></pre></td></tr></table></figure></p><p>其中的matches()方法用来判断这个输入字符串是否匹配正则表达式，而lonkingAt()则用来判断该字符串（不必是整个字符串）的始部分是否匹配模式<br>find()像迭代器那样向前办理输入字符串，而第二个find(int start),该参数表示字符串中的字符位置，并以其作为搜索的起点</p><h3 id="Group-组"><a href="#Group-组" class="headerlink" title="Group(组)"></a>Group(组)</h3><p>组是用括号划分的正则表达式，可以根据组的编号来引用某个组，组号0表示整个表达式，组号1表示被第一对括号括起来的组，依次类推<br>A(B(C))D,这里有三个组，组0是ABCD,组1是BC,组2是C<br>Matcher（匹配器）对象提供了一些列的方法，用来获取与组相关的信息<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">groupCount</span><span class="params">()</span><span class="comment">//返回该匹配器的模式中的分组数量，第0组不算</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">group</span><span class="params">()</span><span class="comment">//返回前一次操作（例如find()）的第0组</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">group</span><span class="params">(<span class="keyword">int</span> i)</span><span class="comment">//返回前一次匹配操作期间指定的组号，如果匹配成功，但是指定的组没有匹配任何输入字符串的任何部分，则会返回null  </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> group)</span><span class="comment">//返回在前一次匹配操作中寻找到的组的起始索引</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">end</span><span class="params">(<span class="keyword">int</span> group)</span><span class="comment">//返回在前一次匹配操作中寻找到的组的最后一个字符索引加1的值</span></span></span><br></pre></td></tr></table></figure></p><p>start()和end()会返回前一次匹配操作的第一个字符位置和最后一个字符位置+1，如果匹配失败（或先于一个正在进行的匹配操作去尝试）。调用start()或end()都会产生一个IllegalStatException异常<br>find()可以在输入的任意位置定位正则表达式，而lookingAt()和matches()只有在正则表达式与输入的最开始位置处开始匹配才会成功</p><h3 id="Pattern标记"><a href="#Pattern标记" class="headerlink" title="Pattern标记"></a>Pattern标记</h3><p>Pattern的compile()还有另一个版本，它接受一个标记参数，以调整匹配的行为</p><pre><code>Pattern.compile(String regex,int flag)</code></pre><p>其中的flag来自一下Pattern类中的常量  </p><table><thead><tr><th></th><th>编译标记</th><th>效果</th></tr></thead><tbody><tr><td>Pattern.CONON_EQ</td><td>两个字符当且仅当它们的完全规范分解相匹配时</td></tr><tr><td>Pattern.CASE.INSENSITIVE(?!)</td><td>默认情况下，大小写不敏感的匹配假定只有US-ASCII字符集中的字符才能进行，这个标记允许模式匹配不必考虑大小写（大写或小写），通过指定UNICODE_CASE标记及结合此标记，基于Unicode的大小写不敏感的匹配就可以开启了</td></tr><tr><td>Pattern.COMMENTS(?x)</td><td>在这种模式下，空格符将被忽略，并且以“#”开始直到行尾的注释也会被忽略掉，通过嵌入的标记表达式也可以开启Unix的行模式</td></tr><tr><td>Pattern.DOTALL(?s)</td><td>在dotall模式中，表达式“.”匹配所有的字符，包括行终结符。默认情况下“.”表达式不匹配行终结符</td></tr><tr><td>Pattern.MULTILINE</td><td>在多行模式下，表达式^和$分别匹配一行的开始和结束，^还匹配输入字符串的开始，而$还匹配输入字符串的结尾，默认情况下，这些表达式仅匹配输入的完整的字符串的开始和结束</td></tr><tr><td>Pattern.UNICODE_CASE(?u)</td><td>当指定这个标记，并且开启CASE.INSENSITIVE时，大小写不敏感的匹配将按照与Unicode标准相一致的方式进行，默认情况下，大小写不敏感的匹配假定只能在US-ASCII字符集中的字符才能进行  </td></tr><tr><td>Pattern.UNIX_LINES(?d)</td><td>在这种模式下，^和$行为中，其识别行终结符\n  </td></tr></tbody></table><h3 id="替换操作"><a href="#替换操作" class="headerlink" title="替换操作"></a>替换操作</h3><p>正则表达式特别便于替换文本，它提供了许多方法，replaceFirst(String replaceStr)替换掉第一个匹配成功的部分,replaceAll(String replaceStr)替换掉所有匹配成功的部分。appendReplacement(StringBuffer sbuf,String replaceent)此方法重要，允许你调用其他的方法来生成或处理replacement(replaceFirst()和replaceAll()则只能使用一个固定的字符串)，使得你能够以编程的方式来将目标分割成组，从而具备更强大的替换功能，appendTail(StringBuffer sbuf)，在执行完appendReplacement()之后，调用此方法可以将输入字符串余下的部分复制到sbuf中  </p><h3 id="reset"><a href="#reset" class="headerlink" title="reset()"></a>reset()</h3><p>通过reset()方法，可以将现有的Matcher对象应用于一个新的字符序列<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Resetting</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Matcher matcher = Pattern.compile(<span class="string">"[firb[aiu][gx]]"</span>).matcher(<span class="string">"fix the rug with bgs"</span>);</span><br><span class="line">        <span class="keyword">while</span>(matcher.find())&#123;</span><br><span class="line">            System.out.print(matcher.group());</span><br><span class="line">        &#125;</span><br><span class="line">        matcher.reset(<span class="string">"fix the rig rags"</span>);</span><br><span class="line">        <span class="keyword">while</span>(matcher.find())&#123;</span><br><span class="line">            System.out.print(matcher.group());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="正则表达式与I-O"><a href="#正则表达式与I-O" class="headerlink" title="正则表达式与I/O"></a>正则表达式与I/O</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;不可变String&quot;&gt;&lt;a href=&quot;#不可变String&quot; class=&quot;headerlink&quot; title=&quot;不可变String&quot;&gt;&lt;/a&gt;不可变String&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;String对象是不可变的，查看JDK文档，会发现，Stri
      
    
    </summary>
    
      <category term="学习心得" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>通过异常处理错误</title>
    <link href="http://yoursite.com/2018/10/11/%E9%80%9A%E8%BF%87%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF/"/>
    <id>http://yoursite.com/2018/10/11/通过异常处理错误/</id>
    <published>2018-10-11T07:57:21.000Z</published>
    <updated>2018-10-11T11:11:58.096Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;java的理念是：结构不佳的代码不能运行<br>&emsp;&emsp;发现错误最好的时期是在编译阶段，也就是在你试图运行程序之前，然而，编译期间并不能找出所有的错误，余下的错误必须要在运行期间解决，这就需要错误源能够通过某种方式，将恰当的信息传递给某个对象——该接收者知道如何正确处理这个问题<br>&emsp;&emsp;改进的错误恢复机制是提供代码健壮性的最强有力的方式，错误恢复在我们所编写的每一个程序都是基本的元素，java使用异常来提供一直的错误报告模型，<strong>使得构件能与客户端代码可靠地沟通问题</strong>  </p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>&emsp;&emsp;C以及早期的语言常常具有多种错误处理模式，这些模式往往建立在约定俗成的基础之上，而这不属于语言的一部分，通常会返回某个特殊值或者设置某个标志，并且假定接收者将对这个返回值或者标志进行检查，以判断是否发生错误，但，随着时间的推移，人们发现很多的程序员更倾向于忽略对这些返回值和标志的检查，因为他们总是在想“这是别人的问题，不关我的事”，这对于构建大型的，健壮性，可维护的程序而言，这种错误处理机制已经成为阻碍<br>&emsp;&emsp;解决的办法是，用强制规定的形式来消除错误处理过程中随心所欲的因素<br>&emsp;&emsp;“异常”这个词有“我对此感到意外”的意思，问题出现了，你也许不清楚该如何处理，当你确实不该置之不理，你要停下来，看看是不是有别人或在别的地方，能够处理这个问题，只要是在当前环境中还没有足够的信息来解决这个问题，就将这个问题提交到一个更高的环境中，在这里将作出正确的决定<br>&emsp;&emsp;使用异常所带来的一个好处是，它往往能够降低错误处理代码的复杂度，如果不使用异常，那么就必须检查特定的错误，并在程序中的许多地方去处理它，而如果使用异常，那就不必再方法调用处进行检查，因为<strong>异常机制保证能够捕获这个错误</strong>，并且，只在一个地方处理错误，即所谓的异常处理程序中，这样不仅节省代码，而且把描述在<strong>正常情况下“执行过程中做什么事”的代码和“出了问题怎么办”的代码相分离</strong></p><h2 id="基本异常"><a href="#基本异常" class="headerlink" title="基本异常"></a>基本异常</h2><p>&emsp;&emsp;异常清晰（exceptional condition）是指阻止当前方法或作用域继续执行的问题，把异常情形与普通问题相区分很重要，普通问题是指，在当前环境下能够得到足够的信息，总能处理这个错误，而对异常情形，就不能继续下去了，因为当前环境下无法获得必要的信息来解决这个问题<br>&emsp;&emsp;当抛出异常后，有几件事会相继发生，甚至，同java中其他对象的创建一样，将使用new在堆上创建异常对象，然后，当前的执行路径（既不能继续下去了）被终止，并且从当前的环境中弹出异常对象的引用，此时，异常处理机制接管程序，并开始寻找一个恰当的地方继续执行程序，这个恰当的地方就是异常处理程序，它的任务是将程序从错误状态恢复<br>&emsp;&emsp;异常最重要的方面之一就是如果发生问题，它们将不允许程序沿着其正常的路径继续走下去  </p><h3 id="异常参数"><a href="#异常参数" class="headerlink" title="异常参数"></a>异常参数</h3><p>&emsp;&emsp;与使用java中的其他对象一样，我们总是用new在堆上创建异常对象，这也伴随着存储空间的分配和构造器的调用，所有的异常类都有两个构造器，一个是默认构造器，另一个是接收字符串作为参数，以便能够把相关信息放入到异常对象的构造器<br>&emsp;&emsp;关键字throw将产生很有趣的结果，一个是新生成的异常对象的引用通过throw关键字传递到更大的环境，另一个效果是通过抛出异常的方式退出方法或作用域 此外还能抛出任意类型的Throwable对象，它是异常类型的根类</p><h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><h3 id="监控区域"><a href="#监控区域" class="headerlink" title="监控区域"></a>监控区域</h3><p>&emsp;&emsp;<strong>如果在方法的内部抛出了异常（或者在方法调用的其他方式抛出了异常），这个方法将在抛出异常的过程中结束，如果不希望方法就此结束，可以在方法内部设置一个特殊的块来捕获异常</strong>  </p><h3 id="异常处理程序"><a href="#异常处理程序" class="headerlink" title="异常处理程序"></a>异常处理程序</h3><p>&emsp;&emsp;抛出的异常必须在某个地方得到处理，这个地点就是异常处理程序，而且针对每一个要捕获的异常准备相应的异常处理程序  </p><h3 id="终止与恢复"><a href="#终止与恢复" class="headerlink" title="终止与恢复"></a>终止与恢复</h3><p>&emsp;&emsp;异常处理理论有两种基本模型，java支持终止模型，在这种模型中，将假设错误非常关键，以至于无法回到错误发生的地方继续执行，一旦异常被抛出，就表明错误无法挽回，也不能回来继续执行<br>&emsp;&emsp;另一种是恢复模型，意思是异常处理程序的工作是修正错误，然后尝试调用出问题的方法，并认为第二次能成功，java也可实现这种错误处理，将异常处理程序一个while循环中吗，直到程序执行成功<br>&emsp;&emsp;虽然恢复模型很吸引人，但是这种错误恢复机制的代码非常难以编写，而且你真的了解错误的所有方方面面吗？所以后来大部分的语言选择转向程序终止模型  </p><h2 id="创建自定义异常"><a href="#创建自定义异常" class="headerlink" title="创建自定义异常"></a>创建自定义异常</h2><p>&emsp;&emsp;java提供的异常体系不可能预见所有的希望加以报告的错误，所以可以自己定义异常类来表示程序中可能会遇到的特定问题<br>&emsp;&emsp;要定义自己的异常类，必须从已有的异常类继承，最好是意思相近的，其实无所谓，异常最重要的是类名，建立新的异常类最简单的方式就是让编译器为你产生默认的构造器</p><h2 id="异常说明"><a href="#异常说明" class="headerlink" title="异常说明"></a>异常说明</h2><p>&emsp;&emsp;<strong>java鼓励人们把方法可能会抛出的异常告知使用此方法的客户端程序员</strong>，这是种优雅的做法，它使得调用者能确切地知道应该写什么代码借用捕获所有的异常，java提供了相应的语法（并强制这个语法）使得你能以礼貌的方式告知客户端程序员某个方法可能会抛出的异常，然后客户端程序员会进行相应的处理，这就是异常说明，它属于方法声明的一部分，紧跟在形式参数列表之后 <code>void f()throws TooBig,TooSmall{}</code><br>&emsp;&emsp;如果代码方法产生了异常却没有对此说明，编译器会发现这错误并提醒你，那么处理这个异常，要么声明这个方法将会抛出异常<br>&emsp;&emsp;这种在编译器就被强制检测的异常被称为<code>被检查的异常</code></p><h2 id="捕获所有的异常"><a href="#捕获所有的异常" class="headerlink" title="捕获所有的异常"></a>捕获所有的异常</h2><p>&emsp;&emsp;可以只写一个异常来捕获所有类型的异常，通过捕获异常类型的基类Exception可以做到这一点,因为Exception是与编程有关的所有异常类的基类，所有它不会包含太多的信息，可以调用它从其基类Throwable继承来的方法<br>&emsp;&emsp;String getMessage()<br>&emsp;&emsp;String getLocalizedMessage()<br>&emsp;&emsp;或用本地语言表示的详细信息<br>&emsp;&emsp;String toString()<br>&emsp;&emsp;void printStackTrace()<br>&emsp;&emsp;void printStackTrace(PrintStream)<br>&emsp;&emsp;void printStackTrace(java.io.PrintWriter)<br>&emsp;&emsp;打印Throwable和Throwable的<code>调用栈轨迹</code>，调用栈显式了“把你带到异常抛出地点”的方法调用序列，其中第一个版本输出到标准错误，后两个版本允许选择要输出的流<br>&emsp;&emsp;Throwable fillStackTrace()<br>&emsp;&emsp;<strong>用于在Throwable对象的内部记录栈帧的当前转态，这在程序重新抛出错误或者异常时很有用</strong><br>&emsp;&emsp;此外还可以使用继承自Object的方法，比如getClass()返回Class类型对象，可以获得更多关于这个异常对象的信息</p><h3 id="栈轨迹"><a href="#栈轨迹" class="headerlink" title="栈轨迹"></a>栈轨迹</h3><p>&emsp;&emsp;<code>printStrackTrace()</code>方法所提供的信息可以通过<code>StackTraceElement getStackTrace()</code>方法来直接访问，这个方法将<strong>返回一个由栈轨迹中的元素所组成的数组，其中每一个元素都表示栈中的一祯，元素0是栈顶元素，并且是调用序列中的最后一个方法调用（这个Throwable被创建和抛出之处）</strong>数组中的最后一个元素和栈底是调用序列中的第一个方法调用</p><h3 id="重新抛出异常"><a href="#重新抛出异常" class="headerlink" title="重新抛出异常"></a>重新抛出异常</h3><p>&emsp;&emsp;重抛异常会把异常抛给上一级环境中的异常处理程序，此外，异常的所有信息都会得以保持，所以上一级环境中捕获此异常的处理程序通过通过这个异常对象得到所有的信息<br>&emsp;&emsp;如果只是将当前的异常对象重新抛出，那么printStackTrace()方法显示的将是原来异常抛出的调用栈信息，而非重新抛出点的信息，要想更新这个信息，<strong>可以调用fillInStackTrace()方法，这个方法将返回一个Throwable对象，它是通过把当前调用栈信息填入原来那个异常对象而建立的,因此调用fillinStackTrace()的那一行就成了异常的新发地</strong><br>&emsp;&emsp;有可能在捕获异常之后抛出另一种异常，那么这么做，得到的效果就类似与使用finInStackTrace(),有关原来异常发生地点的信息就会丢失剩下的是与新的抛出点有关的信息</p><h3 id="异常链"><a href="#异常链" class="headerlink" title="异常链"></a>异常链</h3><p>&emsp;&emsp;常常会想要在捕获一种异常之后抛出另一种异常，并且希望把原始异常的信息保存下来，这被称为异常链，现在所有的Throwable的子类在构造器中都可以接受一个cause(因由)对象作为参数，这个cause就用来表示原始异常，<strong>这样通过把原始异常传递给新的异常，使得即使在当前创建并抛出新的异常，也能够通过这个异常链追踪到异常最初发生的位置</strong><br>&emsp;&emsp;语法: <code>throw new NewException(CauseException)</code></p><h2 id="java标准异常"><a href="#java标准异常" class="headerlink" title="java标准异常"></a>java标准异常</h2><p>&emsp;&emsp;Throwable这个类被用来表示任何可以作为异常抛出的类。Throwable对象，可以分为两种类型（指从Throwable继承中得到的类型），Error用来表示编译时和系统错误（除特殊情况，一般你不用关心），Exception是可以抛出的异常，在java类库，用户方法以及运行时故障中都可能抛出这个Exception异常，所有java程序员关心的异常类型通常是Exception  </p><h3 id="特例-RuntimeExcepton"><a href="#特例-RuntimeExcepton" class="headerlink" title="特例 RuntimeExcepton"></a>特例 RuntimeExcepton</h3><p>&emsp;&emsp;属于运行时的异常类型有很多，它们会自动被java虚拟机抛出，所有不必在异常说明中吧它们列出来，这些异常都是从RuntimeException类继承而来的，不需要再异常说明中声明的异常也被称为“不受检查的异常”，尽管通常不用捕获RuntimeException异常，但还是可以在代码中抛出RuntimeException异常<br>&emsp;&emsp;如果不主动捕获这种类型的异常会发生什么事情呢？因为编译器没有在这个问题上对遗产说明进行强制检查，RuntimeException类型的异常也许会穿越所有的执行过程直达main()方法，而不会被捕获</p><h2 id="使用finally进行清理"><a href="#使用finally进行清理" class="headerlink" title="使用finally进行清理"></a>使用finally进行清理</h2><p>&emsp;&emsp;对于一些代码，你可能希望，无论try块中的异常是否抛出，它们都能得到执行，<strong>这通常适用于内存回收之外的情况</strong>（因为内存回收由垃圾回收器完成），为了达到这个效果，可以在try块之后加上finally子句</p><h3 id="finally用来做什么"><a href="#finally用来做什么" class="headerlink" title="finally用来做什么"></a>finally用来做什么</h3><p>&emsp;&emsp;finally非常重要，它能使程序员保证，无论try块里发生什么，内存总能得到释放，但java有垃圾回收机制，所以内存释放不再是问题<br>&emsp;&emsp;<strong>当把除内存之外的资源恢复到它们的初始转态时，就要用到finally子句</strong>，这种需要清理的资源包括，已经打开的文件或网络连接，在屏幕上画的图形，甚至是外部世界的某个开关  </p><h3 id="缺憾：异常丢失"><a href="#缺憾：异常丢失" class="headerlink" title="缺憾：异常丢失"></a>缺憾：异常丢失</h3><p>&emsp;&emsp;遗憾的是，java的异常实现也有瑕疵，异常通常作为程序出错的标志，绝不应该被忽视，但是还是有可能被轻易忽视，用某些特殊方法的finally放肆使用子句，就会发生这种情况，这种情况的方式吗，一般是在finally子句抛出新的遗产替换了正常方法中抛出的异常，这是相当严重的缺陷</p><h2 id="异常的限制"><a href="#异常的限制" class="headerlink" title="异常的限制"></a>异常的限制</h2><p>&emsp;&emsp;当覆盖方法的时候只能抛出在基类方法的异常说明里列的那些异常，这个限制很有用，因为这意味着，当基类方法使用的代码应用到派生类对象的时候，一样能够工作，异常也不例外，这样的规则在java随处可见，比如，派生类覆盖基类的方法，访问权限一定不能比基类的要小，这些规则都保证了，能调用基类的方法就一定可以调用导出类的方法这个原则</p><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p>&emsp;&emsp;如果异常发生了，所有的东西都能被正确清理吗？因为涉及到构造器，问题就出现了，构造器会把对象设置成安全的初始转态，但是还会有别的动作，比如打开一个文件，这样的动作只有在对象使用完毕并且用户调用了特殊的清理方法之后才能的已清理，如果构造器内抛出了异常，这些清理行为也许就不能正常工作了，这意味着编写构造器时要格外小心，其实我们很少会遇到这也的问题，我们遵循的一条原则就是用尽量简单的方法构建对象</p><h2 id="异常匹配"><a href="#异常匹配" class="headerlink" title="异常匹配"></a>异常匹配</h2><p>异常处理系统会按照代码书写的书信找出“最近”的处理程序，找到匹配的处理程序之后，就认为异常得到了处理，就不在继续查找了查找的时候并不要去抛出的异常同处理程序声明的异常完全匹配，派生类的对象也可以匹配其基类的处理程序，所有一个原则是将更加特定的异常类型放在最前面</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;java的理念是：结构不佳的代码不能运行&lt;br&gt;&amp;emsp;&amp;emsp;发现错误最好的时期是在编译阶段，也就是在你试
      
    
    </summary>
    
      <category term="学习心得" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>持有对象</title>
    <link href="http://yoursite.com/2018/10/10/%E6%8C%81%E6%9C%89%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2018/10/10/持有对象/</id>
    <published>2018-10-10T15:50:46.000Z</published>
    <updated>2018-10-11T07:56:47.593Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;如果一个程序只包含固定数量的且其生命周期都是已知的对象，那么这是一个非常简单的程序<br>&emsp;&emsp;通常，程序总是根据运行时才知道的某些条件去创建对象，在此之前，不会知道所需对象的数量，甚至不知道确切的类型，为了解决这个普遍的编程问题，需要在任意时刻和任意位置创建任意数量的对象，所以，就不能依靠创建命名的引用<code>MyType aReference</code>来持有每一个对象<br>&emsp;&emsp;java有多种保存对象的方式，数组是个保存对象的最有效的方式之一，可是数组具有固定的尺寸，而在一般的情况中，你在写程序的时候根本不知道将需要多少的对象<br>&emsp;&emsp;Java实用类库提供了一整套完整的容器来来解决这个问题，其中基本的类型是List,Set,Queue和Map,这些对象也称为集合类，但是由于java的类库使用了Collection这个名字来指代该类库的一个特殊子集，所以我们使用范围更广的术语“容器”称呼它们<br>&emsp;&emsp;容器还有一些其他的特性，例如，Set对每个值都只保存一个对象，Map是允许你将某些对象与其他的一些对象关联起来的关联数组，java容器类都可以自动调整自己的尺寸，因此，与数组不同，在编程时，你可以将任意数量的对象放置在容器中，而且不需要担心容器应该设置为多大  </p><h2 id="泛型和类型安全的容器"><a href="#泛型和类型安全的容器" class="headerlink" title="泛型和类型安全的容器"></a>泛型和类型安全的容器</h2><p>&emsp;&emsp;在java SE5之前的容器有一个主要的问题就是编译器允许你向容器插入不正确的类型，而在之后，你可以通过预定义的泛型容器通过类型参数来指定你将要向容器中插入的数据类型，编译器将会放置错误的对象放置到容器中，而且不需要转型就可以从容器中取出正确类型的对象，因为容器知道自己保持的对象是什么类型</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>&emsp;&emsp;java容器类类库的用途就是“保存对象”，并将其划分为两个不同的概念  </p><ol><li>Collection 一个独立元素的序列，这些元素都服从一条或者多条规则  </li><li>Map 一组成对的“键值对”的对象，允许你通过键查找对象，ArrayList允许你使用数字来查找值，从某种意义上，它是将数字和对象关联在一起，映射表允许我们使用另一个对象查找另一个对象，它也被称为“关联数组”   <h2 id="添加一组元素"><a href="#添加一组元素" class="headerlink" title="添加一组元素"></a>添加一组元素</h2>&emsp;&emsp;在<code>java.util</code>包中的<code>Arrays</code>和<code>Collections</code>类中都有很多使用的方法，可以在一个<code>Collection</code>中添加一组元素，<code>Arrays.asList()</code>方法接受一个数组或者一个用逗号分隔的元素列表(可变参数)并将其转换为一个<code>List</code>对象，<code>Collections.addAll()</code>方法接受一个<code>Collection</code>对象，以及一个数组或是一个用逗号分隔的列表，将元素添加到<code>Collection</code>对象中  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddingGroup</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Collection&lt;Integer&gt; collection=<span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>));</span><br><span class="line">        Integer[] moreInt = &#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        Collections.addAll(collection,moreInt);</span><br><span class="line">        Collections.addAll(collection,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>);</span><br><span class="line">        List&lt;Integer&gt; list=Arrays.asList(<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">10</span>);</span><br><span class="line">        list.set(<span class="number">1</span>,<span class="number">99</span>);</span><br><span class="line">        <span class="comment">//list.add(21);runtime error because the underlying array connot be resized</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>&emsp;&emsp;Collection构造器可以接受另一个Collection，用它将自身初始化，Collection.addAll()和Collections.addAll()是两个完全不同的两个方法，前者是集合的通用接口中定义的方法，后者是Collections工具类定义的一个静态方法，Collection.addAll()方法只能接受另一个Collection对象作为参数，因此它不如Arrays.list()和Collections.addAll()来的灵活，这两个方法使用的都是可变参数列表<br>&emsp;&emsp;你可以直接使用ArrayList.asList()的输出，将其当做List,但是在这种情况下，其底层表示的是数组，因此不能调整尺寸，如果你试图用add()或delete()方法在这种列表中添加或删除元素，就有可能引发去改变数组尺寸的尝试，会得到一个运行时错误  </p><h2 id="容器的打印"><a href="#容器的打印" class="headerlink" title="容器的打印"></a>容器的打印</h2><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>&emsp;&emsp;List承诺可以将元素维护在特定的序列中，List接口在Collecton的基础上添加了大量的方法，使得可以在List中间插入和移除元素<br>&emsp;&emsp;有两种类型的List：</p><ul><li>基本的ArrayList，它长于随机访问元素，但在List的中间插入和移除元素时较慢</li><li>LinkedList，它通过代价较低的在List中间进行插入和删除操作，提供了优化的顺序访问，LinkedList在随机访问方面相对较慢，但是它的特性集叫ArrayList更大  </li><li>为什么ArrayList和LinkedList对于不同的操作的性能不同的原因是因为底层实现的不同  <img src="/2018/10/10/持有对象/绘图1.png" title="ArrayList"><img src="/2018/10/10/持有对象/绘图2.png" title="LinkedList">&emsp;&emsp;关于List接口api请查看<a href="http://tool.oschina.net/apidocs/apidoc?api=jdk-zh" target="_blank" rel="noopener">http://tool.oschina.net/apidocs/apidoc?api=jdk-zh</a><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2>&emsp;&emsp;任何容器类，都必须有某种方式可以插入元素并将它们取回，毕竟，持有事物是容器的基本工作<br>&emsp;&emsp;如果从更高层的角度思考，我们在对容器的确切类型进行编程方面有一个缺点，那就是如果原本是对List编码的，但是后来我想将相同的代码应用于Set，那会显得很不方便，此时应该怎么做呢？或者打算从头开始编写通用的代码，它们只是使用容器，不知道或者说不关心容器的类型，那么如何才能不重写代码就能应用于不同的容器呢？<br>&emsp;&emsp;迭代器（也是一种设计模式）的概念可以用于达成此目的，迭代器是一个对象，它的工作是遍历并选择序列中的对象，而客户端程序员不必知道或关心该序列底层的结构，java的Iterator只能呢个单向移动，这个Iterator只能用来  </li></ul><ol><li>使用iterator()方法要求容器返回一个Iterator，Iterator将准备返回序列的第一个元素</li><li>使用next()获得序列的下一个元素</li><li>使用hasNext()方法检查序列中是否还有元素</li><li>使用remove()将迭代器新返回的元素删除<br>&emsp;&emsp;注意:Iterator可以删除next()产生的最后一个元素，这意味着调用remove()之前必须先调用next()<br>&emsp;&emsp;<strong>接受对象容器并传递它，从而在每个对象上都执行某种操作，这种思想十分强大</strong><h3 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h3>ListIterator是一个更加强大的Iterator的子类型，它只能用于各种List类的访问，尽管Iterator只能向前移动，但是ListIterator可以双向移动，它还可以产生相对于迭代器在列表中指向的当前位置的前一个和后一个元素的索引，并且可以使用set()方法替换它访问过的最后一个元素,你可以通过listIterator()方法产生一个指向List开始处的ListIterator，并且还可以通过调用listIterator(n)方法创建一个一开始就指向列表索引为n的元素处的ListIterator<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2>&emsp;&emsp;LinkedList也像ArrayList一样实现了List接口，在删除和插入方面的效率比ArrayList更高效，但是在随机访问方面却要逊色一些<br>&emsp;&emsp;<strong>LinkedList还添加了可以使其用作栈，队列或者双端队列的方法</strong><br>&emsp;&emsp;这些方法有些彼此之间只是名称有些差异，后者只存在少许差异，以使得这些名称在特定用法的上下文环境中更加适用（特别是在Queue中）例如，getFirst()和element()完全一样，它们都是返回列表头元素，而并不移除它，如果List为空的话，则抛出NoSuchElementException,<br>peek()方法与这两个方法只是稍有差异，它在列表为空时返回null<br>&emsp;&emsp;removeFirst()和remove()也是完全一样，它们移除并返回列表的头，而在列表为空时，抛出NoSuchElementExcption，poll()稍有差异，它在列表为空的时候，返回null<br>&emsp;&emsp;addFirst()与add()和addLast()，它们都是将元素插入列表的尾（端）部<br>&emsp;&emsp;removerLast()移除并返回最后一个元素<br>&emsp;&emsp;因此我们在使用LinkedList这些方法时，要注意各种方法的不同，进而选择怎样去处理<h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2>&emsp;&emsp;“栈”通常是指“后进先出”(LIFO)的容器，有时栈也被称为叠加栈，如果用一种事物来形容的话，栈的行为就像是弹夹一样，有“压入”和“弹出”<br>&emsp;&emsp;LinkedList具有能实现栈的所有功能的方法，所有我们可以定义一个栈，通过组合的形式复用LinkedList，很简单，这里就不写了<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2>&emsp;&emsp;Set不保存重复的元素，如果你试图将相同对象的多个实例添加到Set中，那么它就会阻止这种重复的发生，Set最常用被使用的是<strong>测试归属性</strong>，你很容易地询问某个对象是否在某个Set中，因此，查找就成了Set中最重要的操作，因此，你可以选择HashSet的实现，它专门对快速查找进行优化<br>&emsp;&emsp;Set和Collection具有完全一样的接口，因此没有额外的功能，实际上Set就是Collection，只是行为不同<br>&emsp;&emsp;Set有不同的实现，HashSet使用了散列函数，使得更快速的保存和查找，TreeSet使用了红黑树数据结构中，LInkedHashSet因为查找的速度也使用了散列，但是看起来它使用了链表来维护元素的插入顺序<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2>&emsp;&emsp;将对象映射到其他对象的能力是一种解决编程问题的杀手锏<br>Map与数组和其他的Collection一样，可以很容易地扩展到多维，我们通过容器的组合，可以很容易生成强大的数据结构  <h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2>&emsp;&emsp;队列是一个“先进先出”（FIFO）的容器，即从容器的另一端放入元素，从容器的另一端取出，<strong>队列常被当作一种可靠的将对象从程序的一个区域传递到另一个区域的途径</strong><br>&emsp;&emsp;LinkedList提供了方法以支持队列的行为，它实现了Queue接口，因此可以将LinkedList作为Queue的一种实现，通过将LinkedList向上转型为Queue  <h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h3>&emsp;&emsp;x先进先出描述了最典型的队列规则，<strong>队列规则是指在给定一组队列中的元素的情况下，确定下一个弹出队列的元素的规则</strong><br>&emsp;&amp;emsp优先队列声明下一个弹出的元素是最需要的元素（具有最高的优先级），当你在PriorityQueue上调用offer()方法插入一个对象时，这个对象会在队里中被排序，默认的排序将使用对象在队列中的自然排序，但是你也可以通过提供自己的Comparator来修改这个顺序，PriorityQueue可以确保当你调用peek()，poll()和remove()方法时，获得的元素将是队列中优先级最高的元素  <h2 id="Collection和Iterator"><a href="#Collection和Iterator" class="headerlink" title="Collection和Iterator"></a>Collection和Iterator</h2>&emsp;&emsp;Collection是描述所有序列容器的共性的根接口，它可能被认为是一个“附属接口”，即因为要表示其他若干接口的共性而出现的接口<br>&emsp;&emsp;使用接口的一个理由就是它可以使我们能够创建更通用的代码，通过针对接口而非具体的实现类编写代码，那么我们的代码就可以应用于更多的类型，然后我们也可以看到有趣的事情是，我们一般是通过迭代器来表现这种共性的，在java中，这两种方式实际上绑定在一起了，如果要一个新类实现Collection接口，也要必须通过iterator()接口，但是如果让一个类去实现Collection接口，虽然可以通过继承AbstractCollection来提供一些默认的实现，但是必须还有提供iterator()，而且如果这个类本身已经继承了其他类，那么就不能再通过继承将其定义为一个Collection类型了，所有相比之下，使用通过迭代器的方式来提供容器的共性更加可取，我们也知道，迭代器模式实际上就是利用了内部类的特性，产生了一个能够访问外围类的闭包对象，我们就可以对外围的成员进行操作  <h3 id="Foreach与迭代器"><a href="#Foreach与迭代器" class="headerlink" title="Foreach与迭代器"></a>Foreach与迭代器</h3>&emsp;&emsp;在java SE5引入了新的被称为Iterable的接口，该接口包含了一个能够产生Iteratoer的Iterator()方法，并且Iterator接口被foreach用来在序列中移动，<strong>因此，如果你创建了任何实现了Iteratable的类，都可以将它用于foreach语法</strong></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;如果一个程序只包含固定数量的且其生命周期都是已知的对象，那么这是一个非常简单的程序&lt;br&gt;&amp;emsp;&amp;emsp;通
      
    
    </summary>
    
      <category term="学习心得" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>内部类</title>
    <link href="http://yoursite.com/2018/10/10/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <id>http://yoursite.com/2018/10/10/内部类/</id>
    <published>2018-10-10T03:44:31.000Z</published>
    <updated>2018-10-11T02:33:13.901Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;<strong>可以将一个类的定义放在另一个类的定义内部，这就是内部类</strong><br>&emsp;&emsp;内部类是一种非常有用的特性，因为它允许你把一些逻辑相关的类组织在一起，并控制内部类的可视性，然而必须要了解，内部类与组合是完全不同的概念，这一点很重要<br>&emsp;&emsp;在最初，内部类看起来就像是一种代码隐藏机制，将类置于其他类的内部，但是，你将会了解到，内部类远不止如此，它了解外围类，并能与之通信，而且你用内部类写出的代码更加优雅而清晰，尽管并不总是如此  </p><h2 id="创建内部类"><a href="#创建内部类" class="headerlink" title="创建内部类"></a>创建内部类</h2><p>&emsp;&emsp;创建内部类的方法很简单，就是将类的定义置于外围类的内部<br>&emsp;&emsp;更典型的情况是，外部类将有一个方法，该方法返回一个指向内部类的引用，就像下面看到<code>to()</code>的<code>contens()</code>和一样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel1</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Contents</span></span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> i =<span class="number">11</span>;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> i;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Destination</span></span>&#123;</span><br><span class="line">      <span class="keyword">private</span> String label;</span><br><span class="line">      Destination(String label)&#123;</span><br><span class="line">          <span class="keyword">this</span>.label=label;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function">String <span class="title">readLable</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> label;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Destination <span class="title">to</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Destination(s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Contents <span class="title">conents</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Contents();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ship</span><span class="params">(String dest)</span></span>&#123;</span><br><span class="line">      Contents c=conents();</span><br><span class="line">      Destination d=to(<span class="string">"dest"</span>);</span><br><span class="line">      System.out.print(d.readLable());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      Parcel1 p=<span class="keyword">new</span> Parcel1();</span><br><span class="line">      p.ship(<span class="string">"Tasmania"</span>);</span><br><span class="line">      Parcel1 q=<span class="keyword">new</span> Parcel1();</span><br><span class="line">      Parcel1.Destination d=q.to(<span class="string">"Borneo"</span>);</span><br><span class="line">      Parcel1.Contents c = q.conents();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="链接到外部类"><a href="#链接到外部类" class="headerlink" title="链接到外部类"></a>链接到外部类</h2><p>&emsp;&emsp;到目前为止，内部类似乎还是一种名字隐藏和组织代码的模式，这些很有用，但还不是最引人注目的，它还有其他的用途，<strong>当生成一个内部类的对象时，此对象与制造它的外围类对象（enclosing object）之间就有了一种联系，所以它能访问其外围类的所有成员，而不需要任何特殊条件</strong>，此外，内部类还拥有外围类所有元素的访问权，内部类可以访问其外围类的的方法和字段，就像自己拥有它们似的<br>&emsp;&emsp;内部类自动拥有对其外围类所有成员的访问权，这是怎么做到的呢？当某个对象创建一个内部类对象的时候，此内部类对象必定会秘密捕获一个指向那个外围类对象的引用，然后，在你访问此外围类的成员时，就是用那个引用来选择外围类的成员，幸运的是，编译器会帮我们处理所有的细节，但你现在可以看到：内部类的对象只能在其外围类的对象相关联的情况下才能被创建（就像你应该看到的，在内部类是非static类时），构建内部类对象时，需要一个指向其外围类对象的引用</p><h2 id="使用-this和-new"><a href="#使用-this和-new" class="headerlink" title="使用.this和.new"></a>使用.this和.new</h2><p>&emsp;&emsp;<strong>如果你需要生成外部类对象的引用，可以使用外部类的名字后面紧跟原点和this</strong>，这样产生的引用自动地具有正确的类型，这一点在编译期就被知晓并受到检查，因此没有任何运行时开销<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dothis</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;System.out.print(<span class="string">"Dothis.f()"</span>);&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Dothis <span class="title">outer</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Dothis.<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Inner <span class="title">inner</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Inner();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Dothis dt=<span class="keyword">new</span> Dothis();</span><br><span class="line">        Dothis.Inner dti=dt.inner();</span><br><span class="line">        dti.outer().f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;有时你想要告知某些其他对象，去创建其某个内部类的对象，要实现此目的，你必须在new表达式中提供对其他外部类对象的引用，这就需要使用<code>.new</code>语法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DotNew</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        DotNew dotNew=<span class="keyword">new</span> DotNew();</span><br><span class="line">        DotNew.Inner di=dotNew.new Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&amp;emsp；要想创建内部类的对象，你不能按照你想象的方式，去引用外部类的名字DotNew,而是<strong>必须使用外部类的对象来创建内部类对象</strong>，像上面<code>newDot.new Inner()</code>那样,这也解决了内部类名字作用域的问题<br>&emsp;&amp;emsp；<strong>在拥有外部类对象之前是不能创建内部类对象的</strong>，这是因为内部类对象暗暗连接到它的外部类对象上，但是，如果你创建的是嵌套类（静态内部类），那么就不需要对外部类对象的引用  </p><h2 id="内部类和向上转型"><a href="#内部类和向上转型" class="headerlink" title="内部类和向上转型"></a>内部类和向上转型</h2><p>&emsp;&amp;emsp；当将内部类向上转型为其基类，尤其是转型为一个接口的时候，内部类就有了用武之地（从实现了某个接口的对象，得到对接口的引用，与向上转型为这个对象的基类，实际上效果是一样的），<strong>这是因为此内部类——某个接口的实现——能够完全不可见，并且不可用</strong>。所得到只是指向基类或则接口的引用，所以能够很方便地隐藏实现细节<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Destination</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">readLabel</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Contents</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parcel</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">PContents</span> <span class="keyword">implements</span> <span class="title">Contents</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> i;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">PDestination</span> <span class="keyword">implements</span> <span class="title">Destination</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String label;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PDestination</span><span class="params">(String toWhere)</span></span>&#123;</span><br><span class="line">            label=toWhere;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">(String s)</span></span>&#123;<span class="keyword">return</span> s;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Destination <span class="title">destination</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PDestination(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PContents();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestParcel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Parcel parcel=<span class="keyword">new</span> Parcel();</span><br><span class="line">        Contents c=parcel.contents();</span><br><span class="line">        <span class="comment">//向下转型为私有的内部类也是不可以的</span></span><br><span class="line">        <span class="comment">//Parcel.PContents pc=parcel.contents();</span></span><br><span class="line">        Destination d= parcel.destination(<span class="string">"tasmania"</span>);</span><br><span class="line">        <span class="comment">//illegal --can't access private class</span></span><br><span class="line">        <span class="comment">//Parcel.PContents ps=parcel.new PContents();</span></span><br><span class="line">        Parcel.PDestination pd=parcel.new PDestination(<span class="string">"同包可访问"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;在上面的例子中，内部类PContents是private,所以除了Parcel，没人能够访问它，PDestination是protected的，所以只有Parcel及其子类，还有同包的类能够访问它，这意味着如果客户端程序员想要了解或访问这些成员，那是要受到限制的，实际上，甚至不能向下转型成private内部类（或是protect内部类，除非是继承自它的子类），因为不能访问其名称，就像上面看到的那样，也是，private内部类给类的设计者提供了一种途径，通过这种方式可以完全阻止任何依赖于类型的编码，并且完全隐藏了实现的细节，此外，从客户端程序员的角度来看，由于不嫩访问任何新增的，原本不属于公共接口的方法，所有扩展接口是没有价值的（也就是说我们对于private内部类，我们只能通过可访问的其向上转型的基类或者接口来访问这个内部类，因为同基类接口访问，任何通过内部类添加的新的方法都是无意义的）。这也给java编译器提供了生成更高效代码的机会<br>&emsp;&emsp;总结如下，对内部类的访问权限修饰同样有效，我们仅能对那些有权限访问的内部类进行访问，例如private内部类，我们无法访问（除了包含它的外部类），对于protected内部类，我们只能在外围类的子类或者同包类能访问，但是如果我们对内部类基类的接口具有访问权的时候，内部类还提供了一种机制，通过外围类的方法获得内部类的向上转型的引用，我们就可以对这个引用的接口进行访问，由此得到一个副作用是，通过向上转型的接口访问时对于那些在内部类中新添加的方法，我们是无法调用的</p><h2 id="在方法和作用域内的内部类"><a href="#在方法和作用域内的内部类" class="headerlink" title="在方法和作用域内的内部类"></a>在方法和作用域内的内部类</h2><p>&emsp;&emsp;我们还可以在方法里面或者在任意的作用域内定义内部类，这么做有两个理由：</p><ol><li>你实现了某类型的接口，于是可以创建并返回对其的引用  </li><li>你要解决一个复杂的问题，想创建一个类来辅助你解决问题，但是又不希望这个类是公共可用的<br>&emsp;&emsp;在后面的例子里，先前的代码将被修改，以用来实现  </li><li>一个定义在方法中的类  </li><li>一个定义在作用域内的类，此作用域在方法内部</li><li>一个实现接口的匿名类</li><li>一个匿名类，它扩展了有非默认构造器的类</li><li>一个匿名类，它执行字段初始化</li><li>一个匿名类，它通过实例初始化实现构造（匿名类不可能有构造器）<h4 id="在方法的作用域内"><a href="#在方法的作用域内" class="headerlink" title="在方法的作用域内"></a>在方法的作用域内</h4>&emsp;&emsp;在方法的作用域内，创建一个完整的类，这被称作局部内部类  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Destination <span class="title">destination</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">PDestination</span> <span class="keyword">implements</span> <span class="title">Destination</span></span>&#123;</span><br><span class="line">            <span class="keyword">private</span> String label;</span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="title">PDestination</span><span class="params">(String whereTo)</span></span>&#123;</span><br><span class="line">                label=whereTo;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> label;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PDestination(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>PDestination类是<code>destination()</code>方法的一部分，而不是<code>Parcel5</code>的一部分，所以destination()方法之外不能访问PDestination,注意出现在return语句中的向上转型——返回的类型是Destionation的引用，它是PDestination的基类，当然，在destination()中定义了内部PDestination，并不意味着一旦destination()方法执行完毕，PDestination就不可用了<br>&emsp;&emsp;你可以在同一个目录下的任意类中对某个内部类使用类标识符PDestination,这并不会引起命名冲突<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">internalTracking</span><span class="params">(<span class="keyword">boolean</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b)&#123;</span><br><span class="line">            <span class="class"><span class="keyword">class</span> <span class="title">TrackingSlip</span></span>&#123;</span><br><span class="line">                <span class="keyword">private</span> String id;</span><br><span class="line">                TrackingSlip(String s)&#123;</span><br><span class="line">                    id = s;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="function">String <span class="title">getSlip</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> id;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            TrackingSlip ts=<span class="keyword">new</span> TrackingSlip(<span class="string">"slip"</span>);</span><br><span class="line">            String s=ts.getSlip();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//con't use it here out of scope</span></span><br><span class="line">    <span class="comment">//TrackingSlip ts=new TrackingSlip();</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">track</span><span class="params">()</span></span>&#123;internalTracking(<span class="keyword">true</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Parcel6 p=<span class="keyword">new</span> Parcel6();</span><br><span class="line">        p.track();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<strong>TrackingSlip类被嵌套入if语句的作用域中，这并不是说该类的创建是有条件的，它其实与别的类一起编译过了，然而，在定义TrackingSlip的作用之外，它是不可用的，除此之外，它与普通的类没什么分别</strong></p><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Contents() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Parcel7 parcel7=<span class="keyword">new</span> Parcel7();</span><br><span class="line">        Contents c=parcel7.contents();</span><br><span class="line">        c.value();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;contents()方法将返回值的生成与表达式这个返回值啊的类的定义结合在一起了，另外，这个类是匿名的，它没有名字，更糟糕的是：看起来似乎是你正在创建一个Contents对象<br>&emsp;&emsp;这种奇怪的语法指的是：“创建一个继承自Contents的匿名类的对象”，通过new表达式返回的引用被自动向上转型为对Contents的引用，上述匿名类的语法是下述形式的简化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel7b</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Mycontents</span> <span class="keyword">implements</span> <span class="title">Contents</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Mycontents();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;在这个匿名内部类中，使用默认的构造器来生成Contents，下面的代码展示的是，如果你的基类需要一个有参数的构造器，应该怎么办？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wrapping</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Wrapping</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; i=x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> i;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel8</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Wrapping <span class="title">wrapping</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Wrapping(x)&#123;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">super</span>.value();</span><br><span class="line">          &#125;  </span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Parcel8 parcel8=<span class="keyword">new</span> Parcel8();</span><br><span class="line">        Wrapping wrapping=<span class="keyword">new</span> Wrapping(<span class="number">2</span>);</span><br><span class="line">        wrapping.value();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;只需要简单传递给基类的构造器即可，尽管Wrapping只是一个具有实现的普通类，但它还是被其导出类当作公共“接口”来使用<br>&emsp;&emsp;<strong>如果定义一个匿名类，并且希望它使用一个在其外部定义的对象，那么编译器会要求并其参数引用是final的</strong><br>&emsp;&emsp;如果只是简单给一个字段，那么普通的字段初始化方法就很好了，但是如果想做一些类似构造器的行为，那该怎么办？在匿名类中不可能含有命名构造器（因为它根本没有名字），但通过实例初始化，就能够达到为匿名内部类创建一个伪构造器的效果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Base</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"Base Constructor,i="</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousConstructor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Base <span class="title">getBase</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Base(x)&#123;</span><br><span class="line">            &#123;System.out.print(<span class="string">"Inside instance initializer"</span>);&#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;System.out.print(<span class="string">"in anonymous f()"</span>);&#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Base base=getBase(<span class="number">10</span>);</span><br><span class="line">        base.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;在此例中，不要求变量一定是final的，因为i被传递给匿名类的基类的构造器，它并不会在匿名类内部被直接使用<br>&emsp;&emsp;下面是带实例初始化的“parcel”形式，注意destinaion的参数必须是final的，因为它们是在匿名类内部使用的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel10</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Destination <span class="title">destination</span><span class="params">(<span class="keyword">final</span> String dest,<span class="keyword">final</span> <span class="keyword">float</span> price)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Destination() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> cost;</span><br><span class="line">            &#123;</span><br><span class="line">                cost=Math.round(price);</span><br><span class="line">                <span class="keyword">if</span>(cost&gt;<span class="number">100</span>)</span><br><span class="line">                    System.out.print(<span class="string">"over Budget"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">private</span> String label=dest;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Parcel10 parcel10=<span class="keyword">new</span> Parcel10();</span><br><span class="line">        parcel10.destination(<span class="string">"houston"</span>,<span class="number">100.3f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;在实例初始化操作的内部，可以看到有一段代码，它们不能作为字段初始化动作的一部分（就是if语句）所以对于匿名类而言，实例初始化的实际效果就是构造器，当然它受到了限制——<strong>你不能重载实例初始化，所以你仅有一个这样的构造器（实例初始化）</strong><br>&emsp;&emsp;匿名内部类与继承相比有些受限，因为<strong>匿名内部类既可以扩展类，也可以实现接口，但不能两者兼备，而且如果是实现接口，也只能实现一个</strong>  </p><h3 id="再访工厂方法"><a href="#再访工厂方法" class="headerlink" title="再访工厂方法"></a>再访工厂方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ServiceFactory</span></span>&#123;</span><br><span class="line">    <span class="function">Service <span class="title">getService</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceImpl1</span> <span class="keyword">implements</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ServiceImpl1</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123; System.out.print(<span class="string">"imple1.m1()"</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123; System.out.print(<span class="string">"impl1.m2()"</span>);&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ServiceFactory serviceFactory=<span class="keyword">new</span> ServiceFactory() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Service <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ServiceImpl1();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceImpl2</span> <span class="keyword">implements</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ServiceImpl2</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123; System.out.print(<span class="string">"imple2.m1()"</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123; System.out.print(<span class="string">"impl2.m2()"</span>);&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ServiceFactory serviceFactory=<span class="keyword">new</span> ServiceFactory() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Service <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ServiceImpl2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factories</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serviceConsumer</span><span class="params">(ServiceFactory factory)</span></span>&#123;</span><br><span class="line">        Service service = factory.getService();</span><br><span class="line">        service.m1();</span><br><span class="line">        service.m2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        serviceConsumer(ServiceImpl1.serviceFactory);</span><br><span class="line">        serviceConsumer(ServiceImpl2.serviceFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>现在用于ServiceImpl1和ServiceImpl2的构造器都可以是private的，并且没有任何必要创建作为工厂的具名类</strong>，另外，你经常需要的是单一的工厂对象，因此在本例中它被创建为Service实现的static域，这样所产生的语法也更具有实际意义</p><h2 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h2><p>&emsp;&emsp;如果不需要内部类与外部类对象之间的联系，那么可以将内部类声明为static，这通常称为嵌套类，嵌套类意味着：</p><ol><li>要创建嵌套类的对象，并不需要其外围类的对象</li><li>不能从嵌套类的对象访问非静态的外围类对象<br>&emsp;&emsp;嵌套类与普通的内部类还有一个区别，<strong>普通内部类的字段与方法，只能放在类的外部层次上，所有普通的内部类不能有static数据和static字段，也不能包含嵌套类，但是嵌套类可以包含所有这些东西</strong><br>&emsp;&emsp;我对于上面问题的理解是，因为普通的内部类是依赖于外部类对象的初始化的，只有得到外部类对象的一个引用，内部类才能构建成功，这是内部类的特性，假设，允许内部类有static数据和static字段，当我们调用内部类的一个static成员时，就会引发内部类的加载，而这是不被推荐的行为，为了确保先外部类后内部类的加载和初始化顺序，编译器必须确保普通内部类中不能存在static成员，而static final是常量，在编译过程就已经存在常量池中，所有对常量没有约束，而嵌套类是static的，和外部类除了在命名空间上有些联系，其实可以将其看成一个独立的类，所以它的加载和初始化对外部类不会产生影响  <h3 id="接口内部的类"><a href="#接口内部的类" class="headerlink" title="接口内部的类"></a>接口内部的类</h3>&emsp;&emsp;正常情况下，不能在接口内部放置任何的代码，但嵌套内部类可以作为接口的一部分，你放在接口中的任何类都自动地是public和static的，因为是被static的，只要将嵌套类置于接口的命名空间内，这并不违反接口的规则，你甚至可以砸内部类中实现其外围类  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ClassInInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">howdy</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span>  <span class="title">ClassInInterface</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">howdy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.print(<span class="string">"Howdy!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">            Test test =<span class="keyword">new</span> Test();</span><br><span class="line">            test.howdy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>&emsp;&emsp;如果你想要创建某些公共代码，使得它们可以被某些接口的所有实现所共用，那么使用接口内部的嵌套类会很方便  </p><h3 id="从多层嵌套类中访问外部类的成员"><a href="#从多层嵌套类中访问外部类的成员" class="headerlink" title="从多层嵌套类中访问外部类的成员"></a>从多层嵌套类中访问外部类的成员</h3><p>&emsp;&emsp;一个内部类被嵌套多少层并不重要——它能透明地访问所有它所嵌入的外围类的所有成员（不包括静态内部类，静态内部类只能访问外部类的静态成员，和普通的类的访问权限一样）</p><h2 id="为什么需要内部类"><a href="#为什么需要内部类" class="headerlink" title="为什么需要内部类"></a>为什么需要内部类</h2><p>&emsp;&emsp;一般来说，内部类继承自某个类或实现某个接口，内部类的代码操作创建它的外围类的对象，所以认为<strong>内部类提供了某种进入外围类的方法</strong><br>&emsp;&emsp;内部类必须要回答的一个问题就是，如果只是需要一个对接口的引用，那么为什么不通过外围类实现那个接口呢？答案是：“如果这能满足要求，那么就应该这么做”，那么内部类实现的接口和外围类实现的这个接口有什么区别呢？答案是：后者不是总能享用到接口带来的便利，有时需要用到接口的实现，所以使用内部类是最吸引人的原因是：<br>&emsp;&emsp;每个接口都能独立地继承自一个（接口的）实现，所以无论外围类是否以及继承了某个（接口的）实现，对于内部类都没有影响<br>&emsp;&emsp;如果没有内部类提供的，可以继承多个具体的或者抽象的类的能力，一些设计与编程的问题就很难解决，从这个角度看，内部类使得多重继承的解决方案变得完美，接口解决了部分问题，而内部类有效地实现了“多重继承”，也就是说吗，内部类允许继承多个非接口类型（类或者抽象类）<br>&emsp;&emsp;使用内部类，还可以获得其他的一些特性：</p><ol><li>内部类可以有多个实例，每个内部类都有自己的状态信息，并且与其外围类对象的信息相互独立</li><li>在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类</li><li>创建内部类对象的时刻并不依赖于外围类对象的创建？</li><li>内部类并没有让人迷惑的“is-a”问题，它就是一个独立的实体<h3 id="闭包与回调"><a href="#闭包与回调" class="headerlink" title="闭包与回调"></a>闭包与回调</h3>&emsp;&emsp;<strong>闭包（closure）是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域</strong>，通过这个定义，可以看出内部类是面向对象的闭包，因为它不仅包含外围类对象（创建内部类的作用域）的信息，还自动拥有一个指向此外围类对象的引用，在此作用域内，内部类有权操作所有的成员，包括private成员<br>&emsp;&emsp;java做引人争议的问题之一就是，人们认为java应该包含某种指针机制，以允许回调（callback）,通过回调，对象能够携带一些信息，这些信息允许它在稍后的某个时候调用初始的对象，，如果回调是通过指针实现的话，那就期待程序员不会误用指针<br>&emsp;&emsp;通过内部类提供闭包的功能是优良的解决方案，它比指针更灵活，更安全  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Incrementtable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Callee1</span> <span class="keyword">implements</span> <span class="title">Incrementtable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">        System.out.print(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyIncrement</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;System.out.print(<span class="string">"Other operation"</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(MyIncrement mi)</span></span>&#123;mi.increment();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Callee2</span> <span class="keyword">extends</span> <span class="title">MyIncrement</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.increment();</span><br><span class="line">        i++;</span><br><span class="line">        System.out.print(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Closure</span> <span class="keyword">implements</span> <span class="title">Incrementtable</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</span><br><span class="line">            Cellee2.<span class="keyword">this</span>.increment();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Incrementtable <span class="title">getCallbackreference</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Closure();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Caller</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Incrementtable callbackReference;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Caller</span><span class="params">(Incrementtable ic)</span></span>&#123;callbackReference=ic;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">()</span></span>&#123;callbackReference.increment();&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallBack</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Callee1 c1=<span class="keyword">new</span> Callee1();</span><br><span class="line">        Callee2 c2=<span class="keyword">new</span> Callee2();</span><br><span class="line">        MyIncrement.f(c2);</span><br><span class="line">        Caller caller1=<span class="keyword">new</span> Caller(c1);</span><br><span class="line">        Caller caller2=<span class="keyword">new</span> Caller(c2.getCallbackreference());</span><br><span class="line">        caller1.go();</span><br><span class="line">        caller2.go(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>&emsp;&emsp;这个例子进一步展示了外围类实现一个接口与内部类实现此接口之间的区别，就代码而言，Callee1是简单的解决方案，Callee2继承自MyIncrement，后者已经有了一个不同的increment()方法，并且与Incrementable接口期望的increment()方法完全不相关，所以入股Cellee2继承了MyIncrement，就不能为了Incrementable的用途而覆盖increment()方法，于是只能使用内部类独立地实现Incrementable，还要主要，当创建一个内部类时，并没有在外围类的接口中添加东西，也没有修改外围类的接口<br>&emsp;&emsp;主要，在Callee2中除了getCallbackReference()方法之外，其他成员都是private的，要想建立与外部世界的任何连接，interface Incrementable都是必需的，在这里可以看到，interface是如何允许接口与接口的实现完全独立的<br>&emsp;&emsp;内部类Closure实现了InCrementable，以提供一个安全的“钩子（hook）”——而且这个钩子是一个安全的钩子，它只能允许调用者对外围类进行特定的操作</p><h3 id="内部类与框架"><a href="#内部类与框架" class="headerlink" title="内部类与框架"></a>内部类与框架</h3><p>&emsp;&emsp;控制框架<br>&emsp;&emsp;应用程序框架（application framework）就是被设计用以解决某类特定问题的一个类或者一组类，要运用某个应用程序框架，通常继承一个或者多个类，并覆盖某些方法，在覆盖后的方法中，编写代码定制应用程序框架提供的通用解决方案，以解决你的特定问题（这是设计模式中模板方法的一个例子）<br>&emsp;&emsp;控制框架是一类特殊的应用程序框架，它用来解决相应时间的需求，主要用来响应时间的系统被称为事件驱动系统，一般来说，我们会考虑使用内部类来设计控制框架系统，原因如下  </p><ol><li>控制框架的完整实现是由单个的类创建的，从而使得实现的细节被封装了起来，<strong>内部类的用来表示解决问题所需要的不同的动作</strong></li><li><strong>内部类能够很容易地访问外围类的任意成员</strong>，所有可以避免这种实现变得笨拙，如果没有这种能力，代码将变得使人讨厌<h2 id="内部类的继承"><a href="#内部类的继承" class="headerlink" title="内部类的继承"></a>内部类的继承</h2>&emsp;&emsp;因为内部类的构造器必须连接到指向其外围类的对象的引用，所有在继承内部类的时候，事情会变得有些复杂，问题在于，那个指向外围类对象的“秘密的”引用必须被初始化<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritInner</span>  <span class="keyword">extends</span> <span class="title">Outer</span>.<span class="title">Inner</span></span>&#123;</span><br><span class="line">    InheritInner(Outer outer)&#123;</span><br><span class="line">        outer.<span class="keyword">super</span>();<span class="comment">//表示的是调用outer的构造器</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Outer outer=<span class="keyword">new</span> Outer();</span><br><span class="line">        InheritInner i = <span class="keyword">new</span> InheritInner(outer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="内部类可以被覆盖吗？"><a href="#内部类可以被覆盖吗？" class="headerlink" title="内部类可以被覆盖吗？"></a>内部类可以被覆盖吗？</h2><p>&emsp;&emsp;如果构建一个内部类，然后继承外部类并重新定义此内部类时，会发生什么？内部类可以被覆盖吗？但是，<strong>“覆盖内部类就像好像它是外围类的一个方法，其实并不起什么作用</strong>”<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Egg</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Yolk y;</span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.print(<span class="string">"Egg.folk()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Egg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"new Egg()"</span>);</span><br><span class="line">        y=<span class="keyword">new</span> Yolk();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigEgg</span> <span class="keyword">extends</span> <span class="title">Egg</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span></span>&#123;System.out.print(<span class="string">"BigEgg.folk()"</span>);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> BigEgg();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//new Egg()</span></span><br><span class="line"><span class="comment">//Egg.folk()</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这说明了一件事情，内部类和外部类其实是两个不同的类，内部类需要外部类对象的引用来创建自己，内部类具有访问外部类成员的权限，<strong>但是当继承一个外部类的时候，并不继承内部类</strong></p><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>前面提到过，可以在方法块里创建局部类，典型的方式是在一个方法的里面创建，<strong>局部内部类不能有访问说明符，因为它不是外围类的一部分，但是它可以访问当前代码块内的常量已经外围类的所有你成员</strong><br>&emsp;&emsp;既然局部内部类的名字在方法外是不可见的，那么我们我什么仍然使用局部内部类而不是匿名类呢？唯一的理由是：<strong>我们需要一个已命名的构造器，或者需要重载构造器，而匿名内部类只能用于实例初始化</strong></p><h2 id="内部类标识符"><a href="#内部类标识符" class="headerlink" title="内部类标识符"></a>内部类标识符</h2><p>&emsp;&emsp;由于每个类都会产生一个.class文件,其中包含了如何创建该类型的对象的全部信息（此信息产生一个meta-class，叫做Class对象），内部类也必须生成一个.class文件以包含他们的Class对象的信息。这些名字有严格的规定，外围类的名字，加上“$”,再加上内部类的名字，如果内部类时匿名的，编译器会简单地产生一个数字作为标识符</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;可以将一个类的定义放在另一个类的定义内部，这就是内部类&lt;/strong&gt;&lt;br&gt;&amp;emsp;&amp;ems
      
    
    </summary>
    
      <category term="学习心得" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>接口</title>
    <link href="http://yoursite.com/2018/10/09/%E6%8E%A5%E5%8F%A3/"/>
    <id>http://yoursite.com/2018/10/09/接口/</id>
    <published>2018-10-09T11:27:30.000Z</published>
    <updated>2018-10-10T08:57:02.180Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;接口和内部类为我们提供了一种将接口与实现分离的更加结构化的方法  </p><h2 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h2><p>&emsp;&emsp;我们创建这样一个类，这个类只提供通用的接口，我们希望通过这个通用接口可以操作一系列类，创建提供通用接口的对象有时是没有意义的，而且我们还希望禁止创建这样的一个类的对象，我们可以在这个抽象的类上写一些“哑”方法，当调用这个“抽象类”对象的“哑”方法时，能抛出错误，但是这样方式，只有在运行时才能被检测到<br>&emsp;&emsp;java提供了一个叫做抽象方法的机制，这种方法是不完整的，仅声明而没有方法体<br>&emsp;&emsp;包含抽象方法的类称为抽象类，如果一个类包含一个或者多个抽象方法，该类必须被限定为抽象的（否则，编译器会报错）<br>&emsp;&emsp;如果从一个抽象类继承，并想创建该新类的对象，那么就必须为基类的所有抽象方法定义，如果不这样做，那么导出类也必须是抽象的，而且编译器会强制我们使用abstract关键字来限定这个类<br>&emsp;&emsp;我们也可能会创建没有任何抽象方法的抽象类，考虑这种情况，这个类包含任何abstract方法都是没有意义的，而且我们也想阻止产生这个类的对象，那么这时这样做就是有意义的<br>&emsp;&emsp;创建抽象类和抽象方法时很有用的，因为它们可以使类的抽象性明确起来，并告诉用户和编译器打算怎样使用它们，抽闲类还是很有用的重构工具，因为它们使得我们可以很容易地将公共方法沿着继承层次结构向上移动</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>&emsp;&emsp;interface这个关键字产生一个完全抽象的类，它根本就没有提供任何具体实现，它允许创建者确定方法名，参数列表和返回类型，但是没有任何方法体<br>一个接口表示：“<strong>所有实现了该接口的类看起来都像是这样的</strong>”因此，任何使用某特定接口的代码都知道可以调用该接口的哪些方法，因此接口被用来建立类与类之间的协议<br>&emsp;&emsp;但是，interface是个极度抽象的类，因为它允许人们通过创建一个能够被向上转型为多积累的类型，来实现某种类似多重继变种的特性<br>&emsp;&emsp;接口的创建很简单，使用interface关键字替代class关键字，也可以在interface前面加上public（但仅限于该接口在与其同名的文件中被定义）如果不加public ，它只具有包权限，这样它只能在同一个包中可用，接口也可以包含域，但是这些域都是static和final的<br>&emsp;&emsp;可以在接口中显式地将方法声明为public，但即使你不这么做，它们也是public的，因此，当要实现一个接口时，在接口被定义的方法必须被定义为public，否则，它们只能得到包访问权限，这样在方法被继承的过程中，其可访问权限就被降低了，这是java编译器不允许的，所有接口中的方法必须是public的，即使不声明这些方法也会自动是public的</p><h2 id="完全解耦"><a href="#完全解耦" class="headerlink" title="完全解耦"></a>完全解耦</h2><p>&emsp;&emsp;只有一个方法操作的是类而非接口，那么你就只能使用这个类及子类，如果你想要将这个方法应用于不在此继承结构的某个类，那么就会很麻烦了，接口可以在很大程度上放宽这些限制，因此，它使得我们可以编写可复用更好的代码  </p><h2 id="java的多重继承"><a href="#java的多重继承" class="headerlink" title="java的多重继承"></a>java的多重继承</h2><p>&emsp;&emsp;接口不仅仅只是一种更纯粹形式的抽象类，它的目标比这更高。因为接口是根本没有任何具体实现的，也就是说，没有任何与接口相关的存储，因此也就无法阻止多个接口的组合，这一点很有价值，因为你需要表示“一个x是一个a和一个b以及一个c”，在C++中，组合多个类的接口的行为被称为<strong>多重继承</strong>它可能使你背负很沉重的负担，因为每个类都有一个具体实现<br>&emsp;&emsp;使用接口的核心原因：为了能够向上转型为多个基类型（以及由此带来的灵活性），然而，使用接口的第二个原因却是与抽象基类相同：防止客户端程序员创建该类的对象，并确保这仅仅是建立一个接口，这就带来了一个问题，我们应该使用接口还是抽象类？如果创建不带任何方法和成员变量的基类，那么你就选择接口而不是抽象类，事实上，如果知道某个事物应该成为一个基类，那么第一选择应该是使它成为一个接口</p><h2 id="通过继承来扩展接口"><a href="#通过继承来扩展接口" class="headerlink" title="通过继承来扩展接口"></a>通过继承来扩展接口</h2><p>接口与接口之间的继承很容易地创建一个新的接口，这个新的接口是这两个接口的并集</p><h3 id="组合接口时的命名冲突"><a href="#组合接口时的命名冲突" class="headerlink" title="组合接口时的命名冲突"></a>组合接口时的命名冲突</h3><p>&emsp;&emsp;组合接口拥有被组合接口的所有方法，所以判断组合接口时接口方法命名是否冲突的一个基本准则是，在新的接口中，被组合的接口能否共存  如下例：  </p><pre><code class="java"><span class="class"><span class="keyword">interface</span> <span class="title">I1</span> </span>{    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>;}<span class="class"><span class="keyword">interface</span> <span class="title">I2</span></span>{    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;}<span class="class"><span class="keyword">interface</span> <span class="title">I3</span></span>{    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a )</span></span>;}<span class="comment">//interface I4 extends I1,I2{ }即使方法返回值不同，I1和I2包含的接口命名冲突，不能共存</span><span class="class"><span class="keyword">interface</span> <span class="title">I5</span> <span class="keyword">extends</span> <span class="title">I1</span>,<span class="title">I3</span></span>{ }</code></pre><h2 id="适配接口"><a href="#适配接口" class="headerlink" title="适配接口"></a>适配接口</h2><p>&emsp;&emsp;接口最吸引人的原因之一就是允许同一个接口具有多个不同的具体实现，在简单的情况中，它的体现形式通常是一个接收接口类型的方法，而接口的实现和向该方法传递的对象则取决于方法的使用者<br>&emsp;&emsp;因此，<strong>接口的一种常见用法就是前面提到的策略设计模式</strong>，此时你编写一个执行某些操作的方法，而该方法将接受一个同样是你指定的接口，你主要就是声明：“你可以用任何你想要的对象来调用我的方法。只要你的对象遵守我的接口”</p><h2 id="接口中的域"><a href="#接口中的域" class="headerlink" title="接口中的域"></a>接口中的域</h2><p>&emsp;&emsp;因为你放入接口中的任何域都自动是static和final的，所以接口就成为了一种很便捷的用来创建常量组的工具，不过SE5之后，有了enum关键字之后，使用接口群组常量已经没什么意义了</p><h2 id="嵌套接口"><a href="#嵌套接口" class="headerlink" title="嵌套接口"></a>嵌套接口</h2><p>&emsp;&emsp;接口可以嵌套在类或者其他接口中，这揭示了许多非常有趣的特性  </p><figure class="highlight java"><figcaption><span>嵌套接口</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"><span class="comment">//在类中嵌套</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">B</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BImpl1</span> <span class="keyword">implements</span> <span class="title">B</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BImpl2</span> <span class="keyword">implements</span> <span class="title">B</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">C</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CImple1</span> <span class="keyword">implements</span> <span class="title">C</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>  <span class="class"><span class="keyword">class</span> <span class="title">CImple12</span> <span class="keyword">implements</span> <span class="title">C</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">D</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DImple1</span> <span class="keyword">implements</span>  <span class="title">D</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DImple2</span> <span class="keyword">implements</span>  <span class="title">D</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> D dRef;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> D <span class="title">getD</span><span class="params">()</span></span>&#123;<span class="keyword">return</span>  <span class="keyword">new</span> DImple1();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveD</span><span class="params">(D d)</span></span>&#123;</span><br><span class="line">        dRef=d;</span><br><span class="line">        d.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//在接口中嵌套</span></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">E</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">G</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//redundant public 多余的public</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">H</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NestingInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bimp</span> <span class="keyword">implements</span> <span class="title">A</span>.<span class="title">B</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CImpl</span> <span class="keyword">implements</span> <span class="title">A</span>.<span class="title">C</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    class DImpl implements  A.D&#123;</span></span><br><span class="line"><span class="comment">//        public void f()&#123;&#125;;</span></span><br><span class="line"><span class="comment">//    &#125;不能实现一个私有的接口</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">EImpl</span> <span class="keyword">implements</span>  <span class="title">E</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">EGImpl</span> <span class="keyword">implements</span> <span class="title">E</span>.<span class="title">G</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        <span class="comment">//Can't access A.D 不能访问A.D,因为A.D是私有的</span></span><br><span class="line">        <span class="comment">//A.D ad=a.getD();</span></span><br><span class="line">        <span class="comment">//除了A.D 也不能返回任何类型的引用 Doesn't return nothing but A.D</span></span><br><span class="line">        <span class="comment">//A.DImple2 dImple2=a.getD();</span></span><br><span class="line">        <span class="comment">//也不能访问这个接口的成员 connot access a member of the interface</span></span><br><span class="line">        <span class="comment">//a.getD().f();</span></span><br><span class="line">        <span class="comment">//可以让另一个A对getD()返回的对象进行操作。Only another A can do anything with getD()</span></span><br><span class="line">        A a2 = <span class="keyword">new</span> A();</span><br><span class="line">        a2.receiveD(a.getD()); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">      &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在类中嵌套接口是相当常见的语法，就像非嵌套接口一样，可以拥有publi和包访问权限，两种可视性，<br>&emsp;&emsp;作为一种新添加的方式，接口也可以被实现为private的，就像<code>A.D</code>中看到的那样（相同的方法，既可以适用于嵌套接口，也可以使用于嵌套类），那么private的嵌套接口能够带来什么好处呢？实现一个private接口只是一种方式，它可以强制接口中定义的定义的方法不要添加任何类型信息（也就是说，不能进行向上转型）<br>&emsp;&emsp;getD()方法陷入了一个两难的境地，这个问题与private接口有关，它是一个返回对private接口引用的public方法，你对这个方法返回值能做什么呢？在main方法时，我们尝试了很多行为都失败了，只有一种方式能够成功，那就是将返回值交给有权使用它的对象，在这个例子中，是另一个A通过<code>receiveD()</code>方法实现的<br>&emsp;&emsp;接口E说明接口彼此之间也是可以嵌套的，与在类嵌套接口不同，被嵌套在接口中的所有接口元素都是public的，，即使不声明，也会自动为public<br>&emsp;&emsp;注意的是，当实现某个接口的时候，并不需要实现嵌套在内部的任何接口，而且private接口也不能在定义它的类之外被实现</p><h2 id="接口和工厂"><a href="#接口和工厂" class="headerlink" title="接口和工厂"></a>接口和工厂</h2><p>&emsp;&emsp;接口是实现多重继承的途径，而生成遵循某个接口的对象的典型方式就是工厂方法设计模式，<strong>这与直接使用构造器不同，我们在工厂对象上调用的是创建方法</strong>，而该工厂对象将生成接口的某个实现的对象，通过这种方式，我们的代码将完全与接口的实现分离，这就使得我们可以透明地将某个实现替换成另一个实现<br><figure class="highlight java"><figcaption><span>工厂方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ServiceFactory</span></span>&#123;</span><br><span class="line">    <span class="function">Service <span class="title">getService</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceImp1</span> <span class="keyword">implements</span>  <span class="title">Service</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServcieImp1Factory</span> <span class="keyword">implements</span> <span class="title">ServiceFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  Service <span class="title">getService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServiceImp1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceImp2</span> <span class="keyword">implements</span>  <span class="title">Service</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServcieImp2Factory</span> <span class="keyword">implements</span> <span class="title">ServiceFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  Service <span class="title">getService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServiceImp2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factories</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serviceConsumer</span><span class="params">(ServiceFactory serviceFactory)</span></span>&#123;</span><br><span class="line">        Service service=serviceFactory.getService();</span><br><span class="line">        service.m1();</span><br><span class="line">        service.m2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        serviceConsumer(<span class="keyword">new</span> ServcieImp1Factory());</span><br><span class="line">        serviceConsumer(<span class="keyword">new</span> ServcieImp2Factory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果不是工厂方法，你的代码就必须要在某处指定将要创建的Service的确切类型，以便调用合适的构造器<br>&emsp;&emsp;为什么我们要增加这种额外级别的间接性呢？一个常见的原因是想要创建框架  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;接口和内部类为我们提供了一种将接口与实现分离的更加结构化的方法  &lt;/p&gt;
&lt;h2 id=&quot;抽象类和抽象方法&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="学习心得" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>多态</title>
    <link href="http://yoursite.com/2018/10/09/%E5%A4%9A%E6%80%81/"/>
    <id>http://yoursite.com/2018/10/09/多态/</id>
    <published>2018-10-09T06:34:58.000Z</published>
    <updated>2018-10-10T09:02:31.083Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;在面向对象的程序设计语言，多态是数据抽象和继承之后的第三种基本特征<br>&emsp;&emsp;多态通过分离做什么和怎么做，从另一个角度将接口和实现相分离，多态不但能够改善代码的组织结构和可读性，还能够创建可扩展的程序——即无论在项目最初创建时还是在需要新功能时都可以“生长”的程序<br>&emsp;&emsp;“封装”通过合并特征和行为来创建新的数据类型，“实现隐藏”则通过将细节“私有化”，把接口和实现分离开来。而多态的作用是消除类型之间的耦合关系，多态方法调用允许一种类型表现出与其他相似类型之间的区别，只要它们都是从一个基类中导出来的，这种区别是根据方法行为的不同而表示出来的，虽然这些方法都是可以通过同一个基类来调用  </p><h2 id="再论向上转型"><a href="#再论向上转型" class="headerlink" title="再论向上转型"></a>再论向上转型</h2><p>&emsp;&emsp;把某个对象的引用类型视为对基类的引用的做法就被称为向上转型  </p><h3 id="忘记对象类型"><a href="#忘记对象类型" class="headerlink" title="忘记对象类型"></a>忘记对象类型</h3><p>&emsp;&emsp;我们在程序的编写时，如果一个方法接受的是一个特定类型的参数，这样就产生了一个问题，我们是不是要为每一种特定类型写一个接受其特定类型的方法？我们有没有更通用的办法，使得方法接收一个更加通用的类型，而不在意具体的类型是什么，只要我们可以将这个特定类型当作通用类型的看待即可  </p><h2 id="转机"><a href="#转机" class="headerlink" title="转机"></a>转机</h2><p>&emsp;&emsp;将一个具体的类型当作向上转型类型的时候，编译器怎么知道它调用的是那个方法呢？实际上，编译器不知道，为了研究这个问题，先来看下绑定的定义<br>&emsp;&emsp;将一个方法调用同一个方法主体关联起来就被称为绑定，例如 <code>f()</code>是一个方法，a是A类型的对象，当a调用<code>f()</code>方法的时候，我们a调用的其实是<code>f()</code>方法,这就叫绑定，或者称作f()和A类型的对象进行了绑定,若在程序执行前进行绑定的话，由编译器和连接程序实现，就做前期绑定，我们没有听过则个术语，因为它是面向对象不需要选择就默认使用的绑定方式<br>&emsp;&emsp;我们对于多态的迷惑，主要是因为前期绑定，那么编译器应该知道调用那个方法才对，为什么不同的具体类型又会有不同的调用结果，不同的调用结果，就表明调用的不是同一个方法<br>&emsp;&emsp;解决的办法就是后期绑定，它的含义就是根据运行是根据对象的类型进行绑定吧，后期绑定也称为动态绑定或者运行期绑定，如果一种语言要想实现后期绑定，就必须具有某种机制，以便在运行时能判断对象的类型，从而调用恰当的方法，也就是说编译器不知道对象的类型，但是方法调用机制能够找到正确的方法体<br>&emsp;&emsp;java中除了static方法和final方法（private方法也属于final方法）之外，其他所有的方法都是后期绑定<br>&emsp;&emsp;为什么要将一个方法声明为final呢？除了之前讲到的原因之外，更重要的一点也许是：这样可以有效地“关闭”动态绑定，或者说，告诉编译器不需要对其进行动态绑定  </p><h3 id="产生正确的行为"><a href="#产生正确的行为" class="headerlink" title="产生正确的行为"></a>产生正确的行为</h3><p>&emsp;&emsp;一旦知道java中所有的方法都是通过动态绑定实现多态这个事实之后，我们就可以编写只与基类打交道的程序代码了，并且这些代码对所有导出类都可以正确运行，由于有多态机制，这样我们可以在系统当中添加任意多的新类型，而不需要改变基于基类编写的代码，这样的程序是可扩展的  </p><h3 id="缺陷：“覆盖”私有方法"><a href="#缺陷：“覆盖”私有方法" class="headerlink" title="缺陷：“覆盖”私有方法"></a>缺陷：“覆盖”私有方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package xyz.egbertday;</span><br><span class="line">class Derived extends PrivateOverride&#123;</span><br><span class="line">    public void f()&#123;</span><br><span class="line">        System.out.print(&quot;publi.f()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class PrivateOverride &#123;</span><br><span class="line">    private void f()&#123;</span><br><span class="line">        System.out.print(&quot;private.f()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        PrivateOverride derived=new Derived();</span><br><span class="line">        derived.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">~~~ </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">我们期望的是输出`public.f()`，但是由于private方法被自动地认为是final方法，在这里对private方法的调用是前期绑定  </span><br><span class="line">### 缺陷：域和静态方法 ###</span><br><span class="line">&amp;emsp;&amp;emsp;任何域访问操作都将由编译器解析，因此不是多态的，对静态方法的调用也不是多态的  </span><br><span class="line">## 构造器和多态 ##</span><br><span class="line">通常，构造器不同于其他种类的方法，设计到多态时也是如此，尽管构造器并不具有多态性（它们实际上是static方法，只不过该static声明的是隐式的），但还是有必要理解构造器怎么通过多态在复杂的层次结构中运作</span><br><span class="line">### 构造器的调用顺序 ###</span><br><span class="line">&amp;emsp;&amp;emsp;基类的构造器总是在导出类的构造过程中被调用，而且按照继承层次逐渐向上链接，以确保内个基类的构造器都能得到调用</span><br><span class="line">### 继承与清理 ###</span><br><span class="line">&amp;emsp;&amp;emsp;通过组合和继承方法创建新类时，方法永远不必担心对象的清理问题，子对象通常都会留给垃圾回收器进行，如果确实遇到清理的问题，那么必须用心为新类创建`dispose()`方法（这是个假设的名字）并且由于继承的缘故，如果我们有其他作为垃圾回收部分的特殊清理动作，必须现在导出类中覆盖`dispose()`方法，当覆盖被继承的`dispose()`方法时，务必调用基类版本的`dispose()`方法，否则，基类的清理动作就不会发生  </span><br><span class="line">~~~java</span><br><span class="line">package xyz.egbertday;</span><br><span class="line">class SuperClass&#123;</span><br><span class="line">    public void dispose()&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">public class SubClass extends SuperClass&#123;</span><br><span class="line">    public void dispose()&#123;</span><br><span class="line">        super.dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造器内部的多态方法的行为"><a href="#构造器内部的多态方法的行为" class="headerlink" title="构造器内部的多态方法的行为"></a>构造器内部的多态方法的行为</h3><p>&emsp;&emsp;构造器调用的层次问题带来了一个有趣的两难问题，如果在一个构造器的内部调用正在构造对象的某个动态绑定，那么会发生什么情况呢？<br>&emsp;&emsp;在一般的方法内部，动态绑定是在运行时才决定的，因为对象无法知道它是属于方法所在的类，还是属于那个类的导出类<br>&emsp;&emsp;如果要调用构造器内部的一个动态绑定方法，就要用到那个方法的被覆盖之后的定义，然而，这个调用的效果可能相当难预料，因为被覆盖的方法在对象被完全构建之前就会被调用，这可能会出现一些难以预料的隐藏错误<br>&emsp;&emsp;从概念上将，构造器的工作实际上是创建对象（这不是一件平常的事情），在任何构造器内部，整个构造器可能只是部分形成，如果构造器只是在构建对象过程中的一个步骤，并且该对象所属的类是从这个构造器所属的类导出的，那么导出部分在当前构造器正在被调用的时刻仍旧没有被初始化，然而，一个动态绑定的方法调用可能会向外深入到继承层次结构内部，它可以调用导出类里的方法,如果我们是在构造器内部这样做，那么就可能会调用这个方法，而这个方法所操作的成员可能还未进行初始化——这肯定会招致灾难<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"SuperClass"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    SuperClass()&#123;</span><br><span class="line">        printA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.print(<span class="string">"SubClass"</span>+a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SubClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolyConstructor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        SubClass subClass = <span class="keyword">new</span> SubClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;我们预期，当创建基类的时候，会先调用基类的构造器，在基类的构造器方法中调用了<code>print()</code>,因为动态代理的缘故，实际上调用的是导出类的<code>printA()</code>我们预期结果会是“SubClass1”,可是因为当调用基类的构造器时，还没有对导出类进行初始化，i仍然是0值<br>&emsp;&emsp;以前讲的初始化顺序并不十分完整，而这正是立即谜题的关键，初始化的实际过程是  </p><ol><li>在其他任意事物发生之前，将分配给对象的存储空间初始化成二进制的零</li><li>如前所述那样调用基类构造器，此时，调用被覆盖后的<code>printA()</code>方法（要在调用导出类的构造器之前），由于步骤1的关系，我们此时会发现i的值为0 </li><li>按照声明的顺序调用成员的初始化方法<br>&emsp;&emsp;这样做有一个优点，那就是所有东西至少初始化为零<br>&emsp;&emsp;编写构造器的时候有一条有效地准则“用尽可能简单的方法使对象进入正常状态，如果可以的话，避免调用其他方法”在构造器中唯一能够安全调用的方法是基类的那些final方法（private也是final方法），这些方法不能被覆盖，因此也就不不会发生动态绑定（多态）的问题了<h2 id="协变返回类型"><a href="#协变返回类型" class="headerlink" title="协变返回类型"></a>协变返回类型</h2>&emsp;&emsp;协变返回类型，它表示在导出类中的被覆盖的方法可以返回基类方法返回类型的某种导出类型<h2 id="用继承进行设计"><a href="#用继承进行设计" class="headerlink" title="用继承进行设计"></a>用继承进行设计</h2>&emsp;&emsp;多态特性很容易诱使我们继承现有的类，以实现多态的特性，实际的开发当中，如果首先考虑继承技术，反而会加重我们的设计负担<br>&emsp;&emsp;更好的方式是首先选择“组合”，尤其是不能十分确定应该使用哪一种方式时，组合不会强制我们的程序设计进入继承的层次结构，而且，组合更加灵活，它可以动态选择类型（因此也就选择了行为），相反，继承在编译时就需要知道确切类型。看看下面的经典案例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Actor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">act</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HappyActor</span> <span class="keyword">extends</span> <span class="title">Actor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">act</span><span class="params">()</span></span>&#123;System.out.print(<span class="string">"happy"</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SadActor</span> <span class="keyword">extends</span> <span class="title">Actor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">act</span><span class="params">()</span></span>&#123;System.out.print(<span class="string">"sad"</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stage</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Actor actor=<span class="keyword">new</span> HappyActor();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">()</span></span>&#123;</span><br><span class="line">        actor=<span class="keyword">new</span> SadActor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line">        actor.act();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transmogrify</span> </span>&#123;</span><br></pre></td></tr></table></figure></li></ol><p>&emsp;&emsp;在这里，Stage对象包含一个对Actor的引用，而Actor被初始化为一个HappyActor对象，这意味着play()会产生某种特殊行为，既然引用在运行时可以与另一个不同对象重新绑定（”<code>change()</code>“），所以SadActor对象的引用可以在actor中被替换，然后由<code>play()</code>产生的行为也随之改变，这样一来，我们在运行期间获得了动态的灵活性（这也称为“状态模式”），与此相反，我们不能再运行期间决定继承不同的对象，因为它要求在编译器间完全确定下来<br>&emsp;&emsp;一条通用的法则是：用继承表达行为之间的差异，并用字段表达状态上的变化，在上面例子，两者都用到了，通过继承得到了两个不同的类，用于表达<code>act()</code>方法的差异，而Stage通过运用组合使自己的状态发生变化，在这情况下，这种状态的改变也就产生了行为的改变</p><h3 id="纯继承与扩展"><a href="#纯继承与扩展" class="headerlink" title="纯继承与扩展"></a>纯继承与扩展</h3><p>&emsp;&emsp;“纯粹”的继承表示导出类和基类的接口完全一致<br>&emsp;&emsp;扩展表示在基类的基础上添加导出类自己所特有的方法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在面向对象的程序设计语言，多态是数据抽象和继承之后的第三种基本特征&lt;br&gt;&amp;emsp;&amp;emsp;多态通过分离做什么
      
    
    </summary>
    
      <category term="学习心得" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>复用类</title>
    <link href="http://yoursite.com/2018/10/07/%E5%A4%8D%E7%94%A8%E7%B1%BB/"/>
    <id>http://yoursite.com/2018/10/07/复用类/</id>
    <published>2018-10-06T17:41:58.000Z</published>
    <updated>2018-10-10T08:57:49.411Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>&emsp;&emsp;复用代码是java众多引人注目的功能之一，但要想成为极具革命性的语言，仅仅能够复制代码并对之加以改变是不够的，它还必须能够做更多的事情<br>&emsp;&emsp;正如Java中所有事物一样，问题的解决都是围绕着类展开的，可以通过创建新类来复用代码，而不必再从头开始编写，可以使用别人业已开发并调试好的类。<br>&emsp;&emsp;此方法的窍门在于使用类而不破坏现有程序的代码，有两种方式可以达到这种目的，组合和继承  </p></blockquote><h2 id="继承语法"><a href="#继承语法" class="headerlink" title="继承语法"></a>继承语法</h2><p>&emsp;&emsp;当创建一个类的时候，总是在继承，因为除非已经明确指出要从其他类继承，否则都是隐式地从Java的标准跟类Object继承<br>&emsp;&emsp;在继承的过程，需要先声明“新类与基本相似”。这种声明是通过extends关键字完成的  </p><h3 id="初始化基类"><a href="#初始化基类" class="headerlink" title="初始化基类"></a>初始化基类</h3><p>&emsp;&emsp;从外部看，导出类就像一个与基类具有相同接口的新类，或许还会有一些额外的方法和域，但继承并不只是复制基类的接口，当创建一个导出来类的对象时，该对象包含一个基类的子对象，这个子对象和你用基类直接创建的对象是一样的，二者之间的区别在于，后者来自于外部，而基类的子对象被包装在导出类对象的内部，其实来说，整个导出类对象的创建过程并没有产生父类的对象，我们只是利用了父类的构造函数来初始化导出类的属性，对基类子对象的初始化必须得到保证，所以就是在导出类的构造器中通过调用基类构造器来执行初始化，而基类构造器具有执行基类初始化所需的所有知识和能力，Java会自动在导出类的构造器中插入对基类构造器的调用，其为什么导出类不能直接访问这些由基类初始化的属性，我们之后再谈<br>&emsp;&emsp;所以我们也会发现，整个创建过程是从导出类依次上溯，构造函数执行的初始化动作依次向下</p><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>&emsp;&emsp;第三种关系称为代理，java并没有提供对它的直接支持，这是继承和组合的中庸之道，因为我们将一个对象置于所要构造的类中（就像组合），但与此同时我们在新类中暴露该成员的所有方法（就像继承）</p><h2 id="结合使用组合和继承"><a href="#结合使用组合和继承" class="headerlink" title="结合使用组合和继承"></a>结合使用组合和继承</h2><p>&emsp;&emsp;同时使用组合和继来创建复杂的类是很常见的，因为新类能够同时可以对继承和组合的类的功能进行复用</p><h2 id="在组合和继承之间选择"><a href="#在组合和继承之间选择" class="headerlink" title="在组合和继承之间选择"></a>在组合和继承之间选择</h2><p>&emsp;&emsp;组合和继承都允许在新类中放置子对象，组合是显式地这样做，而继承则是隐式地这样做，那当我们创建的新类想要使用另一个类的服务（接口）时，该如何选择？<br>&emsp;&emsp;组合技术通常用于想要使用现有类的功能而不是它的接口这种情形，在新类中嵌入某个类的对象，让其实现所需的功能，但新类的用户看到的只是新类所定义的接口，而非所嵌入对象的接口，为取得此效果，需要在新类中嵌入一个现有类的private对象<br>&emsp;&emsp;有时，运行累的用户直接访问新类中的组合成分是及其有意思的，也就是说，将成员对象声明为public，如果成员对象自身隐藏了具体实现，那么这样做也是安全的，当用户能够了解你正在组装一组部件，会使得端口更加易于理解，比如组装一辆车Car，<code>car.left.window.roolup()</code>这样的代码很容易让人理解，但是，一般情况下，我们还是会将一个对象声明为private，并通过公开的接口来获得这个成员对象<br>&emsp;&emsp;在继承的时候，使用现有的类，并开发一个它的特殊版本，通常，这意味着你在使用一个通用类，为了某种特性需要而对其特殊化</p><h2 id="protected关键字"><a href="#protected关键字" class="headerlink" title="protected关键字"></a>protected关键字</h2><p>&emsp;&emsp;在理想世界中，关键字private就足够了，但在实际项目中，经常会将某些事物尽可能对整个世界隐藏，但仍然运行导出类的成员访问它们<br>&emsp;&emsp;关键字protected就是起到这个作用，它指明“就类用户而言，这是private的，但对于任何继承于此类的导出类或任何位于同一个包的类来说，它确实可以访问的（protected也提供了包访问权限）”<br>&emsp;&emsp;尽管可以创建protected域，但是最好的方式还是将域保持为private，你应当一致保留“要更改底层实现”的权利，然后通过protected方法来控制类的继承者的访问权限</p><h2 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h2><p>“为新的类提供方法”并不是继承的最重要的方面，其最重要的方面是用来表现新类和基类之间的关系，这种关系可以用“新类是现有类的一种类型”，这句话加以概括<br>这个描述并不只是一种解释继承的华丽方式，这直接是由语言所支撑的，由于继承可以确保基类中所有的方法在导出类中也同样有效，所有能够向基类发送的所有信息同样也可以向导出类发送<br>&emsp;&emsp;由导出类转型成基类，在继承图上是向上移动的，因此一般称为向上转型，由于向上转型是从一个较专用类型向一个较通用类型转换，所以总是安全的，也就是说，导出类是基类的一个超集，在向上转型的过程中，类接口中唯一可能发生的事情是丢失方法，而不是获取它们，这也是为什么编译器在“未曾明确表示转型”或“未曾指定特殊标记”情况下，仍然允许向上转型的原因  </p><h3 id="再论组合和继承"><a href="#再论组合和继承" class="headerlink" title="再论组合和继承"></a>再论组合和继承</h3><p>&emsp;&emsp;在面向对象时，生成和使用程序代码最有可能的方法就是直接将数据和方法包装进一个类中，并使用该类的对象，也可以运用组合和继承使用现有类来开发新的类，而继承技术其实是不太常用，即使在学习过程中，过多的强调继承，对于这个技术，也是要谨慎使用，那在一个场合下如何确定你应该使用继承还是组合呢？一个最清晰的判断方法就是要问一问你自己是否需要从新类向基类进行向上转型，如果必须向上转型，则继承是必要的，如果不需要，最好使用组合  </p><h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p>&emsp;&emsp;根据上下文关系，java的关键字final含义存在着细微的区别，但通常它指的是“这是无法改变的”，不想改变可能出于两个理由：设计和效率，由于这两个理由相差很远，所以关键字final有可能被误用</p><h3 id="final数据"><a href="#final数据" class="headerlink" title="final数据"></a>final数据</h3><p>&emsp;&emsp;很多编程语言都有某种方法，来向编译器告知一块数据是恒定不变的，有时数据的恒定不变是很有用的，比如  </p><ol><li>一个永不改变的编译时常量  </li><li><p>一个在运行时被初始化的值，而你不希望它被改变<br>&emsp;&emsp;对于编译器常量这种情况，编译器可以将该常量带入任何可能用到它的计算式中，也就是说，可以在编译时执行计算，这样减轻了运行时的负担，在java中，这类常量必须是基本数据类型，并且以关键字final表示，在对这个常量进行定义时，必须对其进行赋值<br>&emsp;&emsp;一个既是static又是final的域只占据一段不能改变的存储空间<br>&emsp;&emsp;当对对象引用而不是基本类型引用final时，含义有一些令人迷惑，对于基本变量，final使其数值恒定不变，而对于对象引用，final使其引用恒定不变，一旦引用被初始化指向一个对象，就无法再将它改为指向另一个对象，然而对象自身是可以被修改的，java并没有提供使任何对象恒定不变的途径（但可以编写类以取得使对象恒定不变的效果），这一个限制也适用数组，它也是对象<br>&emsp;&emsp;还有一个要注意的是，我们不能因为某数据是final的就认为在编译时就可以知道它的值，但是我们知道一旦这个数据被初始化之后就恒定不变，所以说，final关键字修饰的数据，是在数据被初始化之后保持不变  </p><h3 id="空白final"><a href="#空白final" class="headerlink" title="空白final"></a>空白final</h3><p>&emsp;&emsp;java允许生成“空白final” 所谓空白final是被声明为final，但是又为给定初值的域，无论什么情况，编译器确保空白final在使用之前必须被初始化，但是空白final在关键字final的使用上提供了更大的灵活性，为此一个类中的final域可以做到根据对象而不同，却又保持着恒定不变的特性  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package xyz.egbert  </span><br><span class="line">class ProPet&#123;</span><br><span class="line">    private int i;</span><br><span class="line"></span><br><span class="line">    public ProPet(int i) &#123;</span><br><span class="line">        this.i = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class BlankFinal &#123;</span><br><span class="line">    private final int i=0;</span><br><span class="line">    private final int j;</span><br><span class="line">    private final ProPet proPet;</span><br><span class="line"></span><br><span class="line">    public BlankFinal()&#123;</span><br><span class="line">        this.j=0;</span><br><span class="line">        this.proPet=new ProPet(1);</span><br><span class="line">    &#125;</span><br><span class="line">    public BlankFinal(int x)&#123;</span><br><span class="line">        this.j=x;</span><br><span class="line">        this.proPet=new ProPet(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~~~ </span><br><span class="line">从上面代码示例中可以看到，必须在域定义处或者每个构造器内对final进行赋值，否则IDE工具会提示编译错误，进行源码的编译时也会发生编译失败  </span><br><span class="line">### final参数 ###</span><br><span class="line">&amp;emsp;&amp;emsp;java允许在参数列表以声明的方式将指数指名为final，这意味着你无法在方法中更改参数引用所指向的对象</span><br><span class="line">### final方法 ###</span><br><span class="line">&amp;emsp;&amp;emsp;使用final方法的原因有两个，第一个原因是把方法锁定，以防任何继承类修改它的含义，这是出于设计的考虑，想要确保在继承中使方法行为保存不变，并且不会被覆盖  </span><br><span class="line">在过去第二个原因是效率，在java的早期实现中，如果将一个方法指名为final,就是同意编译器将针对该方法的所有调用都转为内嵌调用，但是在最近的java版本中，已经不再需要使用final方法进行优化了，事实上，这种做法正逐渐受到阻止</span><br><span class="line">#### final和private关键字 ####</span><br><span class="line">&amp;emsp;&amp;emsp;类中的所有private方法都隐式地指定为final的，由于无法取用private方法，所以也就无法覆盖它，可以给private添加final修饰词，但这并不能给该方法增加任何额外的意义</span><br><span class="line">这一问题会造成困扰，我们知道final修饰的方法禁止了继承类的覆盖，如果在继承类中重写基类的final方法，则会引发编译错误，它会提示你这个方法以及在基类中被定义了，可是如果你试图覆盖一个private方法（隐含是final的），似乎是奏效的，而且编译器也不会给出错误信息</span><br></pre></td></tr></table></figure><pre><code>package xyz.egbertday;public class Type {    private final void f(){        System.out.print(&quot;Type&quot;);    }}public class SubType extends Type{    public void f(){        System.out.print(&quot;subType&quot;);    }    public static void main(String[] args){        SubType subType=new SubType();        subType.f();        Type type=subType;        //type.f();    }}</code></pre><p>~~~</p></li></ol><p>&emsp;&emsp;”覆盖”只是在某个方法是<strong>基类的接口</strong>的一部分时才会出现，即，必须能将一个对象向上转型为它的基类型并调用相同的方法，如果某个方法为private,它就不是基类的接口的一部分，它仅是一些隐藏于类中的程序代码，只不过是具有相同的名字而已，但如果在导出类中以相似的名称生成为一个public，protected或者包访问权限方法的话，该方法就不会产生在基类中出现的“仅具有相同名称”的情况，此时你并没有覆盖该方法，仅是生成了一个新的方法，由于private方法无法触及而且能够有效隐藏，所有<strong>除了把它看成因为它所归属的累的组织结构的原因而存在外，其他任何事物都不需要考虑到它</strong>  </p><h3 id="final类"><a href="#final类" class="headerlink" title="final类"></a>final类</h3><p>&emsp;&emsp;当将某个类整体定义成final时，就表明了你不打算继承该类，而且也不允许别人这么做，换句话说，出于某种考虑，你对该类的设计永不需要做任何改动，或者出于安全的考虑，你不希望它有子类</p><h2 id="初始化和类的加载"><a href="#初始化和类的加载" class="headerlink" title="初始化和类的加载"></a>初始化和类的加载</h2><p>&emsp;&emsp;在很多传统语言，程序是作为启动过程的一部分立刻被加载的，然后初始化，紧接着程序开始运行    ，这些语言的初始化必须小心控制，以确保定义为static的东西，其初始化的顺序不会造成麻烦<br>&emsp;&emsp;java就不会出现这种问题，因为它采用了不同的加载方式，我喜欢称为（动态加载），加载是众多变得更加容易的动作之一，因为<strong>java中的所有事物都是对象</strong>，请记住，<strong>每个类的编译代码都存在与它自己的独立文件中</strong>    该文件之一在需要使用程序时才会被加载，一般来说，类的代码在初次使用时才加载，这通常是指加载发生在类的第一个对象被创建之时，也会发生当访问static域或static方法时，也会发生加载<br>&emsp;&emsp;初次使用之处也是static初始化发生之处，所有的static对象和static代码都会在加载时依程序中的顺序（即，定义类时的书写顺序）而依次初始化，当然，定义为static的东西只会被初始化一次 </p><h3 id="继承和初始化"><a href="#继承和初始化" class="headerlink" title="继承和初始化"></a>继承和初始化</h3><p>导出类的对象创建过程就是，依继承链向上一次进行加载，加载完成之后，根基类中的static初始化即会被执行，然后是下一个导出类，以此类推，这种方式很重要，因为导出类的static初始化可能会依赖于基类成员能否被正确初始化<br>&emsp;&emsp;至此，必要的类都被加载完毕，对象就可以被创建了，首先，对象中所有的基本类型都被设为默认值，对象引用都被设为null——这是通过将对象内存设为二进制零值而一举生成的，然后，基类的构造器就会被调用，它是被自动调用的，但也可以用super来指定对基类构造器的调用，基类构造器和导出类的构造器一样，以同样的顺序来经历相同的过程，在基类构造器完成之后，实例变量按其次序依次被初始化，然后构造器的其余部分被执行  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;继承和组合都能从现有类型生成新类型，组合一般是将现有类型作为新类型底层实现的一部分加以复用，而继承复用的是接口<br>&emsp;&emsp;在使用继承时，由于导出类具有基类接口，因此它可以向上转型至基类，这对多态来讲至关重要<br>&emsp;&emsp;尽管面向对象编程对继承极力强调，但是开始一个设计时，一般有限选择使用组合（或者可能是代理），只有确实有必要时才使用继承，因为组合更具有灵活性，此外对成员类型使用继承技巧的添加技巧，可以在运行时改变那些成员对象的类型和行为，因此可以在运行时改变组合而成的对象的行为<br>&emsp;&emsp;在设计一个系统时，目标应该是找到或者创建某些类，其中每个类都有具体的用途，而且既不会太大（包含太多的功能而难以复用）。也不会太小（不添加其他功能就不能用），如果你的设计过于复杂，通过将现有类拆分为更小的部分而添加更多的对象，通常这是有帮助的                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;复用代码是java众多引人注目的功能之一，但要想成为极具革命性的语言，仅仅能够复制代码并对
      
    
    </summary>
    
      <category term="学习心得" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>访问权限控制</title>
    <link href="http://yoursite.com/2018/10/06/%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
    <id>http://yoursite.com/2018/10/06/访问权限控制/</id>
    <published>2018-10-06T06:39:23.000Z</published>
    <updated>2018-10-10T09:00:35.830Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>访问控制（或隐藏具体实现）与“最初的实现并不恰当”有关  </p></blockquote><p>几乎所有的代码某些部分经过一段时间再回头看，可能会发现有更好的方式来去实现相同的功能，这正是重构的原动力之一，重构或者重写代码，以使得它更可读，更易理解，更具有可维护性<br>&emsp;&emsp;但是，在这种修改和完善代码的愿望下，也存在着巨大的压力，通常总会有一些消费者（客户端程序员）需要你的代码在某些方面不变，由此产生了面向对象设计中需要考虑的一个基本问题：“如何把变动的事物与保持不变的事物区分开来”<br>这一目标可以通过约定达成，例如，类库的开发者必须保证不得删除任何现有的方法，因为那样会破坏客户端程序员的代码，但是，与之相反的情况更加棘手，在域（数据成员）存在的情况下，类库开发者要怎么知道究竟都有哪些已经被客户端程序员所调用了呢？<br>&emsp;&emsp;为了解决这一问题，java提供了访问权限修饰符，以供类库开发人员指明了哪些是可用的，哪些是不可用的<br>&emsp;&emsp;不过，构件类库的概念已经对于谁有权取用该类库构件的控制问题还是不完善的，其中仍然存在着如何将构件捆绑到一个内聚的类库单元中的问题，对于这一点，java用关键字package加以控制，而访问权限修饰词会因类是存在于一个相同的包还是存在于一个单独的包而受到影响，所以要理解理解访问权限修饰符的全部含义，要先学习如何将类库构件置于包中  </p><h2 id="包：库单元"><a href="#包：库单元" class="headerlink" title="包：库单元"></a>包：库单元</h2><p>&emsp;&emsp;由于名字之间的潜在冲突，在java中对名称空间进行完全控制并为每个类创建唯一的标识符组合就成为了非常重要的事情<br>&emsp;&emsp;当编写一个java源代码文件时，此文件通常被称为编译单元（有时也被称为转译单元），每个编译单元都必须要有一个后缀名.java，而在编译单元内则可以有一个public类，该类的名称必须要与源文件名称相同，否则编译器就不会接受，如果在编译单元之中还有额外的类的话，那么包之外的世界是无法看见这些类的，这是因为他们不是public类，而且他们主要是用来为主public类提供支持的  </p><h3 id="代码组织"><a href="#代码组织" class="headerlink" title="代码组织"></a>代码组织</h3><p>&emsp;&emsp;当编译一个java文件时，在java文件中的每一个类都会有一个输出文件，而输出文件的名称与.java文件的名称相同，只是多了后缀名.class,因此少量的编译.java文件，就会得到大量的<code>.class</code>文件<br>&emsp;&emsp;java可运行程序时一组可以打包并压缩为一个java文档文件（Jar，使用java的jar文档生成器）的.class文件，java解释器负责这些文件的查找，装载和解释<br>&emsp;&emsp;类库实际上是一组类文件，其中每个文件都有一个public类，以及任意数量的非public类，因此每一个文件都有一个构件，如果希望这些构件（每一个都有它们自己的独立的<code>.java</code>和<code>.class</code>文件）从属同一个群组，就可以使用关键字package<br>    package access;<br>&emsp;&emsp;这表明你在声明该编译单元是名为access的类库的一部分，或者换种说法，你正在声明该编译单元中的public类名称位于access名称的保护伞下，任何想要使用该名称的人都必须使用该类库构件的全名或者使用import关键  </p><h3 id="创建独一无二的包名"><a href="#创建独一无二的包名" class="headerlink" title="创建独一无二的包名"></a>创建独一无二的包名</h3><p>&emsp;&emsp;其实一个包从未真正将被打包的东西包装成一个单一的文件，并且一个包可以由许多.class文件构成，也就是说，我们只是定义了类是在哪个命名空间下，通过命名空间和类名唯一地标识这个类，那么情况有点复杂，当我们的程序在运行的时候，应该去哪里找到某个特定类的定义信息（就是<code>.class</code>文件）呢？<br>&emsp;&emsp;为了避免这种情况的发生，一种合乎逻辑的做法就是将特定包内的所有<code>.class</code>文件都置于一个目录下，也就是说，利用操作系统的层次化的文件结构来解决这个问题<br>&emsp;&emsp;将所有文件收入一个子目录还可以解决另外两个问题：创建独一无二的名称已经怎么查找有可能隐藏于目录结构中的某处的类<br>第一个问题是，通过域名反写的形式创建独一无二的类<br>第二个问题是：把package名称分解为你机器上的一个目录，所以java程序运行并需要加载<code>.class</code>文件的时候，它就可以确定<code>.class</code>文件在目录上所处的目录<br>&emsp;&emsp;java解释器的运行过程如下：首先，找到环境变量CLASSPATH，CLASSPATH包含一个或多个目录，用作查找<code>.class</code>文件的根目录，从根目录开始，解释器将包名解析成目录，得到的目录与CLASSPATH中的各个不同的项相连接，解释器就在这些目录下查找与你所要创建的类名称相关的<code>.class</code>文件，所要我们要想使用某个类库，一定要在将类库放在CLASSPATH变量中指定的目录的任意一个，或者也可以将类库的当前目录添加到CLASSPATH变量中，JAR文件有些许变化，必须要在类路径中将JAR文件的实际名称写清楚，而不仅仅只是指出它所在的目录  </p><h2 id="java访问权限修饰符"><a href="#java访问权限修饰符" class="headerlink" title="java访问权限修饰符"></a>java访问权限修饰符</h2><table><thead><tr><th>权限修饰词</th><th>权限说明</th></tr></thead><tbody><tr><td>public</td><td>允许任意的类对其修饰的成员访问</td></tr><tr><td>private</td><td>只有包含该成员的类才能对其访问</td></tr><tr><td>protected</td><td>只有派生类和同包的类才能对其进行访问</td></tr><tr><td>默认包访问权限</td><td>只有同一个类库下的类才能对其访问  </td></tr></tbody></table><p>&emsp;&emsp;我想对访问权限多说一些，对于初学者对访问权限并不是很清楚，即使是工作多年的java工程师对访问权限控制也没有很清晰的认识，即使认知如此，好像也不太影响完成项目的任务，可是我还是想把这些事情讲清楚说明白些<br>&emsp;&emsp;我们都知道java是门面向对象的语言，以面向对象的思维编程很符合人类的思维习惯，可是我们应该清楚的是，java之所以有面向对象的特性,要感谢编译器，我们之前描述方法的执行往往是说发送消息给对象，这是面向对象的说法，真正的过程应该是对这个对象的数据执行方法定义的程序，具有过程，比较复杂，这里牵扯到cpu和内存，指令之间的关系，不过我们只需要知道对对象数据进行操作就足够理解权限控制的含义了，由此我们也知道，同一个类型的所有对象的方法代码只有一份，放在方法区，每个对象都有自己独有的数据放在堆中，方法代码和数据分离，理解下面四个问题，就能明白访问权限控制的全部含义</p><ol><li>什么是“权限”？ </li><li>权限是限制谁的？   </li><li>权限可以修饰哪些元素？</li><li>访问权限修饰符是给谁用的<br>&emsp;&emsp;“权限”中文的含义很简单，就是权力的限制，直接讲就是可以做什么<br>&emsp;&emsp;权限是限制其他类的，对于被访问修饰符修饰的元素来说，其他的类对于它来讲，只有三个身份，分别是其他的类，同类库的类，派生的类，对于这三种身份，不同的权限修饰符给与他们的访问权限不同，举例来说，对于protected修饰的元素来说，其他类型的类不能对其访问，同类库和派生类可以对其访问<br>&emsp;&emsp;访问权限修饰符可以修饰哪些元素，类，域和方法<br>&emsp;&emsp;访问权限修饰符是给编译器使用的，编译过程保证了互相调用的正确性，访问权限会被编译器编译进类的字节码文件（<code>.class</code>文件）中，以供编译器编译新代码时作为权限检查的信息来使用<br>&emsp;&emsp;在讲一些小的细节吧，如果A能访问B,B能够访问C,但是A不能访问C,那么A可以“调用”C中的方法吗？答案是不可以，C中的方法能否被访问，要查看调用它的类对于它的权限，但是A却可以通过B来调用C,我喜欢称为委托，也就是说方法的调用是两个类之间的事情，有点绕，但是很有意思<h2 id="接口和实现"><a href="#接口和实现" class="headerlink" title="接口和实现"></a>接口和实现</h2>&emsp;&emsp;访问权限的控制常被称为具体实现的隐藏，把数据和方法包装进类中，以及具体实现的隐藏，常共同被称作时封装，其结果是一个同时用于特征和行为的数据类型<br>&emsp;&emsp;出于两个很重要的原因，访问权限控制的边界划在了数据类型的内部，第一个原因时要设定客户端程序员可以使用和不可以使用的界限，这个原因直接引出了第二个原因，实现接口和实现的分离  <h2 id="类的访问权限"><a href="#类的访问权限" class="headerlink" title="类的访问权限"></a>类的访问权限</h2>&emsp;&emsp;在java中，权限控制符也可以用于确定库中的哪些类对于库的使用者是可用的，如果希望某个客户端程序员能够使用这个类，就使用public来定义这个类，这样做甚至可以控制客户端程序员能否创建一个该类的对象<br>&emsp;&emsp;这里有一些限制  </li><li>每个编译单元（<code>.java</code>文件）都只能有一个public类，这表示，每个编译单元只能有一个公共接口  </li><li>public类必须完全与含有编译单元的文件名相匹配  </li><li>虽然不是很常用，但编译单元内完全不带public类也是可能的，在这种情况下，可以随意对文件命名，但是不建议<br>&emsp;&emsp;还有需要注意的是：类的定义一定不能是private或者protected的，只能是public或者不加任何修饰符的包访问权限</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;访问控制（或隐藏具体实现）与“最初的实现并不恰当”有关  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;几乎所有的代
      
    
    </summary>
    
      <category term="学习心得" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>初始化与清理</title>
    <link href="http://yoursite.com/2018/10/05/%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/"/>
    <id>http://yoursite.com/2018/10/05/初始化与清理/</id>
    <published>2018-10-05T15:57:28.000Z</published>
    <updated>2018-10-10T08:58:46.853Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>随着计算机革命的发展，“不安全”的编程方式已逐渐成为编程代价高昂的主要原因<br>&emsp;&emsp;初始化和清理（cleanup）正是涉及安全的两个问题，许多C程序的错误都源于程序员忘了初始化变量，特别是在使用程序时，如果用户不知道如何初始化库的构件（或者是用户必须要初始化的其他东西）更是如此，清理也是一个特殊问题，当使用一个元素时，它对你不会有什么影响了，所有很容易把它忘掉，这样一来，这个元素占用的资源得不到释放  </p></blockquote><h2 id="用构造器确保初始化"><a href="#用构造器确保初始化" class="headerlink" title="用构造器确保初始化"></a>用构造器确保初始化</h2><p>&emsp;&emsp;假想为每个类都定义一个初始化方法，命名为<code>intialize()</code>好了，所以你在向对象发送消息之前，为了确保对象被恰当地初始化了，你应该先主动去调用这个<code>initialize()</code>方法，可是如果你忘了怎么办呢？如果我们咋创建对象的时候能够自动进行对象的初始化工作就好了，这样就确保了我们创建的对象一定被正确地初始化了<br>&emsp;&emsp;接下来的问题是如何命名这个初始化方法，有两个问题  </p><ol><li>所取的任何名字都可能会与方法名冲突</li><li>调用构造器是编译器的责任，编译器应该要调用这一个方法<br>我们的解决的方法很简单，构造器的名称和类名相同，这是一种约定，即解决了和方法名字的冲突问题，又解决了编译器识别的问题，构建哪个类的对象就调用那个类的与方法名相同的构造函数  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Rock();</span><br></pre></td></tr></table></figure>&emsp;&emsp;上述创建对象的过程可以被拆解成两步，第一步，为对象分配内存空间，第二步，调用相对应的构造函数，理论上讲，“初始化”和“创建”是彼此独立的，然而在java代码中你找不到两者之间的界限，也看不到对构造的显式调用，java将“初始化”和“创建”捆绑在了一起，两者不能分离<br>&emsp;&emsp;构造函数是一种特殊的函数，说特殊，是因为它在对象创建的过程中就被自动调用了，而且只能被调用一次，且构造函数的代码中没有返回值，这与void不同，其实构造函数被调用之后会返回新对象的一个引用，只是我们在构造函数中不写返回类型，这是一种规定，你只需遵守就行了<h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2>&emsp;&emsp;大多数程序设计语言要求为每个方法（在有些语言中经常成为函数）都提供一个独一无二的标识符，在java（和C++）里，构造器是强制重载方法名的一个很重要的一个原因，既然构造器的方法名由类名决定，那就只能有一个构造器，可是如果我想以多种方式来创建一个对象时该怎么办呢？为了让方法名相同而参数不同的构造器同时存在，必须要用到方法的重载  <h3 id="区分方法重载"><a href="#区分方法重载" class="headerlink" title="区分方法重载"></a>区分方法重载</h3>要是有几个方法都要相同的方法，java如何知道你指的是哪个方法呢？其实规则很简单，每个重载的方法都必须要有一个独一无二的参数类型列表，注意返回值类型不作为方法重载的依据，因为如果我们只是利用方法的副作用而不使用方法的返回值的话，编译器还是没办法判断应该调用哪一个方法例如<br> void say(){};<br> String say(){};<br> a.say();<br>&emsp;&emsp;这样你能判断a调用的是哪个方法吗？不能，所有为了避免java的困扰，返回值类型不能作为方法重载的依据<h3 id="涉及基本类型的重载"><a href="#涉及基本类型的重载" class="headerlink" title="涉及基本类型的重载"></a>涉及基本类型的重载</h3>&emsp;&emsp;基本类型的重载是，先找那些方法的参数类型最符合自己类型的方法，如果找不到以此向上提升，注意，有一个特殊，如基本类型为char，先找参数类型为char的方法，若找不到，则直接提升到int类型<h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2>&emsp;&emsp;我觉得《Thinking in java》的作者Bruce Eckel对方法调用解释的很清楚，我们看下他是如何解释代码调用的：<br>&emsp;&emsp;如果有同一个类型的两个对象a,b，如何让才能这两个对象都能调用peel()方法呢？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Banana&#123; void peel(int i)&#123;/* */&#125;&#125;</span><br><span class="line">public class BananaPeel&#123;</span><br><span class="line">   public static void main(String[] args)&#123;</span><br><span class="line">   Banana a=new Banana(),b=new Banana();</span><br><span class="line">   a.peel(1);</span><br><span class="line">   b.peel(2); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>&emsp;&emsp;如果只有一个peel()方法，它如何知道是被a还是被b调用呢？<br>&emsp;&emsp;为了能用简单，面向对象的语法编写代码——即“发送消息给对象”，编译器做了一些某后工作，它暗自把“操作对象的引用”作为第一个参数传递给peel()，所以上述两个方法的调用就变成了这样：<br>    Banana.peel(a,1);<br>    Banana.peel(b,2);<br>&emsp;&emsp;这是内部表示，我们并不能这样写代码，上面这行的意思时，执行Banana类中定义的<code>peel()</code>方法，方法的参数是a,1,这才是代码底层做的事情，不过为了满足我们面向对象的思维，我们使用<code>a.peel()</code>这种形式，而其他的事情，编译器帮我们摆平<br>&emsp;&emsp;如何在方法内部获得对当前对象的引用？由于这个引用是编译器“偷偷”地帮我们加的，所以没有标识符可用，但是为此有一个专门的关键字this,this关键字只能在方法内部使用，表示“调用方法的那个对象”<br>&emsp;&emsp;this关键字的用法：</p><ol><li>可以将当前对象传递给其他方法使用</li><li>在构造器调用构造器时使用<h3 id="static的含义"><a href="#static的含义" class="headerlink" title="static的含义"></a>static的含义</h3>&emsp;&emsp;了解this关键字之后，就能全面理解static(静态)方法的含义了，static方法就是没有this的方法，在static方法的内部不能调用非静态方法，因为那些非静态类的方法都需要this类型的参数，而static方法并不能提供给它们，反过来，非静态类的方法是可以调用静态方法的<br>&emsp;&emsp;有些人认为static方法不是“面向对象的”，因为它的确具有全局函数的语义，使用static方法时，由于不存在this，所有不是通过“向对象发送消息”的方式执行的，这种说法还是有些道理的，所有，如果你的代码中存在大量的static方法，就该重新考虑自己的程序了  <h2 id="清理：终结处理和垃圾回收"><a href="#清理：终结处理和垃圾回收" class="headerlink" title="清理：终结处理和垃圾回收"></a>清理：终结处理和垃圾回收</h2><h2 id="成员初始化"><a href="#成员初始化" class="headerlink" title="成员初始化"></a>成员初始化</h2>&emsp;&emsp;java尽力保证，所有的变量在使用之前都能得到适当的初始化，对于方法的局部变量，java以编译时错误的形式来贯彻这项保证·<h2 id="构造器初始化"><a href="#构造器初始化" class="headerlink" title="构造器初始化"></a>构造器初始化</h2>&emsp;&emsp;可以用构造器来初始化，在运行时刻，可以调用方法或执行某些动作来确认该值，这为编程带来了更大的灵活性，但是要记住，无法阻止自动初始化的进行，它将在构造器被调用之前发生<h3 id="初始化的顺序"><a href="#初始化的顺序" class="headerlink" title="初始化的顺序"></a>初始化的顺序</h3>&emsp;&emsp;在类的内部，变量定义的顺序决定了初始化的顺序，即使变量定义散布于方法定义之间，它们仍然会在任何方法（包括构造器）之前得到初始化<h3 id="静态数据的初始化"><a href="#静态数据的初始化" class="headerlink" title="静态数据的初始化"></a>静态数据的初始化</h3>无论创建多少个对象，静态数据都只占一份存储区域，static关键字不能应用于局部变量，因此它只能作用于域，如果一个域时静态的基本类型域，且也没有对它进行初始化，那么它就会获得基本类型的标准初值，如果它是一个对象，那么它的默认值就是null<br>&emsp;&emsp;静态初始化只有在必要的时刻才会进行，什么是必要时刻？就是一切触发包含静态成员类的加载的行为都是必要时刻<br>&emsp;&emsp;初始化的顺序是先静态变量（如果它们尚未因前面的对象创建过程而被初始化的话，记住静态初始化只会进行一次，那就是在类第一次被加载的时刻）<br>，而后时非静态变量<br>&emsp;&emsp;总结一下对象的创建过程，假设一个Dog类  </li><li>即使没有显式地使用static关键字，构造器实际上也是静态方法，因此，当首次创建Dog对象时（构造器可以看成静态方法），或者Dog类的静态方法被调用时，解释器必须查找类路径，以定位Dog.class文件</li><li>然后载入Dog.class,创建一个Class对象，有关静态初始化的所有动作都会被执行，因此，静态初始化只在Class对象首次加载的时候进行一次</li><li>当用new Dog()创建对象的时候，首先将在堆上为Dog对象分配足够的内存空间</li><li>这块存储空间会被清零，这就自动地将Dog对象中的所有类型数据都设成默认值</li><li>执行所有出现在字段定义初的初始化</li><li>执行构造器  <h3 id="显示的静态初始化"><a href="#显示的静态初始化" class="headerlink" title="显示的静态初始化"></a>显示的静态初始化</h3>&emsp;&emsp;java允许将多个静态初始化动作组织成一个特殊的“静态子句”，有时也叫做静态块，静态块先其他的静态成员一样，也是在类被首次加载的时候被执行一次  <h3 id="非静态实例初始化"><a href="#非静态实例初始化" class="headerlink" title="非静态实例初始化"></a>非静态实例初始化</h3>&emsp;&emsp;非静态实例初始化很像静态块，只是在代码块前面没有static关键字，这种语法对于支持“匿名内部类”的初始化时必须的，但是它也可以使你保证无论使用那个构造器，某些操作都会发生，而且是在构造器执行之前执行  <h2 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h2>&emsp;&emsp;数组只是相同类型的，用一个标识符名称封装到一起的一个对象序列或基本类型数据序列，记住，数组也是对象，在java中除了基本类型 一起皆对象，数据可以通过方括号下标操作符<code>[]</code>来定义和使用，要定义一个数组，只需要在类型名后面加上一对中括号即可<br> int[] a;<br> int a[];<br>&emsp;&emsp;两种格式都一样，我更喜欢第一种方式，上述两种方式都只是让我们拥有一个引用，并且指出了这个引用所代表的数据类型，随便说一句，java是强类型语言，标识符前面的类型往往是为了类型检查的需要<br>&emsp;&emsp;数组类型主要分为两种，一种是基本数据类型数值，一种时引用类型数值，基本数据类型数组内部持有着基本数据类型的值，而引用类型数值元素是引用，如图：</li></ol><p>&emsp;&emsp;所有数组（无论它们的元素时对象还是引用）都有一个固定成员，可以通过它获知数组内包含了多少元素，但不能对其修改，这个成员就是length,数值索引从0开始</p><h3 id="可变参数列表"><a href="#可变参数列表" class="headerlink" title="可变参数列表"></a>可变参数列表</h3><pre><code>void variableList(String... args);</code></pre><p>&emsp;&emsp;上述语法就是从在java SE5新添加的可变参数列表的特性，有了可变参数，就不用显式地编写数组语法了<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">argsList</span><span class="params">(String[] args)</span></span>;</span><br></pre></td></tr></table></figure>，当你指定参数时，编译器实际上会为你去填充数组，你获取的仍旧是一个数组</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;随着计算机革命的发展，“不安全”的编程方式已逐渐成为编程代价高昂的主要原因&lt;br&gt;&amp;emsp;&amp;emsp;初始化和
      
    
    </summary>
    
      <category term="学习心得" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>操作符</title>
    <link href="http://yoursite.com/2018/10/05/%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <id>http://yoursite.com/2018/10/05/操作符/</id>
    <published>2018-10-05T12:24:07.000Z</published>
    <updated>2018-10-05T12:24:07.477Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="学习心得" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>一切都是对象</title>
    <link href="http://yoursite.com/2018/10/05/%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2018/10/05/一切都是对象/</id>
    <published>2018-10-05T02:40:48.000Z</published>
    <updated>2018-10-05T12:23:03.648Z</updated>
    
    <content type="html"><![CDATA[<h2 id="用引用操作对象"><a href="#用引用操作对象" class="headerlink" title="用引用操作对象"></a>用引用操作对象</h2><p>&emsp;&emsp;每种语言都有自己的操作内存元素的方式，有时候，程序员必须注意将要处理的数据类型是什么。你是直接操作元素，还是用某种基于特殊语法的间间接表示（例如C和C++里的指针）来操作对象<br>&emsp;&emsp;所有的一切在java这里得到了简化，一切都被视为对象，因此可采用单一固定的语法，尽管一切都看作对象，但操作的标识符实际上是对象的一个“引用”（reference）。</p><h2 id="必须由你创建所有对象"><a href="#必须由你创建所有对象" class="headerlink" title="必须由你创建所有对象"></a>必须由你创建所有对象</h2><h3 id="存储到什么地方"><a href="#存储到什么地方" class="headerlink" title="存储到什么地方"></a>存储到什么地方</h3><p>程序运行的时候，对象是怎么进行放置安排的呢？特别是内存时怎样分配的呢？有五个不同的地方可以存储数据  </p><ol><li>寄存器。这是最快的存储区，因为它位于不同于其他存储区的地方——处理器内部，但是寄存器的数量有限，所以寄存器根据需求进行分配，你不能直接控制，也不能在程序中感觉到寄存器存在的任何迹象（一方面，C和C++允许你向编译器建议寄存器的分配方式）  </li><li>堆栈：位于通用RAM(随机访问存储器)中，但通过堆栈指针可以从处理器那里获得直接支持，堆栈指针若向下移动，则分配新的内存，若向上移动，则释放那些内存，这是一种快速有效的分配存储方法，创建程序时，Java系统必须知道存储在堆栈内所有的确切生命周期，以便上下移动堆栈指针，这一约束限制了程序的灵活性，所以虽然某些java数据存储在堆栈中——特别是对象引用，但是java对象并不存储于其中  </li><li>堆，一种通用的内存池（也位于RAM区），用于存放所有的java对象，堆不同于堆栈的好处是：编译器不需要知道存储的数据在堆中存活多少时间，因此，在堆中分配有很大的灵活性  </li><li>常量存储：常量值通常直接存放在程序代码内部，这样做是安全的，因为它们永远不会被改变，有时，在嵌入式系统中，常量本身和其他部分分割离开，所以在这种情况下，可以选择将其存放在ROM（只读存储器）中  </li><li>非RAM存储。如果数据完全存活于程序之外，那么它可以不受程序的任何控制，在程序没有运行时也可以存在，其中两个基本的例子时流对象和持久化对象  </li></ol><h3 id="特例：基本类型"><a href="#特例：基本类型" class="headerlink" title="特例：基本类型"></a>特例：基本类型</h3><p>&emsp;&emsp;在程序设计中经常用到一系列类型，它们需要特殊对待，可以把它们想象成“基本”类型<br>之所以特殊对待，是因为new将对象存储在“堆”里，故用new创建一个对象——特别是小的，简单的变量，往往不是很有效，因此，对于这些类型，java采取与C和C++相同的方法，也就是说，不用new来创建对象，而是创建一个并非是引用的“自动”变量，这个变量直接存储“值”，并置于堆栈中，因此更加高效<br>&emsp;&emsp;java要确定每种基本类型所占存储空间的大小，它们的大小并不像其他大多数语言那样随机器架构的变化而变化，所以java所编写的程序比其他语言更具有可移植性  </p><h3 id="高精度数字"><a href="#高精度数字" class="headerlink" title="高精度数字"></a>高精度数字</h3><p>&emsp;&emsp;java提供了两个用于高精度计算的类：BigInteger和BigDecimal,可以将它们看成是包装器类，但是它们并没有相应的基本类型，它们都支持任意精度的数字，其实很好理解，因为它们的数据类型使得它们可以接受更多的位来表示数值  </p><h3 id="java中的数组"><a href="#java中的数组" class="headerlink" title="java中的数组"></a>java中的数组</h3><p>&emsp;&emsp;几乎所有的程序设计语言都支持数组，在C和C++中使用数组时危险的，因为它们的数组就是内存块，如果一个程序要访问其自身内存块之外的数组，或在数组初始化前使用内存，将产生难以预料的后果<br>&emsp;&emsp;java的一个主要目标之一就是安全性，java确保数组会被初始化，而且不能在它的范围外被访问，这种范围检查，是以每个数组上少量的内存开销及运行时的范围检查为代价的，但由此换来的是安全性和效率的提高  </p><h2 id="永远不需要销毁对象"><a href="#永远不需要销毁对象" class="headerlink" title="永远不需要销毁对象"></a>永远不需要销毁对象</h2><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>&emsp;&emsp;大多数过程型语言都有作用域(scope)的概念,作用域决定了在其内定义的变量名的可见性和生命周期</p><h3 id="对象的作用域"><a href="#对象的作用域" class="headerlink" title="对象的作用域"></a>对象的作用域</h3><p>&emsp;&emsp;java对象不具备和基本数据类型一样的生命周期，当new创建一个java对象时，它可以存活于作用域之外<br>&emsp;&emsp;如果java让对象一直存在，那么靠什么才能防止这些对象填满内存空间，进而阻塞你的程序呢？这正是C++里可能会发生的问题，这也是java的神奇之处，java有一个垃圾回收器，用来监视用new创建的所有对象，并辨别那些不会再被引用的对象。随后，释放这些对象的内存空间，以便供其他新的对象使用</p><h2 id="创建新的数据类型：类"><a href="#创建新的数据类型：类" class="headerlink" title="创建新的数据类型：类"></a>创建新的数据类型：类</h2><p>&emsp;&emsp;如果一切都是对象，那么是什么决定了某一类对象的外观和行为呢？换句话说，是什么确定了对象的类型</p><h3 id="字段和方法"><a href="#字段和方法" class="headerlink" title="字段和方法"></a>字段和方法</h3><p>&emsp;&emsp;一旦定义了一个类（在java中你所做的全部工作就是定义类，产生那些类的对象，以及发送消息给这些对象）就可以在类中设置两种类型的元素，字段（有时称做数据成员）和方法（有时称作函数成员）  </p><h3 id="基本成员默认值"><a href="#基本成员默认值" class="headerlink" title="基本成员默认值"></a>基本成员默认值</h3><p><table><tr><th>基本类型</th><th>默认值</th></tr><tr><td>boolean</td><td>fasle</td></tr><tr><td>char</td><td>‘\u0000’(null)</td></tr><tr><td>byte</td><td>(byte)0</td></tr><tr><td>short</td><td>(short)0</td></tr><tr><td>int</td><td>0</td></tr><tr><td>long</td><td>0L</td></tr><tr><td>float</td><td>0.0f</td></tr><tr><td>double</td><td>0.0d</td></tr></table></p><h2 id="方法，参数和返回值"><a href="#方法，参数和返回值" class="headerlink" title="方法，参数和返回值"></a>方法，参数和返回值</h2><p>&emsp;&emsp;返回类型描述的是在调用方法之后从方法返回的值，参数列表给出了要传递个方法的信息的类型和名称，方法名和参数列表（它们合起来被称为“方法签名”），唯一地标识出某个方法</p><h2 id="java程序"><a href="#java程序" class="headerlink" title="java程序"></a>java程序</h2><h3 id="名字的可见性"><a href="#名字的可见性" class="headerlink" title="名字的可见性"></a>名字的可见性</h3><p>&emsp;&emsp;名字管理对任何程序设计语言都是一个重要的问题，如果在程序的某个模块里使用了一个名字，而其他人在这个程序的另一个模块里也使用了相同的名字，那么怎么区分这两个名字并防止二者互相冲突<br>&emsp;&emsp;java采用了一种全新的方法来避免上述的问题。为了给每一个类库生成不会与其他名字混淆的名字，java设计者希望程序员反过来使用自己的internet域名</p><h3 id="运用其他构件"><a href="#运用其他构件" class="headerlink" title="运用其他构件"></a>运用其他构件</h3><p>&emsp;&emsp;如果想在自己的程序使用预先定义好的类，那么编译器就必须知道怎么定位它们，当然这个类可能就在发生调用的那个<strong>源文件</strong>中，在这种情况下，就可以直接使用这个类<br>&emsp;&emsp;如果那个类位于其他文件中呢？又会怎样？编译器没有那么聪明知道你要使用的类应该在哪里查找，所以你要明确地告诉编译器你想要的类是什么，import指示编译器导入一个包，也就是一个类库</p><h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><p>&emsp;&emsp;通常来说，当创建类时，就是在描述那个类的对象的外观和行为，除非用new创建那个类的对象，否则，实际上并未获得任何对象，执行new来创建对象时，数据存储空间才被分配，其方法才供外部调用<br>&emsp;&emsp;有两种情况是上述方法无法解决的  </p><ol><li>只想为某特定域分配单一存储空间，而不去考虑究竟要创建多少对象吗，甚至根本就不创建对象</li><li>希望某个方法不与包含它的类的任何对象关联在一起，也就是说，寄生不创建对象，也能调用这个方法<br>&emsp;&emsp;通过static关键字可以满足这两方面的要求，有些面向对象的语言采用类数据和类方法两个术语，代表那些数据和方法是作为整个类，而不是类的某个特定对象而存在的<br>&emsp;&emsp;尽管当static作用在某个字段时，肯定会改变数据创建的方式（因为一个static字段对每一个类来说都只是一份存储空间，而非static字段则是每个对象有一个存储空间），但是如果static作用于方法上，差别就没有那么大   <h3 id="编译和运行"><a href="#编译和运行" class="headerlink" title="编译和运行"></a>编译和运行</h3>&emsp;&emsp;要编译，运行一个程序，首先必须要有一个java开发环境，目前，有相当多的第三方厂商提供开发环境，我们当前使用的是SUN免费提供的JDK（java Developer’s Kit）开发环境为例<br>&emsp;&emsp;安装好JDK之后，还要设定好路径信息，以确保计算机能够找到javac和java这两个文件  </li></ol><h2 id="注释和嵌入式文档"><a href="#注释和嵌入式文档" class="headerlink" title="注释和嵌入式文档"></a>注释和嵌入式文档</h2><p>先来看一下注释，在java中有三种方式的注释  </p><ol><li>单行注释 //</li><li>多行注释 /**/</li><li>文档注释 /<strong>  </strong>/   <h3 id="注释文档"><a href="#注释文档" class="headerlink" title="注释文档"></a>注释文档</h3>&emsp;&emsp;文档撰写的最大问题，大概就是对文档的维护了，如果文档与代码是分离的，修改代码时，同时也要修改相应的文档，相当的麻烦啊，解决办法很简单，就是将代码和文档“链接”起来，为了达到这个目的，最简单的方法就是将所有的东西都放在同一个文件内，为了实现这个目的，就必须使用一种特使的注释语法来标记文档，此外还需要一个能够提取文档信息的工具<br>&emsp;&emsp;javadoc就是这样的一个工具，它是jdk安装的一部分，它采用了java编译器的某些技术，查找程序内特殊注释标签，它不仅解析由这些标签标记的信息，也将毗邻的类名或方法名提取出来，因此，我们可以用最少的工作量，生成相当好的程序文档，生成的文档是HTML格式<br>&emsp;&emsp;需要注意的是，能够生成文档的工具不止javadoc，使用时应该要遵守对应工具的语法规则，不过，如果没有什么特别的需求，javadoc已经很好了<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3>使用javadoc的方式有两种   </li></ol><ol><li>一种是HTML,可在文档注释中直接写HTML，并没有什么特殊的，只是要注意不要在嵌入式HTML重使用标题标签，因为javadoc会插入自己的标题，而你的标题可能会同它们冲突  </li><li>一种是使用注释标签下面是这些标签的一些示例</li></ol><table><thead><tr><th>标签</th><th>语法</th><th>描述</th></tr></thead><tbody><tr><td>@see</td><td>@see classname<br>@see classname<br>@see fully-qualfied-classname#method-nam</td><td>会在生成的文档中添加一个具有超链接的“see also”</td></tr><tr><td>{@link package.class#member label}</td><td></td><td>该标签与@see及其类似，只是它用于行内，并且文档使用“label”作为超链接文本而不是“see also”</td></tr><tr><td>{@docRoot}</td><td></td><td>该标签产生到文档根目录的相对路径，用于文档树页面的显式超链接</td></tr><tr><td>{@inheritDoc}</td><td></td><td>该标签从当前这个类的最直接的基类中继承相关文档到当前的文档注释</td></tr><tr><td>@version</td><td>@version version-information</td><td>版本信息</td></tr><tr><td>@author</td><td>@author author-information</td><td>作者信息</td></tr><tr><td>@since</td><td></td><td>允许你指定程序代码最早使用的版本，可以在HTML,java文档中看到它被用来指定所用的JDK版本的情况</td></tr><tr><td>@param</td><td>@param param-name discripton</td><td>可以多次使用这个标签，大约每个参数都有一个这样的标签</td></tr><tr><td>@return</td><td>return description</td><td>用来描述返回值的含义</td></tr><tr><td>@throws</td><td>@throws fully-qualified-class-name descripton</td><td>可以多次使用，异常的全限定名和引发异常的原因</td></tr><tr><td>@deprecated</td><td></td><td>该标签用于指出一些旧特性已由改进的新特性所取代，建议用户不要再使用这些旧特性</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;用引用操作对象&quot;&gt;&lt;a href=&quot;#用引用操作对象&quot; class=&quot;headerlink&quot; title=&quot;用引用操作对象&quot;&gt;&lt;/a&gt;用引用操作对象&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;每种语言都有自己的操作内存元素的方式，有时候，程序员必须注意将要处理的数据类
      
    
    </summary>
    
      <category term="学习心得" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>对象导论</title>
    <link href="http://yoursite.com/2018/10/04/%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%AE%BA/"/>
    <id>http://yoursite.com/2018/10/04/对象导论/</id>
    <published>2018-10-04T14:19:11.000Z</published>
    <updated>2018-10-04T20:15:43.428Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-1抽象过程"><a href="#1-1抽象过程" class="headerlink" title="1.1抽象过程"></a>1.1抽象过程</h2><p>&emsp;&emsp;所有的编程语言都提供抽象机制，汇编语言是对底层机器的轻微抽象，接着出现的所谓“命令式”语言（如FORTRAN,BASIC，C等）都是对汇编语言的抽象，这些语言在汇编语言的基础上有很大的改进，但是它们所做的主要抽象都是基于计算机的结果，而不是基于所要解决的问题的结构来考虑，程序员必须要建立起在机器模型（位于解空间内，这是你对问题建模的地方。例如计算机）和实际待解问题的模型（位于“解空间”内，这是问题存在的地方，例如一项业务）之间的关联，建立这种映射是费时的，而且这不属于编程语言固有的功能，这使得程序难以编写，并且维护代价高，业务逻辑可读性不强<br>&emsp;&emsp;面向对象允许根据问题来描述问题，而不是根据运行解决方案的计算机来描述问题<br>但它仍然与计算机有联系，每个对象看起来就像一台微型计算机——它具有状态，还具有操作，用户可以要求对象执行这些操作，如果要对现实世界中的对象作类比，那么说它们都具有特性和行为似乎不错</p><p>Alan Kay总结一个面向对象编程语言应该具有的5个特性  </p><ol><li>万物皆为对象。将对象视为奇特的变量，它可以存储数据，除此之外，你还可以要求它在自身上执行操作，理论上讲，你可以抽取待解空间的任何概念化构件（狗，建筑物，服务等），使其表示为程序中的对象  </li><li>程序是对象的集合，它们之间通过发送消息来告知彼此所要做的事情  </li><li>每个对象都有自己的由其他对象所构成的存储  </li><li>每个对象都拥有其类型。  </li><li>某一特定类型的所有对象都可以接收同样的消息</li></ol><p>Booch对对象提出了一个更加简洁的描述：对象具有状态（内部数据），行为（方法）和标识（每个对象都可以唯一地与其他对象区分开来，具体来说，就是每个对象在内存中都具有一个唯一的地址）</p><h2 id="每个对象都有一个接口"><a href="#每个对象都有一个接口" class="headerlink" title="每个对象都有一个接口"></a>每个对象都有一个接口</h2><p>&emsp;&emsp;所有的对象都是唯一的，但同时也是具有相同的特性和行为的对象所归属的一部分。<br>&emsp;&emsp;创建抽象数据类型（类）是面向对象程序设计的基本概念之一，抽象数据类型的运行方式与内置（built-in）类型几乎完全一致：你可以创建某一类型的变量（按照面向对象的说法，称其为对象或者实例），然后操作这些变量（称其为发送消息或请求）对象就知道要做什么。<br>每个对象都属于定义了特性和行为的某一特定的类<br>&emsp;&emsp;因为类描述了具有相同特性（数据元素）和行为（功能）的对象的集合，所以一个类实际上就是一个数据类型，例如所有浮点型数字具有相同的特性和行为集合。二者之间的差异在于，程序员通过定义类来适应问题，而不再被迫只能使用现有的用来表示机器的存储单元上的数据类型，可以根据需求，通过添加新的数据类型来扩展编程语言。<br>&emsp;&emsp;一旦类被建立，就可以随心所欲地创建类的任意的对象，然后去操作它们，就像它们是存在于你的待解空间中的元素一样，事实上，面向对象程序设计的挑战之一，就是问题空间的元素和解空间的对象之间创建一对一的映射。<br>&emsp;&emsp;但是怎样才能获得一个有用的对象呢？必须有某种方式产生对对象的请求，使对象完成各种任务。<strong>每个对象都只能满足某些请求，这些请求由对象的接口（interface）,决定接口的便是类型</strong>。<br>&emsp;&emsp;<strong>接口确定了对某一特定对象所能发出的请求</strong>，但是，在程序中必须有满足这些请求的代码，这些代码与<strong>隐藏的数据</strong>一起构成了实现，当向对象发送请求的过程通常被概括为：向某个对象吧“发送消息”（产生请求），这个对象便知道此消息的目的，然后执行相应的代码  </p><h2 id="每个对象都提供服务"><a href="#每个对象都提供服务" class="headerlink" title="每个对象都提供服务"></a>每个对象都提供服务</h2><p>&emsp;&emsp;当试图开发或试图理解一个程序设计时，更好的方法之一就是将<strong>对象想象为“服务的提供者</strong>”，程序本身将向用户提供服务，它将通过调用其他对象提供的服务来实现这一目的，你的目标就是去创建（或者最好是在现有的代码库中寻找）能够提供理想的服务来解决问题的一系列对象<br>&emsp;&emsp;将对象看作服务提供者还有一个附加的好处，<strong>它有助于提高对象的内聚性</strong>，内聚性是软件设计的基本质量之一，在良好的面向对象设计中，每个对象都可以很好地完成一项任务，但是它并不试图做更多的事情<br>&emsp;&emsp;将对象作为服务提供者看待是一种伟大的简化工具，这不仅在设计过程中有用，而且对于其他人试图理解你的代码或重用某个对象也是有帮助的。  </p><h2 id="被隐藏的具体实现"><a href="#被隐藏的具体实现" class="headerlink" title="被隐藏的具体实现"></a>被隐藏的具体实现</h2><p>&emsp;&emsp;将程序开发人员按照角色分为类创建者（那些创建新数据类型的程序员）和客户端程序员（那些在其应用中使用数据类型的类消费着）是大有裨益的<br>&emsp;&emsp;客户端程序员的目标是收集各种用来实现快速开放的类<br>&emsp;&emsp;类创建者的目标是构建类，这种类只向客户端程序员暴露必须的部分，而隐藏其他部分<br>&emsp;&emsp;为什么要对部分实现加以隐藏呢？因为被隐藏的部分通常代表对象内部脆弱的部分，它们很容易被粗心的或是不知情的客户端程序员所毁坏，所以隐藏起来可以减少bug，这也意味着类创建着可以对这些隐藏的部分进行修改，而不用担心对其他任何人造成影响<br>&emsp;&emsp;在相互关系中，具有关系所涉及的各方都遵守的边界是非常重要的事情，当创建一个类库时，就建立了与客户端程序员之间的关系，如果所有类成员都任何人都是可用的，那么客户端程序员就可以对类做任何事情，而不受任何约束，即使你希望客户端程序员不要去直接操作你的类中的某些成员，但是如果没有任何访问控制，将无法阻止此事发生，所有东西都将赤裸裸地暴露于世人面前。<br>&emsp;&emsp;因此控制访问的第一个存在的原因就是让客户端程序员无法触及它们不应该触及的部分——这些部分对数据类型的内部操作是必需的，但并不是用户解决特定问题所需的接口的一部分<br>&emsp;&emsp;控制访问的第二个存在的原因是运行库设计者可以改变类内部的工作方式而不担心会影响到客户端程序员，如果接口和实现可以清晰地分离并得以保护，那么你就可以轻而易举地完成这项工作<br>&emsp;&emsp;java用三个关键字在类的内部设定边界：public,private,protected,这些访问指定词(access specifier)决定了紧跟在其后被定义的元素可以被谁使用<br>java还有一种默认的访问权限，当没有使用前面提到的任何访问指定词时，它将发挥作用，这种权限通常被称为包访问权限  </p><h2 id="复用具体实现"><a href="#复用具体实现" class="headerlink" title="复用具体实现"></a>复用具体实现</h2><p>&emsp;&emsp;一旦类被创建并被测试完，那么它就应该代表一个有用的代码单元<br>&emsp;&emsp;最简单地复用某个类的方法就是直接使用类的一个对象，此外也可以将那个类的一个对象置于某个全新的类中，我们称其为“创建一个成员对象”，新的类可以由任意数量，任意类型的某个对象以任意可以实现新的类中想要的功能的方式组成，因为是使用现有的类合成新的类，所以这种概念被称为组合（compression）,如果组合是动态发生的，那么它通常被称为聚合（aggregaton）。组合经常被视为“has-a”（拥有）关系。<br>组合带来了极大的灵活性，新类的成员对象通常被声明为pravate,使得使用新类的客户端程序员不能访问它，这也使得你可以在不干扰现有客户端代码的情况下，修改这些成员，也可以在运行时修改这些成员对象，以实现动态修改程序的行为  </p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>&emsp;&emsp;在创建了一个类之后，即使另一个新类与其具有相同的功能，难道我们还要再重新创建一个新的类型吗？如果我们能够以现有的类为基础，复制它，然后通过添加或者修改这个副本来创建新类那就好了（当然，继承的底层实现并没有对基类进行复制，而是在导出类中保存了一个指向基类的引用），通过继承既可以达到这样的效果<br>&emsp;&emsp;类型不仅仅只是描述了一个对象集合上的约束条件，同时还有与其他类型之间的关系，两个类型的行为可以有相同的特性和行为，但是其中一个类型可能比另一个类型含义更多的特性，并且可以处理更多的信息（或以不同方式处理信息），继承使用基类和导出类的概念表示了这种类型之间的相似性，一个基类包含其所有导出类所共享的特性和行为，可以创建一个基类来表示系统中某些对象的核心概念<br>&emsp;&emsp;当继承现有类型时，也就创造了新的类型，这个类型不仅包括现有类型的所有成员（尽管private被隐藏起啦，并且不能访问）而且更重要的是它复制了基类的接口，也就是说，所有可以发送给基类对象的消息同时也可以发送给导出类对象<br>&emsp;&emsp;由于基类和导出类具有相同的基础接口，所有伴随此接口的必定有某些具体实行，也就是说，当对象接收到特定消息时，必须有某些代码去执行，如果只是简单地继承一个类而不去做其他事情，这意味着导出类的对象不仅与基类具有相同的类型，而且还拥有着相同的行为<br>&emsp;&emsp;有两种办法可以使基类和导出类产生差异，第一中方法非常直接，直接在导出类中添加新方法，这些方法并不是基类接口的一部分，这意味着基类不能满足你的所有需求，因此要添加更多的方法，但是，应该仔细考虑是否存在基类也需要这种方法的可能性，这种发现和迭代过程是开发当中经常会发生的<br>&emsp;&emsp;第二种也是最重要的一种导出类和基类之间产生差异的方法是改变继承至基类的方法，这被称为覆盖（overriding）有些书上也叫“改写”（我并不是很赞成这种叫法，因为我们实际上并没有去触碰基类中的接口方法，因此这种叫法比较奇怪）  </p><h3 id="“是一个”与“像一个”"><a href="#“是一个”与“像一个”" class="headerlink" title="“是一个”与“像一个”"></a>“是一个”与“像一个”</h3><p>&emsp;&emsp;对于继承可能会引发某种争论：继承应该只覆盖基类的方法（而并不添加在基类中不存在的新方法），如果这样做，就意味着导出类和基类是完全相同的类型，结果一个导出类对象可以完全替代一个基类对象因为它们具有完全相同的接口（虽然接口的实现可能不同），这种方式被称为“纯粹替代”，导出类与基类之间的关系被称为is-a(是一个)关系<br>&emsp;&emsp;有时必须在导出类中添加新的接口元素，这样也就扩展了接口，这个新的类型仍然可以替代基类，但是这种替代并不完美，因为基类无法访问新添加的方法，这种情况我们称为is-like-a(像是一个)关系  </p><h2 id="伴随多态的可互换对象"><a href="#伴随多态的可互换对象" class="headerlink" title="伴随多态的可互换对象"></a>伴随多态的可互换对象</h2><p>&emsp;&emsp;在处理类型的层次结构时，经常想把一个对象不当做它所属的特定类型来看待，而是将其当作其基类的对象来看待，这使得人们可以写出不依赖特定类型的代码<br>&emsp;&emsp;但是，在试图将导出类的对象当作其泛型化基类对象来看待时，仍然存在一个问题，如果某个方法要让泛型化的对象执行自身的接口实现时应该怎么办？编译器在编译时是不可能知道应该执行哪段代码的，这就是关键所在，虽然我们在编译代码的时候不知道也不关心我们发送给对象的消息会使得哪段代码被执行，但是对象会依据自身的具体类型来执行恰当的代码，那么这是怎么实现的呢？<br>&emsp;&emsp;一个非面向对象编程的编译器产生的函数调用会引起所谓的前期绑定，这样就意味着编译器将产生一个具体函数名字的调用，而运行时将这个调用解析到将要执行的代码的绝对地址<br>&emsp;&emsp;然而在OOP中，程序直到运行时才能够确定代码的地址，为了解决这个问题，面向对象的语言使用了后期绑定的概念，当向对象发送消息时，被调用代码直到运行才能确定，编译器确保了调用方法的存在，并对调用参数和返回值执行类型检查（无法通过此类保证的语言被称为弱类型语言，比如javascript）<br>&emsp;&emsp;为了执行后期绑定，java使用了一段特殊的代码来替代绝对地址调用（JVM的工作），这段代码使用在对象中存储的信息来计算方法体的地址（反射概念），这样，根据这一小段代码的内容，每个对象都可以具有不同的行为表现，当向一个对象发送消息时，该对象就能够知道这条消息应该做些什么（JVM通过一小段代码实行java语言后期绑定的特性，虽然相比非面向对象语言来说，牺牲了性能，可是却带来了编程上极大的灵活性和低耦合，与其相比，这段性能的牺牲是微不足道的）</p><h2 id="单根继承结构"><a href="#单根继承结构" class="headerlink" title="单根继承结构"></a>单根继承结构</h2><p>&emsp;&emsp;单根继承结构中的所有对象都具有一个公共的接口，所以它们归根到底都是相同的基本类型<br>&emsp;&emsp;单根继承结构保证了所有对象都具备某些功能，因此，在你的系统中可以对这些对象执行某些基本操作，例如垃圾回收机制，在进行垃圾回收时就是将所有的对象当作同一种类型</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>&emsp;&emsp;通常来说，如果你不知道咋解决某个问题时需要多少个对象，或者它们将存活多久，那么juice不可能知道该如何存储这些对象，如何才能知道需要多少空间来创建这些对象呢？<br>答案是你也可能不知道，因为这类信息只有在程序运行时才能够获得<br>&emsp;&emsp;大部分的面向对象语言，解决这些问题，就是创建另一种新的数据类型，这种新的对象类型持有对其他对象的引用，在java中，这通常被称为容器（也可以被称为集合）的新对象，在任何需要时都可以扩充自己以容纳于你置于其中的所有东西，因此不需要知道未来将会把多少个对象置于容器中，只需要创建一个容器对象昂，然后让它处理所有细节<br>&emsp;&emsp;java在标准类型中包含有大量的容器，从设计的观点来看，真正需要只有一个可被操作，从而解决问题的序列，如果单一类型的容器可以满足所有的需要，那么就没有理由设计不同类型的序列了，然而还是需要对象容器有所选择，这有两个原因  </p><ol><li>不同的容器提供了不同类型的接口和外部行为  </li><li>不同的容器对某些操作具有不同的效率  <h3 id="参数化类型"><a href="#参数化类型" class="headerlink" title="参数化类型"></a>参数化类型</h3>在java SE5出现之前，容器存储的对象都只具有java中的通用类型：Object,要使用这样的容器，只需在其中置入对象的引用，稍后还可以将它们取回，但是由于容器只存储Object，所以当将对象引用置入容器时，它必须被向上转型为Object，因此就丢失了身份，所以当把它取回时，就获取了一个对Object的引用，而不是对置入时那个对象的引用<br>&emsp;&emsp;怎样将它变回先前置入容器时的具有实用接口的对象呢？（其实更准确的说是将对象的引用类型转变为放置前更具体的特定类型，转型实际上分为两种，一种是对基本数据类型进行转型，这种方式的转型除了将引用类型转型之外还会对基本类型数据的底层结构进行改写，另一种是对引用对象进行转型，这种方式的转型只是对引用类型进行转型，使得对象所指向的类型发生改变，对象内部的数据并没有发生变化，向下转型时危险的，需要特别小心）<br>&emsp;&emsp;向下转型和运行需要额外的运行时间，也需要程序员付出更多的心血，如果创建这样的一个容器，它知道自己所保存对象的类型，从而不需要向下转型以及消除犯错的可能，这样不是更有意义吗？这种解决方案被称为参数化类型机制<br>&emsp;&emsp;Java SE5的重大变化之一就是增加了参数化类型，在java中它被称为泛型，一对尖括号，中间时类型信息  <h2 id="对象的创建和生命周期"><a href="#对象的创建和生命周期" class="headerlink" title="对象的创建和生命周期"></a>对象的创建和生命周期</h2>&emsp;&emsp;在使用对象时，最关键的问题之一便是对象的创建和销毁，每个对象为了生存都需要资源，尤其是内存，当我们不再需要一个对象时，它必须要被清理掉，使其占有的资源得到释放<br>&emsp;&emsp;现在的问题是 怎样创建对象？对象的数据位于何处？对象何时应该被销毁？因为当处理完某个对象之后，系统的某个部分可能还在处理它，这就是对象的生命周期<br>&emsp;&emsp;第一种方式：我们先来看看其他编程语言是如何管理对象的生命周期的，C++认为效率控制是最重要的议题，所以给了程序员选择的权利，为了追求执行速度，对象的存储空间和生命周期可以在编写程序时确定，也就是所对象的存储位置和生命周期由程序员来决定，在某些情况下这样控制是有价值的，但是，也牺牲了灵活性，而且，一旦，程序员在设计当中对对象的处理不够谨慎，内存泄漏是常发生的事情<br>&emsp;&emsp;第二方式是在被称为堆（heap）的内存区域（内存池）中动态地创建对象，在这种方式中，直到运行时才知道需要多少个对象，它的生命周期如何，以及它们的具体类型是什么，这些问题的答案只能在程序运行相关代码被执行的那一刻才确定，如果需要一个新对象，可以在需要的时刻直接在堆中创建，因为存储空间是运行时被动态的管理的，所以需要大量的时间在堆中分配存储空间（因为在堆中存放对象的数据相较于在栈中会涉及跟多的算法，比如可分配空间查找，可分配空间大小与对象数据大小比较），这可能要远大于在堆栈中创建空间的时间，在堆栈（栈）中创建和释放存储空间通常各需要一条汇编指令即可，分别对应将栈顶指针的下移和上移<br>&emsp;&emsp;java完全采用了动态内存分配方式，创建一个对象很简单，使用new关键字即可，至于对象存储在堆中的哪个位置，完全不需要考虑，JVM虚拟机会帮我们完成一切<br>&emsp;&emsp;还有个议题，就是对象的生命周期，对于允许在堆栈（栈）上创建对象的语言，编译器可以确定对象的存活时间，并可以自动销毁它，然后，如果在堆中创建的对象，编译器就会对它的生命周期一无所知，而java提供了被称为“垃圾收集器”的机制，它可以自动发现对象何时不再被使用，并继而销毁它，它减少了程序员以前必须考虑的议题和必须编写的代码，更重要的是，垃圾回收器提供了更高层次的保障，可以避免暗藏的内存泄漏的问题<h2 id="异常处理：处理错误"><a href="#异常处理：处理错误" class="headerlink" title="异常处理：处理错误"></a>异常处理：处理错误</h2>&emsp;&emsp;自从编程语言面世以来，错误处理就始终是最困难的问题之一，因为设计一个良好的错误处理机制非常困难，所以许多语言直接忽略掉了这个问题，将其交给程序设计库去处理，而这些设计库的作者提出的方法也不彻底，所以，大部分错误处理机制的主要问题在于，它们都依靠程序员的警惕性，这种警惕性来自于一种共同约定，而不是编程语言所强制的<br>&emsp;&emsp;异常处理将错误处理直接置于编程语言中，有时甚至置于操作系统中，异常是一种对象，它从错误发生的地点被“抛出”，并被专门设计用来处理特定类型错误的相应的异常处理器“捕获”，异常处理器就像是与程序正常执行路径并行的，在错误发生时执行的另一条路径，因为它是另一条完全分离的执行路径。所以它不会干扰到程序的正常运行，这往往使得代码编写变得简单，因为不需要被迫定期检测错误，此外，被抛出的异常不像方法返回的错误值和方法设置的用来表示错误条件的标志位那样可以被忽略，异常不能被忽略，所以它保证一定会在某个地方会得到处理<br>&emsp;&emsp;java一开始就内置了异常处理，而且强制你必须使用它，如果没有编写正确的异常处理代码，那么就会得到一条编译时的错误信息<h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2>&emsp;&emsp;在计算机编程中有一个基本概念，就是同一时刻处理多个任务的思想，许多程序设计问题都要求，程序能够停下正在做的工作，转而处理某个其他问题，然后在返回主进程，有许多方法可以实行按这个目的，最初，程序员用所掌握的有关机器底层的知识来编写中断服务程序，主进程的挂起是通过硬件中断来触发，这种方式难度大，移植性差<br>&emsp;&emsp;有时中断对处理时间性强的任务是必要的，不过对于大量的问题，我们只是想要把问题切分成多个可独立运行的部分（任务）从而提高程序的相应能力，在程序中，这些彼此独立运行的部分被称为线程，上述概念被称为“并发”<br>&emsp;&emsp;通常，线程只是一种为单一处理器分配执行时间的手段，但是如果操作系统有多处理器，那么每个任务都可以被指派给不同的处理器，而且它们时真正的在并发执行，在语言级别上，多线程所带来的便利之一时程序员不必关系机器上是有多个处理器还是单个<br>&emsp;&emsp;所有这些都使的并发看起来相当简单，但是有一个问题：共享资源</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-1抽象过程&quot;&gt;&lt;a href=&quot;#1-1抽象过程&quot; class=&quot;headerlink&quot; title=&quot;1.1抽象过程&quot;&gt;&lt;/a&gt;1.1抽象过程&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;所有的编程语言都提供抽象机制，汇编语言是对底层机器的轻微抽象，接着出现的所谓
      
    
    </summary>
    
      <category term="学习心得" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
</feed>
