<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>代海峰</title>
  
  <subtitle>个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-18T17:04:33.749Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>EgbertDay</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>泛型</title>
    <link href="http://yoursite.com/2018/10/14/%E6%B3%9B%E5%9E%8B/"/>
    <id>http://yoursite.com/2018/10/14/泛型/</id>
    <published>2018-10-14T11:22:59.000Z</published>
    <updated>2018-10-18T17:04:33.749Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一般的类和方法，只能使用具体的类型，要么是基本类型，那么是自定义的类，如果要编写可以应用与多种类型的代码，这种刻板的限制对代码的束缚就会很大<br>在面向对象语言中，动态算是一种泛化机制，你可以将方法的掺水设为基类，那么该方法就可以接受从这个基类中导出的任何类作为参数，这样的方法也更加通用些，可以应用的地方也更多些，但是考虑到除了final类不能被扩展，其他任何类都可以被扩展，所以这种灵活性大多时候也会有一些性能损耗<br>有时候，拘泥于单继承体系，也会使程序受限太多，如果方法的参数是一个接口，而不是一个类，这种限制就放松了很多，因为任何事实现了该接口的类都能满足该方法，这也包括了暂时还不存在的类，这给了客户端程序员一种选择，他可以选择实现一个接口来满足类或方法的<br>可是有时候，即使使用接口，对程序的约束也还是太强了，因为一旦指明了接口，它就要求你的代码必须使用特定的接口，而我们希望达到的目的是编写更通用的代码，要使代码能够用于“某种不具体的类型”而不是具体的接口或类<br>java SE5的重大变化之一，就是泛型的概念，泛型实现了参数化类型的概念，使代码可以应用于多种类型，“泛型”这个术语的意思就是：“适用于多种类型”，<strong>泛型在编程语言出现时，其最初的目的是希望类或方法能够具备更广泛的表达能力</strong>，如何做到这一点的呢？正是实现通过解耦类和方法与所使用的类型之间的解耦，扫后你将会看到，java中的泛型并没有那么高的追求<br>在学习了java的泛型之后，泛型确实是一个很好的补充，在你创建<strong>参数化类型</strong>的一个实例时，编译器会为你负责转型操作，并确保类型的正确性，这是一个进步<br>但是java中的泛型还没有能够做到像C++那样实现了纯粹的泛型，你不要对java的泛型期望太高，在java中使用一个别人已经建好的泛型类型很容易，但是如果自己创建一个泛型实例，就会遇到很多令人吃惊的事情  </p><h2 id="与C-d的比较"><a href="#与C-d的比较" class="headerlink" title="与C++d的比较"></a>与C++d的比较</h2><p>java的设计灵感来自于C++,那么先了解C++的泛型机制对理解java泛型有些帮助，了解C++魔板的某些方面，有助于你理解泛型的基础，你可以了解java泛型的局限是什么，已经为什么会有这些限制，最终的目的是帮助理解，java泛型的边界在哪里，理解了边界所在，你才会知道某个技术不能做什么，你才能更好地做到所能做的  </p><h2 id="简单泛化"><a href="#简单泛化" class="headerlink" title="简单泛化"></a>简单泛化</h2><p>许多的原因促使了泛型的出现，而最引人注目的一个原因，就是为了创造容器类，我们先来看下一个只能持有单一对象的类，当然这个对象可以明确指定其持有对象的类型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Automobile</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Automobile automobile;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">(Automobile automobile)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.automobile = automobile;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Automobile <span class="title">getAutomobile</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  automobile;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面自定义的容器类Holder，指定了只能存储Automobile这种类型的对象，这个类的可重用性就不怎么样，难道我们要为每一种类型都要创建一个像这样的容器类吗？当然不<br>在java SE5之前我们可以让一个类直接持有Object类型的对象，实际上，我们是使用了关于基类的编程，这要这个类能够应用于这个基类，那么基类的导出类也适用于这个代码，因为导出类本质上也是基类类型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder2</span><span class="params">(Object obj)</span></span>&#123;<span class="keyword">this</span>.obj=obj;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObj</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> obj;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Holder2 holder2=<span class="keyword">new</span> Holder2(<span class="keyword">new</span> Automobile());</span><br><span class="line">        Automobile automobile=(Automobile) holder2.getObj();</span><br><span class="line">        <span class="comment">//特别是这段代码，虽然getObj()返回的实际类型是Automolie类型，我们还是可以做转型操作，编译器才会发现类型转换失败</span></span><br><span class="line">        String s=(String) holder2.getObj();</span><br><span class="line">        holder2.setObj(<span class="string">"Not a Automoblie"</span>);</span><br><span class="line">        String str=(String) holder2.getObj();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~~~在有些情况下，我们确实希望容器具有能持有不同类型的能力，但是，通常情况下，我们希望使用容器来存储一种特定的类型，泛型的主要目的之一就是用来指定容器要持有什么类型的对象，而且由编译器来保证类型的正确性  </span><br><span class="line">因此，与其使用Object，我们更喜欢暂时不指定类型，而是稍后再决定具体使用什么类型，要达到这个目的，需要使用**类型参数**，用尖括号括住，放在类名后面，然后在什么这个类的时候，再用实际的类型替换此类型参数  </span><br><span class="line">~~~java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder3</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder3</span><span class="params">(T a)</span></span>&#123;<span class="keyword">this</span>.a=a;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T a)</span></span>&#123;<span class="keyword">this</span>.a=a;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> a;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Holder3&lt;Automobile&gt; h3=<span class="keyword">new</span> Holder3&lt;&gt;(<span class="keyword">new</span> Automobile());</span><br><span class="line">        Automobile automobile=h3.get();</span><br><span class="line">        <span class="comment">//h3.set(1);</span></span><br><span class="line">        <span class="comment">//h3.set("not a Automoblie");</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当你创建h3对象时，必须指明想要持有什么类型的对象，将其置于尖括号内，然后你就只能在Hold3中存入该类型（或者子类，多态和泛型不冲突，明确指定了泛型类型，那么这个类型的子类型也是该类型，基类与导出类的关系）<br>这就是java泛型的核心概念：告诉编译器想要什么什么类型，然后编译器处理一切   </p><h3 id="一个元祖类库"><a href="#一个元祖类库" class="headerlink" title="一个元祖类库"></a>一个元祖类库</h3><p>仅一次方法调用就返回多个对象，我们经常需要这个功能，可是return只能返回一个对象，因此解决办法就是创建一个对象，用它来持有想要返回的多个对象<br>难道我们每次都要创建这样的一个类，指定它能够保存的类型，所有每次需要保存不同类型的元组时，都要创建保存不同类型的类吗？<br>有了泛型，我们不需要这样做，这样一个类保存两种类型的对象，这个类在创建时才指定它需要用到的类型，同时我们在编译期就能确保类型安全<br>这个概念被称为“元组” ，它是将一组对象直接打包存储于其他的一个单一对象，这个容器对象允许读取其中元素，但是不允许向其中存放新的对象，这和对象就被称为<strong>数据传送对象或者信使 </strong><br>通常，元组可以具有任意长度，同时，元组中的对象可以是任意不同的类型，不过我们希望能够为每一个对象指明类型，并且从容器中读取出来时，能够得到正确的类型，看下下面的二维元组，它能够持有两个对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoTuple</span>&lt;<span class="title">A</span>,<span class="title">B</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> A first;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> B second;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TwoTuple</span><span class="params">(A a,B b)</span></span>&#123;</span><br><span class="line">        first=a;</span><br><span class="line">        second=b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">"("</span>+first+second+<span class="string">")"</span>;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>仔细看上面的代码，我们或许会疑惑，上面的代码违反了java编程的安全性原则，first和second应该被声明为private，然后提供getFirst()和getSecond()子类的访问方法才对，让我们看下这个例子的安全性，客户端程序可以读取fisrt和second，然后随心所欲的使用它们，但是，它们却无法赋值给first和second，因为final声明为你提供了相同的安全性，而且这种格式更简洁明了<br>还有另外一个设计考虑，你确实希望客户端程序员改变first或second所引用的对象，如果是这样的话，就强制程序员另外创建一个新的TwoTuple对象<br>我们可以利用继承机制实现长度更长的元组，下面的例子可以看到，增加类型参数是件很简单的事情<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeTuple</span>&lt;<span class="title">A</span>,<span class="title">B</span>,<span class="title">C</span>&gt; <span class="keyword">extends</span> <span class="title">TwoTuple</span>&lt;<span class="title">A</span>,<span class="title">B</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> C third;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreeTuple</span><span class="params">(A a,B b,C c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(a,b);</span><br><span class="line">        third=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">super</span>.toString()+third;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以看到下面的代码也可以编译通过，这两个代码定义的泛型的导出类是一样的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeTuple</span>&lt;<span class="title">D</span>,<span class="title">E</span>,<span class="title">C</span>&gt; <span class="keyword">extends</span> <span class="title">TwoTuple</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> C third;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreeTuple</span><span class="params">(D a,E b,C c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(a,b);</span><br><span class="line">        third=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">super</span>.toString()+third;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这表明了继承一个泛型类是，基类不一定要添加&lt;A,B&gt;这样的参数类型，导出类添加参数类型即可，实际上我们在定义导出类的泛型类型，而且参数类型只是一个占位符，名称无所谓，只要能够与内部的代码对应就好<br>元组代码测试<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TupleTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TwoTuple&lt;String,Integer&gt; <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span>  <span class="keyword">new</span> TwoTuple&lt;&gt;(<span class="string">"hi"</span>,<span class="number">46</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreeTuple&lt;Automobile,String,Integer&gt; <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span>  <span class="keyword">new</span> ThreeTuple&lt;&gt;(<span class="keyword">new</span> Automobile(),<span class="string">"hi"</span>,<span class="number">46</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      TwoTuple&lt;String,Integer&gt; ttsi=f();</span><br><span class="line">      System.out.print(ttsi);</span><br><span class="line">      ttsi.first=<span class="string">"can't change"</span></span><br><span class="line">      System.out.print(g());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="一个堆栈类"><a href="#一个堆栈类" class="headerlink" title="一个堆栈类"></a>一个堆栈类</h3><p>传统的下推堆栈，在之前的例子，我们是用一个LinkList实现的，LinkedListb本身具备了创建堆栈所需的所有方法<br>现在我们不用LinkedList，来实现自己的内部链式存储机制<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.generics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedStack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">U</span>&gt;</span>&#123;</span><br><span class="line">        U item;</span><br><span class="line">        Node&lt;U&gt; next;</span><br><span class="line">        Node()&#123;</span><br><span class="line">            item=<span class="keyword">null</span>;</span><br><span class="line">            next=<span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node(U item,Node&lt;U&gt; next)&#123;</span><br><span class="line">            <span class="keyword">this</span>.item=item;</span><br><span class="line">            <span class="keyword">this</span>.next=next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> item==<span class="keyword">null</span> &amp;&amp; next==<span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; top =<span class="keyword">new</span> Node&lt;T&gt;();<span class="comment">//哨兵</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T item)</span></span>&#123;</span><br><span class="line">        top=<span class="keyword">new</span> Node&lt;T&gt;(item,top);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        T result = top.item;</span><br><span class="line">        <span class="keyword">if</span>(!top.end())&#123;</span><br><span class="line">            top=top.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        LinkedStack&lt;String&gt; list=<span class="keyword">new</span> LinkedStack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String s:<span class="string">"Phasers on stun!"</span>.split(<span class="string">" "</span>))&#123;</span><br><span class="line">            list.push(s);</span><br><span class="line">        &#125;</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span>((s=list.pop())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到内部类Node也是一个泛型，它拥有自己的参数类型</p><h3 id="RandomList"><a href="#RandomList" class="headerlink" title="RandomList"></a>RandomList</h3><p>作为另一个例子，假设我们需要一个特定类型对象的列表，每次调用其上的select()方法时，它可以随机地选取一个元素，如果我们希望以此构建一个可以应用与各种类型的对象的工具，就需要泛型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;T&gt; storage=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Random random=<span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T item)</span></span>&#123;storage.add(item);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">select</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> storage.get(random.nextInt());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        RandomList&lt;String&gt; rs=<span class="keyword">new</span> RandomList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String s:<span class="string">"the queue broken brown fox"</span>.split(<span class="string">" "</span>))&#123;</span><br><span class="line">            rs.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            System.out.println(rs.select());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>泛型也可以应用于接口，例如生成器，这是一种专门负责创建对象的类，实际上，这是工厂方法设计模式的一种应用，不过，当使用生成器创建新的对象时，它不需要任何参数，而工厂方法需要参数，也就是说，生成器无需额外的信息就知道如何创建对象，<br>一般而言，一个生成器只定义一个方法，该方法用于产生新的对象，在这里就是next()方法<br><code>public interface Generator&lt;T&gt; {    T next();}</code><br>首先我们先创建一个Coffee类及其子类，我们将创建一个生成咖啡的生成器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id =counter++;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName()+id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Latte</span> <span class="keyword">extends</span> <span class="title">Coffee</span></span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mocha</span> <span class="keyword">extends</span>  <span class="title">Coffee</span></span>&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cappuccino</span> <span class="keyword">extends</span> <span class="title">Coffee</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Americano</span> <span class="keyword">extends</span> <span class="title">Coffee</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>在创建一个实现了生成器泛型接口和迭代器的coffee生成器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoffeeGenerator</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">Coffee</span>&gt;,<span class="title">Iterable</span>&lt;<span class="title">Coffee</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class[] types=&#123;Latte.class,Cappuccino.class,Americano.class,Mocha.class&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random random=<span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CoffeeGenerator</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CoffeeGenerator</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;size=a;&#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CoffeeIterator</span> <span class="keyword">implements</span>  <span class="title">Iterator</span>&lt;<span class="title">Coffee</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> counter=<span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> counter&gt;<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Coffee <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            counter--;</span><br><span class="line">            <span class="keyword">return</span> CoffeeGenerator.<span class="keyword">this</span>.next();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Coffee&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CoffeeIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Coffee <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Coffee) types[random.nextInt(types.length)].newInstance();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        CoffeeGenerator gen=<span class="keyword">new</span> CoffeeGenerator();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.out.println(gen.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们再来看下实现Generator泛型接口的另一个实现 Fibonacci数列<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fibonacci</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">next</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> fib(count++); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> fib(n-<span class="number">2</span>)+fib(n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们还想要更近一步，编写一个实现了Itearable的Fibonacci生成器，我们的第一个选择是重写这个类，可是我们并不是总能拥有代码的控制权，并且除非必要，我们也不愿重写代码，我们还有另一种选择，那就是创建一个适配器（adapter）来实现所需要的接口，有很多方法可以实现适配器模式，我们先来看看第一种吧，通过继承实现适配<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FibonacciAdapter</span> <span class="keyword">extends</span> <span class="title">Fibonacci</span> <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FibonacciAdapter</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;<span class="keyword">this</span>.n=n;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Integer&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;Integer&gt;()&#123;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> n&gt;<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                n--;</span><br><span class="line">                <span class="keyword">return</span> FibonacciAdapter.<span class="keyword">this</span>.next();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Integer i:<span class="keyword">new</span> FibonacciAdapter(<span class="number">10</span>))&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>泛型可以应用到整个类上，但同样的也可在类中包含参数化方法，这个方法所在的类可以是泛型类，也可以不是，也就是说，是否用于泛型方法，与其所在的类是否是泛型没有关系<br>一个基本的指导原则是：无论何时，只要你能做到，你就应该尽量使用泛型方法，也就是说，如果使用泛型方法可以取代将整个类泛型话，那么就应该值使用泛型方法，因为它可以使事情更清除明白，<strong>另外，对于一个static的方法而言，无法访问类的类型参数，所以，如果static方法需要使用泛型能力的话，就必须称为泛型方法</strong><br><strong>要定义泛型方法，只需要将泛型参数列表置于返回值之前</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericMothed</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">        System.out.println(x.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        GenericMothed gm=<span class="keyword">new</span> GenericMothed();</span><br><span class="line">        gm.f(<span class="string">""</span>);</span><br><span class="line">        gm.f(<span class="number">1</span>);</span><br><span class="line">        gm.f(<span class="number">1.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的GenericMothed类不是泛型类，尽管这个类和其内部的方法可以被同时参数化，<strong>在使用泛型类时，必须在创建对象的时候指定类型参数的值，而使用泛型方法的时候，通常不必指明参数类，因为编译器会为我们找出具体的类型，这被称为类型参数推断（type argument inference）</strong></p><h3 id="杠杆利用类型参数推断"><a href="#杠杆利用类型参数推断" class="headerlink" title="杠杆利用类型参数推断"></a>杠杆利用类型参数推断</h3><p>以前我们在使用泛型的时候，总是会抱怨需要向程序中添加更多的代码，现在编译器可以使得我们能够省略到对泛型参数列表的重复了，我们看下之前我们的代码的例子<br>    Map&lt;Person,List&lt;? extends Pet&gt;&gt; map=new HashMap&lt;Person,List&lt;? extends Pet&gt;&gt;();<br>现在可以这样写<br>    Map&lt;Person,List&lt;? extends Pet&gt;&gt; map=new HashMap&lt;&gt;();<br>参数类型推断也可以用在泛型方法中  下面的例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">New</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="function">Map&lt;K,V&gt; <span class="title">map</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HashMap&lt;K,V&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">list</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Map&lt;String,Integer&gt; map=New.map();</span><br><span class="line">        List&lt;String&gt; list=New.list();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>类型参数推断避免了重复的泛型参数列表<br>类型参数推断只对赋值有效，其他时候并不起作用，如果将一个泛型方法调用的结果作为参数，传递给另一个方法，这时编译器并不会执行类型推断，在这种情况下，编译器认为，调用泛型方法后，其返回值被赋给列哦一个Object类型的变量，<br>    f(New.map())//does not compile<br>应该这样说，编译器之所以能够进行类型推断的一个基本的条件是，编译器能够获得泛型参数的信息，将泛型方法的返回值直接赋给一个泛型类引用，可以通过这个泛型类引用的类型参数推断出泛型方法的泛型参数，但是如果将泛型方法的返回值直接传递给一个方法，编译器得不到指导  </p><h3 id="显示的类型说明"><a href="#显示的类型说明" class="headerlink" title="显示的类型说明"></a>显示的类型说明</h3><p>在泛型方法中，可以显式地指明类型，不过这种语法比较少见，<strong>要显示地指明类型，必须在点操作符与方法名之间插入尖括号，然后把类型置于尖括号内如果是在定义该方法的类的内部，必须在点操作符之前使用this关键字，如果是使用static的方法，必须在点操作符之前加上类名</strong><br>    f(New.&lt;String,Integer&gt;map());</p><h3 id="可变参数列表与泛型方法"><a href="#可变参数列表与泛型方法" class="headerlink" title="可变参数列表与泛型方法"></a>可变参数列表与泛型方法</h3><p>泛型和可变参数列表能够很好地共存<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericVarargs</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">makeList</span><span class="params">(T... args)</span></span>&#123;</span><br><span class="line">        List&lt;T&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(T item:args)&#123;</span><br><span class="line">            list.add(item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; ls=makeList(<span class="string">"A"</span>);</span><br><span class="line">        System.out.println(ls);</span><br><span class="line">        ls=makeList(<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>);</span><br><span class="line">        ls=makeList(<span class="string">"ABCDRFGHIJKMLNOPQRST"</span>.split(<span class="string">""</span>));</span><br><span class="line">        System.out.println(ls);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="用于Generator的泛型方法"><a href="#用于Generator的泛型方法" class="headerlink" title="用于Generator的泛型方法"></a>用于Generator的泛型方法</h3><p>下面的程序为任何类构造一个Generator，只要该类有没默认的构造器，并且构造器可访问<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicGenerator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; type;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BasicGenerator</span><span class="params">(Class&lt;T&gt; type)</span></span>&#123;</span><br><span class="line">        type=type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> type.newInstance();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Generator&lt;T&gt; <span class="title">create</span><span class="params">(Class&lt;T&gt; type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> BasicGenerator&lt;&gt;( type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面我们创建一个具有默认构造器的类，来测试上面的泛型生成器（generator<t>）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id=count++;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CounterObject</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">id</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> id;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">"CounterObject"</span>+id;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicGenertorDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Generator&lt;CounterObject&gt; gen=BasicGenerator.create(CounterObject.class);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            gen.next();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一个Set实用工具"><a href="#一个Set实用工具" class="headerlink" title="一个Set实用工具"></a>一个Set实用工具</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sets</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Set&lt;T&gt; <span class="title">union</span><span class="params">(Set&lt;T&gt; a,Set&lt;T&gt; b)</span> </span>&#123;</span><br><span class="line">        Set&lt;T&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;(a);</span><br><span class="line">        result.addAll(b);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Set&lt;T&gt; <span class="title">intersection</span><span class="params">(Set&lt;T&gt; a,Set&lt;T&gt; b)</span></span>&#123;</span><br><span class="line">        Set&lt;T&gt; result =<span class="keyword">new</span> HashSet&lt;&gt;(a);</span><br><span class="line">        result.retainAll(b);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Set&lt;T&gt; <span class="title">different</span><span class="params">(Set&lt;T&gt; superSet,Set&lt;T&gt; subSet)</span></span>&#123;</span><br><span class="line">        Set&lt;T&gt; result=<span class="keyword">new</span> HashSet&lt;&gt;(superSet);</span><br><span class="line">        result.removeAll(subSet);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Set&lt;T&gt; <span class="title">complement</span><span class="params">(Set&lt;T&gt; a,Set&lt;T&gt; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> different(union(a,b),intersection(a,b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>泛型还可以应用于内部类和匿名内部类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id =counter++;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Customer</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">"Customer"</span>+id;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Generator&lt;Customer&gt; <span class="title">generator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Generator&lt;Customer&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Customer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Customer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teller</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id=counter++;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Teller</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">"Teller"</span>+id;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Generator&lt;Teller&gt; <span class="title">create</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Generator&lt;Teller&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Teller <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Teller();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="构建复杂模型"><a href="#构建复杂模型" class="headerlink" title="构建复杂模型"></a>构建复杂模型</h2><p>泛型的一个重要好处就是能够简单而安全地创建复杂的模型，例如我们很容易地创建元组列表这样的结构<br>    class TupleList&lt;A,B,C,D&gt; extends List&lt;FourTuple&lt;A,B,C,D&gt;&gt;{}<br>下面这个示例，展示了使用泛型来创建复杂模型是多么简单，即使每个类都作为一个构建块创建，但是其整个还是包含很多部分，在这个例子中，构建一个零售商，它包含走廊，货架和商品<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Product</span><span class="params">(<span class="keyword">int</span> IDNumber,String descr,<span class="keyword">double</span> price)</span></span>&#123;</span><br><span class="line">        id= IDNumber;</span><br><span class="line">        description=descr;</span><br><span class="line">        price=price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id+<span class="string">":"</span>+description+price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">priceChange</span><span class="params">(<span class="keyword">double</span> price)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price=price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Generator&lt;Product&gt; generator=<span class="keyword">new</span> Generator&lt;Product&gt;() &#123;</span><br><span class="line">        <span class="keyword">private</span> Random rand=<span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Product <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Product(rand.nextInt(<span class="number">1000</span>),<span class="string">"Test"</span>,Math.round(rand.nextDouble()*<span class="number">1000</span>)+<span class="number">0.99</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shelf</span> <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">Product</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Shelf</span><span class="params">(<span class="keyword">int</span> nProduct)</span></span>&#123;</span><br><span class="line">        Generators.fill(<span class="keyword">this</span>,Product.generator,nProduct);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Aisle</span> <span class="keyword">extends</span>  <span class="title">ArrayList</span>&lt;<span class="title">Shelf</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Aisle</span><span class="params">(<span class="keyword">int</span> nShives,<span class="keyword">int</span> nProduct)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nShives;i++)&#123;</span><br><span class="line">            add(<span class="keyword">new</span> Shelf(nProduct));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Checkoutstand</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Office</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Store</span> <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">Aisle</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Checkoutstand&gt; checkoutstands= <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Office&gt; offices=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Store</span><span class="params">(<span class="keyword">int</span> nAisles,<span class="keyword">int</span> nShives,<span class="keyword">int</span> nProduct)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nAisles;i++)&#123;</span><br><span class="line">            add(<span class="keyword">new</span> Aisle(nShives,nProduct));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuilder stb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(Aisle aisle:<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(Shelf shelf:aisle)&#123;</span><br><span class="line">                <span class="keyword">for</span>(Product product:shelf)&#123;</span><br><span class="line">                    stb.append(product.toString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="擦除的神秘之处"><a href="#擦除的神秘之处" class="headerlink" title="擦除的神秘之处"></a>擦除的神秘之处</h2><p>当开始真正研究泛型的时候，会发现大量的东西初看起来是没有任何意义的，例如，尽管可以声明ArrayList.class。但是不能声明ArrayList<integer>.class 再看下面的例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErasedTypeEquivalence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Class c1=<span class="keyword">new</span> ArrayList&lt;String&gt;().getClass();</span><br><span class="line">        Class c2=<span class="keyword">new</span> ArrayList&lt;Integer&gt;().getClass();</span><br><span class="line">        System.out.println(c1==c2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></integer></p><p>ArrayList<string>与ArrayList<integer>很容易被认为是不同的类型，不同的类型在行为上肯定不同，比如尝试将一个Integer放入一个ArrayLIst<string>中，但是上面的程序确实认为它们是相同的<br>我们再来看一个例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Frob</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quark</span>&lt;<span class="title">Q</span>&gt;</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LostInformation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Map&lt;String,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Quark&lt;Frob&gt; quark=<span class="keyword">new</span> Quark&lt;&gt;();</span><br><span class="line">        System.out.println(Arrays.toString(list.getClass().getTypeParameters()));</span><br><span class="line">        System.out.println(Arrays.toString(map.getClass().getTypeParameters()));</span><br><span class="line">        System.out.println(Arrays.toString(quark.getClass().getTypeParameters()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*output</span></span><br><span class="line"><span class="comment">[E]</span></span><br><span class="line"><span class="comment">[K,V]</span></span><br><span class="line"><span class="comment">[Q]</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></string></integer></string></p><p>根据JDK文档的描述，<strong><code>Class.getTypeParameters()</code>将“返回一个TypeVariable对象数组”,表示有泛型声明所声明的类型参数…</strong>，这就好像是在暗示你可能发现参数类型的信息，但是，正是正如我们所看到的，我们发现的只是作为参数占位符的标识符，这并非是有用的信息<br>我的理解是，如果在我们第一次创建泛型类的对象的时候，传递给它的构造器一个参数类型，在这个类加载生成Class对象里能够保存这个参数类型的信息就好了，可是我们看到，事实并不是这样<br>因此，残酷的现实是：<br><strong>在泛型代码内部，无法获得任何关于泛型参数类型的信息</strong><br>你可以知道诸如类型参数标记和泛型类型边界这类的信息——你却无法知道用来创建某个特定实例的实际的类型参数<br>java泛型是使用擦除来实现的，这意味着当你在使用泛型时，任何具体的类型信息都被擦除了</p><h3 id="C-的方式"><a href="#C-的方式" class="headerlink" title="C++的方式"></a>C++的方式</h3><p>下面是使用模板的C++示例<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Manipulate</span>&#123;</span></span><br><span class="line"> T obj;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Manipulate(T x)&#123;obj=x;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">mainpulate</span><span class="params">()</span></span>&#123;obj.f();&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasF</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"HasF::f()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  HasF hf;</span><br><span class="line">  manipulate&lt;HasF&gt; manipulate(hf)；</span><br><span class="line">  manipulate.manipulate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*output</span></span><br><span class="line"><span class="comment">HasF::f()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p>Manipulate类存储了一个类型T的对象，有意思的地方是manipulate()方法，它在obj上调用f(),它怎么知道f()方法时为类型参数T而存在的呢？当你实例化一个模板时，C++编译器将会进行检查，因此在Manipulate<hasf>被实例化的那一刻，它看到HasF拥有一个f()方法，否则，就会得到一个编译器错误，这样类型安全就会得到保障<br>我们可以将上面的代码用java的方式重写一次，可是这会出现问题，因此擦除的原因，代码内部并不清楚参数类型是什么？我们就没办法去编写类似obj.f()这样的代码<br>为了能够调用f()，我们必须帮助泛型类，给定泛型类的边界，以表示编译器只能接受遵循这个边界的类型，有可以保证给泛型关于参数类型的信息，<br>在这里我们重用extends这个关键字<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manipulate</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">HasF</span>&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> T obj;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Manipulate</span><span class="params">(T x)</span></span>&#123;obj=x;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">manipulate</span><span class="params">()</span></span>&#123;obj.f();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></hasf></p><p>边界<t extends="" hasf=""> 声明T必须具有类型HasF或者从HasF导出的类，如果情况确实如此，就可以安全地使用obj.f()了<br>我们说泛型参数将擦除到它的第一个边界（它可能会有多个边界），我们还提到了类型参数的擦除，编译器实际上会把类型参数替换为它的擦除，就像上面的例子一样，T擦除到了HasF，就好像在类的声明中用HasF替换了T一样<br>我们有看到了，在上面的一个提过了泛型的例子好像并没有贡献什么好处，只需要很容易地自己去执行擦除，就可以创建没有泛型的类，而且代码也比较泛化，看下一个我们主动执行擦除的例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manipulate</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> HasF obj;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Manipulate</span><span class="params">(HasF x)</span></span>&#123;obj=x;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">manipulate</span><span class="params">()</span></span>&#123;obj.f();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></p><p>这给来哦我们很重要的启示，<strong>只有当你希望使用的类型参数比某个具体类型（以及它所有的子类类型）更加“泛化”的时——也就是说，当你希望代码能够跨越多个类工作时，使用泛型才有所帮助</strong><br><strong>但是</strong>，我们也不要认为<t extends="" hasf="">形式的任何东西都是有缺陷的，例如，如果某个类有一个返回T的方法，那么泛型就会非常有用，因为在使用这个泛型类的时候，泛型参数给了编译器提示，编译器很容易会将T转换为我们使用泛型时指定的参数类型，可以帮助我们很轻松的解决返回值的转型问题  </t></p><h3 id="迁移兼容性"><a href="#迁移兼容性" class="headerlink" title="迁移兼容性"></a>迁移兼容性</h3><p>为了减少潜在的关于擦除的混淆，你必须清楚地认识到这不是一个语言特性，它是java的泛型实现的一种折中，因为泛型不是java语言出现时就有的组成部分，所以这种折中是必须的，虽然它会让你很痛苦<br>擦除减少了泛型的泛化性，泛型在java中仍然有用，但是不如它们本来设想的那么有用，而原因就是擦除<br>在基于擦除的实现中，泛型类型被当作第二类类型处理，即不能在某些重要的上下文环境中使用的类型，<strong>泛型类型只有在静态类型检查期间才出现，在此之后，程序中的所有泛型类型都被擦除，替换为它们的非泛型上界</strong>，例如List<t>这样的类型注解将被擦除为List,而普通的类型变量在未指定边界的情况下将被擦除为Object<br><strong>擦除的核心动机是它使得泛化的客户端可以用非泛化的类库来使用，反之亦然，这经常被称为“迁移兼容性”</strong> 在现实中，即使程序员只编写泛型代码，他们也必须处理在Java SE5之前编写的非泛化类库，这些类库饿作者可能从没想过要泛化它们的代码，或者可能刚刚接触泛型<br><strong>因此java泛化不仅必须支持向后兼容性，即现有的代码和类文件仍旧合法 </strong>（这句话的意思是，在泛化之前出现的类库，那些代码并没有考虑使用泛化的情况，如果我们为了使用泛化，那么就无法使用之前以及创建好的而且很成熟的类库了，为了增加泛化特性，就要抛弃以往已经被实践所验证的代码库，即使是对现有代码库进行修改这样代价也太大了）</t></p><h3 id="擦除的问题"><a href="#擦除的问题" class="headerlink" title="擦除的问题"></a>擦除的问题</h3><p>因此，擦除主要的正当理由是从非泛化代码到泛化代码的转变过程，以及在不随意破坏现有类库的情况下，将泛型融入到java语言，擦除使得现有的非泛型客户端代码能够在不改变的情况下继续使用，直至客户端准备好用泛型重写这些代码，这是一个崇高的动机，因为它不会破坏所有现有的代码<br>擦除的代价是显著的，<strong>泛型不能被显式地被引用至运行时类型的操作之中</strong>，例如转型，instanceOf操作和new表达式，因为所有有关参数的类型信息都丢失了，无论何时，<strong>当你在编写泛型代码的时候，必须时刻提醒自己，你只是看起来好像拥有有关参数的类型信息而已</strong><br>    Foo<cat> foo=new Foo<cat>();<br>class Foo中代码应该知道现在工作于Cat之上，而泛型语法也在强烈地暗示，在整个类的各个地方，类型都在被替换，<strong>但是事实并非如此</strong>，无论何时，当你编写这个代码的时，时刻提醒自己“不，它只是个Object”<br>另外，擦除和迁移兼容性意味着，使用泛型并不是强制的，尽管你可能希望这样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericBasic</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T element;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  T <span class="title">getElement</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> element;&#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setElement</span><span class="params">(T x)</span></span>&#123;element=x;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived1</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">GenericBasic</span>&lt;<span class="title">T</span>&gt;</span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived2</span> <span class="keyword">extends</span> <span class="title">GenericBasic</span></span>&#123;&#125; <span class="comment">//no Warning没有警告</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErasuereAndInheritance</span> </span>&#123;</span><br><span class="line">    Derived2 d2=<span class="keyword">new</span> Derived2();</span><br><span class="line">    Object obj=d2.getElement();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//d2.set(obj) //warning here  在这里警告</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></cat></cat></p><h3 id="边界处的动作"><a href="#边界处的动作" class="headerlink" title="边界处的动作"></a>边界处的动作</h3><p>正因为有了擦除，泛型最令人困惑的方面源于这样一个事实，即可以表示没有任何意义的事物 ，例如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayMaker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; type;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayMaker</span><span class="params">(Class&lt;T&gt; type)</span></span>&#123;type=type;&#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    T[] create(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">return</span> (T[])Array.newInstance(type,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ArrayMaker&lt;String&gt; stringMaker=<span class="keyword">new</span> ArrayMaker&lt;&gt;(String.class);</span><br><span class="line">        String[] stringArray=stringMaker.create(<span class="number">10</span>);</span><br><span class="line">        System.out.println(Arrays.toString(stringArray));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[null,null,null,null,null,null,null,null,null,null]</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p><p>即使type被存储为Class<t>,**擦除也意味着它将被存储为Class,没有任何参数，因此，当你使用它的时候，例如在创建数组时，Array.newInstance()实际上并未拥有kind所蕴含的类型信息，因此它不会产生具体的结果，所以必须转型，这将产生一条令你无法满意的警告<br>注意，对于在泛型中创建数组，使用Array.newInstance()是推荐的方式<br>如果我们要创建一个容器而不是一个数组，情况就有些不同了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListMaker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">create</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//指定了参数类型，实际上就是给了编译器的一个指示，以使得编译期的静态类型检查和转型代码的插入</span></span><br><span class="line">        ListMaker&lt;String&gt; listMaker=<span class="keyword">new</span> ListMaker&lt;T&gt;();</span><br><span class="line">        List&lt;String&gt; list=listMaker.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></p><p>编译器不会给出任何警告，尽管我们知道在create()内部的new ArrayList<t>的T被移除了——在运行时，这个类的内部没有任何<t>,因此看起来毫无意义，但是如果你遵从这种思路，并将这个表达式改为new ArrayList()编译器就会给出警告<br>是否真的毫无意义呢？如果返回list之前，将某些对象放入其中，就像下面这样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilledListMaker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">create</span><span class="params">(T item,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        List&lt;T&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            list.add(item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        FilledListMaker&lt;String&gt; fl=<span class="keyword">new</span> FilledListMaker&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; list=fl.create(<span class="string">"hello"</span>,<span class="number">4</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></t></p><p><strong>即使，编译器无法知道有关create()中的T信息，但是它仍旧可以在编译期确保你放置到result中的对象具有T类型，使其合适ArrayList<t>,因此，即使擦除在方法或者类内部移除了有关实际类型的信息，编译器仍旧可以确保在方法或类中使用的类型的内部一致性</t></strong><br><strong>因为擦除在方法体中移除了类型信息，所以在运行时的问题就是边界，即对象进入和离开方法的地点，这些正是编译器在编译期执行类型检查并插入转型代码的地点</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObj</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> obj;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">(Object obj)</span></span>&#123;obj=obj;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以使用javap-c SimpleHolder反编译这个代码<br>我们再来看下下面的代码，除了类名和添加了类型参数之外，和上面的代码几乎完全一样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericHolder</span> &lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  T <span class="title">getObj</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> obj;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">(T x)</span></span>&#123;obj=x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        GenericHolder&lt;String&gt; gen =<span class="keyword">new</span> GenericHolder&lt;&gt;();</span><br><span class="line">        gen.setObj(<span class="string">"hello"</span>);</span><br><span class="line">        String str=gen.getObj();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们再来反编译上面的代码，可以看出，转型是在调用get()的时候接受检查的，从get()返回之后的转型消失，但是我们还知道传递给set()的值在编译期接收检查<br>从上面的例子，我们可以得出这样的结论，在使用泛型类的时候，指定参数类型信息，其实是给编译器一个指示，通过添加的参数类型信息，编译器在编译过程中，会主动进行类型检查和添加转型代码，但是在运行期，参数类型信息被擦除<br>所以在泛型中的所有动作都发生在边界处——对传递进来的值进行额外的编译期类型检查，并插入对传递出去的值的转型，这有助于我们澄清对擦除的混淆，记住，<strong>边界是发生动作的地方</strong></p><h2 id="擦除的补偿"><a href="#擦除的补偿" class="headerlink" title="擦除的补偿"></a>擦除的补偿</h2><p><strong>擦除丢失了在泛型代码中执行某些操作的能力，任何运行是需要知道确切类型信息的操作都无法工作</strong> 如下例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Erased</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE=<span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Object args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args <span class="keyword">instanceof</span> T)&#123;&#125;<span class="comment">//error</span></span><br><span class="line">        <span class="keyword">new</span> T();<span class="comment">//error</span></span><br><span class="line">        T[] array=<span class="keyword">new</span> T[SIZE];<span class="comment">//error</span></span><br><span class="line">        T[] array=(T) <span class="keyword">new</span> Object[SIZE];<span class="comment">//unckecked warning</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>偶尔可以绕开这些问题，<strong>但是有时必须通过引入类型标签来对擦除进行补偿，这意味着你需要显式地传递你的类型的Class对象，以便你可以在类型表达式中使用它</strong><br>如前面的例子中使用instanceof的尝试失败了，因为其类型信息已经被擦除了，如果引入类型标签，就可以转而使用动态的isInstance();<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassTypeCapture</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; type;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassTypeCapture</span><span class="params">(Class&lt;T&gt; type)</span></span>&#123;type=type;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">f</span><span class="params">(Object arg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  type.isInstance(arg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ClassTypeCapture&lt;String&gt; ct=<span class="keyword">new</span> ClassTypeCapture&lt;&gt;(String.class);</span><br><span class="line">        <span class="keyword">boolean</span> b=ct.f(<span class="string">"hello"</span>);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译器将确保类型标签可以匹配任何泛型参数</p><h3 id="创建类型实例"><a href="#创建类型实例" class="headerlink" title="创建类型实例"></a>创建类型实例</h3><p><strong>在Erased.java中创建一个new T()的尝试将无法实现，部分原因是因为擦除，而另一部分原因是因为编译器不能验证T具有默认（无参）构造器</strong><br>在C++中，这种操作是很自然且直观的因为它在编译期受到检查<br>java中的解决办法是传递一个工厂对象，并用它来创建新的实例，最便利的工厂对象就是Class对象，因此如果使用类型标签，那么你就可以使用new Instance（）来创建这个类型的新对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassAsFactory</span> &lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T x;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassAsFactory</span><span class="params">(Class&lt;T&gt; type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            x = type.newInstance();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstantiateGenericType</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ClassAsFactory&lt;Employee&gt; fe=<span class="keyword">new</span> ClassAsFactory&lt;&gt;(Employee.class);</span><br><span class="line">        System.out.println(<span class="string">"ClassAsFactory&lt;Employee&gt; succeeded"</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ClassAsFactory&lt;Integer&gt; ci=<span class="keyword">new</span> ClassAsFactory&lt;&gt;(Integer.class);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"ClassAsFactory&lt;Integer&gt; failed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这可以编译，但是会因为ClassAsFactory<integer>而失败，因为Integer没有默认构造器，因为这个错误不是在编译器捕获的，所以这种方式使用泛型创建对象并不太好，我们没有尽最大的努力将错误隔绝在编译期，<br>Sun建议使用显式的工厂，并限制其类型，使得只能接受实现了这个工厂的类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">FactoryI</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo2</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T x;</span><br><span class="line">    <span class="keyword">public</span> &lt;F extends FactoryI&lt;T&gt;&gt; Foo2(F factory)&#123;<span class="comment">//这里是重点，确保传递的参数必须是那些可向上转型为FactoryI的的类型</span></span><br><span class="line">        x=factory.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntegerFactory</span> <span class="keyword">implements</span> <span class="title">FactoryI</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;  <span class="comment">//这些类都实现料Factory接口，使得对象的创建得到了保证</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span>  Integer <span class="title">create</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> Integer(<span class="number">0</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">FactoryI</span>&lt;<span class="title">Widget</span>&gt;</span>&#123;  <span class="comment">//Widget.Factory也是实现了FcatoryI的接口</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Widget <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Widget();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryConstraint</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Foo2&lt;Integer&gt;(<span class="keyword">new</span> IntegerFactory());</span><br><span class="line">        <span class="keyword">new</span> Foo2&lt;Widget&gt;(<span class="keyword">new</span> Widget.Factory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></integer></p><p>注意，这确实是传递Class<t>的一种变体，两种方式都传递了工厂对象，Class<t>碰巧是内建的工厂对象，而上面的方式创建了一个显式的工厂对象，但是你却获得了编译器检查<br>另一种方式是模板方法设计模式，在这个示例中，get是模板方法，而create()是在子类中定义的，用来产生子类类型的对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericWithCreate</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> T element;</span><br><span class="line">    GenericWithCreate()&#123;</span><br><span class="line">        element=create();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> T <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Creator</span> <span class="keyword">extends</span> <span class="title">GenericWithCreate</span>&lt;<span class="title">X</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">X <span class="title">create</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> X();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(element.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreatorGeneric</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Creator creator= <span class="keyword">new</span> Creator();<span class="comment">//在创建导出类对象的时候,element就得到了初始化，</span></span><br><span class="line">        creator.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></t></p><h3 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h3><p>Erased.java看到，不能创建泛型数组，一般的解决办法是在任何想要创建泛型数组的地方都使用ArrayList<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListOfGeneric</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; array=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T item)</span></span>&#123;</span><br><span class="line">        array.add(item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> array.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是有时你仍然想要创建泛型类型的数组，<br>数组将会跟着它们的实际类型，而这个类型是在数组被创建时确定的，因此，即使gia已经被转型为Generic<integer>[],但是这个信息只存在与编译器，在运行时，它仍然是Object数组，而这将会引起问题，成功创建泛型数组的唯一方式就是创建一个被擦除类型的新数组，然后对其转型<br>因为有了擦除，数组在运行时类型就只能是Object[],如果我们立即将其转型为T[]，那么在编译器该数组的实际类型就会丢失，而编译器可能会错过某些潜在的错误检查，正因这样，最好是在集合内部使用Object[]，然后当你使用数组元素时，添加一个对T的转型，让我们看下面这个例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericArray2</span> &lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] array;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericArray2</span><span class="params">(<span class="keyword">int</span> sz)</span></span>&#123;</span><br><span class="line">        array=<span class="keyword">new</span> Object[sz];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> index,T item)</span></span>&#123;</span><br><span class="line">        array[index]=item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"Unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;<span class="keyword">return</span> (T)array[index];&#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"Unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> T[] rep()&#123;</span><br><span class="line">        <span class="keyword">return</span> (T[])array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        GenericArray2&lt;Integer&gt; gia=<span class="keyword">new</span> GenericArray2&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            gia.put(i,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.out.println(gia.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Integer[] ia=gia.rep();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></integer></p><p>初看起来没什么太多变化，只是转型挪了地方，如果没有@SuppressWranings注解，你依然会得到unchecked警告，但是，现在的内部表示是Object而不是T[],<strong>当get()被调用的时，它将对象转型为T,这实际上是正确的类型，因此也是安全的，然而，如果你调用rep()，它还是尝试着将Object数组转型为T[],这仍旧不正确的，将在编译器生成警告，在运行时产生异常，因此，没有任何方式可以推翻底层的数组类型，它只能是Object[],</strong>在内部将array当作Object[]而不是T[]处理的优势是，我们不太可能忘记这个数组的运行时类型，从而意外地引入缺陷（尽管大多数也可能是所有这类缺陷都可以在运行时快速地探测到）<br>对于新代码，应该传递一个类型标记，在这种情况下，GenericArray看起来应该像下面这样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericArrayWithToken</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"Unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericArrayWithToken</span><span class="params">(Class&lt;T&gt; type,<span class="keyword">int</span> sz)</span></span>&#123;</span><br><span class="line">        array=(T[]) Array.newInstance(type,sz);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> index,T item)</span></span>&#123;</span><br><span class="line">        array[index]=item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T[] rep()&#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        GenericArrayWithToken&lt;Integer&gt; gia=<span class="keyword">new</span> GenericArrayWithToken&lt;&gt;(Integer.class,<span class="number">10</span>);</span><br><span class="line">        Integer[] ia=gia.rep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>注意，Class<t>被传递到构造器，以便从擦除中恢复，使得我们可创建需要的实际类型的数组</t></strong>，由此，也可以看出，rep()返回的数组被Integer[]捕获在运行期也没有问题，因为数组底层是type类型的元素，数组的创建也是以type为元素类型创建的，所以没有任何问题，所有从这里也可以看出来，数组类型和数组元素类型是不相同的两个概念</p><h2 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h2><p><strong>边界使得你可以在用于泛型的参数类型上设置限制条件，尽管这样使得你可以强制规定泛型可以应用的类型，但是潜在的一个更重要的效果是你可以按照自己的边界类型调用方法</strong><br><strong>因为擦除移除了类型信息，所有，可以用无界泛型参数调用的方法只是那些可以用Object调用的方法，但是，如果能够将这个参数限制为某个参数子集，那么你就可以用这些类型子集来调用方法，为了执行这种限制，java重用了extends关键字</strong>，对你来说有一点很重要，即要理解extends关键字在泛型边界上下文环境中和在普通情况下所具有的意义是完全不同的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">HasColor</span></span>&#123;</span><br><span class="line">    <span class="function">Color <span class="title">getColor</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Colored</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">HasColor</span>&gt;</span>&#123;</span><br><span class="line">    T item;</span><br><span class="line">    Colored(T item)&#123; item=item;&#125;</span><br><span class="line">    <span class="function">T <span class="title">getItem</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item;&#125;</span><br><span class="line">    <span class="function">Color <span class="title">getColor</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item.getColor();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dimnension</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x,y,z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColoredDimension</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Dimnension</span> &amp; <span class="title">HasColor</span>&gt;</span>&#123;</span><br><span class="line">    T item;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ColoredDimension</span><span class="params">(T item)</span></span>&#123;</span><br><span class="line">        item=item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">getItem</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item;&#125;</span><br><span class="line">    <span class="function">Color <span class="title">getColor</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item.getColor() ;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item.x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span></span>&#123;<span class="keyword">return</span>  item.y;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getZ</span><span class="params">()</span></span>&#123;<span class="keyword">return</span>  item.z;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Weight</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">weight</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solid</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Dimnension</span> &amp; <span class="title">HasColor</span> &amp; <span class="title">Weight</span>&gt;</span>&#123;</span><br><span class="line">    T item;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solid</span><span class="params">(T item)</span></span>&#123;</span><br><span class="line">        item=item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">getItem</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item;&#125;</span><br><span class="line">    <span class="function">Color <span class="title">getColor</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item.getColor();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item.x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">weight</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item.weight();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bounded</span> <span class="keyword">extends</span> <span class="title">Dimnension</span> <span class="keyword">implements</span> <span class="title">HasColor</span>,<span class="title">Weight</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Color <span class="title">getColor</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">weight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicBounds</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Solid&lt;Bounded&gt; solid=<span class="keyword">new</span> Solid&lt;&gt;(<span class="keyword">new</span> Bounded());</span><br><span class="line">        solid.getColor();</span><br><span class="line">        solid.weight();</span><br><span class="line">        solid.getX();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面是一个很简单的一个例子，我们创建里一个泛型类，这个泛型类能够接受的类型必须是 <code>extends Diamension &amp; HasColor &amp; Weight</code>的，这种对参数类型进行限定的方式，因为编译器的静态类型检查，我们可以很安全的使用这些基类或接口的方法<br>下面例子，看看如何在继承的每个层次上添加边界限制<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HoldItem</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    T item;</span><br><span class="line">    HoldItem(T item)&#123;</span><br><span class="line">        item=item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Colored2</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">HasColor</span>&gt; <span class="keyword">extends</span> <span class="title">HoldItem</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    Colored2(T item)&#123;<span class="keyword">super</span>(item);&#125;</span><br><span class="line">    <span class="function">Color <span class="title">getColor</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item.getColor();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColoredDimension2</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Dimnension</span> &amp; <span class="title">HasColor</span>&gt; <span class="keyword">extends</span> <span class="title">Colored</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">      ColoredDimension2(T item)&#123;<span class="keyword">super</span>(item);&#125;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item.x;&#125;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span></span>&#123;<span class="keyword">return</span>  item.y;&#125;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getZ</span><span class="params">()</span></span>&#123;<span class="keyword">return</span>  item.z;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solid2</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Dimnension</span> &amp; <span class="title">HasColor</span> &amp; <span class="title">Weight</span>&gt; <span class="keyword">extends</span> <span class="title">ColoredDimension2</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    Solid2(T item)&#123;<span class="keyword">super</span>(item);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">weight</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item.weight();&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritBounds</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Solid2&lt;Bounded&gt; solid2=<span class="keyword">new</span> Solid2&lt;&gt;(<span class="keyword">new</span> Bounded());</span><br><span class="line">        solid2.getColor();</span><br><span class="line">        solid2.getX();</span><br><span class="line">        solid2.weight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>HoldItem持有一个对象，因此这种行为被继承到了Color2中，它也要求其参数与HasColor一致，</strong>或者说参数类型要与HoldItem的参数限定的保存一致，这样才能继承基类那些涉及到限定参数类型的方法</p><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><p>我们首先先看一下数组的一种特殊行为，可以向导出类型的数组赋予基类型的数据引用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CovariantArrays</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Fruit[] fruits=<span class="keyword">new</span> Apple[<span class="number">10</span>];</span><br><span class="line">        fruits[<span class="number">0</span>] = <span class="keyword">new</span> Apple();</span><br><span class="line">        fruits[<span class="number">1</span>] = <span class="keyword">new</span> Jonathan();</span><br><span class="line">        <span class="comment">//runtime type is Apple[],not Fruit[] or Orange[]</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            fruits[<span class="number">0</span>]=<span class="keyword">new</span> Fruit();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123; System.out.println(e);&#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            fruits[<span class="number">0</span>]=<span class="keyword">new</span> Orange();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;System.out.println(e);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>main()第一行创建了一个Apple数组，并将其赋值给一个Fruit数组引用，这是有意义的，因为Apple也是一种Fruit，因此Apple数组应该也是Fruit数组<br><strong>但是，如果实际的数组类型是Apple[],你应该只能往里面放Apple或者Apple的子类型，这在编译器和运行期都可以工作</strong>，但是请注意，编译器允许你将Fruit放置到这个数组，这对于编译器是有意义的，因为它有一个Fruit引用——它有什么理由拒绝将Fruit对象或者任何从Fruit继承出来的对象呢放置到这个数组中呢？因此，编译期，这是允许的，但是，运行时的数组机制知道它处理的是Apple[],因此会向数组中放置异构类型是抛出异常<br>我的理解是这样的，数组和其他的对象是不同的，数组对象中的元素所在的内存空间就在数组对象的内存空间呢，当数组对象创建完成后数组的内存空间，所保存的元素的类型信息就已经定下来了，不能改变，那么这也保证了数组不能保存异构类型的元素<br>实际上，向上转型不适合用在这里，你真正做的是将一个数组赋值给另一个数组，数组行为应当是它可以持有其他对象，这里只是因为我们能够向上转型而已，所有很明显，数组对象可以保留有关它们包含的对象类型的规则，就好像数组对它们持有的对象是有意识的，因此在编译器检查和运行时检查之间，你不能滥用它们<br>对数组的这种滥用并不那么可怕，因为在运行时可以发现你已经插入了不正确的类型，<strong>但是泛型的主要目标之一就是将这种错误检测移到编译期</strong>，因此当我们试图使用泛型容器来替代数组时，会发生什么？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//compile error</span></span><br><span class="line">List&lt;Fruit&gt; fruit=<span class="keyword">new</span> ArrayList&lt;Apple&gt;()</span><br></pre></td></tr></table></figure></p><p>尽管你在第一次阅读这段代码时会认为：“不能讲一个Apple容器赋值给一个Fruit容器”，别忘了，<strong>泛型不仅和容器相关正确的说法是：“不能把一个涉及Apple的泛型赋给一个设计Fruit的泛型</strong>”，如果就像在数组中的情况一样，编译器对代码的了解足够多，可以确定所涉及的容器，那么它可能留有一些余地，但是它不知道任何有关这方面的信息，因此它拒绝向上转型，<strong>实际上，这里也不是向上转型—</strong>—Apple的List不是Fruit的List，Apple的List将持有Apple和Apple的子类型，而Fruit的List将持有任何类型的Fruit,诚然，这包括Apple，一个Apple的List，它仍然是Fruit的List，Apple的List在类型上不等价于Fruit的List,即使Apple是一种Fruit类型，我们还记得运行时类型信息讲过的<code>Class&lt;Number&gt; Nclass=Integer.class</code>会引发编译错误也是这个原因<br><strong>真正的问题是我们在谈容器的类型，而不是容器持有的类型</strong>，与数组不同，泛型没没有内建的协变类型，这是因为数组在语言上是完全定义的，因为可以内建了编译期和运行时的检查，但是，<strong>在使用泛型时，编译器和运行时系统都不知道你想用类型做些什么，以及应该采用什么样的规则</strong><br>但是有时你想要在两个类型之间建立某种类型的向上转型关系，这正是通配符所允许的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericAndCovariance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;? extends Fruit&gt; fruit=<span class="keyword">new</span> ArrayList&lt;Apple&gt;();</span><br><span class="line">        <span class="comment">//fruit.add(new Apple())编译错误</span></span><br><span class="line">        <span class="comment">//fruit.add(new Fruit());</span></span><br><span class="line">        <span class="comment">//fruit.add(new Object());</span></span><br><span class="line">        fruit.add(<span class="keyword">null</span>);<span class="comment">//legal but uninstersting</span></span><br><span class="line">        <span class="comment">// we know that it returns at least Fruit;</span></span><br><span class="line">        Fruit f = fruit.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>fruit类型现在是List&lt;? extends Fruit&gt;,你可以将其读作“具有任何从Fruit继承的类型的列表”，<strong>但是实际上， 并不意味着这个List将持有任何类型的Fruit</strong>，<strong>通配符引用的是明确的类型</strong>，<strong>因此它意味着“某种fruit引用没有指定的具体类型</strong>”，因此这个被赋值的List必须持有诸如Fruit或Apple这样的某种指定类型，但是为了向上转型为fruit，这个类型是什么并没有人关心<br>如果唯一的限制是这个List要持有某种具体的Fruit或Fruit的子类型，但是你实际上并不关系它是什么，那么你能用这样的List做什么呢？如果不知道List持有什么类型，那么你怎样才能安全地向其中添加对象呢？你不能，除非编译器而不是运行时系统可以阻止这种操作的发生（也就是说只有编译器阻止向其中添加对象，你添加对象的行为才是安全的，这也是为什么我们不能向List&lt;? extends Fruit&gt;这种类型的对象添加对象的原因，一切都是为了类型安全，我们无法容忍在添加之后，运行时才发现问题的这种情况的发生）<br>你可能认为，事情变得有点走极端了，因为现在你甚至不能向刚刚声明过将持有Apple对象的List中放置一个Apple对象了，是的，编译器并不知道这一点，List&lt;? extends Fruit&gt;可以合法地指向一个List<orange>,一旦指向这种类型的向上转型，你就会丢失掉向其中传递任何对象的能力，甚至Object也不行<br>一方面，如果你调用一个返回Fruit的方法，则是安全的，因为你知道在这个List中的任何对象都至少具有Fruit类型，因此编译器允许这么做 </orange></p><h3 id="编译器有多聪明"><a href="#编译器有多聪明" class="headerlink" title="编译器有多聪明"></a>编译器有多聪明</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompileIntelligence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;? extends Fruit&gt; fruits=<span class="keyword">new</span> ArrayList&lt;Apple&gt;();</span><br><span class="line">        Apple a=(Apple)fruits.get(<span class="number">0</span>);</span><br><span class="line">        fruits.contains(<span class="keyword">new</span> Apple());<span class="comment">//argument is "Object"</span></span><br><span class="line">        fruits.indexOf(<span class="keyword">new</span> Apple()); <span class="comment">//argument is "Object"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以看到，对contains()和indexOf()的调用，这两个方法都接受Apple对象作为参数，而这些调用都可以正常执行，这是否意味着编译器实际上将检查代码，以查看是否有某个特定的方法修改了它的对象？<br>通过查看ArrayList文档，我们发现，编译器并没有那么充满，尽管add()方法接受一个具有泛型参数类型的参数，但是contains()和indexOf()将接受一个Object类型的参数，因此当你指向一个ArrayList&lt;? extends Fruit&gt;时，add()的参数就变成了“？extends Fruit”(我在编辑add()方法的时候，确实IDE会提醒这个方法的参数是“？ extends Fruit”，这里的意思是：这个方法接受Fruit类型及其子类型的参数，从这个描述中看，编译器也不确定，接受的是哪个确切的类型，因为编译器对参数类型的信息了解的并不多，为了类型安全（编译期的静态类型检查），编译器拒绝接受任何类型的参数)<br>在使用contains()和indexOf()时，参数类型是Object，因此不涉及任何通配符，而编译器也将允许这个调用，这意味这个将由泛型类的设计来决定哪些调用是“安全”的，并使用Object类型作为其参数类型，<strong>为了在类型中使用了通配符的情况下禁止这类调用，我们需要在参数列表中使用类型参数</strong><br>我们来做个总结，当我们使用类似&lt;? extends Fruit&gt;这样的类型参数时，泛型类中那些在方法列表中不涉及类型参数的方法可以正常调用，而在参数列表中使用了类型参数的方法将会被编译器禁止调用<br>看下面是一个很简单的例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T item;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">(T item)</span></span>&#123;</span><br><span class="line">        item=item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T item)</span></span>&#123;item=item;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.equals(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Holder&lt;Apple&gt; apple=<span class="keyword">new</span> Holder&lt;&gt;(<span class="keyword">new</span> Apple);</span><br><span class="line">        Apple d=apple.get();</span><br><span class="line">        apple.set(<span class="keyword">new</span> Apple());</span><br><span class="line">        Holder&lt;? extends Fruit&gt; fruit=apple;</span><br><span class="line">        Fruit p=fruit.get();</span><br><span class="line">        d=(Apple) fruit.get();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Orange o = (Orange) fruit.get();<span class="comment">//可以，但是运行时类型转换异常</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//fruit.set(new Orange()); 参数列表中涉及到类型参数的方法不能调用</span></span><br><span class="line">        <span class="comment">//fruit.set(new Apple());</span></span><br><span class="line">        System.out.println(fruit.equals(d));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="逆变"><a href="#逆变" class="headerlink" title="逆变"></a>逆变</h3><p><strong>还可以走另外一条路，即使用超类型通配符，这里，可以声明通配符是由某个特定类的任意基类来界定，方法是指定&lt;? super MyClass&gt;，甚至或者使用类型参数&lt;? extends T&gt;</strong>（尽管你不能对泛型参数给出一个超类型边界，即不能声明<t super="" myclass="">）,<strong>这使得你可以安全地传递一个类型对象到泛型类型中</strong> 看下面一个例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperTypeWildcards</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeTo</span><span class="params">(List&lt;? <span class="keyword">super</span> Apple&gt; apples)</span></span>&#123;</span><br><span class="line">        apples.add(<span class="keyword">new</span> Apple());</span><br><span class="line">        apples.add(<span class="keyword">new</span> Jonathan());</span><br><span class="line">        <span class="comment">//apples.add(new Fruit()); //error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></p><p>从这例子看出&lt;? super Apple&gt;表明参数类型被指定为Apple的基类，因此泛型类的那些方法的参数列表就变为&lt;? super Apple&gt;，方法接受的类型是Apple的基类，Apple是下界，这样向这些方法传递Apple及其子类型是安全的，（Apple的基类都能接受，Apple及Apple的子类型更是不在话下）</p><p>因此你可能根据如何能够向一个泛型类型“写入”(传递给一个方法)，以及如何能够从一个泛型类型中“读取”（从一个方法中返回），来这手思考子类型边界&lt;? extends MyClass&gt;和超类型边界(&lt;? super MyClass&gt;)<br>超类型边界放松了在可以向方法传递参数上所作的限制<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericWriting</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">writeExact</span><span class="params">(List&lt;T&gt; list,T item)</span></span>&#123;</span><br><span class="line">        list.add(item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">writeWithSuperWildcard</span><span class="params">(List&lt;? <span class="keyword">super</span> T&gt; list,T item)</span></span>&#123;</span><br><span class="line">        list.add(item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> List&lt;Apple&gt; apples= <span class="keyword">new</span> ArrayList&lt;Apple&gt;();</span><br><span class="line">    <span class="keyword">static</span> List&lt;Fruit&gt; fruit =<span class="keyword">new</span> ArrayList&lt;Fruit&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        writeExact(apples,<span class="keyword">new</span> Apple());</span><br><span class="line">        writeExact(fruit,<span class="keyword">new</span> Apple());<span class="comment">//为什么，没有编译错误？</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        writeWithSuperWildcard(apples,<span class="keyword">new</span> Apple());</span><br><span class="line">        writeWithSuperWildcard(fruit,<span class="keyword">new</span> Apple());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        f1();</span><br><span class="line">        f2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在《编程思想》中，writeExact(fruit，new Apple())中指明这种方式有编译错误，found Fruit required Apple,但是为什么，我在编译器中没有发现任何编译错误的提示呢？难道是java之后的版本支持了向List<fruit>类型的引用，传递Apple?<br>回来再研究这个问题<br>下面的例子，作为对协变和通配符的一个复习<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericReading</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">readExact</span><span class="params">(List&lt;T&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> List&lt;Apple&gt; apples=Arrays.asList(<span class="keyword">new</span> Apple());</span><br><span class="line">    <span class="keyword">static</span> List&lt;Fruit&gt; fruits=Arrays.asList(<span class="keyword">new</span> Fruit());</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">     Apple a=readExact(apples);</span><br><span class="line">     Fruit f=readExact(fruits);</span><br><span class="line">     f=readExact(apples);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Reader</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">        <span class="function">T <span class="title">readExact</span><span class="params">(List&lt;T&gt; list)</span></span>&#123; <span class="keyword">return</span> list.get(<span class="number">0</span>);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Reader&lt;Fruit&gt; fruitReader=<span class="keyword">new</span> Reader&lt;&gt;();</span><br><span class="line">        Fruit f=fruitReader.readExact(fruits);</span><br><span class="line">        <span class="comment">//error raedFruit(List&lt;Fruit&gt;) cannot be applied to (Lisy&lt;Apple&gt;)</span></span><br><span class="line">        <span class="comment">//Fruit a=fruitReader.readExact(apples);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CovariantReader</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function">T <span class="title">readCovariant</span><span class="params">(List&lt;? extends T&gt; list)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        CovariantReader&lt;Fruit&gt; convariantRead=<span class="keyword">new</span> CovariantReader&lt;&gt;();</span><br><span class="line">        Fruit f=convariantRead.readCovariant(apples);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        f1();f2();f3()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></fruit></p><p>第1个方法readExact()使用了精确类型，因此如果使用了这个没有任何通配符的精确类型，就可以向List中写入和读取这个精确类型，另外，对于返回值，静态的泛型方法readExact()可以有效地“适应”每个方法调用，并能从List<apple>中返回一个Apple，从List<fruit>，返回一个Fruit,就像f1()看到的那样，因此，如果可以摆脱静态泛型方法，那么当只是读取时，就不需要协变类型了<br>但是，如果有个泛型类，那么当你创建这个类的实例时，要为这个类确定参数，就像在f2()中看到的那样，fruitReader实例可以从List<fruit>中读取一个Fruit，因为这就是它的确切类型，但是List<apple>还应该产生一个Fruit对象，而fruitReader不允许这么做<br>为了修正这个问题。CovariantReader.readCovariant()方法将接受List&lt;? extends T&gt;,因此，从这个列表读取一个T是安全的（你知道在这个列表中的所有对象至少是一个T，并且可能是从T导出的某种对象），在f3()中，你可以看到现在可以从List<apple><br>中读取Fruit了</apple></apple></fruit></fruit></apple></p><h3 id="无界通配符"><a href="#无界通配符" class="headerlink" title="无界通配符"></a>无界通配符</h3><p>无界通配符&lt;?&gt;看起来意味着“任何事物”，因此使用无界通配符好像等价于使用原生类型，事实上，编译器初看起来是支持这种判断的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnboundWildcards1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> List list1;</span><br><span class="line">    <span class="keyword">static</span> List&lt;?&gt; list2;</span><br><span class="line">    <span class="keyword">static</span> List&lt;? extends Object&gt; list3;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign1</span><span class="params">(List list)</span></span>&#123;</span><br><span class="line">        list1=list;</span><br><span class="line">        list2=list;</span><br><span class="line">        <span class="comment">//list3=list; warning:unchecked coversion</span></span><br><span class="line">        <span class="comment">//found List,Required: List&lt;? extends Object&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign2</span><span class="params">(List&lt;?&gt; list)</span></span>&#123;</span><br><span class="line">        list1=list;</span><br><span class="line">        list2=list;</span><br><span class="line">        list3=list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign3</span><span class="params">(List&lt;? extends Object&gt; list)</span></span>&#123;</span><br><span class="line">        list1=list;</span><br><span class="line">        list2=list;</span><br><span class="line">        list3=list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assign1(<span class="keyword">new</span> ArrayList());</span><br><span class="line">        assign2(<span class="keyword">new</span> ArrayList());</span><br><span class="line">        <span class="comment">//assign3(new ArrayList()); warning unchecked conversion found ArrayList Required:list&lt;? extends Object&gt;</span></span><br><span class="line">        assign1(<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">        assign2(<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">        assign3(<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">        List&lt;?&gt; wildList=<span class="keyword">new</span> ArrayList();</span><br><span class="line">        wildList=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        assign1(wildList);</span><br><span class="line">        assign2(wildList);</span><br><span class="line">        assign3(wildList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有很多情况都和你在这里看到的情况类似，即编译器很少关心使用的原生类型还是&lt;?&gt;。在这种情况中，&lt;?&gt;可以被认为是一种装饰，但是它仍旧是有价值的，<strong>因为实际上，它是在声明：我想要java的泛型来编写这段代码，我在这里并不是要用原生类型，但是在当前这种情况下，泛型参数可以持有任何类型</strong><br>下面一个示例展示了无界通配符的一个重要应用，<strong>当你在处理多个泛型参数时，有时允许一个参数可以是任何类型，因此为其他参数确定某种特定类型的这种能力很重要</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Unboundwildcards2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Map map1；</span><br><span class="line">    <span class="keyword">static</span> Map&lt;?,?&gt; map2;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;String,?&gt; map3;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign1</span><span class="params">(Map map)</span></span>&#123;</span><br><span class="line">        map1=map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign2</span><span class="params">(Map&lt;?,?&gt; map)</span></span>&#123;map2=map;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign3</span><span class="params">(Map&lt;String,?&gt; map)</span></span>&#123;map3=map;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        assign1(<span class="keyword">new</span> HashMap());</span><br><span class="line">        assign2(<span class="keyword">new</span> HashMap());</span><br><span class="line">        <span class="comment">//assign3(new HashMap());//warning</span></span><br><span class="line">        assign1(<span class="keyword">new</span> HashMap&lt;String,Integer&gt;());</span><br><span class="line">        assign2(<span class="keyword">new</span> HashMap&lt;String,Integer&gt;());</span><br><span class="line">        assign3(<span class="keyword">new</span> HashMap&lt;String,Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是，当你拥有的是全部的无界通配符时，就像在Map&lt;?,?&gt;中看到的那样，编译器看起来即无法将其与原生Map区分开了，另外，UnboundWildcard1.java展示了编译器处理List&lt;?&gt;和List&lt;? extends Object&gt;时是不同的<br>令人困惑的是，编译器并非总是关注像List&lt;?&gt;和List之间的这种差异，因此它们看起来就像是相同的事物，因为，事实上，由于泛型参数将擦除到它的第一边界，因此List&lt;?&gt;看起来等价于List<object>，而实际上也是List<object>——除非这些语句都不为真，List世家上表示“持有任何Object类型的原生List”，而List&lt;?&gt;表示“具有某种特定类型的非元素List,只是我们不知道那种类型是什么”<br>编译器何时才会关注原生类型和涉及无界通配符的类型之间的差异呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wildcards</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rawArgs</span><span class="params">(Holder holder,Object args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//holder.set(args);//warning unchecked call to set(T) as a member of the raw Holder</span></span><br><span class="line">       <span class="comment">// holder.set(new Wildcards());//simple warning</span></span><br><span class="line">        Object obj=holder.get();</span><br><span class="line">        <span class="comment">//can't do this; don't have any T</span></span><br><span class="line">        <span class="comment">//T t=holder.get();</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unboundedArgs</span><span class="params">(Holder&lt;?&gt; holder,Object args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//holder.set(args);error注意这里是直接错误而不是警告</span></span><br><span class="line">        <span class="comment">//set(captre of ?) in Holder&lt;capture of ?&gt;</span></span><br><span class="line">        <span class="comment">//can't do this; don't have any T</span></span><br><span class="line">        <span class="comment">//T t=holder.get();</span></span><br><span class="line">        <span class="comment">//ok but type information has been lost</span></span><br><span class="line">        Object obj=holder.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">exact1</span><span class="params">(Holder&lt;T&gt; holder)</span></span>&#123;</span><br><span class="line">        T t= holder.get();</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">exact2</span><span class="params">(Holder&lt;T&gt; holder,T args)</span></span>&#123;</span><br><span class="line">        holder.set(args);</span><br><span class="line">        T t = holder.get();</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">wildSubType</span><span class="params">(Holder&lt;? extends T&gt; holder,T args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//holder.set(args); error</span></span><br><span class="line">        T t= holder.get();</span><br><span class="line">        <span class="keyword">return</span>  t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">wildSupType</span><span class="params">(Holder&lt;? <span class="keyword">super</span> T&gt; holder,T args)</span></span>&#123;</span><br><span class="line">        holder.set(args);</span><br><span class="line">        <span class="comment">//T t=holder.get();error</span></span><br><span class="line">        Object obj=holder.get();<span class="comment">//but type information has been lost</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Holder raw =<span class="keyword">new</span> Holder&lt;Long&gt;();</span><br><span class="line">        <span class="comment">//or</span></span><br><span class="line">        raw=<span class="keyword">new</span> Holder();</span><br><span class="line">        Holder&lt;Long&gt; qualified=<span class="keyword">new</span> Holder&lt;&gt;();</span><br><span class="line">        Holder&lt;?&gt; unbounded=<span class="keyword">new</span> Holder&lt;Long&gt;();</span><br><span class="line">        Holder&lt;? extends Long&gt; bounded=<span class="keyword">new</span> Holder&lt;Long&gt;();</span><br><span class="line">        Long lng=<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">        rawArgs(raw,lng);</span><br><span class="line">        rawArgs(qualified,lng);</span><br><span class="line">        rawArgs(unbounded,lng);</span><br><span class="line">        rawArgs(bounded,lng);</span><br><span class="line"></span><br><span class="line">        unboundedArgs(raw,lng);</span><br><span class="line">        unboundedArgs(qualified,lng);</span><br><span class="line">        unboundedArgs(unbounded,lng);</span><br><span class="line">        unboundedArgs(bounded,lng);</span><br><span class="line"></span><br><span class="line">        Object r1=exact1(raw);<span class="comment">//warnning</span></span><br><span class="line">        Long r2 =exact1(qualified);</span><br><span class="line">        Object r3=exact1(unbounded);<span class="comment">//Must return Object</span></span><br><span class="line">        Long r4=exact1(bounded);</span><br><span class="line"></span><br><span class="line">        Long r5=exact2(raw,lng)<span class="comment">//warning</span></span><br><span class="line">        Long r6 =exact2(qualified,lng);</span><br><span class="line">        <span class="comment">//Long r7 = exact2(unbounded,lng);//Error</span></span><br><span class="line">        <span class="comment">//Long r8=exact2(bounded,lng);//error</span></span><br><span class="line">        <span class="comment">//exact2(Holder&lt;T&gt;,T) cannot be applied</span></span><br><span class="line">        <span class="comment">//to (Holder&lt;capture of ? extends Long&gt;,Long)</span></span><br><span class="line"></span><br><span class="line">        Long r9=wildSubType(raw,lng);<span class="comment">//warnings</span></span><br><span class="line">        <span class="comment">//unchecked conversion form Holder to Holder&lt;? extends Long&gt;</span></span><br><span class="line">        <span class="comment">//unchecked method invocation:</span></span><br><span class="line">        <span class="comment">//wildSubType(Holder&lt;? extends T&gt;,T) is applied to (Holder,Long)</span></span><br><span class="line"></span><br><span class="line">        Long r10=wildSubType(qualified,lng);</span><br><span class="line">        <span class="comment">//ok but can only return Object</span></span><br><span class="line">        Object r11=wildSubType(unbounded,lng);</span><br><span class="line">        Long r12=wildSubType(bounded,lng);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//wildSubType(raw,lng);warnnings</span></span><br><span class="line">        <span class="comment">//unchecked conversion from Holder to Holder&lt;? super Long&gt;</span></span><br><span class="line">        <span class="comment">//nchecked method invocation;</span></span><br><span class="line">        <span class="comment">//wildSupType(Holder&lt;? super T&gt;,T) is applied to (Holder,Long)</span></span><br><span class="line"></span><br><span class="line">        wildSupType(qualified,lng);</span><br><span class="line">        <span class="comment">//wildSupType(unbounded,lng);//error</span></span><br><span class="line">        <span class="comment">//wildSuType(Holder&lt;? super T&gt;,T) cannot be applied to (Holder&lt;Capture of ?&gt;,Long)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//wildSupType(bounded,lng);error</span></span><br><span class="line">        <span class="comment">//wildSpType(Holder&lt;? super T&gt;,T)cannot be applied to (Holder&lt;capture of ? extends Long&gt;,Long )</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></object></object></p><p>在rawArgs()中，编译器知道Holder是一个泛型类型，因此即使它在这里表示成一个原生类型，编译器仍然知道向set()传递一个Obeject是不安全的，由于它是原生类型，你可以将任何类型的对象传递给set()，而这个对象将被向上转型为Object，因此无论何时，<strong>只要使用了原生类型，都会放弃编译器检查</strong>，对get()的调用说明了相同的问题，没有任何T类型的睇相，因此结果只能是一个Object<br>人们很自然会开始考虑原生类型Holder和Holder&lt;?&gt;是大致相同的事物，但是unboundArg()强调了它们的不同——它揭示了相同的问题，但是它将这些问题作为错误而不是警告报告，<strong>因为原生Holder将持有任何类型的组合，而Holder&lt;?&gt;将持有具有某种具体类型的同构集合，因此不能只是向其中传递Object</strong><br>在exact1()和exact2()中，你可以看到使用了确切的泛型类型——没有任何通配符，你将看到，exact2和exact1()有不同的限制，因为它有额外的参数<br>在wildSubType()中，在Holder类型上的限制被放松为包括持有任何扩展子T的对象的Holder，这还是意味着如果T是Fruit，那么Holder可以是Holder<apple>,这是合法的，为了防止将Orange()放置到Holder<apple>中，对set()的调用（或者任何接受这个类型参数的方法的调用）都是不允许的，但是，你仍旧知道任何来自Holder&lt;? extends Fruit&gt;的对象至少都是Fruit的，因此get()(任何参数列表不涉及类型参数的方法)的调用都是允许的<br>wildSupType()展示了超类型通配符，因此set()可以接受T,因为任何可以工作于基类的对象都可以多态地作用于导出类（这里就是T），但是尝试着调用get()是没用的，因此由Holder持有的类型可以是任何超类型，因此唯一安全的类型即使Object,但是这样具体的类型信息就会丢失<br>这个例子还展示了对于unbounded()中使用无界通配符能够做什么不能做什么所做出的限制，对于迁移兼容性，rawArgs()将接受所有Holder的不同变体，而不会产生警告，unboundedArgs()方法也可以接受相同的所有类型，尽管如前所示，它在方法体内部处理这些类型的方式并不相同<br><strong>如果向接受“确切”泛型类型（没有通配符）的方法产地一个原生Holder引用，就会得到一个警告，因为确切的参数期望得到在原生类型中并不存在的信息</strong>如果向exact1()传递一个无界引用，就不会有任何可以确定返回类型的类型信息<br>可以看到，exact2()具有更多的限制，因为它希望精确地得到一个Holder<t>，已经一个具有T类型的参数，正因如此，它将产生错误或者警告，除非提供确切的参数，有时，这样做很好，但是如果它过于受限，那么就可以使用通配符，这取决与是否想要从泛型参数中返回类型确定返回值（就像在wildSubType中看到的那样），或者是否想要向泛型参数传递类型确定的参数（就像在wildSupType()中看到的那样）<br>因此使用确切类型来替代通配符的好处是，可以用泛型参数来做更多事，但是使用通配符使得你必须接受范围更宽的参数化类型作为参数，因此，必须逐个情况地权衡利弊，找到更适合你的方法</t></apple></apple></p><h3 id="捕获转换"><a href="#捕获转换" class="headerlink" title="捕获转换"></a>捕获转换</h3><p><strong>有一种情况特别需要使用&lt;?&gt;而不是原生类型，如果像一个使用&lt;?&gt;的方法传递原生类型，那么对与编译器来说，可能会推断出实际的参数类型，使得这个方法可以回转并调用另一个使用这个确切类型的方法</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CaptureConversion</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(Holder&lt;T&gt; holdedr)</span></span>&#123;</span><br><span class="line">        T t=holdedr.get();</span><br><span class="line">        System.out.println(t.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">(Holder&lt;?&gt; holder)</span></span>&#123;</span><br><span class="line">        f1(holder);<span class="comment">//call with capture type</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Holder raw = <span class="keyword">new</span> Holder&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//f1(raw);//warnings</span></span><br><span class="line">        f2(raw);<span class="comment">//no warning</span></span><br><span class="line">        Holder rawBasic=<span class="keyword">new</span> Holder();</span><br><span class="line">        rawBasic.set(<span class="keyword">new</span> Object());<span class="comment">//warning</span></span><br><span class="line">        f2(rawBasic);<span class="comment">//no warning</span></span><br><span class="line">        Holder&lt;?&gt; wildcarded=<span class="keyword">new</span> Holder&lt;Double&gt;();</span><br><span class="line">        f2(wildcarded);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output</span></span><br><span class="line"><span class="comment">Integer</span></span><br><span class="line"><span class="comment">Object</span></span><br><span class="line"><span class="comment">Double</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p><p>f1()的参数类型都是确切的，没有通配符或边界，在f2()中，Holder参数是一个无界通配符，因此它看起来是未知的，但是，在f2()中，f1()被调用，而f1()需要一个已知参数，<strong>这里发生的是，参数类型在调用f2()的过程中被捕获，因此它可以在对f1()的调用中被使用</strong><br>你可能想知道，这项技术是否可以用于写入，但是这要求要在床底Holder&lt;?&gt;同时传递以恶搞具体类型，捕获站好只有在这样的情况下才能工作：即在方法内部，你需要使用确切的类型  </p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="任何基本类型都不能作为类型参数"><a href="#任何基本类型都不能作为类型参数" class="headerlink" title="任何基本类型都不能作为类型参数"></a>任何基本类型都不能作为类型参数</h3><h3 id="实现参数化接口"><a href="#实现参数化接口" class="headerlink" title="实现参数化接口"></a>实现参数化接口</h3><p>一个类不能实现一个泛型接口的两种变体，由于擦除的影响，这两个变体会成为相同的接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Payable</span>&lt;<span class="title">T</span>&gt;</span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Payable</span>&lt;<span class="title">Employee</span>&gt;</span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hourly</span> <span class="keyword">extends</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Payable</span>&lt;<span class="title">Hourly</span>&gt;</span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>Hourly不能编译成功，因为擦除会将Payable<eployee>和Payable<hourly>简化成相同的类Payable</hourly></eployee></p><h3 id="转型和警告"><a href="#转型和警告" class="headerlink" title="转型和警告"></a>转型和警告</h3><p>使用带有泛型参数的转型或instanceof不会产生任何效果，下面的容器在内部将各个值存储为Object，并在获取这些值时，再将它们转型回T<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FixedSizeStack</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Object[] storage;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FixedSizeStack</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">       storage=<span class="keyword">new</span> Object[size]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T item)</span></span>&#123;storage[index++]=item;&#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> (T)storage[index--];&#125;<span class="comment">//重点在这一行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericCast</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE=<span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        FixedSizeStack&lt;String&gt; strings=<span class="keyword">new</span> FixedSizeStack&lt;&gt;(SIZE);</span><br><span class="line">        <span class="keyword">for</span>(String str:<span class="string">"A B C D E F G H I J"</span>.split(<span class="string">" "</span>))&#123;</span><br><span class="line">            strings.push(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;SIZE;i++)&#123;</span><br><span class="line">            String s=strings.pop();</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果没有@SuppressWranings注解，编译将会产生“unchecked cast”警告,<strong>由于擦除的影响，编译器无法知道这个转型是否是安全的，并且pop()方法实际上没有执行任何转型，这是因为，T被擦除到它的第一个边界，默认情况下是Object，因此pop()实际上只是将Object转型为Object</strong><br><strong>有时，泛型没有消除对转型的需要，就会产生编译器警告，而这个警告是不恰当的，例如</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NeedCasting</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]));</span><br><span class="line">        List&lt;Widget&gt; shape=(List&lt;Widget&gt;)in.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>readObject()无法知道它正在读取的是什么，因此它返回的是必须转型的对象，但是当注释点@SuppressWranings注解，并编译这个程序的时，就会出现下面的警告<br>Note:NeedCasting,java uses unchecked or unsafe operations<br>Note:Recompile with —Xlint:unchecked for detail<br>如果遵循这条指示，使用—Xlint：unchecked来重新编译<br>NeedCasting.java:12: warning:[unckecked] unchecked cast<br>found :java.lang.Object<br>required: java.util.List<widget><br>   List<shape> shapes=(List<widget>)in.readObject();<br>你会被强制要求转型，但是又被告知不应该转型，为了解决这个问题，必须使用在java SE5中引入的新的转型形式，既通过泛型类来转型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NeedCasting</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]));</span><br><span class="line">        <span class="comment">//List&lt;Widget&gt; lw1=List&lt;Widget&gt;.class.cast(in.readObject());</span></span><br><span class="line">        List&lt;Widget&gt; lw2=List.class.cast(in.readObject());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></widget></shape></widget></p><p>这里是相当奇怪的</p><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>下面的程序是不能编译的，即使编译它是一种合理的尝试<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseList</span>&lt;<span class="title">W</span>,<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(List&lt;T&gt; v)</span></span>&#123;&#125;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(List&lt;W&gt; v)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于擦除的影响，重载方法将产生相同的类型签名</p><h3 id="基类劫持了接口"><a href="#基类劫持了接口" class="headerlink" title="基类劫持了接口"></a>基类劫持了接口</h3><p>假设你有一个Pet类，它可以与其他的Pet类对象进行比较（实现了Comparable接口）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparablePet</span>  <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ComparablePet</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(@NotNull ComparablePet o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对可以与ComparablePet的子类比较的类型进行窄化是有意义的，例如，一个Cat对象就只能与其他Cat对象进行比较<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">ComparablePet</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Cat</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(@NotNull Cat o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>遗憾的是上面代码错误，一旦为Comparable确定了ComparablePet参数，那么其他任何实现类都不能与ComparablePet之外的任何对象比较<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hamster</span> <span class="keyword">extends</span> <span class="title">ComparablePet</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ComparablePet</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(ComparablePet args)</span></span>&#123;<span class="keyword">return</span>  <span class="number">1</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Hasmter说明再次实现ComparablePet中的接口是可能的，只要它们精确地相同，包括参数类型在内</p><h2 id="自限定的类型"><a href="#自限定的类型" class="headerlink" title="自限定的类型"></a>自限定的类型</h2><p>在java中，经常出现一个令人费解的惯用法<br>class SelfBound&lt;T extends SelfBound<t>&gt;<br>这就像是两面镜子彼此看着对方产生的炫目感，是一种无限循环，SelfBound接受泛型参数T，而T由一个边界类限定，这个边界就是拥有T作为参数的ShefBound</t></p><h3 id="古怪的循环泛型"><a href="#古怪的循环泛型" class="headerlink" title="古怪的循环泛型"></a>古怪的循环泛型</h3><p>我们先从简单的版本入手<br><strong>不能直接继承一个泛型参数，但是，可以继承在其自己的定义中使用这个泛型参数的类</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericType</span>&lt;<span class="title">T</span>&gt;</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuriouslyRecurringGeneric</span> <span class="keyword">extends</span> <span class="title">GenericType</span>&lt;<span class="title">CuriouslyRecurringGeneric</span>&gt;</span>&#123; &#125;</span><br></pre></td></tr></table></figure></p><p>上面的例子可以称为“古怪的循环”，<strong>“古怪的循环”是指类相当古怪地出现在自己的基类中这一事实</strong><br>为了理解其含义，努力地大声说“<strong>我正在创建一个新类吗，这个类继承子一个泛型类型，这个泛型类型的接受我的类的名字作为其参数</strong>”，当给出导出类的名字时，<strong>这个泛型基类能够实现什么呢？好吧，java中的泛型关乎参数和返回类型，因此它能够产生使用导出类作为参数和返回类型的积累，它还能将导出类用作其域类型，甚至那些将其擦除为Object的类型</strong><br>下面是一个普通的泛型类,它的方法将接受和产生具有参数类型的对象，还有一个方法将在其存储的域上执行操作（尽管只在这个域上执行Object操作）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicHolder</span> &lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T item;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setItem</span><span class="params">(T item)</span></span>&#123;item=item;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getItem</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(item.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面这个示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubType</span> <span class="keyword">extends</span> <span class="title">BasicHolder</span>&lt;<span class="title">SubType</span>&gt;</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CRWithBasicHolder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">      SubType subType1=<span class="keyword">new</span> SubType();</span><br><span class="line">      SubType subType2=<span class="keyword">new</span> SubType();</span><br><span class="line">      subType1.setItem(subType2);</span><br><span class="line">      SubType subType3=subType1.getItem();</span><br><span class="line">      subType1.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>新类SubType接受的参数和返回的值具有SubType类型而不仅仅是基类Basicholder的类型，这就是CRG(古怪的循环)的本质，<strong>基类用导出类替代其参数</strong>，<strong>这意味着泛型基类变成了一种其所有导出类的公共功能的模版，但是这些功能对于其所有参数和返回值，将使用导出类型，也就是说，在产生的类中将使用确切类型而不是其基类型</strong>，因此，在SubType中，传递给set()的参数和从get()返回的类型都是确切的SubType</p><h3 id="自限定"><a href="#自限定" class="headerlink" title="自限定"></a>自限定</h3><p>BasicHolder可以使用任何类型作为其泛型参数，就像下面看到的那样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Other</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicOther</span> <span class="keyword">extends</span> <span class="title">BasicHolder</span>&lt;<span class="title">Other</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        BasicOther b=<span class="keyword">new</span> BasicOther();</span><br><span class="line">        b.setItem(<span class="keyword">new</span> Other());</span><br><span class="line">        Other o=b.getItem();</span><br><span class="line">        b.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>自限定将采取额外的步骤，强制泛型当作其自己的边界参数来使用</strong><br>观察所产生的类可以如何使用以及不可以如何使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelfBounded</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&gt;</span>&#123;</span><br><span class="line">    T element;</span><br><span class="line">    <span class="function">SelfBounded&lt;T&gt; <span class="title">set</span><span class="params">(T arg)</span></span>&#123;</span><br><span class="line">        element=arg;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">A</span>&gt;</span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">A</span>&gt;</span>&#123;&#125;<span class="comment">//also ok</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">C</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">C <span class="title">setAndGet</span><span class="params">(C arg)</span></span>&#123;</span><br><span class="line">        set(arg);</span><br><span class="line">        <span class="keyword">return</span> get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//class E extends SelfBounded&lt;D&gt;&#123;&#125;can't do this</span></span><br><span class="line"><span class="comment">//compile error : Type parameter D is not within its bound</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//also you can do this ,so you can't force the idiom</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelfBounding</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        A a =<span class="keyword">new</span> A();</span><br><span class="line">        a.set(<span class="keyword">new</span> A());</span><br><span class="line">        a=a.set(<span class="keyword">new</span> A()).get();</span><br><span class="line">        a=a.get();</span><br><span class="line"></span><br><span class="line">        C c=<span class="keyword">new</span> C();</span><br><span class="line">        c=c.setAndGet(<span class="keyword">new</span> C());</span><br><span class="line"></span><br><span class="line">        B b=<span class="keyword">new</span> B();</span><br><span class="line">        b.set(<span class="keyword">new</span> A());</span><br><span class="line">        A ba=b.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>自限定所做的，就是要求在继承关系中，像下面这样使用这个类</strong><br>    class A extends SelfBounded<a>{}<br><strong>这会强制要求将正在定义的类当作参数传递给基类</strong><br>从基类的类型参数的表达式也能看的出来</a></p><p>&lt;T extends SelfBounded<t>&gt; T表示类型参数，这个参数的类型是其自身类型的导出类<br>自限定的参数有何意义呢？它可以保证类型参数必须与正在被定义的类相同<br>正如你从B类的定义所看到的，还可以从另一个SelfBounded参数的SelfBounded中导出，尽管A类看到的用法是最主要的用法<br>对定义E的尝试说明不能使用不是SelfBounded的类型参数<br>遗憾的是，F可以编译，不会有任何警告，这是比较奇怪的吗？这也说明了自限定惯用法不是可强制执行的，如果它确实很重要，可以要求一个外部工具来确保不会使用原生类型来替代参数化类型<br>注意，可以移除自限定这个限制，这样所有的类仍旧可以编译的，但是E也因此可编译成功<br>其实自限定类型的目的就是限定导出类在继承基类的时候，必须将参数类型替换为导出类（只要是基类的导出类都可以，一般我们惯用的是新建的这个导出类自身来替代参数类型而已，一次泛型类的自限定对于继承自它的类来说，没什么一样，自限定最大的功效就是强制而已）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A2</span> <span class="keyword">extends</span> <span class="title">NotSelfBounded</span>&lt;<span class="title">A</span>&gt;</span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span> <span class="keyword">extends</span> <span class="title">NotSelfBounded</span>&lt;<span class="title">A2</span>&gt;</span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C2</span> <span class="keyword">extends</span> <span class="title">NotSelfBounded</span>&lt;<span class="title">C2</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">C2 <span class="title">getAndSet</span><span class="params">(C2 arg)</span></span>&#123; set(arg);<span class="keyword">return</span> get(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E2</span> <span class="keyword">extends</span> <span class="title">NotSelfBounded</span>&lt;<span class="title">D2</span>&gt;</span>&#123;&#125;<span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotSelfBounded</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T element;</span><br><span class="line">    <span class="function">NotSelfBounded&lt;T&gt; <span class="title">set</span><span class="params">(T arg)</span></span>&#123;</span><br><span class="line">        element=arg;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> element;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></p><p>这里E2能够编译，即使D2不在NotSelfBounded继承关系中，因此得出结论：<strong>自限定限制只能强制作用于继承关系</strong>。<br>自限定也可以用在泛型方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelfBoundedMethods</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T extends SelfBounded&lt;T&gt;&gt; <span class="function">T <span class="title">f</span><span class="params">(T arg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arg.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        A a=f(<span class="keyword">new</span> A());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="参数协变"><a href="#参数协变" class="headerlink" title="参数协变"></a>参数协变</h3><p>自限定类型的价值是它可以产生协变参数类型——方法参数类型会随着子类而变化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">OrdinaryGetter</span></span>&#123;</span><br><span class="line">    <span class="function">Base <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">DerivedGetter</span> <span class="keyword">extends</span> <span class="title">OrdinaryGetter</span></span>&#123;</span><br><span class="line">    <span class="function">Derived <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CovariantReturnType</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(DerivedGetter d)</span></span>&#123;</span><br><span class="line">        Derived d2=d.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>DerivedGetter中的get()方法覆盖了OrderinaryGetter中的get()方法，并返回一个从OrderinaryGetter.get()返回类型中导出的类型，尽管这是很合理的，导出类方法应该能够返回比它覆盖的基类方法更具体的类型，但是这在java之前的版本中是不合法的<br>自限定泛型实际上将产生确切的导出类型作为其返回值，就像在get()中看到的那样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GenericGetter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">GenericGetter</span>&lt;<span class="title">T</span>&gt;&gt;</span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Getter</span> <span class="keyword">extends</span> <span class="title">GenericGetter</span>&lt;<span class="title">Getter</span>&gt;</span>&#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsAndGetter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(Getter g)</span></span>&#123;</span><br><span class="line">        Getter result=g.get();</span><br><span class="line">        GenericGetter gg=g.get();<span class="comment">//also the base type</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在非泛代码中，参数类型不能随子类型发生变化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrdinarySetter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Base base)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"OrdinarySetter.set(Base)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedSetter</span> <span class="keyword">extends</span> <span class="title">OrdinarySetter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Derived derived)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"DerivedSetter.set(Derived)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderinaryArguments</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Base base=<span class="keyword">new</span> Base();</span><br><span class="line">        Derived derived=<span class="keyword">new</span> Derived();</span><br><span class="line">        DerivedSetter ds=<span class="keyword">new</span> DerivedSetter();</span><br><span class="line">        ds.set(derived);</span><br><span class="line">        ds.set(base);<span class="comment">//这是重载，不是覆盖，overloade，not overridden</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">DerivedSetter.set(Derived)</span></span><br><span class="line"><span class="comment">OrdinarySetter,set(Base)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p><p>set(Derived)和set(Base)都是合法的，因此DerivdeSetter.set(Derived)方法没有覆盖OrdinarySetter.set(Base)方法，而是重载了它，基类版本的代码依然是可用的<br>但是，在使用自限定类型时，在导出类中只有一个方法，并且这个方法接受导出类而不是基类型为参数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SelfBoundSetter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SelfBoundSetter</span>&lt;<span class="title">T</span>&gt;&gt;</span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">set</span><span class="params">(T arg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Setter</span> <span class="keyword">extends</span> <span class="title">SelfBoundSetter</span>&lt;<span class="title">Setter</span>&gt;</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelfBoundingAndConvariantArguments</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testA</span><span class="params">(Setter s1,Setter s2,SelfBoundSetter sb3)</span></span>&#123;</span><br><span class="line">        s1.set(s2);</span><br><span class="line">        <span class="comment">//s1.set(sb3);  set(Setter) in SelfBoundSetter&lt;Setter&gt;</span></span><br><span class="line">        <span class="comment">//cannot be applied to SelfBoundSetter</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>上面这个例子可以看出，编译器不能识别将基类当作参数传递给setter()的尝试，因为没有任何方法具有这样的签名</strong><br>如果不使用自限定类型，普通的继承机制就会介入，而你将能够重载，就像在非泛型的情况下一样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericSetter</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(T arg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"GenericSetter.set(Base)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedGs</span> <span class="keyword">extends</span> <span class="title">GenericSetter</span>&lt;<span class="title">Base</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Derived derived)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"DerivedGs.set(Derived)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlainGenericInheritance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Base base=<span class="keyword">new</span> Base();</span><br><span class="line">        Derived derived=<span class="keyword">new</span> Derived();</span><br><span class="line">        DerivedGs derivedGs=<span class="keyword">new</span> DerivedGs();</span><br><span class="line">        derivedGs.set(base);</span><br><span class="line">        derivedGs.set(derived);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">GenericSetter.set(Base)</span></span><br><span class="line"><span class="comment">DerivedGs.set(Derived)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p><h2 id="动态类型安全"><a href="#动态类型安全" class="headerlink" title="动态类型安全"></a>动态类型安全</h2><p>因为可以向java SE5之前的代码传递容器，所以旧式代码仍旧有可能破坏你的容器（这句话的意思，向你的容器插入不正确的类型）,java SE5的java.util.Collections中有一组便利的工具，可以解决在这种情况下的类型检查问题，它们是，静态方法checkedCollection(),checkedList(),checkedMap(),checkedSet(),checkedSortedMap()和checkedSortedSet(),这些方法每一个都将会希望动态检查的容器作为第一第一个参数接受，并将你希望强制要求的类型作为第二个参数接受<br>受检查的容器，在你试图插入类型不正确的对象时抛出ClassCastException，这与泛型之前的（原生）容器形成对比，对于后者来说，当你将对象从容器中取出的时候，才会通知你出现了问题，而且你也不知道问题是什么时候造成的，受检查的容器与其不同，当向这个容器插入不良对象的时候我们就立刻知道问题发生了<br>用受检查的容器来看看“将猫插入狗列表中”这个问题，这里oldStyleMethod代表遗留代码，因为它接受原生容器List，而@SuppressWarnings注解对这些遗留代码是必需的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pet</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span>  <span class="title">Pet</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span>  <span class="title">Pet</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckedList</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">oldStyleMethod</span><span class="params">(List probablyDogs)</span></span>&#123;</span><br><span class="line">        probablyDogs.add(<span class="keyword">new</span> Cat());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;Dog&gt; dogs1=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        oldStyleMethod(dogs1);<span class="comment">//Quietyly accepts a Cat//不会抛出异常 也不会警告，因为遗留代码使用了原生类型作为参数</span></span><br><span class="line">        List&lt;Dog&gt; dogs2= Collections.checkedList(<span class="keyword">new</span> ArrayList&lt;Dog&gt;(),Dog.class);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oldStyleMethod(dogs2);<span class="comment">//抛出异常</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//derived Type work fine</span></span><br><span class="line">        List&lt;Pet&gt;  pets=Collections.checkedList(<span class="keyword">new</span> ArrayList&lt;Pet&gt;(),Pet.class);</span><br><span class="line">        pets.add(<span class="keyword">new</span> Dog());</span><br><span class="line">        pets.add(<span class="keyword">new</span> Cat());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行这个程序，会发现向dog1插入Cat没有任何问题，如果问题出现也只会在以后从容器中取出时才会发现，因为遗留代码使用了原生类型而不是泛型类型，向dog2插入一个Cat会立马抛出异常</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>由于擦除的影响，将泛型应用于异常是非常受限的。catch语句不能捕获泛型类型的异常，因为在编译期和运行期都必须知道异常的确切类型，泛型类也不呢个直接或间接继承自Throwable(这将进一步阻止你去定义一个不能捕获的泛型异常)<br>但是，类型参数可能会在一个方法的throws子句中用到，这使得你可以编写随检查型异常的类型而发生变化的泛型代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Processor</span>&lt;<span class="title">T</span>,<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Exception</span>&gt;</span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;T&gt; resultCollector)</span><span class="keyword">throws</span> E</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProcessRuuner</span>&lt;<span class="title">T</span>,<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Exception</span>&gt; <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">Processor</span>&lt;<span class="title">T</span>,<span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">processAll</span><span class="params">()</span><span class="keyword">throws</span> E</span>&#123;</span><br><span class="line">        List&lt;T&gt; resultCollector=<span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Processor&lt;T,E&gt; p:<span class="keyword">this</span>)&#123;</span><br><span class="line">            p.process(resultCollector); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  resultCollector;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Failure1</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Processor1</span> <span class="keyword">implements</span> <span class="title">Processor</span>&lt;<span class="title">String</span>,<span class="title">Failure1</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;String&gt; resultCollector)</span> <span class="keyword">throws</span> Failure1 </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count--&gt;<span class="number">1</span>)</span><br><span class="line">            resultCollector.add(<span class="string">"hep!"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            resultCollector.add(<span class="string">"Ho!"</span>);</span><br><span class="line">        <span class="keyword">if</span>(count&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Failure1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Failuer2</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Processor2</span> <span class="keyword">implements</span>  <span class="title">Processor</span>&lt;<span class="title">Integer</span>,<span class="title">Failuer2</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;Integer&gt; resultCollector)</span> <span class="keyword">throws</span> Failuer2 </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count-- == <span class="number">0</span>)</span><br><span class="line">            resultCollector.add(<span class="number">11</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            resultCollector.add(<span class="number">47</span>);</span><br><span class="line">        <span class="keyword">if</span>(count&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Failuer2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowGenericException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ProcessRuuner&lt;String,Failure1&gt; runner1=<span class="keyword">new</span> ProcessRuuner&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            runner1.add(<span class="keyword">new</span> Processor1());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(runner1.processAll());</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Failure1 e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ProcessRuuner&lt;Integer,Failuer2&gt; runner2 = <span class="keyword">new</span> ProcessRuuner&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            runner2.add(<span class="keyword">new</span> Processor2());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(runner2.processAll());</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Failuer2 e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码是很简单的，虽然看起来很长，说明了异常也可以参数化</p><h2 id="混型"><a href="#混型" class="headerlink" title="混型"></a>混型</h2><p>混型（混合的类型，使得这个类型可以混合多个类的能力）随着时间的推移好像拥有无数的含义，<strong>但是其最基本的概念是混合多个类型的能力，以产生一个可以表示混型中所有类型的类</strong>，这往往是你最后的手段，它使得组装多个类型变得简单易行</p><h3 id="C-中的混型"><a href="#C-中的混型" class="headerlink" title="C++中的混型"></a>C++中的混型</h3><p>代码不写了，C++中，使用多重继承的最大理由，就是为了使用混型，但是对于混型来说，更有趣，更优雅的方式是使用参数化类型，因为混型就是继承子其类型参数的类，在C++中，可以很容易的创建混型，因为C++能够记住模版参数的类型</p><h3 id="与接口混合"><a href="#与接口混合" class="headerlink" title="与接口混合"></a>与接口混合</h3><p>在java中，最常见的解决方案就是使用接口来产生混型的效果,类似这样的吧<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">C</span></span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span></span>;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">C</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mix</span> <span class="keyword">extends</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">B</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><h3 id="使用装饰器模式"><a href="#使用装饰器模式" class="headerlink" title="使用装饰器模式"></a>使用装饰器模式</h3><p>当你观察混型的使用方式时，你会发现混型概念好像与装饰器模式关系很近，装饰器常用于满足各种可能的组合，而直接子类化会产生过多的类，因此是不实际的<br><strong>装饰器模式使用了分层对象来动态透明地向单个对象添加责任，装饰器是指包装在最初的对象周围的所有对象都具有的基本接口</strong>，某些事物是可装饰的，可以通过是其他类包装在这个可装饰对象的四周，来将功能分层，这使得对装饰器的使用是透明的——无论对象是否被装饰，你都拥有一个可以向对象发送的公共接口集，装饰器也可以添加新的方法，但是正如你所见的，这将是受限的<br><strong>装饰器是使用组合和形式化结构（可装饰物/装饰器层次结构）来实现的</strong>，而混型是基于继承的，因此可以将基于参数化类型的混型当作是一种泛型装饰器机制，这种机制不需要装饰器设计模式的继承结构<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Processor</span>&lt;<span class="title">T</span>,<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Exception</span>&gt;</span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;T&gt; resultCollector)</span><span class="keyword">throws</span> E</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProcessRuuner</span>&lt;<span class="title">T</span>,<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Exception</span>&gt; <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">Processor</span>&lt;<span class="title">T</span>,<span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">processAll</span><span class="params">()</span><span class="keyword">throws</span> E</span>&#123;</span><br><span class="line">        List&lt;T&gt; resultCollector=<span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Processor&lt;T,E&gt; p:<span class="keyword">this</span>)&#123;</span><br><span class="line">            p.process(resultCollector); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  resultCollector;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Failure1</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Processor1</span> <span class="keyword">implements</span> <span class="title">Processor</span>&lt;<span class="title">String</span>,<span class="title">Failure1</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;String&gt; resultCollector)</span> <span class="keyword">throws</span> Failure1 </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count--&gt;<span class="number">1</span>)</span><br><span class="line">            resultCollector.add(<span class="string">"hep!"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            resultCollector.add(<span class="string">"Ho!"</span>);</span><br><span class="line">        <span class="keyword">if</span>(count&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Failure1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Failuer2</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Processor2</span> <span class="keyword">implements</span>  <span class="title">Processor</span>&lt;<span class="title">Integer</span>,<span class="title">Failuer2</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;Integer&gt; resultCollector)</span> <span class="keyword">throws</span> Failuer2 </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count-- == <span class="number">0</span>)</span><br><span class="line">            resultCollector.add(<span class="number">11</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            resultCollector.add(<span class="number">47</span>);</span><br><span class="line">        <span class="keyword">if</span>(count&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Failuer2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowGenericException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ProcessRuuner&lt;String,Failure1&gt; runner1=<span class="keyword">new</span> ProcessRuuner&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            runner1.add(<span class="keyword">new</span> Processor1());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(runner1.processAll());</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Failure1 e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ProcessRuuner&lt;Integer,Failuer2&gt; runner2 = <span class="keyword">new</span> ProcessRuuner&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            runner2.add(<span class="keyword">new</span> Processor2());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(runner2.processAll());</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Failuer2 e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>产生自泛型的类包含所有感兴趣的方法，<strong>但是由使用装饰器所产生的对象类型是最后被装饰的类型，也就是说，尽管可以添加多个层，但是最后一层才是实际的类型，因此只有最后一层的方法时可视的</strong>，而混型的类型是所有被混合到一起的类型，因此对于装饰器来说，其明显的缺陷就是它只能有效地工作于装饰器中的一层（最后一层），而混型方法显然会更自然一些，因此，装饰器只是对由混型提出的问题的一种局限的解决方案</p><h3 id="与动态代理混合"><a href="#与动态代理混合" class="headerlink" title="与动态代理混合"></a>与动态代理混合</h3><p><strong>可以使用动态代理来创建一种比装饰器更贴近混型模型的机制，通过使用动态代理，所产生的类的动态类型将会是已经混入的组合类型</strong><br>由于动态代理的限制，每个被混入的类都必须是某个接口的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MixinProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">    Map&lt;String,Object&gt; delegatesByMethod;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mixin</span><span class="params">(TwoTuple&lt;Object,Class&lt;?&gt;&gt;... pairs)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(TwoTuple&lt;Object,Class&lt;?&gt;&gt; pair:pairs)&#123;</span><br><span class="line">          <span class="keyword">for</span>(Method method:pair.second.getMethods())&#123;</span><br><span class="line">              String methodName=method.getName();</span><br><span class="line">              <span class="comment">//the first inferface in the map</span></span><br><span class="line">              <span class="comment">//implements the method</span></span><br><span class="line">              <span class="keyword">if</span>(!delegatesByMethod.containsKey(methodName))&#123;</span><br><span class="line">                  delegatesByMethod.put(methodName,pair.first);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        String methodName=method.getName();</span><br><span class="line">        Object delegate=delegatesByMethod.get(methodName);</span><br><span class="line">        <span class="keyword">return</span> method.invoke(delegate,args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newInstance</span><span class="params">(TwoTuple... pairs)</span></span>&#123;</span><br><span class="line">        Class[] interfaces=<span class="keyword">new</span> Class[pairs.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pairs.length;i++)&#123;</span><br><span class="line">            interfaces[i]=(Class) pairs[i].second</span><br><span class="line">        &#125;</span><br><span class="line">        ClassLoader c1=pairs[<span class="number">0</span>].first.getClass().getClassLoader();</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(c1,interfaces,<span class="keyword">new</span> MixinProxy(pairs));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyMixin</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Object mixin=MixinProxy.newInstance(</span><br><span class="line">                tuple(<span class="keyword">new</span> BasicImp(),Basic.class),tuple(<span class="keyword">new</span> TimeStampedImp(),TimeStamped.class),</span><br><span class="line">                tuple(<span class="keyword">new</span> SerialNumberedImp(),SerialNumbered.class));</span><br><span class="line">        Basic b=(Basic)mixin;<span class="comment">//重点在这里</span></span><br><span class="line">        TimeStamped t=(TimeStamped)mixin;</span><br><span class="line">        SerialNumbered s=(SerialNumbered)mixin;</span><br><span class="line">        b.set(<span class="string">"Hello"</span>);</span><br><span class="line">        b.get();</span><br><span class="line">        t.getStamp();<span class="comment">//重点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为只有动态类型而不是静态类型才包含所有的混入类型，因此这种方式依然不如C++的方式好，因为可以在具有这些类型的对象上调用方法之前，你必须被强制要求向下转型到恰当的类型，但是，它明显更接近于真正的混型</p><h2 id="潜在类型机制"><a href="#潜在类型机制" class="headerlink" title="潜在类型机制"></a>潜在类型机制</h2><p>泛型的理想就是能够编写尽可能泛化代码，为了实现这一点，我们需要各种途径来放松带我们代码将要作用的类型所做的限制，同时不丢失静态类型检查的好处，然后，我们就可以编写出无需修改就可以应用于更多情况的代码，即更加“泛化”的代码<br>java泛型看起来是向这一方向迈进了一步，但你编写或使用只是持有对象的泛型时，这些代码可以引用于任何类型，后者，换个角度，“持有器”泛型能够声明：“我不关心你是什么类型”，如果代码不关心它将要作用的类型，那么这种代码就可以真正地被用在任何地方，并因此而相当地泛化<br>还是正如你所看到的那样，<strong>当要在泛型类型上执行操作（即调用Object方法之外的操作）时，就会产生问题，因为擦除要求指定可能会用到的泛型参数的边界，以安全地调用代码中的泛型对象上的具体方法，这是对“泛化”概念 的一种很明显地限制，因为限制了你的泛型类型，使它们继承自特定的类，或者实现特定的接口，在某些情况下，你最终可能会使用普通类或普通接口，因为限定边界的泛型可能会和指定类和接口没有任何区别</strong><br>某些编程语言提供了一种解决方案称为潜在类型机制或结构化参数机制，而更古怪的术语称为“鸭子类型机制”，鸭子理论非常有名，如果“它走起来像鸭子，叫起来像鸭子，那你你就可以将它当作鸭子看待”<br>泛型代码典型地将在泛型类型上调用少量的代码，而且潜在类型机制的语言只要求实现某个方法的子集，而不是某个特定的接口，从而方式了这种限制（并且产生了更加泛化的代码），正由于此，<strong>潜在类型机制使得你可以横跨多个类继承结构，调用不属于某个公共接口的方法，因此，实际上一段代码可以声明：“我不关心你是什么类型，只要你可以speck()和sit()即可</strong>”由于不要求具体类型，因此代码更加泛化<br>潜在类型机制是一种代码组织和复用机制，有了它编写出的代码相对没有它编写出的代码，能够更容易复用，代码组织和复用是所有计算机编程的基本手段，编写一次，多次使用，并在一个位置上保存代码，因为我并未被要求去命名我的代码要操作于其上的确切接口<br><strong>两种支持潜在类型机制的语言实例是Python和C++，Python是动态类型语言（实际上所有的类型检查都发生在运行时），而C++是静态类型语言（类型检查发生在编译期），因此潜在类型机制不要求静态类型还是动态类型检查</strong><br>我们下Python和C++的代码吧，即使你没有学过这两门语言，你也能理解下面代码的概念</p><h2 id="对缺乏潜在类型安全机制的补偿"><a href="#对缺乏潜在类型安全机制的补偿" class="headerlink" title="对缺乏潜在类型安全机制的补偿"></a>对缺乏潜在类型安全机制的补偿</h2><p>尽管java不支持潜在类型机制，但是这并不意味着有界泛型代码不能在不同的类型层次结构之间应用，也就是说，我们仍旧可以创建真正的泛型代码，但是这需要付出一些额外的努力</p><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>下面的profrom就是用了潜在类型机制<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mime</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walkAgainstTheWind</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span></span>&#123;System.out.println(<span class="string">"pretending to sit"</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushInvisibleWalls</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">"Mime"</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartDog</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;System.out.println(<span class="string">"Woof"</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span></span>&#123;System.out.println(<span class="string">"Sitting"</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reproduct</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommunicateReflectively</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">perform</span><span class="params">(Object specker)</span></span>&#123;</span><br><span class="line">        Class&lt;?&gt; spkr=specker.getClass();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Method m = spkr.getMethod(<span class="string">"speak"</span>);</span><br><span class="line">                m.invoke(specker);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                System.out.println(specker + <span class="string">" cannot speak"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Method m = spkr.getMethod(<span class="string">"sit"</span>);</span><br><span class="line">                m.invoke(specker);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                System.out.println(specker + <span class="string">"cannot sit"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(specker.toString(),e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LatentReflection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        CommunicateReflectively.perform(<span class="keyword">new</span> Mime());</span><br><span class="line">        CommunicateReflectively.perform(<span class="keyword">new</span> SmartDog());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的例子，类完全啊彼此分离的，没有任何公共基类（除了Object）或接口,通过反射，CommunicateReflectively.perform()能够动态地确定所需要的方法是否可用并调用它们，它甚至能够处理Mime只具有一个必须的方法这一事实，并能够部分实现其目标</p><h3 id="将一个方法应用于序列"><a href="#将一个方法应用于序列" class="headerlink" title="将一个方法应用于序列"></a>将一个方法应用于序列</h3><p><strong>反射提供了一些有趣的可能性，但是它将所有的类型检查都转移到了运行时，因此在许多情况下并不是我们所希望的，如果能够实现编译器类型检查，这通常更符合要求</strong>，但是有可能实现编译器类型检查和潜在类型机制吗？<br>我们看一个说明这个问题的示例，假设想要创建一个apply()方法，它能够将任何方法应用于谋而序列的所有对象，这是接口看起来并不适合的情况，因为你想要将任何方法应用到一个对象集合，而接口对于描述“任何方法”存在过多的限制，任何用java来实现这个需求呢？<br>最初，我们可以用反射来解决这个问题，由于有JavaSE5的可变参数，这种方法被证明是优雅的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apply</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T ,S extends Iterable&lt;? extends T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(S seq, Method f, Object... args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (T t : seq) &#123;</span><br><span class="line">                f.invoke(t, args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">()</span></span>&#123;System.out.println(<span class="keyword">this</span>+<span class="string">"rotate"</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reSize</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;System.out.println(<span class="keyword">this</span>+<span class="string">"resize"</span>+size);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilledList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">FilledList</span><span class="params">(Class&lt;? extends T&gt; type,<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">              add(type.newInstance());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplyTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        List&lt;Shape&gt;  shapes=<span class="keyword">new</span> FilledList&lt;&gt;(Shape.class,<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            shapes.add(<span class="keyword">new</span> Shape());</span><br><span class="line">        &#125;</span><br><span class="line">        Apply.apply(shapes, Shape.class.getMethod(<span class="string">"rotate()"</span>));</span><br><span class="line">        Apply.apply(shapes,Shape.class.getMethod(<span class="string">"reSize"</span>, <span class="keyword">int</span>.class),<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Square&gt; squares=<span class="keyword">new</span> FilledList&lt;&gt;(Square.class,<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            squares.add(<span class="keyword">new</span> Square());</span><br><span class="line">        &#125;</span><br><span class="line">        Apply.apply(squares,Square.class.getMethod(<span class="string">"retate"</span>));</span><br><span class="line">        Apply.apply(squares,Square.class.getMethod(<span class="string">"reSize"</span>, <span class="keyword">int</span>.class),<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        Apply.apply(<span class="keyword">new</span> FilledList&lt;Shape&gt;(Shape.class,<span class="number">10</span>),Shape.class.getMethod(<span class="string">"retate"</span>));</span><br><span class="line">        Apply.apply(<span class="keyword">new</span> FilledList&lt;Shape&gt;(Square.class,<span class="number">10</span>),Square.class.getMethod(<span class="string">"retate"</span>));</span><br><span class="line">        SimpleQueue&lt;Shape&gt; shapeQ=<span class="keyword">new</span> SimpleQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            shapeQ.add(<span class="keyword">new</span> Shape());</span><br><span class="line">            shapeQ.add(<span class="keyword">new</span> Square());</span><br><span class="line">        &#125;</span><br><span class="line">        Apply.apply(shapeQ,Shape.class.getMethod(<span class="string">"retate"</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们运气很好，因为碰巧在Java中内建了一个由Java容器类库使用的Iterable接口，因此，apply()方法可以接受任何实现了Iterable接口的事物，实际上，它还接受其他任何事物，只要能够使得这些事物是Iterable的就可以了<br>注意，我们必须要使用边界和通配符，以便是Apply和FilledList在所需要的情况下都可以使用，<br><strong>FilledList表示有些进退两难的情况，为了使用某种类型，它必须要有默认的构造器，但是java没有任何方式可以在编译器断言这件事，因此变成了一个运行时问题，确保编译器检查的有个常见的建议是定义一个工厂接口</strong>，它有一个可以生产对象的方法，然后FilledList接受这个接口而不是这个类型标记的“原生工厂（Class对象）”，<strong>但是，大部分的类都是在不了解你的接口的情况下创建的，因此也就没有实现这个接口</strong>，稍后，我们展示一种使用适配器的解决办法<br>使用类型标记是一种合理的折中，错误在运行时报告，所有你要有把握，这些错误将在开发过程的早期出现<br>注意，使用类型标记是java文献推荐的技术，但是也有很多人强烈推荐使用工厂方法让错误在编译器就被发现<br>尽管java解决方案被证明很优雅，但是我们必须知道使用反射（尽管反射在最近的版本中以及明显的改善）可能比非反射的实现要慢一些，因为大多数动作都是在运行时发生的，但是这不应该成为你使用这个解决方案的脚本，至少可以将其作为一种马上就能想到的解决方案  </p><h3 id="当你并未碰巧拥有正确的接口时"><a href="#当你并未碰巧拥有正确的接口时" class="headerlink" title="当你并未碰巧拥有正确的接口时"></a>当你并未碰巧拥有正确的接口时</h3><p>我们看到上面的例子，Iterable接口是内建，我们很容易创建容器并使用它，但是如果不存在刚好适合你的需求的接口呢？<br>看下面一个例子，让我们泛化FilledList中的思想，创建一个参数化的方法fill(),它接受一个序列<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fill</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(Collection&lt;T&gt; collection, Class&lt;? extends T&gt; type, <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                collection.add(type.newInstance());</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Contract</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id =counter++;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getSimpleName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TitleTransfer</span> <span class="keyword">extends</span> <span class="title">Contract</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FillTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       List&lt;Contract&gt; contracts=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       Fill.fill(contracts,Contract.class,<span class="number">3</span>);</span><br><span class="line">       Fill.fill(contracts,TitleTransfer.class,<span class="number">2</span>);</span><br><span class="line">       <span class="keyword">for</span>(Contract c:contracts)&#123;</span><br><span class="line">           System.out.println(c);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//don't work fill()is not generic enough;</span></span><br><span class="line">       <span class="comment">//SimpleQueue&lt;Contract&gt; simpleQueue=new SimpleQueue&lt;&gt;();</span></span><br><span class="line">       <span class="comment">//Fill.fill(simpleQueue,Contract.class,3);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们使用java编写代码时，会陷入问题之中，因为没有任何像前面实例的Iterable接口那样的“Addable”便利接口，因此你不能说：“可以在任何事物上调用add()”,而必须说：“可以在Collection的子类型上调用add()”,这样产生的代码就不是特别泛化，因为它必须被限制为只能工作于Collection的实现，如果我试图使用没有实现Collection的类，那么我的泛化代码将不能工作<br>上面的情况中，因为java设计着（可以理解地）没有预见对“Addable()”接口的需要，所有我们被现在在Collection的继承层次结构之内，即便SimpleQueue有个add()方法，它也不能工作，因此这样的代码不是特别泛化，有了潜在类型机制，情况就会不同了</p><h3 id="用适配器仿真潜在类型机制"><a href="#用适配器仿真潜在类型机制" class="headerlink" title="用适配器仿真潜在类型机制"></a>用适配器仿真潜在类型机制</h3><p>java泛型并不是没有潜在类型机制，而我们需要使用潜在类型机制这样的东西去编写能够跨类边界应用的代码（也就是“泛化”代码），存在某种方式可以绕过这项限制吗？<br>潜在类型机制将在这里实现什么？它意味着你可以编写代码声明：“我不关心我在这里使用的类型，只要它们具有这些方法即可”，<strong>实际上，潜在类型机制创建了一个包含所需方法的隐式接口</strong>，因此它遵循这样的规则，如果我们手工编写了所需的接口（因为java并没有为我们做这些事），那么它就应该能够解决问题<br><strong>从我们拥有的接口中编写代码来产生我们需要的接口，这就是适配器设计模式的一个典型示例</strong>，我们可以使用适配器来适配已有的接口，以产生想要的接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Addable</span>&lt;<span class="title">T</span>&gt;</span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(T item)</span></span>;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fill2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(Addable&lt;T&gt; addable,Class&lt;? extends T&gt; type,<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                addable.add(type.newInstance());</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载的fill()的类型参数Generator&lt;T&gt; 确保了编译期的类型安全，所以将错误阻止在编译期，在运行时不会抛出</span></span><br><span class="line">    <span class="comment">//任何错误，这种方式比使用类型标记更安全</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(Addable&lt;T&gt; addable,Generator&lt;T&gt; generator,<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            addable.add(generator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//to adapter a base Type,you must use composition</span></span><br><span class="line"><span class="comment">//make any Collection Addable using composition</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddableCollectionAdapter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Addable</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Collection&lt;T&gt; c;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AddableCollectionAdapter</span><span class="params">(Collection&lt;T&gt; c)</span></span>&#123; c=c;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T item)</span></span>&#123; c.add(item); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//a Helper to capture the type automatically</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Addable&lt;T&gt; <span class="title">collectionAdapetr</span><span class="params">(Collection&lt;T&gt; c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AddableCollectionAdapter&lt;T&gt;(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//to adapt a specific type,you can use inheritance</span></span><br><span class="line"><span class="comment">//make a SimpleQueue Addable using inheritance</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddableSimpleQueue</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">SimpleQueue</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Addable</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T item)</span></span>&#123; <span class="keyword">super</span>.add(item);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fill2Test</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       List&lt;Coffee&gt; coffees=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       Fill2.fill(<span class="keyword">new</span> AddableCollectionAdapter&lt;&gt;(coffees),Coffee.class,<span class="number">3</span>);</span><br><span class="line">       Fill2.fill(Adapter.collectionAdapetr(coffees),Coffee.class,<span class="number">3</span>);</span><br><span class="line">       Fill2.fill(Adapter.collectionAdapetr(coffees),Latte.class,<span class="number">3</span>);</span><br><span class="line">       <span class="keyword">for</span>(Coffee coffee:coffees)&#123;</span><br><span class="line">           System.out.println(coffee);</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(<span class="string">"-------------------------------------------------------"</span>);</span><br><span class="line">       AddableSimpleQueue&lt;Coffee&gt; coffeeQueue=<span class="keyword">new</span> AddableSimpleQueue&lt;&gt;();</span><br><span class="line">       Fill2.fill(coffeeQueue,Coffee.class,<span class="number">3</span>);</span><br><span class="line">       Fill2.fill(coffeeQueue,Latte.class,<span class="number">3</span>);</span><br><span class="line">       <span class="keyword">for</span>(Coffee coffee:coffeeQueue)&#123;</span><br><span class="line">           System.out.println(coffee);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Fill2对Collection的要求与Fill不同，它只需要实现了Addable的对象，而Addable已经为Fill编写了——它是我希望编译器帮我创建的潜在类型的一种体现<br>在这个版本中，我还<strong>添加了一个重载的fill,它接受一个Generateor而不是类型标记，Generator在编译器是类型安全的，编译器将确保传递的是正确的Generator,因此不会抛出任何异常</strong><br>第一个适配器，AddableCollectionAdapter，可以工作与基类Collection，这意味着Collection的任何实现都可以使用，这个版本直接存储Collection引用，并使用它来实现Add();<br>如果一个具体类型而不是继承结构的基类，那么当使用继承来创建适配器时，你可以稍微少写一些代码，但是这个适配器只适用于为特定的类型适配所需的接口，这种适配器称为“预适配器”，也就是预先定义好的适配器，之间创建使用即可，而第一种适配器需要传递需要适配的接口才能创建，这就是两种适配器设计模式的不同</p><h2 id="将函数对象作为策略"><a href="#将函数对象作为策略" class="headerlink" title="将函数对象作为策略"></a>将函数对象作为策略</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Combiner</span>&lt;<span class="title">T</span>&gt;</span>&#123; <span class="function">T <span class="title">combine</span><span class="params">(T x, T y)</span></span>;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UnaryFunction</span>&lt;<span class="title">R</span>,<span class="title">T</span>&gt;</span>&#123; <span class="function">R <span class="title">function</span><span class="params">(T x)</span></span>;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Collector</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">UnaryFunction</span>&lt;<span class="title">T</span>,<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">result</span><span class="params">()</span></span>;<span class="comment">//extract result of collecting parameter</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UnaryPredicate</span>&lt;<span class="title">T</span>&gt;</span>&#123; <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T x)</span></span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Functional</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">reduce</span><span class="params">(Iterable&lt;T&gt; seq,Combiner&lt;T&gt; combiner)</span></span>&#123;</span><br><span class="line">        Iterator&lt;T&gt; it=seq.iterator();</span><br><span class="line">        <span class="keyword">if</span>(it.hasNext())&#123;</span><br><span class="line">            T result=it.next();</span><br><span class="line">            <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">                result=combiner.combine(result,it.next());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Collector&lt;T&gt; <span class="title">forEach</span><span class="params">(Iterable&lt;T&gt; seq,Collector&lt;T&gt; func)</span></span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(T item:seq)&#123;</span><br><span class="line">           func.function(item);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> func;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;R,T&gt; <span class="function">List&lt;R&gt; <span class="title">transform</span><span class="params">(Iterable&lt;T&gt; seq,UnaryFunction&lt;R,T&gt; func)</span></span>&#123;</span><br><span class="line">        List&lt;R&gt; result=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(T t:seq)&#123;</span><br><span class="line">            result.add(func.function(t));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">filter</span><span class="params">(Iterable&lt;T&gt; seq, UnaryPredicate&lt;T&gt; pred)</span></span>&#123;</span><br><span class="line">        List&lt;T&gt; result =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(T t:seq)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pred.test(t))&#123;</span><br><span class="line">                result.add(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerAdder</span> <span class="keyword">implements</span> <span class="title">Combiner</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">combine</span><span class="params">(Integer a,Integer b)</span></span>&#123;<span class="keyword">return</span> a + b;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerSubtracter</span> <span class="keyword">implements</span>  <span class="title">Combiner</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">combine</span><span class="params">(Integer a, Integer b)</span></span>&#123;<span class="keyword">return</span> a-b;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BigDecimalAdder</span> <span class="keyword">implements</span> <span class="title">Combiner</span>&lt;<span class="title">BigDecimal</span>&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> BigDecimal <span class="title">combine</span><span class="params">(BigDecimal x,BigDecimal y)</span></span>&#123;<span class="keyword">return</span> x.add(y);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BigIntegerAdder</span> <span class="keyword">implements</span> <span class="title">Combiner</span>&lt;<span class="title">BigInteger</span>&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> BigInteger <span class="title">combine</span><span class="params">(BigInteger x,BigInteger y)</span></span>&#123;<span class="keyword">return</span> x.add(y);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">GreaterThan</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; <span class="keyword">implements</span> <span class="title">UnaryPredicate</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> T bound;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">GreaterThan</span><span class="params">(T bound)</span></span>&#123; bound=bound;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T item)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> item.compareTo(bound)&gt;<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiplyingInteger</span> <span class="keyword">implements</span> <span class="title">Collector</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer val=<span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">function</span><span class="params">(Integer x)</span></span>&#123;</span><br><span class="line">            val*=x;</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">result</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; l1= Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>);</span><br><span class="line">       </span><br><span class="line">        Integer addResult=reduce(l1,<span class="keyword">new</span> IntegerAdder());</span><br><span class="line">        Integer substractResult=reduce(l1,<span class="keyword">new</span> IntegerSubtracter());</span><br><span class="line">        List&lt;Integer&gt; listResult=filter(l1,<span class="keyword">new</span> GreaterThan&lt;Integer&gt;(<span class="number">4</span>));</span><br><span class="line">        forEach(l1,<span class="keyword">new</span> MultiplyingInteger()).result();</span><br><span class="line">        <span class="comment">//省略不写</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>策略模式可以产生非常优雅得的代码，因为它将“变化的事物”完全隔离到一个函数对象<strong>，函数对象就是在某种程度上行为像函数的对象——一般地，会有一个相关的方法，函数对象的价值就在于，与普通的方法不同，它们可以传递出去，并且还可以拥有在多个调用之间持久化的状态，当然可以用类中的任何方法来实现与此相似的工作，但是（与使用任何设计模式一样）函数对象主要是由其目的来区别的</strong>这里的，目的即使要创建某种事物，使它的行为就像一个可以传递出去的单个方法一样，这样，它就和策略模式紧耦合了，有时甚至无法区分<br>其实各种设计模式之间的界限真的很模糊，有时很难区分，有时靠设计目的区分，所以没有绝对的模式</p><h2 id="总结：转型真的如此之糟吗？"><a href="#总结：转型真的如此之糟吗？" class="headerlink" title="总结：转型真的如此之糟吗？"></a>总结：转型真的如此之糟吗？</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;一般的类和方法，只能使用具体的类型，要么是基本类型，那么是自定义的类，如果要编写可以应用与多种类型的代码，这种刻板的限制对代码的束缚就会很大
      
    
    </summary>
    
      <category term="学习心得" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>类型信息</title>
    <link href="http://yoursite.com/2018/10/12/%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF/"/>
    <id>http://yoursite.com/2018/10/12/类型信息/</id>
    <published>2018-10-12T05:21:23.000Z</published>
    <updated>2018-10-12T17:52:21.559Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>运行时类型信息（runtime Type information）使得你可以在程序运行时发现和使用类型信息<br>它使你从只能在编译期执行面向类型的操作的禁锢中解脱出来<br>java是如何让我们在运行时识别对象和类的信息的，主要有两种方式，一种是“传统的”RTTI，它假定我么不能在编译时已经知道了所有的类型，另一种是“反射”机制，它允许我们在运行时发现和使用类的信息  </p><h2 id="为什么需要RTTI"><a href="#为什么需要RTTI" class="headerlink" title="为什么需要RTTI"></a>为什么需要RTTI</h2><p>我们看一下多态的例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123; System.out.print(<span class="keyword">this</span>+<span class="string">".draw()"</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cricle</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">"Cricle"</span>;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">"Square"</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shapes</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;Shape&gt; shapeList= Arrays.asList(<span class="keyword">new</span> Cricle(),<span class="keyword">new</span> Square());</span><br><span class="line">        <span class="keyword">for</span>(Shape shape:shapeList)&#123;</span><br><span class="line">            shape.draw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个例子中，当把Shape对象放在List<shape>列表时会向上转型，但向上转型为Shape的时候，也丢失了Shape对象的具体的类型，对于列表而言，它们只是Shape类型的对象（我们这样思考一个问题，为什么我们在编程的时候，没有使用具有的引用类型，而是向上转型为更加通用的类型引用，诚然，我们可以使用更具体的类型来表示对象类型，拥有更多的方法可以操作这个类型，但是我们却没有办法写更适用的代码，每一个代码片段都与特定类型相关联，耦合度太高，我们要将类型向上转型为它的基类，这样拥有同样的接口，但是却丢失了关于这个对象具体类型的信息，<strong>注意，我们说的丢失了具体类型的信息指的是在编译期，在编译期，我们会将它的对象类型当作基类看待，实际上，对象本身的类型信息并没有丢失，我们可以在程序运行的时候重新拿到本来属于它的身份（类型信息）</strong>，这就是运行时类型信息的全部解释）<br>当从列表中取出元素时，这种容器——实际上将它所有的事物都当成Object持有——会自动将结果转型回Shape的，在java中所有的类型转换都是在运行是进行正确的检查，这也是RTTI名字的含义，在这个例子中，RTTI类型转换的并不彻底，Object被转型为Shape，而不是转换成Cricle，Square这种更具体的类型，这是因为我们只知道这个List<shape>保存的是Shape，将由容器和Java泛型机制保证这一点，而在运行时，由类型转换确保这一点</shape></shape></p><h2 id="Class对象"><a href="#Class对象" class="headerlink" title="Class对象"></a>Class对象</h2><p>要理解RTTI在java中的工作原理，首先必须知道类型信息在运行时是如何表示的，这项工作是被称为Class对象的特殊对象完成的，它包含了与类相关的信息， Class对象就是用来创建类的所有“常规”对象的，java使用Class对象来执行其RTTI，即使你正在执行类型转换这样的工作<br>类是程序的一部分，每个类都是一个Class对象，换言之，每当编写并且编译一个新类，就会产生一个Class对象（更恰当的说，是保存在一个同名的.class文件中，这个.class文件保存在关于这个类的一切信息，我们可以将这个.class文件看作对象，这和类加载之后在内存中创建的Class对象没有太大的分别，最大的区别也许就是存储位置的不同）为了生成这个类的对象，运行这个程序的Java虚拟机（JVM)将使用被称为“类加载器”的子系统<br>所有的类都是在第一次被使用时，动态加载到JVM中的，当程序创建第一个对类的静态成员的引用时，就会加载这个类，这额证明了构造器也是静态方法，虽然在它之前没有static关键字，因此，java程序在它开始之前并非完全加载，其各个部分都是在必需时才加载的，如果尚未加载，默认的类加载器就会根据类名查找.class文件，而这个类的字节码文件就被加载，它会接受验证，以确保其没有被破坏，并且不包含不良的Java代码<br>（从我的理解来看，程序是对象与对象之间通讯，而Class掌握着生成这些对象和怎样通讯的所有知识，我们编写程序就是编写这些类，类由虚拟机加载，并且通过虚拟机创建对象，互相在对象之间传递消息，那么虚拟机是什么？虚拟机是程序，是代码运行的平台，我们编写的类都是程序的构件，以供虚拟机使用）<br>一旦某个类的Class对象被载入内存，它就被用来创建这个类的所有对象</p><pre><code>Class Class.forName(String className);</code></pre><p>上面的方法是Class类的一个静态方法，返回一个Class对象的引用，如果你有某个对象的引用，也可以使用Object的getClass()方法，得到一个Class对象的引用，对forName()的调用就是为了产生副作用，其实更准确的说，forName()方法的调用是为了加载某个类，所有，如果这个类还没有被加载，那么就加载它，在加载的过程中，类的static子句开始执行<br>记住，所有的Class对象都是Class类，这听起来感觉很奇怪，我们知道类的所有信息都是在.class文件保存着，类加载器子系统通过这些文件会在内存空间创建相应的Class对象，其实这些对象和普通的对象的共同点就是对象，只不过这个Class对象拥有着这个类型信息，而其他对象拥有着属性数据，那么这些Class对象之间肯定有着某种共性，而这种共性就是它们都是Class类型<br>我们得到了Class对象的引用，就可以操作它以获得它的数据（类型信息）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getName()</span><br><span class="line">getSimpleName()</span><br><span class="line">getCanonicalName()</span><br><span class="line">getInterfaces()</span><br><span class="line">isInterface()</span><br><span class="line">getSuperClass()</span><br><span class="line">newInstance()</span><br></pre></td></tr></table></figure></p><p>Class对象的newInstance()方法是实现“虚拟构造器”的一种途径，虚拟构造器允许你声明“我不知道你的确切类型”，但是啊无论如何要正确地创建你自己，<strong>比如up是一个Class引用，在编译期不具备任何更进一步的类型信息，当你创建新实例时，会得到一个Object对象</strong>，但是这个引用指向一个确切的类型，当然你可以发送Object能够接受的信息之外的任何消息之前，你必须更多的了解它，并进行某种转型，另外，使用newInstance()必须带有默认的构造器  </p><h3 id="类字面常量"><a href="#类字面常量" class="headerlink" title="类字面常量"></a>类字面常量</h3><p>java提供了另一种方法来生成对Class对象的引用，即使用类字面量常量 例如<br>    FancyToy.class<br>这样做不仅更简单，而且也更安全，因为它在编译时就会受到检查（因此不需要置于try语句块中），并且它根除了forName()方法的调用，所有也更高效<br>建议使用“.class”的形式，以保持与普通类的一致性<br>注意，有一点很有趣，使用“.class”来创建对Class对象的引用时，不会自动地初始化Class对象，为了使用类而做的准备工作实际上包含三个步骤</p><ol><li>加载：这是类加载器执行的，该步骤将查找字节码，并从这些字节码中创建一个Class对象</li><li>链接：在链接阶段将验证类中的字节码，为静态域分配存储空间，并且如果必需的话，将解析这个类对其他类的所有引用</li><li>初始化：如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块<br>初始化被延迟到了对静态方法（构造器隐式地是静态的）或非常数静态方法进行首次引用是才执行<br>初始化有效地实现了尽可能的“惰性”，仅使用.class语法来获得对类的引用不会引发初始化，和是和forName()不同的  <h3 id="泛化的Class引用"><a href="#泛化的Class引用" class="headerlink" title="泛化的Class引用"></a>泛化的Class引用</h3>Class引用总是指向某一个Class对象，它可以制造类的实例，并包含可作用与这些实例的所有方法代码，它还包括了该类的静态成员。因此。Class引用表示的就是指向它所指对象的确切类型，而该对象表示Class类的一个对象<br>如何将它的类型变得更具体，而<strong>这是通过允许你对Class引用所指向的Class对象的类型进行限定而实现的</strong>，这里使用了泛型语法，比如<br> Class<integer> classRef=int.class;<br>你也许会认为，下面的代码也是正确的<br> Class<number> classRef=int.class;<br>但是它是无法工作的，虽然Number是Integer的基类，但是Integer的Class对象不是Number的Class对象的子类，这个例子的正确做法是<br> Class&lt;? extends Number&gt; classRef=int.class;<br>当你使用泛型语法的时候将会发生一件有趣的事情，newInstance()将会返回该对象的确切的类型，而不是基本的Object,如下：<h3 id="新的转型语法"><a href="#新的转型语法" class="headerlink" title="新的转型语法"></a>新的转型语法</h3>Class引用的转型语法 cast()  不过我们很少使用<h2 id="类型转换前先做检查"><a href="#类型转换前先做检查" class="headerlink" title="类型转换前先做检查"></a>类型转换前先做检查</h2>目前我们已知的RTTI形式包括</number></integer></li><li>传统的类型转换 如“(Shape)” 由RTTI确保类型转换的正确性，如果执行了一个错误的转换，就会抛出一个ClassCastException</li><li>代表对象的类型的Class对象，通过查询Class对象可以获取运行时所需的信息</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;运行时类型信息（runtime Type information）使得你可以在程序运行时发现和使用类型信息&lt;br&gt;它使你从只能在编译期执行面
      
    
    </summary>
    
      <category term="学习心得" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>字符串</title>
    <link href="http://yoursite.com/2018/10/11/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://yoursite.com/2018/10/11/字符串/</id>
    <published>2018-10-11T11:14:03.000Z</published>
    <updated>2018-10-12T05:20:29.109Z</updated>
    
    <content type="html"><![CDATA[<h2 id="不可变String"><a href="#不可变String" class="headerlink" title="不可变String"></a>不可变String</h2><p>&emsp;&emsp;String对象是不可变的，查看JDK文档，会发现，String类中每一个看起来会修改String值的方法，实际上都是创建了一个全新的String对象，以包含修改后的字符串内容，而最初的String对象纹丝未动，当吧String对象作为方法的参数时，都会复制一份引用，而该引用所指的对象其实一直待在单一的物理位置上，从未动过<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Immutable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">upcase</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String q=<span class="string">"howdy"</span>;</span><br><span class="line">        System.out.print(q);<span class="comment">//howdy</span></span><br><span class="line">        String qq=upcase(q);</span><br><span class="line">        System.out.print(qq);<span class="comment">//HOWDY</span></span><br><span class="line">        System.out.print(q);<span class="comment">//howdy</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;上例upcase()返回的引用已经指向了一个新的对象了，而原本的q则还在原地<br>&emsp;&emsp;String的这种行为方式其实正是我们想要的，难道我们真的希望upcase()改变参数的行为吗？参数是为该方法提供信息的，而不是先让该方法改变自己的</p><h2 id="重载“-”与StringBuilder"><a href="#重载“-”与StringBuilder" class="headerlink" title="重载“+”与StringBuilder"></a>重载“+”与StringBuilder</h2><p>&emsp;&emsp;String对象的不可变性带来了效率的问题，为String对象重载的“+”操作符就是一个例子，重载的意思是，一个操作符在应用于不同的类上，被赋予老特殊的含义<br>&emsp;&emsp;我们经常使用“+”操作进行字符串的拼接，可是由于String对象的不可变性，我们猜想每一次的连接操作都会产生一个新的String对象，若是进行多次的拼接操作，会有大量的中间String对象产生，会造成内存资源的浪费和垃圾回收器的负担，比如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String concatStr=<span class="string">"asdad"</span>+<span class="string">"asdas"</span>+<span class="string">"sfadfdf"</span>+<span class="string">"asdasd"</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;但是当我们使用javap，对上述代码jinx反编译的时候，就会看到，在进行字符拼接的时候，编译器帮我们做了优化，首先new StringBuilder对象，通过append()方法拼接，使用toString()返回一个字符串对象，编译器以及帮我们的源码进行了优化，那么是否我们就确信编译器优化，而毫无考虑的就到处使用“+”操作符进行字符串的拼接操作呢？我们在看一个例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(String str:StringArr[])&#123;</span><br><span class="line">    s+=str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">for</span>(String str:StringArr)&#123;</span><br><span class="line">   sb.append(str);</span><br><span class="line">&#125;</span><br><span class="line">sb.toString();</span><br></pre></td></tr></table></figure></p><p>我们在进行javap进行反编译，可知在上面的第一个例子，每次循环内都要创建new StringBuilder(),而第二个例子只创建一次，那么这个例子就可以说明什么时候应该使用StringBuilder来对字符串进行拼接操作了<br>StringBuilder提供了丰富而全面的方法，包括insert(),replace(),subString()甚至reverse(),但是最常用的还是append()a,toString()，还有delete()<br>Stringbuilder是Java SE5引入的，在这之前java用的是StringBuffer,后者是线程安全的，因此开销也会大些  </p><h2 id="无意识的递归"><a href="#无意识的递归" class="headerlink" title="无意识的递归"></a>无意识的递归</h2><p>我们一般经常都会调用一个对象的toString()方法，比如容器的打印，实际上也会调用每个元素的toString()方法，若我们想要打印对象的内存地址怎么办呢？下面是一个对象，重新定义了toString()方法，并且打印自己的内存地址<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InfiniteRecursion</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"asdasdas"</span>+<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的定义是对的吗？完全错误，如果我们调用这个对象的toString()方法就会导致递归，因为我们对this也执行了toString()调用，没完没了，正确的方法如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="string">"asdasdas"</span>+<span class="keyword">super</span>.toString();</span><br></pre></td></tr></table></figure></p><p>因为这样会调用基类的toString方法，就避免了递归</p><h2 id="String上的操作"><a href="#String上的操作" class="headerlink" title="String上的操作"></a>String上的操作</h2><p>下面是String对象具备的一些基本操作  </p><table><thead><tr><th>方法</th><th>参数，重载版本</th><th>应用</th></tr></thead><tbody><tr><td>构造器</td><td>重载版本：默认版本，String，StringBuilder<br>StringBuffer char数组，byte数组</td><td>创建String对象</td></tr><tr><td>length()</td><td></td><td>String中字符的个数</td></tr><tr><td>charAt()</td><td>int索引</td><td>取得String中该索引位置上的char</td></tr><tr><td>getChars(),getBytes()</td><td>要复制部分的起点和终点的索引，<br>复制的目标数组，目标数组，目标数组的起始索引</td><td>复制char或byte到一个目标数组中</td></tr><tr><td>toCharArray()</td><td></td><td>生成一个char[]</td></tr><tr><td>equals(),equalsIgnoreCase()</td><td>与之进行比较的String</td><td>比较两个String的内容是否相同</td></tr><tr><td>compareTo()</td><td>与之进行比较的String</td><td>按词典顺序比较String的内容，比较结果为负数，零，正数，注意，大小写不等价</td></tr><tr><td>contains()</td><td>要搜索的CharSequence</td><td>如果该String对象包含参数的内容，则返回true</td></tr><tr><td>containEquals()</td><td>与之进行比较的CharSequence或StringBuffer</td><td>如果该String与参数的内容一致，则返回true</td></tr><tr><td>equealsIgnoreCase()</td><td>与之进行比较的String</td><td>忽略大小写的比较相等性</td></tr><tr><td>regionMatcher()</td><td>该String的索引偏移量，另一个String及其索引偏移量，<br>要比较的长度，重载版本增加了“忽略大小写”功能</td><td>返回boolean结果，已表明所比较区域是否相等</td></tr><tr><td>StartsWith()</td><td>可能的起始String，重载版本在参数中增加了偏移量</td><td>返回值为boolean值</td></tr><tr><td>endsWith()</td><td>该String可能的后缀String</td><td>返回boolean值</td></tr><tr><td>indexOf(),lastIndexOf()</td><td>重载版本包括：char，char与起始索引，<br>String，String与起始索引</td><td>如果该String并不包含此参数，就返回-1<br>否则返回此参数在String中的起始索引，lastIndexOf()是从后向前搜索</td></tr><tr><td>subString()(subSequence())</td><td>重载版本：起始索引;起始索引+终点索引</td><td>返回一个新的String，以包含参数指定的字符串</td></tr><tr><td>concat()</td><td>要连接的字符串</td><td>返回一个新的String对象，内容为原始String连接上参数String</td></tr><tr><td>replace()</td><td>要替换掉的字符，用来进行替换的新字符。<br>也可以用一个CharSequence来替换另一个CharSequence</td><td>返回替换字符后的新String对象<br>如果，没有替换发生，则返回原始的String对象</td></tr><tr><td>toLowerCase(),toUpCase()</td><td></td><td>将字符的大小写改变，返回一个新的字符串</td></tr><tr><td>trim()</td><td></td><td>将字符串两端的空白字符删除</td></tr><tr><td>valueOf()</td><td>重载版本：Object;char[];char[],偏移量，与字符个数；<br>boolean；char;int;lang;float;double</td><td>返回一个表示参数内容的String</td></tr><tr><td>intern()</td><td></td><td>为每个唯一的字符序列生成一个且仅生成一个String引用  </td></tr></tbody></table><h2 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h2><p>在长久的等待之后，java SE5终于推出了C语言中printf()风格的格式化输出</p><h3 id="System-out-format"><a href="#System-out-format" class="headerlink" title="System.out.format"></a>System.out.format</h3><p>java SE5引入的format()方法可用于PrintStream或PrintWriter对象，format()方法模仿C语言的printf()，它只需要一个简单的格式化字符串和一串的参数就可，语法如下.以System.out为例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.format(<span class="string">"Row 1:[%d %f]\n"</span>,x,y);</span><br></pre></td></tr></table></figure></p><h3 id="Formatter类"><a href="#Formatter类" class="headerlink" title="Formatter类"></a>Formatter类</h3><p>在java中，所有新的格式化功能都由java.util.Formatter类处理,可以将Formatter看作一个翻译机，它将你的格式化字符串与数据翻译成需要的结果，当你创建一个Formatter对象的时候，可以向其构造器传递一些信息，告诉它最终的结果将向哪里输出  </p><h3 id="格式化说明符"><a href="#格式化说明符" class="headerlink" title="格式化说明符"></a>格式化说明符</h3><p>在插入数据时，如果想要控制空格与对齐，你需要更精细复杂的格式修饰符，一下是其抽象的语法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[argument_index$][flags][width].[precision]conversion</span><br></pre></td></tr></table></figure></p><p>最常用的是width控制一个域的最小尺寸，数据是右对齐的，可以添加“-”标志来控制对其方向<br>不是所有类型的元素都能用precision，而且不同类型的元素使用precision代表的含义也不相同<br>Formatter转换（conversion）<br>下面包含了最常用的类型转换   </p><table><thead><tr><th></th><th>：类型转换：</th></tr></thead><tbody><tr><td>d</td><td>整数型（十进制）</td></tr><tr><td>c</td><td>unicode字符</td></tr><tr><td>b</td><td>Boolean值</td></tr><tr><td>s</td><td>String</td></tr><tr><td>f</td><td>浮点数（十进制）</td></tr><tr><td>e</td><td>浮点数（科学计数）</td></tr><tr><td>x</td><td>整数（十六进制）</td></tr><tr><td>h</td><td>散列码</td></tr><tr><td>%</td><td>字符“%”</td></tr></tbody></table><h3 id="String-format"><a href="#String-format" class="headerlink" title="String.format()"></a>String.format()</h3><p>java SE5也参考了C的sprintf()的方法，以生成格式化的String对象，String.format()是一个static方法，它接受与Formatter.format()相同的参数，但返回一个String对象，当你只使用formatter()方法一次的时候，String.format()是个不错的选择，语法 类似如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String result = String.format(<span class="string">"(t%d,q%d) %s"</span>,transcationID,queryID,message);</span><br></pre></td></tr></table></figure></p><p>其实在String.format()内部，它是创建一个Formatter对象，然后将你的参数传递给它，不过与其自己做这些事情，不如使用便捷的String.format()代码更清晰易读</p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式是一种强大而灵活的文本处理工具，<strong>使用正则表达式，我们能够以编程的方式，构造复杂的文本，并对输入的字符串进行搜索，一旦找到匹配这些模式的部分，你就能够随心所欲地对它们进行处理</strong>，正则表达式提供了一种完全通用的方式，能够解决各种字符串处理相关的问题，匹配，选择，编辑以及验证</p><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>在其他的语言中,\\表示“我想要在表达式中插入一个普通的反斜线，请不要给他任何特殊的意义，而在java中，\\的意思是”我要插入正则表达式的反斜线，”，所以其后的字符具有一个特殊的意义，你想插入一个普通的反斜线，则应该这样\\\\”<br>应用正则表达式最简单的途径，就是利用String类内建的matches()方法<br>String还有一个非常有用的正则表达式工具——split()方法，其功能是“将字符串从正则表达式匹配的地方切开”，split()还有一个重载的版本，它允许你限制字符串分割的次数<br>如果只是需要使用一次正则表达式，那么上面的方法是很方便的吗，但是如果你想对一个正则表达式反复复用，那么非String类型的正则表达式具备更加的性能和功能</p><h3 id="创建正则表达式"><a href="#创建正则表达式" class="headerlink" title="创建正则表达式"></a>创建正则表达式</h3><hr><table><thead><tr><th></th><th>字符</th></tr></thead><tbody><tr><td>B</td><td>指定字符B</td></tr><tr><td>\xhh</td><td>十六进制值为0xhh的字符</td></tr><tr><td>\uhhhh</td><td>十六进制表示为oxhhhh的Unicode字符</td></tr><tr><td>\n</td><td>换行符</td></tr><tr><td>\t</td><td>制表符</td></tr><tr><td>\r</td><td>回车</td></tr><tr><td>\f</td><td>换页</td></tr><tr><td>\e</td><td>转义（Escape）</td></tr></tbody></table><table><thead><tr><th></th><th>字符类</th></tr></thead><tbody><tr><td>.</td><td>任意字符</td></tr><tr><td>[abc]</td><td>包含a,b，c的任何字符（和a</td><td>b</td><td>c作用相同）</td></tr><tr><td>[^abc]</td><td>除了a,b,c之外的任意字符（否定）</td></tr><tr><td>[a-zA-Z]</td><td>从a到或从A到Z的任何一个字符</td></tr><tr><td>[abc[hij]]</td><td>任意a,b,c,h.i,j的字符（与a</td><td>b</td><td>c</td><td>h</td><td>i</td><td>j的作用相同）</td></tr><tr><td>[a-z&amp;&amp;[hij]]</td><td>任意h,i,j（交集）</td></tr><tr><td>\s</td><td>空白符（空格，tab,换行，换页或回车）</td></tr><tr><td>\S</td><td>非空白符</td></tr><tr><td>\d</td><td>数字[0-9]</td></tr><tr><td>\D</td><td>非数字[^0-9]</td></tr><tr><td>\w</td><td>词字符[a-zA-Z0-9]</td></tr><tr><td>\w</td><td>非词字符[^\w]</td></tr></tbody></table><table><thead><tr><th></th><th>逻辑操作符</th></tr></thead><tbody><tr><td>XY</td><td>Y紧跟在X后面</td></tr><tr><td>X</td><td>Y</td><td>X或Y</td></tr><tr><td>(X)</td><td>捕获组（capturing group）可以在表达式中引用\i第一i个捕获组</td></tr></tbody></table><table><thead><tr><th></th><th>边界匹配符</th></tr></thead><tbody><tr><td>^</td><td>一行的起始</td></tr><tr><td>$</td><td>一行的结束</td></tr><tr><td>\b</td><td>非词的边界</td></tr><tr><td>\B</td><td>词的边界</td></tr><tr><td>\G</td><td>前一个匹配的结束</td></tr></tbody></table><h3 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h3><p>量词描述了一个模式吸收输入文本的方式：</p><ul><li>贪婪型：量词总是贪婪的，除非有其他的选项被设置，贪婪表达式会为所有可能的模式发现尽可能多的匹配，导致此问题的一个典型理由就是假定我们的模式仅能匹配第一个可能的字符组，如果它是贪婪的，那么它就会继续往下匹配  </li><li>勉强型：用问好来指定，这个量词匹配满足模式所需最少字符数，因此也称做懒惰的，最少匹配的，非贪婪的，或不贪婪的  </li><li>占有型：目前，这种类型的量词只有java语言中才可用，并且也更高级，当正则表达式被应用于字符串时，它会产生相当多的状态，以便在匹配失败时可以回溯，而“占有的”量词并不保存这些中间状态，因此它们可以防止回溯，它们常常用于防止正则表达式失控，因此可以使正则表达式执行起来更有效  </li></ul><table><thead><tr><th></th><th>贪婪型</th><th>勉强型</th><th>占有型</th><th>如何匹配</th></tr></thead><tbody><tr><td>X?</td><td>X??</td><td>x?+</td><td>一个或零个X</td></tr><tr><td>X*</td><td>X*?</td><td>X*+</td><td>零个或者多个X</td></tr><tr><td>X+</td><td>X+?</td><td>X++</td><td>一个或者多个X</td></tr><tr><td>X{n}</td><td>X{n}?</td><td>X{n}+</td><td>恰好n次</td></tr><tr><td>X{n,}</td><td>X{n,}?</td><td>X{n,}+</td><td>至少n次</td></tr><tr><td>X{n,m}</td><td>X{n,m}?</td><td>X{n,m}+</td><td>X至少n次，最多m次</td></tr></tbody></table><p>要非常注意的是表达式X必须要用圆括号括起来，以便它能按照我们期望的效果去执行，例如 abc+和（abc）+,前面的表示表示匹配ab，后面跟随1个或者多个c，而(abc)+表示匹配一个或者多个abc<br>接口CharSequence从CharBuffer,String,StringBuffer,StringBuilder类之中抽象出了字符序列的一般化定义<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CharSequenece</span></span>&#123;</span><br><span class="line">  charAt();</span><br><span class="line">  length();</span><br><span class="line">  subSequence(<span class="keyword">int</span> start,<span class="keyword">int</span> end);</span><br><span class="line">  toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因此，这些类都实现了接口，多数正则表达式操作都接受CharSequence类型的参数  </p><h3 id="Pattern和Matcher"><a href="#Pattern和Matcher" class="headerlink" title="Pattern和Matcher"></a>Pattern和Matcher</h3><p>比起功能有限的String，我们更愿意构造功能强大的正则表达式对象，只需要导入java.util.regex包，然后用static Pattern.compile()方法来编译你的正则表达式即可，它会根据你的String类型的正则表达式生成一个Pattern对象，接下来，把你想要检索的字符串传入Pattern对象的matcher()方法会生成一个Matcher对象，它有很多功能可用，例如它的replaceAll()方法能够将所有匹配的部分替换成你传入的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRegularExpression</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            System.out.print(<span class="string">"args's count is not right"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String arg:args)&#123;</span><br><span class="line">            Pattern p = Pattern.compile(arg);</span><br><span class="line">            Matcher m = p.matcher(<span class="string">"args[0]"</span>);</span><br><span class="line">            <span class="keyword">while</span>(m.find())&#123;</span><br><span class="line">                System.out.print(m.group()+m.start()+m.end());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Pattern变量表示编译后的正则表达式，我们可以使用编译后的Pattern对象的matcher()方法，加上一个输入字符串，从而共同构造一个Matcher对象，同时Pattern类还提供了一个静态方法<br>    static boolean matcher(String regex,CharSequence input)<br>编译后的Pattern对象还提供了split()方法，它从匹配的regex的地方分割字符串，返回分割后的字符串的一个String数组<br>通过调用Pattern.matcher()方法，我们得到一个Matcher对象，使用Matcher上的方法，我们能够判断各种不同类型的匹配是否成功<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">lookingAt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">find</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> start)</span></span></span><br></pre></td></tr></table></figure></p><p>其中的matches()方法用来判断这个输入字符串是否匹配正则表达式，而lonkingAt()则用来判断该字符串（不必是整个字符串）的始部分是否匹配模式<br>find()像迭代器那样向前办理输入字符串，而第二个find(int start),该参数表示字符串中的字符位置，并以其作为搜索的起点</p><h3 id="Group-组"><a href="#Group-组" class="headerlink" title="Group(组)"></a>Group(组)</h3><p>组是用括号划分的正则表达式，可以根据组的编号来引用某个组，组号0表示整个表达式，组号1表示被第一对括号括起来的组，依次类推<br>A(B(C))D,这里有三个组，组0是ABCD,组1是BC,组2是C<br>Matcher（匹配器）对象提供了一些列的方法，用来获取与组相关的信息<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">groupCount</span><span class="params">()</span><span class="comment">//返回该匹配器的模式中的分组数量，第0组不算</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">group</span><span class="params">()</span><span class="comment">//返回前一次操作（例如find()）的第0组</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">group</span><span class="params">(<span class="keyword">int</span> i)</span><span class="comment">//返回前一次匹配操作期间指定的组号，如果匹配成功，但是指定的组没有匹配任何输入字符串的任何部分，则会返回null  </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> group)</span><span class="comment">//返回在前一次匹配操作中寻找到的组的起始索引</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">end</span><span class="params">(<span class="keyword">int</span> group)</span><span class="comment">//返回在前一次匹配操作中寻找到的组的最后一个字符索引加1的值</span></span></span><br></pre></td></tr></table></figure></p><p>start()和end()会返回前一次匹配操作的第一个字符位置和最后一个字符位置+1，如果匹配失败（或先于一个正在进行的匹配操作去尝试）。调用start()或end()都会产生一个IllegalStatException异常<br>find()可以在输入的任意位置定位正则表达式，而lookingAt()和matches()只有在正则表达式与输入的最开始位置处开始匹配才会成功</p><h3 id="Pattern标记"><a href="#Pattern标记" class="headerlink" title="Pattern标记"></a>Pattern标记</h3><p>Pattern的compile()还有另一个版本，它接受一个标记参数，以调整匹配的行为</p><pre><code>Pattern.compile(String regex,int flag)</code></pre><p>其中的flag来自一下Pattern类中的常量  </p><table><thead><tr><th></th><th>编译标记</th><th>效果</th></tr></thead><tbody><tr><td>Pattern.CONON_EQ</td><td>两个字符当且仅当它们的完全规范分解相匹配时</td></tr><tr><td>Pattern.CASE.INSENSITIVE(?!)</td><td>默认情况下，大小写不敏感的匹配假定只有US-ASCII字符集中的字符才能进行，这个标记允许模式匹配不必考虑大小写（大写或小写），通过指定UNICODE_CASE标记及结合此标记，基于Unicode的大小写不敏感的匹配就可以开启了</td></tr><tr><td>Pattern.COMMENTS(?x)</td><td>在这种模式下，空格符将被忽略，并且以“#”开始直到行尾的注释也会被忽略掉，通过嵌入的标记表达式也可以开启Unix的行模式</td></tr><tr><td>Pattern.DOTALL(?s)</td><td>在dotall模式中，表达式“.”匹配所有的字符，包括行终结符。默认情况下“.”表达式不匹配行终结符</td></tr><tr><td>Pattern.MULTILINE</td><td>在多行模式下，表达式^和$分别匹配一行的开始和结束，^还匹配输入字符串的开始，而$还匹配输入字符串的结尾，默认情况下，这些表达式仅匹配输入的完整的字符串的开始和结束</td></tr><tr><td>Pattern.UNICODE_CASE(?u)</td><td>当指定这个标记，并且开启CASE.INSENSITIVE时，大小写不敏感的匹配将按照与Unicode标准相一致的方式进行，默认情况下，大小写不敏感的匹配假定只能在US-ASCII字符集中的字符才能进行  </td></tr><tr><td>Pattern.UNIX_LINES(?d)</td><td>在这种模式下，^和$行为中，其识别行终结符\n  </td></tr></tbody></table><h3 id="替换操作"><a href="#替换操作" class="headerlink" title="替换操作"></a>替换操作</h3><p>正则表达式特别便于替换文本，它提供了许多方法，replaceFirst(String replaceStr)替换掉第一个匹配成功的部分,replaceAll(String replaceStr)替换掉所有匹配成功的部分。appendReplacement(StringBuffer sbuf,String replaceent)此方法重要，允许你调用其他的方法来生成或处理replacement(replaceFirst()和replaceAll()则只能使用一个固定的字符串)，使得你能够以编程的方式来将目标分割成组，从而具备更强大的替换功能，appendTail(StringBuffer sbuf)，在执行完appendReplacement()之后，调用此方法可以将输入字符串余下的部分复制到sbuf中  </p><h3 id="reset"><a href="#reset" class="headerlink" title="reset()"></a>reset()</h3><p>通过reset()方法，可以将现有的Matcher对象应用于一个新的字符序列<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Resetting</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Matcher matcher = Pattern.compile(<span class="string">"[firb[aiu][gx]]"</span>).matcher(<span class="string">"fix the rug with bgs"</span>);</span><br><span class="line">        <span class="keyword">while</span>(matcher.find())&#123;</span><br><span class="line">            System.out.print(matcher.group());</span><br><span class="line">        &#125;</span><br><span class="line">        matcher.reset(<span class="string">"fix the rig rags"</span>);</span><br><span class="line">        <span class="keyword">while</span>(matcher.find())&#123;</span><br><span class="line">            System.out.print(matcher.group());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="正则表达式与I-O"><a href="#正则表达式与I-O" class="headerlink" title="正则表达式与I/O"></a>正则表达式与I/O</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;不可变String&quot;&gt;&lt;a href=&quot;#不可变String&quot; class=&quot;headerlink&quot; title=&quot;不可变String&quot;&gt;&lt;/a&gt;不可变String&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;String对象是不可变的，查看JDK文档，会发现，Stri
      
    
    </summary>
    
      <category term="学习心得" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>通过异常处理错误</title>
    <link href="http://yoursite.com/2018/10/11/%E9%80%9A%E8%BF%87%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF/"/>
    <id>http://yoursite.com/2018/10/11/通过异常处理错误/</id>
    <published>2018-10-11T07:57:21.000Z</published>
    <updated>2018-10-11T11:11:58.096Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;java的理念是：结构不佳的代码不能运行<br>&emsp;&emsp;发现错误最好的时期是在编译阶段，也就是在你试图运行程序之前，然而，编译期间并不能找出所有的错误，余下的错误必须要在运行期间解决，这就需要错误源能够通过某种方式，将恰当的信息传递给某个对象——该接收者知道如何正确处理这个问题<br>&emsp;&emsp;改进的错误恢复机制是提供代码健壮性的最强有力的方式，错误恢复在我们所编写的每一个程序都是基本的元素，java使用异常来提供一直的错误报告模型，<strong>使得构件能与客户端代码可靠地沟通问题</strong>  </p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>&emsp;&emsp;C以及早期的语言常常具有多种错误处理模式，这些模式往往建立在约定俗成的基础之上，而这不属于语言的一部分，通常会返回某个特殊值或者设置某个标志，并且假定接收者将对这个返回值或者标志进行检查，以判断是否发生错误，但，随着时间的推移，人们发现很多的程序员更倾向于忽略对这些返回值和标志的检查，因为他们总是在想“这是别人的问题，不关我的事”，这对于构建大型的，健壮性，可维护的程序而言，这种错误处理机制已经成为阻碍<br>&emsp;&emsp;解决的办法是，用强制规定的形式来消除错误处理过程中随心所欲的因素<br>&emsp;&emsp;“异常”这个词有“我对此感到意外”的意思，问题出现了，你也许不清楚该如何处理，当你确实不该置之不理，你要停下来，看看是不是有别人或在别的地方，能够处理这个问题，只要是在当前环境中还没有足够的信息来解决这个问题，就将这个问题提交到一个更高的环境中，在这里将作出正确的决定<br>&emsp;&emsp;使用异常所带来的一个好处是，它往往能够降低错误处理代码的复杂度，如果不使用异常，那么就必须检查特定的错误，并在程序中的许多地方去处理它，而如果使用异常，那就不必再方法调用处进行检查，因为<strong>异常机制保证能够捕获这个错误</strong>，并且，只在一个地方处理错误，即所谓的异常处理程序中，这样不仅节省代码，而且把描述在<strong>正常情况下“执行过程中做什么事”的代码和“出了问题怎么办”的代码相分离</strong></p><h2 id="基本异常"><a href="#基本异常" class="headerlink" title="基本异常"></a>基本异常</h2><p>&emsp;&emsp;异常清晰（exceptional condition）是指阻止当前方法或作用域继续执行的问题，把异常情形与普通问题相区分很重要，普通问题是指，在当前环境下能够得到足够的信息，总能处理这个错误，而对异常情形，就不能继续下去了，因为当前环境下无法获得必要的信息来解决这个问题<br>&emsp;&emsp;当抛出异常后，有几件事会相继发生，甚至，同java中其他对象的创建一样，将使用new在堆上创建异常对象，然后，当前的执行路径（既不能继续下去了）被终止，并且从当前的环境中弹出异常对象的引用，此时，异常处理机制接管程序，并开始寻找一个恰当的地方继续执行程序，这个恰当的地方就是异常处理程序，它的任务是将程序从错误状态恢复<br>&emsp;&emsp;异常最重要的方面之一就是如果发生问题，它们将不允许程序沿着其正常的路径继续走下去  </p><h3 id="异常参数"><a href="#异常参数" class="headerlink" title="异常参数"></a>异常参数</h3><p>&emsp;&emsp;与使用java中的其他对象一样，我们总是用new在堆上创建异常对象，这也伴随着存储空间的分配和构造器的调用，所有的异常类都有两个构造器，一个是默认构造器，另一个是接收字符串作为参数，以便能够把相关信息放入到异常对象的构造器<br>&emsp;&emsp;关键字throw将产生很有趣的结果，一个是新生成的异常对象的引用通过throw关键字传递到更大的环境，另一个效果是通过抛出异常的方式退出方法或作用域 此外还能抛出任意类型的Throwable对象，它是异常类型的根类</p><h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><h3 id="监控区域"><a href="#监控区域" class="headerlink" title="监控区域"></a>监控区域</h3><p>&emsp;&emsp;<strong>如果在方法的内部抛出了异常（或者在方法调用的其他方式抛出了异常），这个方法将在抛出异常的过程中结束，如果不希望方法就此结束，可以在方法内部设置一个特殊的块来捕获异常</strong>  </p><h3 id="异常处理程序"><a href="#异常处理程序" class="headerlink" title="异常处理程序"></a>异常处理程序</h3><p>&emsp;&emsp;抛出的异常必须在某个地方得到处理，这个地点就是异常处理程序，而且针对每一个要捕获的异常准备相应的异常处理程序  </p><h3 id="终止与恢复"><a href="#终止与恢复" class="headerlink" title="终止与恢复"></a>终止与恢复</h3><p>&emsp;&emsp;异常处理理论有两种基本模型，java支持终止模型，在这种模型中，将假设错误非常关键，以至于无法回到错误发生的地方继续执行，一旦异常被抛出，就表明错误无法挽回，也不能回来继续执行<br>&emsp;&emsp;另一种是恢复模型，意思是异常处理程序的工作是修正错误，然后尝试调用出问题的方法，并认为第二次能成功，java也可实现这种错误处理，将异常处理程序一个while循环中吗，直到程序执行成功<br>&emsp;&emsp;虽然恢复模型很吸引人，但是这种错误恢复机制的代码非常难以编写，而且你真的了解错误的所有方方面面吗？所以后来大部分的语言选择转向程序终止模型  </p><h2 id="创建自定义异常"><a href="#创建自定义异常" class="headerlink" title="创建自定义异常"></a>创建自定义异常</h2><p>&emsp;&emsp;java提供的异常体系不可能预见所有的希望加以报告的错误，所以可以自己定义异常类来表示程序中可能会遇到的特定问题<br>&emsp;&emsp;要定义自己的异常类，必须从已有的异常类继承，最好是意思相近的，其实无所谓，异常最重要的是类名，建立新的异常类最简单的方式就是让编译器为你产生默认的构造器</p><h2 id="异常说明"><a href="#异常说明" class="headerlink" title="异常说明"></a>异常说明</h2><p>&emsp;&emsp;<strong>java鼓励人们把方法可能会抛出的异常告知使用此方法的客户端程序员</strong>，这是种优雅的做法，它使得调用者能确切地知道应该写什么代码借用捕获所有的异常，java提供了相应的语法（并强制这个语法）使得你能以礼貌的方式告知客户端程序员某个方法可能会抛出的异常，然后客户端程序员会进行相应的处理，这就是异常说明，它属于方法声明的一部分，紧跟在形式参数列表之后 <code>void f()throws TooBig,TooSmall{}</code><br>&emsp;&emsp;如果代码方法产生了异常却没有对此说明，编译器会发现这错误并提醒你，那么处理这个异常，要么声明这个方法将会抛出异常<br>&emsp;&emsp;这种在编译器就被强制检测的异常被称为<code>被检查的异常</code></p><h2 id="捕获所有的异常"><a href="#捕获所有的异常" class="headerlink" title="捕获所有的异常"></a>捕获所有的异常</h2><p>&emsp;&emsp;可以只写一个异常来捕获所有类型的异常，通过捕获异常类型的基类Exception可以做到这一点,因为Exception是与编程有关的所有异常类的基类，所有它不会包含太多的信息，可以调用它从其基类Throwable继承来的方法<br>&emsp;&emsp;String getMessage()<br>&emsp;&emsp;String getLocalizedMessage()<br>&emsp;&emsp;或用本地语言表示的详细信息<br>&emsp;&emsp;String toString()<br>&emsp;&emsp;void printStackTrace()<br>&emsp;&emsp;void printStackTrace(PrintStream)<br>&emsp;&emsp;void printStackTrace(java.io.PrintWriter)<br>&emsp;&emsp;打印Throwable和Throwable的<code>调用栈轨迹</code>，调用栈显式了“把你带到异常抛出地点”的方法调用序列，其中第一个版本输出到标准错误，后两个版本允许选择要输出的流<br>&emsp;&emsp;Throwable fillStackTrace()<br>&emsp;&emsp;<strong>用于在Throwable对象的内部记录栈帧的当前转态，这在程序重新抛出错误或者异常时很有用</strong><br>&emsp;&emsp;此外还可以使用继承自Object的方法，比如getClass()返回Class类型对象，可以获得更多关于这个异常对象的信息</p><h3 id="栈轨迹"><a href="#栈轨迹" class="headerlink" title="栈轨迹"></a>栈轨迹</h3><p>&emsp;&emsp;<code>printStrackTrace()</code>方法所提供的信息可以通过<code>StackTraceElement getStackTrace()</code>方法来直接访问，这个方法将<strong>返回一个由栈轨迹中的元素所组成的数组，其中每一个元素都表示栈中的一祯，元素0是栈顶元素，并且是调用序列中的最后一个方法调用（这个Throwable被创建和抛出之处）</strong>数组中的最后一个元素和栈底是调用序列中的第一个方法调用</p><h3 id="重新抛出异常"><a href="#重新抛出异常" class="headerlink" title="重新抛出异常"></a>重新抛出异常</h3><p>&emsp;&emsp;重抛异常会把异常抛给上一级环境中的异常处理程序，此外，异常的所有信息都会得以保持，所以上一级环境中捕获此异常的处理程序通过通过这个异常对象得到所有的信息<br>&emsp;&emsp;如果只是将当前的异常对象重新抛出，那么printStackTrace()方法显示的将是原来异常抛出的调用栈信息，而非重新抛出点的信息，要想更新这个信息，<strong>可以调用fillInStackTrace()方法，这个方法将返回一个Throwable对象，它是通过把当前调用栈信息填入原来那个异常对象而建立的,因此调用fillinStackTrace()的那一行就成了异常的新发地</strong><br>&emsp;&emsp;有可能在捕获异常之后抛出另一种异常，那么这么做，得到的效果就类似与使用finInStackTrace(),有关原来异常发生地点的信息就会丢失剩下的是与新的抛出点有关的信息</p><h3 id="异常链"><a href="#异常链" class="headerlink" title="异常链"></a>异常链</h3><p>&emsp;&emsp;常常会想要在捕获一种异常之后抛出另一种异常，并且希望把原始异常的信息保存下来，这被称为异常链，现在所有的Throwable的子类在构造器中都可以接受一个cause(因由)对象作为参数，这个cause就用来表示原始异常，<strong>这样通过把原始异常传递给新的异常，使得即使在当前创建并抛出新的异常，也能够通过这个异常链追踪到异常最初发生的位置</strong><br>&emsp;&emsp;语法: <code>throw new NewException(CauseException)</code></p><h2 id="java标准异常"><a href="#java标准异常" class="headerlink" title="java标准异常"></a>java标准异常</h2><p>&emsp;&emsp;Throwable这个类被用来表示任何可以作为异常抛出的类。Throwable对象，可以分为两种类型（指从Throwable继承中得到的类型），Error用来表示编译时和系统错误（除特殊情况，一般你不用关心），Exception是可以抛出的异常，在java类库，用户方法以及运行时故障中都可能抛出这个Exception异常，所有java程序员关心的异常类型通常是Exception  </p><h3 id="特例-RuntimeExcepton"><a href="#特例-RuntimeExcepton" class="headerlink" title="特例 RuntimeExcepton"></a>特例 RuntimeExcepton</h3><p>&emsp;&emsp;属于运行时的异常类型有很多，它们会自动被java虚拟机抛出，所有不必在异常说明中吧它们列出来，这些异常都是从RuntimeException类继承而来的，不需要再异常说明中声明的异常也被称为“不受检查的异常”，尽管通常不用捕获RuntimeException异常，但还是可以在代码中抛出RuntimeException异常<br>&emsp;&emsp;如果不主动捕获这种类型的异常会发生什么事情呢？因为编译器没有在这个问题上对遗产说明进行强制检查，RuntimeException类型的异常也许会穿越所有的执行过程直达main()方法，而不会被捕获</p><h2 id="使用finally进行清理"><a href="#使用finally进行清理" class="headerlink" title="使用finally进行清理"></a>使用finally进行清理</h2><p>&emsp;&emsp;对于一些代码，你可能希望，无论try块中的异常是否抛出，它们都能得到执行，<strong>这通常适用于内存回收之外的情况</strong>（因为内存回收由垃圾回收器完成），为了达到这个效果，可以在try块之后加上finally子句</p><h3 id="finally用来做什么"><a href="#finally用来做什么" class="headerlink" title="finally用来做什么"></a>finally用来做什么</h3><p>&emsp;&emsp;finally非常重要，它能使程序员保证，无论try块里发生什么，内存总能得到释放，但java有垃圾回收机制，所以内存释放不再是问题<br>&emsp;&emsp;<strong>当把除内存之外的资源恢复到它们的初始转态时，就要用到finally子句</strong>，这种需要清理的资源包括，已经打开的文件或网络连接，在屏幕上画的图形，甚至是外部世界的某个开关  </p><h3 id="缺憾：异常丢失"><a href="#缺憾：异常丢失" class="headerlink" title="缺憾：异常丢失"></a>缺憾：异常丢失</h3><p>&emsp;&emsp;遗憾的是，java的异常实现也有瑕疵，异常通常作为程序出错的标志，绝不应该被忽视，但是还是有可能被轻易忽视，用某些特殊方法的finally放肆使用子句，就会发生这种情况，这种情况的方式吗，一般是在finally子句抛出新的遗产替换了正常方法中抛出的异常，这是相当严重的缺陷</p><h2 id="异常的限制"><a href="#异常的限制" class="headerlink" title="异常的限制"></a>异常的限制</h2><p>&emsp;&emsp;当覆盖方法的时候只能抛出在基类方法的异常说明里列的那些异常，这个限制很有用，因为这意味着，当基类方法使用的代码应用到派生类对象的时候，一样能够工作，异常也不例外，这样的规则在java随处可见，比如，派生类覆盖基类的方法，访问权限一定不能比基类的要小，这些规则都保证了，能调用基类的方法就一定可以调用导出类的方法这个原则</p><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p>&emsp;&emsp;如果异常发生了，所有的东西都能被正确清理吗？因为涉及到构造器，问题就出现了，构造器会把对象设置成安全的初始转态，但是还会有别的动作，比如打开一个文件，这样的动作只有在对象使用完毕并且用户调用了特殊的清理方法之后才能的已清理，如果构造器内抛出了异常，这些清理行为也许就不能正常工作了，这意味着编写构造器时要格外小心，其实我们很少会遇到这也的问题，我们遵循的一条原则就是用尽量简单的方法构建对象</p><h2 id="异常匹配"><a href="#异常匹配" class="headerlink" title="异常匹配"></a>异常匹配</h2><p>异常处理系统会按照代码书写的书信找出“最近”的处理程序，找到匹配的处理程序之后，就认为异常得到了处理，就不在继续查找了查找的时候并不要去抛出的异常同处理程序声明的异常完全匹配，派生类的对象也可以匹配其基类的处理程序，所有一个原则是将更加特定的异常类型放在最前面</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;java的理念是：结构不佳的代码不能运行&lt;br&gt;&amp;emsp;&amp;emsp;发现错误最好的时期是在编译阶段，也就是在你试
      
    
    </summary>
    
      <category term="学习心得" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>持有对象</title>
    <link href="http://yoursite.com/2018/10/10/%E6%8C%81%E6%9C%89%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2018/10/10/持有对象/</id>
    <published>2018-10-10T15:50:46.000Z</published>
    <updated>2018-10-11T07:56:47.593Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;如果一个程序只包含固定数量的且其生命周期都是已知的对象，那么这是一个非常简单的程序<br>&emsp;&emsp;通常，程序总是根据运行时才知道的某些条件去创建对象，在此之前，不会知道所需对象的数量，甚至不知道确切的类型，为了解决这个普遍的编程问题，需要在任意时刻和任意位置创建任意数量的对象，所以，就不能依靠创建命名的引用<code>MyType aReference</code>来持有每一个对象<br>&emsp;&emsp;java有多种保存对象的方式，数组是个保存对象的最有效的方式之一，可是数组具有固定的尺寸，而在一般的情况中，你在写程序的时候根本不知道将需要多少的对象<br>&emsp;&emsp;Java实用类库提供了一整套完整的容器来来解决这个问题，其中基本的类型是List,Set,Queue和Map,这些对象也称为集合类，但是由于java的类库使用了Collection这个名字来指代该类库的一个特殊子集，所以我们使用范围更广的术语“容器”称呼它们<br>&emsp;&emsp;容器还有一些其他的特性，例如，Set对每个值都只保存一个对象，Map是允许你将某些对象与其他的一些对象关联起来的关联数组，java容器类都可以自动调整自己的尺寸，因此，与数组不同，在编程时，你可以将任意数量的对象放置在容器中，而且不需要担心容器应该设置为多大  </p><h2 id="泛型和类型安全的容器"><a href="#泛型和类型安全的容器" class="headerlink" title="泛型和类型安全的容器"></a>泛型和类型安全的容器</h2><p>&emsp;&emsp;在java SE5之前的容器有一个主要的问题就是编译器允许你向容器插入不正确的类型，而在之后，你可以通过预定义的泛型容器通过类型参数来指定你将要向容器中插入的数据类型，编译器将会放置错误的对象放置到容器中，而且不需要转型就可以从容器中取出正确类型的对象，因为容器知道自己保持的对象是什么类型</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>&emsp;&emsp;java容器类类库的用途就是“保存对象”，并将其划分为两个不同的概念  </p><ol><li>Collection 一个独立元素的序列，这些元素都服从一条或者多条规则  </li><li>Map 一组成对的“键值对”的对象，允许你通过键查找对象，ArrayList允许你使用数字来查找值，从某种意义上，它是将数字和对象关联在一起，映射表允许我们使用另一个对象查找另一个对象，它也被称为“关联数组”   <h2 id="添加一组元素"><a href="#添加一组元素" class="headerlink" title="添加一组元素"></a>添加一组元素</h2>&emsp;&emsp;在<code>java.util</code>包中的<code>Arrays</code>和<code>Collections</code>类中都有很多使用的方法，可以在一个<code>Collection</code>中添加一组元素，<code>Arrays.asList()</code>方法接受一个数组或者一个用逗号分隔的元素列表(可变参数)并将其转换为一个<code>List</code>对象，<code>Collections.addAll()</code>方法接受一个<code>Collection</code>对象，以及一个数组或是一个用逗号分隔的列表，将元素添加到<code>Collection</code>对象中  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddingGroup</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Collection&lt;Integer&gt; collection=<span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>));</span><br><span class="line">        Integer[] moreInt = &#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        Collections.addAll(collection,moreInt);</span><br><span class="line">        Collections.addAll(collection,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>);</span><br><span class="line">        List&lt;Integer&gt; list=Arrays.asList(<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">10</span>);</span><br><span class="line">        list.set(<span class="number">1</span>,<span class="number">99</span>);</span><br><span class="line">        <span class="comment">//list.add(21);runtime error because the underlying array connot be resized</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>&emsp;&emsp;Collection构造器可以接受另一个Collection，用它将自身初始化，Collection.addAll()和Collections.addAll()是两个完全不同的两个方法，前者是集合的通用接口中定义的方法，后者是Collections工具类定义的一个静态方法，Collection.addAll()方法只能接受另一个Collection对象作为参数，因此它不如Arrays.list()和Collections.addAll()来的灵活，这两个方法使用的都是可变参数列表<br>&emsp;&emsp;你可以直接使用ArrayList.asList()的输出，将其当做List,但是在这种情况下，其底层表示的是数组，因此不能调整尺寸，如果你试图用add()或delete()方法在这种列表中添加或删除元素，就有可能引发去改变数组尺寸的尝试，会得到一个运行时错误  </p><h2 id="容器的打印"><a href="#容器的打印" class="headerlink" title="容器的打印"></a>容器的打印</h2><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>&emsp;&emsp;List承诺可以将元素维护在特定的序列中，List接口在Collecton的基础上添加了大量的方法，使得可以在List中间插入和移除元素<br>&emsp;&emsp;有两种类型的List：</p><ul><li>基本的ArrayList，它长于随机访问元素，但在List的中间插入和移除元素时较慢</li><li>LinkedList，它通过代价较低的在List中间进行插入和删除操作，提供了优化的顺序访问，LinkedList在随机访问方面相对较慢，但是它的特性集叫ArrayList更大  </li><li>为什么ArrayList和LinkedList对于不同的操作的性能不同的原因是因为底层实现的不同  <img src="/2018/10/10/持有对象/绘图1.png" title="ArrayList"><img src="/2018/10/10/持有对象/绘图2.png" title="LinkedList">&emsp;&emsp;关于List接口api请查看<a href="http://tool.oschina.net/apidocs/apidoc?api=jdk-zh" target="_blank" rel="noopener">http://tool.oschina.net/apidocs/apidoc?api=jdk-zh</a><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2>&emsp;&emsp;任何容器类，都必须有某种方式可以插入元素并将它们取回，毕竟，持有事物是容器的基本工作<br>&emsp;&emsp;如果从更高层的角度思考，我们在对容器的确切类型进行编程方面有一个缺点，那就是如果原本是对List编码的，但是后来我想将相同的代码应用于Set，那会显得很不方便，此时应该怎么做呢？或者打算从头开始编写通用的代码，它们只是使用容器，不知道或者说不关心容器的类型，那么如何才能不重写代码就能应用于不同的容器呢？<br>&emsp;&emsp;迭代器（也是一种设计模式）的概念可以用于达成此目的，迭代器是一个对象，它的工作是遍历并选择序列中的对象，而客户端程序员不必知道或关心该序列底层的结构，java的Iterator只能呢个单向移动，这个Iterator只能用来  </li></ul><ol><li>使用iterator()方法要求容器返回一个Iterator，Iterator将准备返回序列的第一个元素</li><li>使用next()获得序列的下一个元素</li><li>使用hasNext()方法检查序列中是否还有元素</li><li>使用remove()将迭代器新返回的元素删除<br>&emsp;&emsp;注意:Iterator可以删除next()产生的最后一个元素，这意味着调用remove()之前必须先调用next()<br>&emsp;&emsp;<strong>接受对象容器并传递它，从而在每个对象上都执行某种操作，这种思想十分强大</strong><h3 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h3>ListIterator是一个更加强大的Iterator的子类型，它只能用于各种List类的访问，尽管Iterator只能向前移动，但是ListIterator可以双向移动，它还可以产生相对于迭代器在列表中指向的当前位置的前一个和后一个元素的索引，并且可以使用set()方法替换它访问过的最后一个元素,你可以通过listIterator()方法产生一个指向List开始处的ListIterator，并且还可以通过调用listIterator(n)方法创建一个一开始就指向列表索引为n的元素处的ListIterator<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2>&emsp;&emsp;LinkedList也像ArrayList一样实现了List接口，在删除和插入方面的效率比ArrayList更高效，但是在随机访问方面却要逊色一些<br>&emsp;&emsp;<strong>LinkedList还添加了可以使其用作栈，队列或者双端队列的方法</strong><br>&emsp;&emsp;这些方法有些彼此之间只是名称有些差异，后者只存在少许差异，以使得这些名称在特定用法的上下文环境中更加适用（特别是在Queue中）例如，getFirst()和element()完全一样，它们都是返回列表头元素，而并不移除它，如果List为空的话，则抛出NoSuchElementException,<br>peek()方法与这两个方法只是稍有差异，它在列表为空时返回null<br>&emsp;&emsp;removeFirst()和remove()也是完全一样，它们移除并返回列表的头，而在列表为空时，抛出NoSuchElementExcption，poll()稍有差异，它在列表为空的时候，返回null<br>&emsp;&emsp;addFirst()与add()和addLast()，它们都是将元素插入列表的尾（端）部<br>&emsp;&emsp;removerLast()移除并返回最后一个元素<br>&emsp;&emsp;因此我们在使用LinkedList这些方法时，要注意各种方法的不同，进而选择怎样去处理<h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2>&emsp;&emsp;“栈”通常是指“后进先出”(LIFO)的容器，有时栈也被称为叠加栈，如果用一种事物来形容的话，栈的行为就像是弹夹一样，有“压入”和“弹出”<br>&emsp;&emsp;LinkedList具有能实现栈的所有功能的方法，所有我们可以定义一个栈，通过组合的形式复用LinkedList，很简单，这里就不写了<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2>&emsp;&emsp;Set不保存重复的元素，如果你试图将相同对象的多个实例添加到Set中，那么它就会阻止这种重复的发生，Set最常用被使用的是<strong>测试归属性</strong>，你很容易地询问某个对象是否在某个Set中，因此，查找就成了Set中最重要的操作，因此，你可以选择HashSet的实现，它专门对快速查找进行优化<br>&emsp;&emsp;Set和Collection具有完全一样的接口，因此没有额外的功能，实际上Set就是Collection，只是行为不同<br>&emsp;&emsp;Set有不同的实现，HashSet使用了散列函数，使得更快速的保存和查找，TreeSet使用了红黑树数据结构中，LInkedHashSet因为查找的速度也使用了散列，但是看起来它使用了链表来维护元素的插入顺序<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2>&emsp;&emsp;将对象映射到其他对象的能力是一种解决编程问题的杀手锏<br>Map与数组和其他的Collection一样，可以很容易地扩展到多维，我们通过容器的组合，可以很容易生成强大的数据结构  <h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2>&emsp;&emsp;队列是一个“先进先出”（FIFO）的容器，即从容器的另一端放入元素，从容器的另一端取出，<strong>队列常被当作一种可靠的将对象从程序的一个区域传递到另一个区域的途径</strong><br>&emsp;&emsp;LinkedList提供了方法以支持队列的行为，它实现了Queue接口，因此可以将LinkedList作为Queue的一种实现，通过将LinkedList向上转型为Queue  <h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h3>&emsp;&emsp;x先进先出描述了最典型的队列规则，<strong>队列规则是指在给定一组队列中的元素的情况下，确定下一个弹出队列的元素的规则</strong><br>&emsp;&amp;emsp优先队列声明下一个弹出的元素是最需要的元素（具有最高的优先级），当你在PriorityQueue上调用offer()方法插入一个对象时，这个对象会在队里中被排序，默认的排序将使用对象在队列中的自然排序，但是你也可以通过提供自己的Comparator来修改这个顺序，PriorityQueue可以确保当你调用peek()，poll()和remove()方法时，获得的元素将是队列中优先级最高的元素  <h2 id="Collection和Iterator"><a href="#Collection和Iterator" class="headerlink" title="Collection和Iterator"></a>Collection和Iterator</h2>&emsp;&emsp;Collection是描述所有序列容器的共性的根接口，它可能被认为是一个“附属接口”，即因为要表示其他若干接口的共性而出现的接口<br>&emsp;&emsp;使用接口的一个理由就是它可以使我们能够创建更通用的代码，通过针对接口而非具体的实现类编写代码，那么我们的代码就可以应用于更多的类型，然后我们也可以看到有趣的事情是，我们一般是通过迭代器来表现这种共性的，在java中，这两种方式实际上绑定在一起了，如果要一个新类实现Collection接口，也要必须通过iterator()接口，但是如果让一个类去实现Collection接口，虽然可以通过继承AbstractCollection来提供一些默认的实现，但是必须还有提供iterator()，而且如果这个类本身已经继承了其他类，那么就不能再通过继承将其定义为一个Collection类型了，所有相比之下，使用通过迭代器的方式来提供容器的共性更加可取，我们也知道，迭代器模式实际上就是利用了内部类的特性，产生了一个能够访问外围类的闭包对象，我们就可以对外围的成员进行操作  <h3 id="Foreach与迭代器"><a href="#Foreach与迭代器" class="headerlink" title="Foreach与迭代器"></a>Foreach与迭代器</h3>&emsp;&emsp;在java SE5引入了新的被称为Iterable的接口，该接口包含了一个能够产生Iteratoer的Iterator()方法，并且Iterator接口被foreach用来在序列中移动，<strong>因此，如果你创建了任何实现了Iteratable的类，都可以将它用于foreach语法</strong></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;如果一个程序只包含固定数量的且其生命周期都是已知的对象，那么这是一个非常简单的程序&lt;br&gt;&amp;emsp;&amp;emsp;通
      
    
    </summary>
    
      <category term="学习心得" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>内部类</title>
    <link href="http://yoursite.com/2018/10/10/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <id>http://yoursite.com/2018/10/10/内部类/</id>
    <published>2018-10-10T03:44:31.000Z</published>
    <updated>2018-10-11T02:33:13.901Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;<strong>可以将一个类的定义放在另一个类的定义内部，这就是内部类</strong><br>&emsp;&emsp;内部类是一种非常有用的特性，因为它允许你把一些逻辑相关的类组织在一起，并控制内部类的可视性，然而必须要了解，内部类与组合是完全不同的概念，这一点很重要<br>&emsp;&emsp;在最初，内部类看起来就像是一种代码隐藏机制，将类置于其他类的内部，但是，你将会了解到，内部类远不止如此，它了解外围类，并能与之通信，而且你用内部类写出的代码更加优雅而清晰，尽管并不总是如此  </p><h2 id="创建内部类"><a href="#创建内部类" class="headerlink" title="创建内部类"></a>创建内部类</h2><p>&emsp;&emsp;创建内部类的方法很简单，就是将类的定义置于外围类的内部<br>&emsp;&emsp;更典型的情况是，外部类将有一个方法，该方法返回一个指向内部类的引用，就像下面看到<code>to()</code>的<code>contens()</code>和一样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel1</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Contents</span></span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> i =<span class="number">11</span>;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> i;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Destination</span></span>&#123;</span><br><span class="line">      <span class="keyword">private</span> String label;</span><br><span class="line">      Destination(String label)&#123;</span><br><span class="line">          <span class="keyword">this</span>.label=label;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function">String <span class="title">readLable</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> label;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Destination <span class="title">to</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Destination(s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Contents <span class="title">conents</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Contents();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ship</span><span class="params">(String dest)</span></span>&#123;</span><br><span class="line">      Contents c=conents();</span><br><span class="line">      Destination d=to(<span class="string">"dest"</span>);</span><br><span class="line">      System.out.print(d.readLable());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      Parcel1 p=<span class="keyword">new</span> Parcel1();</span><br><span class="line">      p.ship(<span class="string">"Tasmania"</span>);</span><br><span class="line">      Parcel1 q=<span class="keyword">new</span> Parcel1();</span><br><span class="line">      Parcel1.Destination d=q.to(<span class="string">"Borneo"</span>);</span><br><span class="line">      Parcel1.Contents c = q.conents();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="链接到外部类"><a href="#链接到外部类" class="headerlink" title="链接到外部类"></a>链接到外部类</h2><p>&emsp;&emsp;到目前为止，内部类似乎还是一种名字隐藏和组织代码的模式，这些很有用，但还不是最引人注目的，它还有其他的用途，<strong>当生成一个内部类的对象时，此对象与制造它的外围类对象（enclosing object）之间就有了一种联系，所以它能访问其外围类的所有成员，而不需要任何特殊条件</strong>，此外，内部类还拥有外围类所有元素的访问权，内部类可以访问其外围类的的方法和字段，就像自己拥有它们似的<br>&emsp;&emsp;内部类自动拥有对其外围类所有成员的访问权，这是怎么做到的呢？当某个对象创建一个内部类对象的时候，此内部类对象必定会秘密捕获一个指向那个外围类对象的引用，然后，在你访问此外围类的成员时，就是用那个引用来选择外围类的成员，幸运的是，编译器会帮我们处理所有的细节，但你现在可以看到：内部类的对象只能在其外围类的对象相关联的情况下才能被创建（就像你应该看到的，在内部类是非static类时），构建内部类对象时，需要一个指向其外围类对象的引用</p><h2 id="使用-this和-new"><a href="#使用-this和-new" class="headerlink" title="使用.this和.new"></a>使用.this和.new</h2><p>&emsp;&emsp;<strong>如果你需要生成外部类对象的引用，可以使用外部类的名字后面紧跟原点和this</strong>，这样产生的引用自动地具有正确的类型，这一点在编译期就被知晓并受到检查，因此没有任何运行时开销<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dothis</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;System.out.print(<span class="string">"Dothis.f()"</span>);&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Dothis <span class="title">outer</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Dothis.<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Inner <span class="title">inner</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Inner();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Dothis dt=<span class="keyword">new</span> Dothis();</span><br><span class="line">        Dothis.Inner dti=dt.inner();</span><br><span class="line">        dti.outer().f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;有时你想要告知某些其他对象，去创建其某个内部类的对象，要实现此目的，你必须在new表达式中提供对其他外部类对象的引用，这就需要使用<code>.new</code>语法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DotNew</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        DotNew dotNew=<span class="keyword">new</span> DotNew();</span><br><span class="line">        DotNew.Inner di=dotNew.new Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&amp;emsp；要想创建内部类的对象，你不能按照你想象的方式，去引用外部类的名字DotNew,而是<strong>必须使用外部类的对象来创建内部类对象</strong>，像上面<code>newDot.new Inner()</code>那样,这也解决了内部类名字作用域的问题<br>&emsp;&amp;emsp；<strong>在拥有外部类对象之前是不能创建内部类对象的</strong>，这是因为内部类对象暗暗连接到它的外部类对象上，但是，如果你创建的是嵌套类（静态内部类），那么就不需要对外部类对象的引用  </p><h2 id="内部类和向上转型"><a href="#内部类和向上转型" class="headerlink" title="内部类和向上转型"></a>内部类和向上转型</h2><p>&emsp;&amp;emsp；当将内部类向上转型为其基类，尤其是转型为一个接口的时候，内部类就有了用武之地（从实现了某个接口的对象，得到对接口的引用，与向上转型为这个对象的基类，实际上效果是一样的），<strong>这是因为此内部类——某个接口的实现——能够完全不可见，并且不可用</strong>。所得到只是指向基类或则接口的引用，所以能够很方便地隐藏实现细节<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Destination</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">readLabel</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Contents</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parcel</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">PContents</span> <span class="keyword">implements</span> <span class="title">Contents</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> i;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">PDestination</span> <span class="keyword">implements</span> <span class="title">Destination</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String label;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PDestination</span><span class="params">(String toWhere)</span></span>&#123;</span><br><span class="line">            label=toWhere;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">(String s)</span></span>&#123;<span class="keyword">return</span> s;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Destination <span class="title">destination</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PDestination(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PContents();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestParcel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Parcel parcel=<span class="keyword">new</span> Parcel();</span><br><span class="line">        Contents c=parcel.contents();</span><br><span class="line">        <span class="comment">//向下转型为私有的内部类也是不可以的</span></span><br><span class="line">        <span class="comment">//Parcel.PContents pc=parcel.contents();</span></span><br><span class="line">        Destination d= parcel.destination(<span class="string">"tasmania"</span>);</span><br><span class="line">        <span class="comment">//illegal --can't access private class</span></span><br><span class="line">        <span class="comment">//Parcel.PContents ps=parcel.new PContents();</span></span><br><span class="line">        Parcel.PDestination pd=parcel.new PDestination(<span class="string">"同包可访问"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;在上面的例子中，内部类PContents是private,所以除了Parcel，没人能够访问它，PDestination是protected的，所以只有Parcel及其子类，还有同包的类能够访问它，这意味着如果客户端程序员想要了解或访问这些成员，那是要受到限制的，实际上，甚至不能向下转型成private内部类（或是protect内部类，除非是继承自它的子类），因为不能访问其名称，就像上面看到的那样，也是，private内部类给类的设计者提供了一种途径，通过这种方式可以完全阻止任何依赖于类型的编码，并且完全隐藏了实现的细节，此外，从客户端程序员的角度来看，由于不嫩访问任何新增的，原本不属于公共接口的方法，所有扩展接口是没有价值的（也就是说我们对于private内部类，我们只能通过可访问的其向上转型的基类或者接口来访问这个内部类，因为同基类接口访问，任何通过内部类添加的新的方法都是无意义的）。这也给java编译器提供了生成更高效代码的机会<br>&emsp;&emsp;总结如下，对内部类的访问权限修饰同样有效，我们仅能对那些有权限访问的内部类进行访问，例如private内部类，我们无法访问（除了包含它的外部类），对于protected内部类，我们只能在外围类的子类或者同包类能访问，但是如果我们对内部类基类的接口具有访问权的时候，内部类还提供了一种机制，通过外围类的方法获得内部类的向上转型的引用，我们就可以对这个引用的接口进行访问，由此得到一个副作用是，通过向上转型的接口访问时对于那些在内部类中新添加的方法，我们是无法调用的</p><h2 id="在方法和作用域内的内部类"><a href="#在方法和作用域内的内部类" class="headerlink" title="在方法和作用域内的内部类"></a>在方法和作用域内的内部类</h2><p>&emsp;&emsp;我们还可以在方法里面或者在任意的作用域内定义内部类，这么做有两个理由：</p><ol><li>你实现了某类型的接口，于是可以创建并返回对其的引用  </li><li>你要解决一个复杂的问题，想创建一个类来辅助你解决问题，但是又不希望这个类是公共可用的<br>&emsp;&emsp;在后面的例子里，先前的代码将被修改，以用来实现  </li><li>一个定义在方法中的类  </li><li>一个定义在作用域内的类，此作用域在方法内部</li><li>一个实现接口的匿名类</li><li>一个匿名类，它扩展了有非默认构造器的类</li><li>一个匿名类，它执行字段初始化</li><li>一个匿名类，它通过实例初始化实现构造（匿名类不可能有构造器）<h4 id="在方法的作用域内"><a href="#在方法的作用域内" class="headerlink" title="在方法的作用域内"></a>在方法的作用域内</h4>&emsp;&emsp;在方法的作用域内，创建一个完整的类，这被称作局部内部类  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Destination <span class="title">destination</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">PDestination</span> <span class="keyword">implements</span> <span class="title">Destination</span></span>&#123;</span><br><span class="line">            <span class="keyword">private</span> String label;</span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="title">PDestination</span><span class="params">(String whereTo)</span></span>&#123;</span><br><span class="line">                label=whereTo;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> label;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PDestination(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>PDestination类是<code>destination()</code>方法的一部分，而不是<code>Parcel5</code>的一部分，所以destination()方法之外不能访问PDestination,注意出现在return语句中的向上转型——返回的类型是Destionation的引用，它是PDestination的基类，当然，在destination()中定义了内部PDestination，并不意味着一旦destination()方法执行完毕，PDestination就不可用了<br>&emsp;&emsp;你可以在同一个目录下的任意类中对某个内部类使用类标识符PDestination,这并不会引起命名冲突<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">internalTracking</span><span class="params">(<span class="keyword">boolean</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b)&#123;</span><br><span class="line">            <span class="class"><span class="keyword">class</span> <span class="title">TrackingSlip</span></span>&#123;</span><br><span class="line">                <span class="keyword">private</span> String id;</span><br><span class="line">                TrackingSlip(String s)&#123;</span><br><span class="line">                    id = s;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="function">String <span class="title">getSlip</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> id;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            TrackingSlip ts=<span class="keyword">new</span> TrackingSlip(<span class="string">"slip"</span>);</span><br><span class="line">            String s=ts.getSlip();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//con't use it here out of scope</span></span><br><span class="line">    <span class="comment">//TrackingSlip ts=new TrackingSlip();</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">track</span><span class="params">()</span></span>&#123;internalTracking(<span class="keyword">true</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Parcel6 p=<span class="keyword">new</span> Parcel6();</span><br><span class="line">        p.track();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<strong>TrackingSlip类被嵌套入if语句的作用域中，这并不是说该类的创建是有条件的，它其实与别的类一起编译过了，然而，在定义TrackingSlip的作用之外，它是不可用的，除此之外，它与普通的类没什么分别</strong></p><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Contents() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Parcel7 parcel7=<span class="keyword">new</span> Parcel7();</span><br><span class="line">        Contents c=parcel7.contents();</span><br><span class="line">        c.value();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;contents()方法将返回值的生成与表达式这个返回值啊的类的定义结合在一起了，另外，这个类是匿名的，它没有名字，更糟糕的是：看起来似乎是你正在创建一个Contents对象<br>&emsp;&emsp;这种奇怪的语法指的是：“创建一个继承自Contents的匿名类的对象”，通过new表达式返回的引用被自动向上转型为对Contents的引用，上述匿名类的语法是下述形式的简化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel7b</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Mycontents</span> <span class="keyword">implements</span> <span class="title">Contents</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Mycontents();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;在这个匿名内部类中，使用默认的构造器来生成Contents，下面的代码展示的是，如果你的基类需要一个有参数的构造器，应该怎么办？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wrapping</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Wrapping</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; i=x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> i;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel8</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Wrapping <span class="title">wrapping</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Wrapping(x)&#123;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">super</span>.value();</span><br><span class="line">          &#125;  </span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Parcel8 parcel8=<span class="keyword">new</span> Parcel8();</span><br><span class="line">        Wrapping wrapping=<span class="keyword">new</span> Wrapping(<span class="number">2</span>);</span><br><span class="line">        wrapping.value();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;只需要简单传递给基类的构造器即可，尽管Wrapping只是一个具有实现的普通类，但它还是被其导出类当作公共“接口”来使用<br>&emsp;&emsp;<strong>如果定义一个匿名类，并且希望它使用一个在其外部定义的对象，那么编译器会要求并其参数引用是final的</strong><br>&emsp;&emsp;如果只是简单给一个字段，那么普通的字段初始化方法就很好了，但是如果想做一些类似构造器的行为，那该怎么办？在匿名类中不可能含有命名构造器（因为它根本没有名字），但通过实例初始化，就能够达到为匿名内部类创建一个伪构造器的效果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Base</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"Base Constructor,i="</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousConstructor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Base <span class="title">getBase</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Base(x)&#123;</span><br><span class="line">            &#123;System.out.print(<span class="string">"Inside instance initializer"</span>);&#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;System.out.print(<span class="string">"in anonymous f()"</span>);&#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Base base=getBase(<span class="number">10</span>);</span><br><span class="line">        base.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;在此例中，不要求变量一定是final的，因为i被传递给匿名类的基类的构造器，它并不会在匿名类内部被直接使用<br>&emsp;&emsp;下面是带实例初始化的“parcel”形式，注意destinaion的参数必须是final的，因为它们是在匿名类内部使用的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel10</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Destination <span class="title">destination</span><span class="params">(<span class="keyword">final</span> String dest,<span class="keyword">final</span> <span class="keyword">float</span> price)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Destination() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> cost;</span><br><span class="line">            &#123;</span><br><span class="line">                cost=Math.round(price);</span><br><span class="line">                <span class="keyword">if</span>(cost&gt;<span class="number">100</span>)</span><br><span class="line">                    System.out.print(<span class="string">"over Budget"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">private</span> String label=dest;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Parcel10 parcel10=<span class="keyword">new</span> Parcel10();</span><br><span class="line">        parcel10.destination(<span class="string">"houston"</span>,<span class="number">100.3f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;在实例初始化操作的内部，可以看到有一段代码，它们不能作为字段初始化动作的一部分（就是if语句）所以对于匿名类而言，实例初始化的实际效果就是构造器，当然它受到了限制——<strong>你不能重载实例初始化，所以你仅有一个这样的构造器（实例初始化）</strong><br>&emsp;&emsp;匿名内部类与继承相比有些受限，因为<strong>匿名内部类既可以扩展类，也可以实现接口，但不能两者兼备，而且如果是实现接口，也只能实现一个</strong>  </p><h3 id="再访工厂方法"><a href="#再访工厂方法" class="headerlink" title="再访工厂方法"></a>再访工厂方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ServiceFactory</span></span>&#123;</span><br><span class="line">    <span class="function">Service <span class="title">getService</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceImpl1</span> <span class="keyword">implements</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ServiceImpl1</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123; System.out.print(<span class="string">"imple1.m1()"</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123; System.out.print(<span class="string">"impl1.m2()"</span>);&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ServiceFactory serviceFactory=<span class="keyword">new</span> ServiceFactory() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Service <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ServiceImpl1();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceImpl2</span> <span class="keyword">implements</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ServiceImpl2</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123; System.out.print(<span class="string">"imple2.m1()"</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123; System.out.print(<span class="string">"impl2.m2()"</span>);&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ServiceFactory serviceFactory=<span class="keyword">new</span> ServiceFactory() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Service <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ServiceImpl2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factories</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serviceConsumer</span><span class="params">(ServiceFactory factory)</span></span>&#123;</span><br><span class="line">        Service service = factory.getService();</span><br><span class="line">        service.m1();</span><br><span class="line">        service.m2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        serviceConsumer(ServiceImpl1.serviceFactory);</span><br><span class="line">        serviceConsumer(ServiceImpl2.serviceFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>现在用于ServiceImpl1和ServiceImpl2的构造器都可以是private的，并且没有任何必要创建作为工厂的具名类</strong>，另外，你经常需要的是单一的工厂对象，因此在本例中它被创建为Service实现的static域，这样所产生的语法也更具有实际意义</p><h2 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h2><p>&emsp;&emsp;如果不需要内部类与外部类对象之间的联系，那么可以将内部类声明为static，这通常称为嵌套类，嵌套类意味着：</p><ol><li>要创建嵌套类的对象，并不需要其外围类的对象</li><li>不能从嵌套类的对象访问非静态的外围类对象<br>&emsp;&emsp;嵌套类与普通的内部类还有一个区别，<strong>普通内部类的字段与方法，只能放在类的外部层次上，所有普通的内部类不能有static数据和static字段，也不能包含嵌套类，但是嵌套类可以包含所有这些东西</strong><br>&emsp;&emsp;我对于上面问题的理解是，因为普通的内部类是依赖于外部类对象的初始化的，只有得到外部类对象的一个引用，内部类才能构建成功，这是内部类的特性，假设，允许内部类有static数据和static字段，当我们调用内部类的一个static成员时，就会引发内部类的加载，而这是不被推荐的行为，为了确保先外部类后内部类的加载和初始化顺序，编译器必须确保普通内部类中不能存在static成员，而static final是常量，在编译过程就已经存在常量池中，所有对常量没有约束，而嵌套类是static的，和外部类除了在命名空间上有些联系，其实可以将其看成一个独立的类，所以它的加载和初始化对外部类不会产生影响  <h3 id="接口内部的类"><a href="#接口内部的类" class="headerlink" title="接口内部的类"></a>接口内部的类</h3>&emsp;&emsp;正常情况下，不能在接口内部放置任何的代码，但嵌套内部类可以作为接口的一部分，你放在接口中的任何类都自动地是public和static的，因为是被static的，只要将嵌套类置于接口的命名空间内，这并不违反接口的规则，你甚至可以砸内部类中实现其外围类  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ClassInInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">howdy</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span>  <span class="title">ClassInInterface</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">howdy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.print(<span class="string">"Howdy!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">            Test test =<span class="keyword">new</span> Test();</span><br><span class="line">            test.howdy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>&emsp;&emsp;如果你想要创建某些公共代码，使得它们可以被某些接口的所有实现所共用，那么使用接口内部的嵌套类会很方便  </p><h3 id="从多层嵌套类中访问外部类的成员"><a href="#从多层嵌套类中访问外部类的成员" class="headerlink" title="从多层嵌套类中访问外部类的成员"></a>从多层嵌套类中访问外部类的成员</h3><p>&emsp;&emsp;一个内部类被嵌套多少层并不重要——它能透明地访问所有它所嵌入的外围类的所有成员（不包括静态内部类，静态内部类只能访问外部类的静态成员，和普通的类的访问权限一样）</p><h2 id="为什么需要内部类"><a href="#为什么需要内部类" class="headerlink" title="为什么需要内部类"></a>为什么需要内部类</h2><p>&emsp;&emsp;一般来说，内部类继承自某个类或实现某个接口，内部类的代码操作创建它的外围类的对象，所以认为<strong>内部类提供了某种进入外围类的方法</strong><br>&emsp;&emsp;内部类必须要回答的一个问题就是，如果只是需要一个对接口的引用，那么为什么不通过外围类实现那个接口呢？答案是：“如果这能满足要求，那么就应该这么做”，那么内部类实现的接口和外围类实现的这个接口有什么区别呢？答案是：后者不是总能享用到接口带来的便利，有时需要用到接口的实现，所以使用内部类是最吸引人的原因是：<br>&emsp;&emsp;每个接口都能独立地继承自一个（接口的）实现，所以无论外围类是否以及继承了某个（接口的）实现，对于内部类都没有影响<br>&emsp;&emsp;如果没有内部类提供的，可以继承多个具体的或者抽象的类的能力，一些设计与编程的问题就很难解决，从这个角度看，内部类使得多重继承的解决方案变得完美，接口解决了部分问题，而内部类有效地实现了“多重继承”，也就是说吗，内部类允许继承多个非接口类型（类或者抽象类）<br>&emsp;&emsp;使用内部类，还可以获得其他的一些特性：</p><ol><li>内部类可以有多个实例，每个内部类都有自己的状态信息，并且与其外围类对象的信息相互独立</li><li>在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类</li><li>创建内部类对象的时刻并不依赖于外围类对象的创建？</li><li>内部类并没有让人迷惑的“is-a”问题，它就是一个独立的实体<h3 id="闭包与回调"><a href="#闭包与回调" class="headerlink" title="闭包与回调"></a>闭包与回调</h3>&emsp;&emsp;<strong>闭包（closure）是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域</strong>，通过这个定义，可以看出内部类是面向对象的闭包，因为它不仅包含外围类对象（创建内部类的作用域）的信息，还自动拥有一个指向此外围类对象的引用，在此作用域内，内部类有权操作所有的成员，包括private成员<br>&emsp;&emsp;java做引人争议的问题之一就是，人们认为java应该包含某种指针机制，以允许回调（callback）,通过回调，对象能够携带一些信息，这些信息允许它在稍后的某个时候调用初始的对象，，如果回调是通过指针实现的话，那就期待程序员不会误用指针<br>&emsp;&emsp;通过内部类提供闭包的功能是优良的解决方案，它比指针更灵活，更安全  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Incrementtable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Callee1</span> <span class="keyword">implements</span> <span class="title">Incrementtable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">        System.out.print(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyIncrement</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;System.out.print(<span class="string">"Other operation"</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(MyIncrement mi)</span></span>&#123;mi.increment();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Callee2</span> <span class="keyword">extends</span> <span class="title">MyIncrement</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.increment();</span><br><span class="line">        i++;</span><br><span class="line">        System.out.print(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Closure</span> <span class="keyword">implements</span> <span class="title">Incrementtable</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</span><br><span class="line">            Cellee2.<span class="keyword">this</span>.increment();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Incrementtable <span class="title">getCallbackreference</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Closure();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Caller</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Incrementtable callbackReference;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Caller</span><span class="params">(Incrementtable ic)</span></span>&#123;callbackReference=ic;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">()</span></span>&#123;callbackReference.increment();&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallBack</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Callee1 c1=<span class="keyword">new</span> Callee1();</span><br><span class="line">        Callee2 c2=<span class="keyword">new</span> Callee2();</span><br><span class="line">        MyIncrement.f(c2);</span><br><span class="line">        Caller caller1=<span class="keyword">new</span> Caller(c1);</span><br><span class="line">        Caller caller2=<span class="keyword">new</span> Caller(c2.getCallbackreference());</span><br><span class="line">        caller1.go();</span><br><span class="line">        caller2.go(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>&emsp;&emsp;这个例子进一步展示了外围类实现一个接口与内部类实现此接口之间的区别，就代码而言，Callee1是简单的解决方案，Callee2继承自MyIncrement，后者已经有了一个不同的increment()方法，并且与Incrementable接口期望的increment()方法完全不相关，所以入股Cellee2继承了MyIncrement，就不能为了Incrementable的用途而覆盖increment()方法，于是只能使用内部类独立地实现Incrementable，还要主要，当创建一个内部类时，并没有在外围类的接口中添加东西，也没有修改外围类的接口<br>&emsp;&emsp;主要，在Callee2中除了getCallbackReference()方法之外，其他成员都是private的，要想建立与外部世界的任何连接，interface Incrementable都是必需的，在这里可以看到，interface是如何允许接口与接口的实现完全独立的<br>&emsp;&emsp;内部类Closure实现了InCrementable，以提供一个安全的“钩子（hook）”——而且这个钩子是一个安全的钩子，它只能允许调用者对外围类进行特定的操作</p><h3 id="内部类与框架"><a href="#内部类与框架" class="headerlink" title="内部类与框架"></a>内部类与框架</h3><p>&emsp;&emsp;控制框架<br>&emsp;&emsp;应用程序框架（application framework）就是被设计用以解决某类特定问题的一个类或者一组类，要运用某个应用程序框架，通常继承一个或者多个类，并覆盖某些方法，在覆盖后的方法中，编写代码定制应用程序框架提供的通用解决方案，以解决你的特定问题（这是设计模式中模板方法的一个例子）<br>&emsp;&emsp;控制框架是一类特殊的应用程序框架，它用来解决相应时间的需求，主要用来响应时间的系统被称为事件驱动系统，一般来说，我们会考虑使用内部类来设计控制框架系统，原因如下  </p><ol><li>控制框架的完整实现是由单个的类创建的，从而使得实现的细节被封装了起来，<strong>内部类的用来表示解决问题所需要的不同的动作</strong></li><li><strong>内部类能够很容易地访问外围类的任意成员</strong>，所有可以避免这种实现变得笨拙，如果没有这种能力，代码将变得使人讨厌<h2 id="内部类的继承"><a href="#内部类的继承" class="headerlink" title="内部类的继承"></a>内部类的继承</h2>&emsp;&emsp;因为内部类的构造器必须连接到指向其外围类的对象的引用，所有在继承内部类的时候，事情会变得有些复杂，问题在于，那个指向外围类对象的“秘密的”引用必须被初始化<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritInner</span>  <span class="keyword">extends</span> <span class="title">Outer</span>.<span class="title">Inner</span></span>&#123;</span><br><span class="line">    InheritInner(Outer outer)&#123;</span><br><span class="line">        outer.<span class="keyword">super</span>();<span class="comment">//表示的是调用outer的构造器</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Outer outer=<span class="keyword">new</span> Outer();</span><br><span class="line">        InheritInner i = <span class="keyword">new</span> InheritInner(outer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="内部类可以被覆盖吗？"><a href="#内部类可以被覆盖吗？" class="headerlink" title="内部类可以被覆盖吗？"></a>内部类可以被覆盖吗？</h2><p>&emsp;&emsp;如果构建一个内部类，然后继承外部类并重新定义此内部类时，会发生什么？内部类可以被覆盖吗？但是，<strong>“覆盖内部类就像好像它是外围类的一个方法，其实并不起什么作用</strong>”<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Egg</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Yolk y;</span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.print(<span class="string">"Egg.folk()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Egg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"new Egg()"</span>);</span><br><span class="line">        y=<span class="keyword">new</span> Yolk();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigEgg</span> <span class="keyword">extends</span> <span class="title">Egg</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span></span>&#123;System.out.print(<span class="string">"BigEgg.folk()"</span>);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> BigEgg();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//new Egg()</span></span><br><span class="line"><span class="comment">//Egg.folk()</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这说明了一件事情，内部类和外部类其实是两个不同的类，内部类需要外部类对象的引用来创建自己，内部类具有访问外部类成员的权限，<strong>但是当继承一个外部类的时候，并不继承内部类</strong></p><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>前面提到过，可以在方法块里创建局部类，典型的方式是在一个方法的里面创建，<strong>局部内部类不能有访问说明符，因为它不是外围类的一部分，但是它可以访问当前代码块内的常量已经外围类的所有你成员</strong><br>&emsp;&emsp;既然局部内部类的名字在方法外是不可见的，那么我们我什么仍然使用局部内部类而不是匿名类呢？唯一的理由是：<strong>我们需要一个已命名的构造器，或者需要重载构造器，而匿名内部类只能用于实例初始化</strong></p><h2 id="内部类标识符"><a href="#内部类标识符" class="headerlink" title="内部类标识符"></a>内部类标识符</h2><p>&emsp;&emsp;由于每个类都会产生一个.class文件,其中包含了如何创建该类型的对象的全部信息（此信息产生一个meta-class，叫做Class对象），内部类也必须生成一个.class文件以包含他们的Class对象的信息。这些名字有严格的规定，外围类的名字，加上“$”,再加上内部类的名字，如果内部类时匿名的，编译器会简单地产生一个数字作为标识符</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;可以将一个类的定义放在另一个类的定义内部，这就是内部类&lt;/strong&gt;&lt;br&gt;&amp;emsp;&amp;ems
      
    
    </summary>
    
      <category term="学习心得" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>接口</title>
    <link href="http://yoursite.com/2018/10/09/%E6%8E%A5%E5%8F%A3/"/>
    <id>http://yoursite.com/2018/10/09/接口/</id>
    <published>2018-10-09T11:27:30.000Z</published>
    <updated>2018-10-10T08:57:02.180Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;接口和内部类为我们提供了一种将接口与实现分离的更加结构化的方法  </p><h2 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h2><p>&emsp;&emsp;我们创建这样一个类，这个类只提供通用的接口，我们希望通过这个通用接口可以操作一系列类，创建提供通用接口的对象有时是没有意义的，而且我们还希望禁止创建这样的一个类的对象，我们可以在这个抽象的类上写一些“哑”方法，当调用这个“抽象类”对象的“哑”方法时，能抛出错误，但是这样方式，只有在运行时才能被检测到<br>&emsp;&emsp;java提供了一个叫做抽象方法的机制，这种方法是不完整的，仅声明而没有方法体<br>&emsp;&emsp;包含抽象方法的类称为抽象类，如果一个类包含一个或者多个抽象方法，该类必须被限定为抽象的（否则，编译器会报错）<br>&emsp;&emsp;如果从一个抽象类继承，并想创建该新类的对象，那么就必须为基类的所有抽象方法定义，如果不这样做，那么导出类也必须是抽象的，而且编译器会强制我们使用abstract关键字来限定这个类<br>&emsp;&emsp;我们也可能会创建没有任何抽象方法的抽象类，考虑这种情况，这个类包含任何abstract方法都是没有意义的，而且我们也想阻止产生这个类的对象，那么这时这样做就是有意义的<br>&emsp;&emsp;创建抽象类和抽象方法时很有用的，因为它们可以使类的抽象性明确起来，并告诉用户和编译器打算怎样使用它们，抽闲类还是很有用的重构工具，因为它们使得我们可以很容易地将公共方法沿着继承层次结构向上移动</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>&emsp;&emsp;interface这个关键字产生一个完全抽象的类，它根本就没有提供任何具体实现，它允许创建者确定方法名，参数列表和返回类型，但是没有任何方法体<br>一个接口表示：“<strong>所有实现了该接口的类看起来都像是这样的</strong>”因此，任何使用某特定接口的代码都知道可以调用该接口的哪些方法，因此接口被用来建立类与类之间的协议<br>&emsp;&emsp;但是，interface是个极度抽象的类，因为它允许人们通过创建一个能够被向上转型为多积累的类型，来实现某种类似多重继变种的特性<br>&emsp;&emsp;接口的创建很简单，使用interface关键字替代class关键字，也可以在interface前面加上public（但仅限于该接口在与其同名的文件中被定义）如果不加public ，它只具有包权限，这样它只能在同一个包中可用，接口也可以包含域，但是这些域都是static和final的<br>&emsp;&emsp;可以在接口中显式地将方法声明为public，但即使你不这么做，它们也是public的，因此，当要实现一个接口时，在接口被定义的方法必须被定义为public，否则，它们只能得到包访问权限，这样在方法被继承的过程中，其可访问权限就被降低了，这是java编译器不允许的，所有接口中的方法必须是public的，即使不声明这些方法也会自动是public的</p><h2 id="完全解耦"><a href="#完全解耦" class="headerlink" title="完全解耦"></a>完全解耦</h2><p>&emsp;&emsp;只有一个方法操作的是类而非接口，那么你就只能使用这个类及子类，如果你想要将这个方法应用于不在此继承结构的某个类，那么就会很麻烦了，接口可以在很大程度上放宽这些限制，因此，它使得我们可以编写可复用更好的代码  </p><h2 id="java的多重继承"><a href="#java的多重继承" class="headerlink" title="java的多重继承"></a>java的多重继承</h2><p>&emsp;&emsp;接口不仅仅只是一种更纯粹形式的抽象类，它的目标比这更高。因为接口是根本没有任何具体实现的，也就是说，没有任何与接口相关的存储，因此也就无法阻止多个接口的组合，这一点很有价值，因为你需要表示“一个x是一个a和一个b以及一个c”，在C++中，组合多个类的接口的行为被称为<strong>多重继承</strong>它可能使你背负很沉重的负担，因为每个类都有一个具体实现<br>&emsp;&emsp;使用接口的核心原因：为了能够向上转型为多个基类型（以及由此带来的灵活性），然而，使用接口的第二个原因却是与抽象基类相同：防止客户端程序员创建该类的对象，并确保这仅仅是建立一个接口，这就带来了一个问题，我们应该使用接口还是抽象类？如果创建不带任何方法和成员变量的基类，那么你就选择接口而不是抽象类，事实上，如果知道某个事物应该成为一个基类，那么第一选择应该是使它成为一个接口</p><h2 id="通过继承来扩展接口"><a href="#通过继承来扩展接口" class="headerlink" title="通过继承来扩展接口"></a>通过继承来扩展接口</h2><p>接口与接口之间的继承很容易地创建一个新的接口，这个新的接口是这两个接口的并集</p><h3 id="组合接口时的命名冲突"><a href="#组合接口时的命名冲突" class="headerlink" title="组合接口时的命名冲突"></a>组合接口时的命名冲突</h3><p>&emsp;&emsp;组合接口拥有被组合接口的所有方法，所以判断组合接口时接口方法命名是否冲突的一个基本准则是，在新的接口中，被组合的接口能否共存  如下例：  </p><pre><code class="java"><span class="class"><span class="keyword">interface</span> <span class="title">I1</span> </span>{    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>;}<span class="class"><span class="keyword">interface</span> <span class="title">I2</span></span>{    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;}<span class="class"><span class="keyword">interface</span> <span class="title">I3</span></span>{    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a )</span></span>;}<span class="comment">//interface I4 extends I1,I2{ }即使方法返回值不同，I1和I2包含的接口命名冲突，不能共存</span><span class="class"><span class="keyword">interface</span> <span class="title">I5</span> <span class="keyword">extends</span> <span class="title">I1</span>,<span class="title">I3</span></span>{ }</code></pre><h2 id="适配接口"><a href="#适配接口" class="headerlink" title="适配接口"></a>适配接口</h2><p>&emsp;&emsp;接口最吸引人的原因之一就是允许同一个接口具有多个不同的具体实现，在简单的情况中，它的体现形式通常是一个接收接口类型的方法，而接口的实现和向该方法传递的对象则取决于方法的使用者<br>&emsp;&emsp;因此，<strong>接口的一种常见用法就是前面提到的策略设计模式</strong>，此时你编写一个执行某些操作的方法，而该方法将接受一个同样是你指定的接口，你主要就是声明：“你可以用任何你想要的对象来调用我的方法。只要你的对象遵守我的接口”</p><h2 id="接口中的域"><a href="#接口中的域" class="headerlink" title="接口中的域"></a>接口中的域</h2><p>&emsp;&emsp;因为你放入接口中的任何域都自动是static和final的，所以接口就成为了一种很便捷的用来创建常量组的工具，不过SE5之后，有了enum关键字之后，使用接口群组常量已经没什么意义了</p><h2 id="嵌套接口"><a href="#嵌套接口" class="headerlink" title="嵌套接口"></a>嵌套接口</h2><p>&emsp;&emsp;接口可以嵌套在类或者其他接口中，这揭示了许多非常有趣的特性  </p><figure class="highlight java"><figcaption><span>嵌套接口</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"><span class="comment">//在类中嵌套</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">B</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BImpl1</span> <span class="keyword">implements</span> <span class="title">B</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BImpl2</span> <span class="keyword">implements</span> <span class="title">B</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">C</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CImple1</span> <span class="keyword">implements</span> <span class="title">C</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>  <span class="class"><span class="keyword">class</span> <span class="title">CImple12</span> <span class="keyword">implements</span> <span class="title">C</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">D</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DImple1</span> <span class="keyword">implements</span>  <span class="title">D</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DImple2</span> <span class="keyword">implements</span>  <span class="title">D</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> D dRef;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> D <span class="title">getD</span><span class="params">()</span></span>&#123;<span class="keyword">return</span>  <span class="keyword">new</span> DImple1();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveD</span><span class="params">(D d)</span></span>&#123;</span><br><span class="line">        dRef=d;</span><br><span class="line">        d.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//在接口中嵌套</span></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">E</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">G</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//redundant public 多余的public</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">H</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NestingInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bimp</span> <span class="keyword">implements</span> <span class="title">A</span>.<span class="title">B</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CImpl</span> <span class="keyword">implements</span> <span class="title">A</span>.<span class="title">C</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    class DImpl implements  A.D&#123;</span></span><br><span class="line"><span class="comment">//        public void f()&#123;&#125;;</span></span><br><span class="line"><span class="comment">//    &#125;不能实现一个私有的接口</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">EImpl</span> <span class="keyword">implements</span>  <span class="title">E</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">EGImpl</span> <span class="keyword">implements</span> <span class="title">E</span>.<span class="title">G</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        <span class="comment">//Can't access A.D 不能访问A.D,因为A.D是私有的</span></span><br><span class="line">        <span class="comment">//A.D ad=a.getD();</span></span><br><span class="line">        <span class="comment">//除了A.D 也不能返回任何类型的引用 Doesn't return nothing but A.D</span></span><br><span class="line">        <span class="comment">//A.DImple2 dImple2=a.getD();</span></span><br><span class="line">        <span class="comment">//也不能访问这个接口的成员 connot access a member of the interface</span></span><br><span class="line">        <span class="comment">//a.getD().f();</span></span><br><span class="line">        <span class="comment">//可以让另一个A对getD()返回的对象进行操作。Only another A can do anything with getD()</span></span><br><span class="line">        A a2 = <span class="keyword">new</span> A();</span><br><span class="line">        a2.receiveD(a.getD()); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">      &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在类中嵌套接口是相当常见的语法，就像非嵌套接口一样，可以拥有publi和包访问权限，两种可视性，<br>&emsp;&emsp;作为一种新添加的方式，接口也可以被实现为private的，就像<code>A.D</code>中看到的那样（相同的方法，既可以适用于嵌套接口，也可以使用于嵌套类），那么private的嵌套接口能够带来什么好处呢？实现一个private接口只是一种方式，它可以强制接口中定义的定义的方法不要添加任何类型信息（也就是说，不能进行向上转型）<br>&emsp;&emsp;getD()方法陷入了一个两难的境地，这个问题与private接口有关，它是一个返回对private接口引用的public方法，你对这个方法返回值能做什么呢？在main方法时，我们尝试了很多行为都失败了，只有一种方式能够成功，那就是将返回值交给有权使用它的对象，在这个例子中，是另一个A通过<code>receiveD()</code>方法实现的<br>&emsp;&emsp;接口E说明接口彼此之间也是可以嵌套的，与在类嵌套接口不同，被嵌套在接口中的所有接口元素都是public的，，即使不声明，也会自动为public<br>&emsp;&emsp;注意的是，当实现某个接口的时候，并不需要实现嵌套在内部的任何接口，而且private接口也不能在定义它的类之外被实现</p><h2 id="接口和工厂"><a href="#接口和工厂" class="headerlink" title="接口和工厂"></a>接口和工厂</h2><p>&emsp;&emsp;接口是实现多重继承的途径，而生成遵循某个接口的对象的典型方式就是工厂方法设计模式，<strong>这与直接使用构造器不同，我们在工厂对象上调用的是创建方法</strong>，而该工厂对象将生成接口的某个实现的对象，通过这种方式，我们的代码将完全与接口的实现分离，这就使得我们可以透明地将某个实现替换成另一个实现<br><figure class="highlight java"><figcaption><span>工厂方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ServiceFactory</span></span>&#123;</span><br><span class="line">    <span class="function">Service <span class="title">getService</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceImp1</span> <span class="keyword">implements</span>  <span class="title">Service</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServcieImp1Factory</span> <span class="keyword">implements</span> <span class="title">ServiceFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  Service <span class="title">getService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServiceImp1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceImp2</span> <span class="keyword">implements</span>  <span class="title">Service</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServcieImp2Factory</span> <span class="keyword">implements</span> <span class="title">ServiceFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  Service <span class="title">getService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServiceImp2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factories</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serviceConsumer</span><span class="params">(ServiceFactory serviceFactory)</span></span>&#123;</span><br><span class="line">        Service service=serviceFactory.getService();</span><br><span class="line">        service.m1();</span><br><span class="line">        service.m2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        serviceConsumer(<span class="keyword">new</span> ServcieImp1Factory());</span><br><span class="line">        serviceConsumer(<span class="keyword">new</span> ServcieImp2Factory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果不是工厂方法，你的代码就必须要在某处指定将要创建的Service的确切类型，以便调用合适的构造器<br>&emsp;&emsp;为什么我们要增加这种额外级别的间接性呢？一个常见的原因是想要创建框架  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;接口和内部类为我们提供了一种将接口与实现分离的更加结构化的方法  &lt;/p&gt;
&lt;h2 id=&quot;抽象类和抽象方法&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="学习心得" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>多态</title>
    <link href="http://yoursite.com/2018/10/09/%E5%A4%9A%E6%80%81/"/>
    <id>http://yoursite.com/2018/10/09/多态/</id>
    <published>2018-10-09T06:34:58.000Z</published>
    <updated>2018-10-10T09:02:31.083Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;在面向对象的程序设计语言，多态是数据抽象和继承之后的第三种基本特征<br>&emsp;&emsp;多态通过分离做什么和怎么做，从另一个角度将接口和实现相分离，多态不但能够改善代码的组织结构和可读性，还能够创建可扩展的程序——即无论在项目最初创建时还是在需要新功能时都可以“生长”的程序<br>&emsp;&emsp;“封装”通过合并特征和行为来创建新的数据类型，“实现隐藏”则通过将细节“私有化”，把接口和实现分离开来。而多态的作用是消除类型之间的耦合关系，多态方法调用允许一种类型表现出与其他相似类型之间的区别，只要它们都是从一个基类中导出来的，这种区别是根据方法行为的不同而表示出来的，虽然这些方法都是可以通过同一个基类来调用  </p><h2 id="再论向上转型"><a href="#再论向上转型" class="headerlink" title="再论向上转型"></a>再论向上转型</h2><p>&emsp;&emsp;把某个对象的引用类型视为对基类的引用的做法就被称为向上转型  </p><h3 id="忘记对象类型"><a href="#忘记对象类型" class="headerlink" title="忘记对象类型"></a>忘记对象类型</h3><p>&emsp;&emsp;我们在程序的编写时，如果一个方法接受的是一个特定类型的参数，这样就产生了一个问题，我们是不是要为每一种特定类型写一个接受其特定类型的方法？我们有没有更通用的办法，使得方法接收一个更加通用的类型，而不在意具体的类型是什么，只要我们可以将这个特定类型当作通用类型的看待即可  </p><h2 id="转机"><a href="#转机" class="headerlink" title="转机"></a>转机</h2><p>&emsp;&emsp;将一个具体的类型当作向上转型类型的时候，编译器怎么知道它调用的是那个方法呢？实际上，编译器不知道，为了研究这个问题，先来看下绑定的定义<br>&emsp;&emsp;将一个方法调用同一个方法主体关联起来就被称为绑定，例如 <code>f()</code>是一个方法，a是A类型的对象，当a调用<code>f()</code>方法的时候，我们a调用的其实是<code>f()</code>方法,这就叫绑定，或者称作f()和A类型的对象进行了绑定,若在程序执行前进行绑定的话，由编译器和连接程序实现，就做前期绑定，我们没有听过则个术语，因为它是面向对象不需要选择就默认使用的绑定方式<br>&emsp;&emsp;我们对于多态的迷惑，主要是因为前期绑定，那么编译器应该知道调用那个方法才对，为什么不同的具体类型又会有不同的调用结果，不同的调用结果，就表明调用的不是同一个方法<br>&emsp;&emsp;解决的办法就是后期绑定，它的含义就是根据运行是根据对象的类型进行绑定吧，后期绑定也称为动态绑定或者运行期绑定，如果一种语言要想实现后期绑定，就必须具有某种机制，以便在运行时能判断对象的类型，从而调用恰当的方法，也就是说编译器不知道对象的类型，但是方法调用机制能够找到正确的方法体<br>&emsp;&emsp;java中除了static方法和final方法（private方法也属于final方法）之外，其他所有的方法都是后期绑定<br>&emsp;&emsp;为什么要将一个方法声明为final呢？除了之前讲到的原因之外，更重要的一点也许是：这样可以有效地“关闭”动态绑定，或者说，告诉编译器不需要对其进行动态绑定  </p><h3 id="产生正确的行为"><a href="#产生正确的行为" class="headerlink" title="产生正确的行为"></a>产生正确的行为</h3><p>&emsp;&emsp;一旦知道java中所有的方法都是通过动态绑定实现多态这个事实之后，我们就可以编写只与基类打交道的程序代码了，并且这些代码对所有导出类都可以正确运行，由于有多态机制，这样我们可以在系统当中添加任意多的新类型，而不需要改变基于基类编写的代码，这样的程序是可扩展的  </p><h3 id="缺陷：“覆盖”私有方法"><a href="#缺陷：“覆盖”私有方法" class="headerlink" title="缺陷：“覆盖”私有方法"></a>缺陷：“覆盖”私有方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package xyz.egbertday;</span><br><span class="line">class Derived extends PrivateOverride&#123;</span><br><span class="line">    public void f()&#123;</span><br><span class="line">        System.out.print(&quot;publi.f()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class PrivateOverride &#123;</span><br><span class="line">    private void f()&#123;</span><br><span class="line">        System.out.print(&quot;private.f()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        PrivateOverride derived=new Derived();</span><br><span class="line">        derived.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">~~~ </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">我们期望的是输出`public.f()`，但是由于private方法被自动地认为是final方法，在这里对private方法的调用是前期绑定  </span><br><span class="line">### 缺陷：域和静态方法 ###</span><br><span class="line">&amp;emsp;&amp;emsp;任何域访问操作都将由编译器解析，因此不是多态的，对静态方法的调用也不是多态的  </span><br><span class="line">## 构造器和多态 ##</span><br><span class="line">通常，构造器不同于其他种类的方法，设计到多态时也是如此，尽管构造器并不具有多态性（它们实际上是static方法，只不过该static声明的是隐式的），但还是有必要理解构造器怎么通过多态在复杂的层次结构中运作</span><br><span class="line">### 构造器的调用顺序 ###</span><br><span class="line">&amp;emsp;&amp;emsp;基类的构造器总是在导出类的构造过程中被调用，而且按照继承层次逐渐向上链接，以确保内个基类的构造器都能得到调用</span><br><span class="line">### 继承与清理 ###</span><br><span class="line">&amp;emsp;&amp;emsp;通过组合和继承方法创建新类时，方法永远不必担心对象的清理问题，子对象通常都会留给垃圾回收器进行，如果确实遇到清理的问题，那么必须用心为新类创建`dispose()`方法（这是个假设的名字）并且由于继承的缘故，如果我们有其他作为垃圾回收部分的特殊清理动作，必须现在导出类中覆盖`dispose()`方法，当覆盖被继承的`dispose()`方法时，务必调用基类版本的`dispose()`方法，否则，基类的清理动作就不会发生  </span><br><span class="line">~~~java</span><br><span class="line">package xyz.egbertday;</span><br><span class="line">class SuperClass&#123;</span><br><span class="line">    public void dispose()&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">public class SubClass extends SuperClass&#123;</span><br><span class="line">    public void dispose()&#123;</span><br><span class="line">        super.dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造器内部的多态方法的行为"><a href="#构造器内部的多态方法的行为" class="headerlink" title="构造器内部的多态方法的行为"></a>构造器内部的多态方法的行为</h3><p>&emsp;&emsp;构造器调用的层次问题带来了一个有趣的两难问题，如果在一个构造器的内部调用正在构造对象的某个动态绑定，那么会发生什么情况呢？<br>&emsp;&emsp;在一般的方法内部，动态绑定是在运行时才决定的，因为对象无法知道它是属于方法所在的类，还是属于那个类的导出类<br>&emsp;&emsp;如果要调用构造器内部的一个动态绑定方法，就要用到那个方法的被覆盖之后的定义，然而，这个调用的效果可能相当难预料，因为被覆盖的方法在对象被完全构建之前就会被调用，这可能会出现一些难以预料的隐藏错误<br>&emsp;&emsp;从概念上将，构造器的工作实际上是创建对象（这不是一件平常的事情），在任何构造器内部，整个构造器可能只是部分形成，如果构造器只是在构建对象过程中的一个步骤，并且该对象所属的类是从这个构造器所属的类导出的，那么导出部分在当前构造器正在被调用的时刻仍旧没有被初始化，然而，一个动态绑定的方法调用可能会向外深入到继承层次结构内部，它可以调用导出类里的方法,如果我们是在构造器内部这样做，那么就可能会调用这个方法，而这个方法所操作的成员可能还未进行初始化——这肯定会招致灾难<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"SuperClass"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    SuperClass()&#123;</span><br><span class="line">        printA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.print(<span class="string">"SubClass"</span>+a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SubClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolyConstructor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        SubClass subClass = <span class="keyword">new</span> SubClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;我们预期，当创建基类的时候，会先调用基类的构造器，在基类的构造器方法中调用了<code>print()</code>,因为动态代理的缘故，实际上调用的是导出类的<code>printA()</code>我们预期结果会是“SubClass1”,可是因为当调用基类的构造器时，还没有对导出类进行初始化，i仍然是0值<br>&emsp;&emsp;以前讲的初始化顺序并不十分完整，而这正是立即谜题的关键，初始化的实际过程是  </p><ol><li>在其他任意事物发生之前，将分配给对象的存储空间初始化成二进制的零</li><li>如前所述那样调用基类构造器，此时，调用被覆盖后的<code>printA()</code>方法（要在调用导出类的构造器之前），由于步骤1的关系，我们此时会发现i的值为0 </li><li>按照声明的顺序调用成员的初始化方法<br>&emsp;&emsp;这样做有一个优点，那就是所有东西至少初始化为零<br>&emsp;&emsp;编写构造器的时候有一条有效地准则“用尽可能简单的方法使对象进入正常状态，如果可以的话，避免调用其他方法”在构造器中唯一能够安全调用的方法是基类的那些final方法（private也是final方法），这些方法不能被覆盖，因此也就不不会发生动态绑定（多态）的问题了<h2 id="协变返回类型"><a href="#协变返回类型" class="headerlink" title="协变返回类型"></a>协变返回类型</h2>&emsp;&emsp;协变返回类型，它表示在导出类中的被覆盖的方法可以返回基类方法返回类型的某种导出类型<h2 id="用继承进行设计"><a href="#用继承进行设计" class="headerlink" title="用继承进行设计"></a>用继承进行设计</h2>&emsp;&emsp;多态特性很容易诱使我们继承现有的类，以实现多态的特性，实际的开发当中，如果首先考虑继承技术，反而会加重我们的设计负担<br>&emsp;&emsp;更好的方式是首先选择“组合”，尤其是不能十分确定应该使用哪一种方式时，组合不会强制我们的程序设计进入继承的层次结构，而且，组合更加灵活，它可以动态选择类型（因此也就选择了行为），相反，继承在编译时就需要知道确切类型。看看下面的经典案例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Actor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">act</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HappyActor</span> <span class="keyword">extends</span> <span class="title">Actor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">act</span><span class="params">()</span></span>&#123;System.out.print(<span class="string">"happy"</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SadActor</span> <span class="keyword">extends</span> <span class="title">Actor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">act</span><span class="params">()</span></span>&#123;System.out.print(<span class="string">"sad"</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stage</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Actor actor=<span class="keyword">new</span> HappyActor();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">()</span></span>&#123;</span><br><span class="line">        actor=<span class="keyword">new</span> SadActor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line">        actor.act();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transmogrify</span> </span>&#123;</span><br></pre></td></tr></table></figure></li></ol><p>&emsp;&emsp;在这里，Stage对象包含一个对Actor的引用，而Actor被初始化为一个HappyActor对象，这意味着play()会产生某种特殊行为，既然引用在运行时可以与另一个不同对象重新绑定（”<code>change()</code>“），所以SadActor对象的引用可以在actor中被替换，然后由<code>play()</code>产生的行为也随之改变，这样一来，我们在运行期间获得了动态的灵活性（这也称为“状态模式”），与此相反，我们不能再运行期间决定继承不同的对象，因为它要求在编译器间完全确定下来<br>&emsp;&emsp;一条通用的法则是：用继承表达行为之间的差异，并用字段表达状态上的变化，在上面例子，两者都用到了，通过继承得到了两个不同的类，用于表达<code>act()</code>方法的差异，而Stage通过运用组合使自己的状态发生变化，在这情况下，这种状态的改变也就产生了行为的改变</p><h3 id="纯继承与扩展"><a href="#纯继承与扩展" class="headerlink" title="纯继承与扩展"></a>纯继承与扩展</h3><p>&emsp;&emsp;“纯粹”的继承表示导出类和基类的接口完全一致<br>&emsp;&emsp;扩展表示在基类的基础上添加导出类自己所特有的方法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在面向对象的程序设计语言，多态是数据抽象和继承之后的第三种基本特征&lt;br&gt;&amp;emsp;&amp;emsp;多态通过分离做什么
      
    
    </summary>
    
      <category term="学习心得" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>复用类</title>
    <link href="http://yoursite.com/2018/10/07/%E5%A4%8D%E7%94%A8%E7%B1%BB/"/>
    <id>http://yoursite.com/2018/10/07/复用类/</id>
    <published>2018-10-06T17:41:58.000Z</published>
    <updated>2018-10-10T08:57:49.411Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>&emsp;&emsp;复用代码是java众多引人注目的功能之一，但要想成为极具革命性的语言，仅仅能够复制代码并对之加以改变是不够的，它还必须能够做更多的事情<br>&emsp;&emsp;正如Java中所有事物一样，问题的解决都是围绕着类展开的，可以通过创建新类来复用代码，而不必再从头开始编写，可以使用别人业已开发并调试好的类。<br>&emsp;&emsp;此方法的窍门在于使用类而不破坏现有程序的代码，有两种方式可以达到这种目的，组合和继承  </p></blockquote><h2 id="继承语法"><a href="#继承语法" class="headerlink" title="继承语法"></a>继承语法</h2><p>&emsp;&emsp;当创建一个类的时候，总是在继承，因为除非已经明确指出要从其他类继承，否则都是隐式地从Java的标准跟类Object继承<br>&emsp;&emsp;在继承的过程，需要先声明“新类与基本相似”。这种声明是通过extends关键字完成的  </p><h3 id="初始化基类"><a href="#初始化基类" class="headerlink" title="初始化基类"></a>初始化基类</h3><p>&emsp;&emsp;从外部看，导出类就像一个与基类具有相同接口的新类，或许还会有一些额外的方法和域，但继承并不只是复制基类的接口，当创建一个导出来类的对象时，该对象包含一个基类的子对象，这个子对象和你用基类直接创建的对象是一样的，二者之间的区别在于，后者来自于外部，而基类的子对象被包装在导出类对象的内部，其实来说，整个导出类对象的创建过程并没有产生父类的对象，我们只是利用了父类的构造函数来初始化导出类的属性，对基类子对象的初始化必须得到保证，所以就是在导出类的构造器中通过调用基类构造器来执行初始化，而基类构造器具有执行基类初始化所需的所有知识和能力，Java会自动在导出类的构造器中插入对基类构造器的调用，其为什么导出类不能直接访问这些由基类初始化的属性，我们之后再谈<br>&emsp;&emsp;所以我们也会发现，整个创建过程是从导出类依次上溯，构造函数执行的初始化动作依次向下</p><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>&emsp;&emsp;第三种关系称为代理，java并没有提供对它的直接支持，这是继承和组合的中庸之道，因为我们将一个对象置于所要构造的类中（就像组合），但与此同时我们在新类中暴露该成员的所有方法（就像继承）</p><h2 id="结合使用组合和继承"><a href="#结合使用组合和继承" class="headerlink" title="结合使用组合和继承"></a>结合使用组合和继承</h2><p>&emsp;&emsp;同时使用组合和继来创建复杂的类是很常见的，因为新类能够同时可以对继承和组合的类的功能进行复用</p><h2 id="在组合和继承之间选择"><a href="#在组合和继承之间选择" class="headerlink" title="在组合和继承之间选择"></a>在组合和继承之间选择</h2><p>&emsp;&emsp;组合和继承都允许在新类中放置子对象，组合是显式地这样做，而继承则是隐式地这样做，那当我们创建的新类想要使用另一个类的服务（接口）时，该如何选择？<br>&emsp;&emsp;组合技术通常用于想要使用现有类的功能而不是它的接口这种情形，在新类中嵌入某个类的对象，让其实现所需的功能，但新类的用户看到的只是新类所定义的接口，而非所嵌入对象的接口，为取得此效果，需要在新类中嵌入一个现有类的private对象<br>&emsp;&emsp;有时，运行累的用户直接访问新类中的组合成分是及其有意思的，也就是说，将成员对象声明为public，如果成员对象自身隐藏了具体实现，那么这样做也是安全的，当用户能够了解你正在组装一组部件，会使得端口更加易于理解，比如组装一辆车Car，<code>car.left.window.roolup()</code>这样的代码很容易让人理解，但是，一般情况下，我们还是会将一个对象声明为private，并通过公开的接口来获得这个成员对象<br>&emsp;&emsp;在继承的时候，使用现有的类，并开发一个它的特殊版本，通常，这意味着你在使用一个通用类，为了某种特性需要而对其特殊化</p><h2 id="protected关键字"><a href="#protected关键字" class="headerlink" title="protected关键字"></a>protected关键字</h2><p>&emsp;&emsp;在理想世界中，关键字private就足够了，但在实际项目中，经常会将某些事物尽可能对整个世界隐藏，但仍然运行导出类的成员访问它们<br>&emsp;&emsp;关键字protected就是起到这个作用，它指明“就类用户而言，这是private的，但对于任何继承于此类的导出类或任何位于同一个包的类来说，它确实可以访问的（protected也提供了包访问权限）”<br>&emsp;&emsp;尽管可以创建protected域，但是最好的方式还是将域保持为private，你应当一致保留“要更改底层实现”的权利，然后通过protected方法来控制类的继承者的访问权限</p><h2 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h2><p>“为新的类提供方法”并不是继承的最重要的方面，其最重要的方面是用来表现新类和基类之间的关系，这种关系可以用“新类是现有类的一种类型”，这句话加以概括<br>这个描述并不只是一种解释继承的华丽方式，这直接是由语言所支撑的，由于继承可以确保基类中所有的方法在导出类中也同样有效，所有能够向基类发送的所有信息同样也可以向导出类发送<br>&emsp;&emsp;由导出类转型成基类，在继承图上是向上移动的，因此一般称为向上转型，由于向上转型是从一个较专用类型向一个较通用类型转换，所以总是安全的，也就是说，导出类是基类的一个超集，在向上转型的过程中，类接口中唯一可能发生的事情是丢失方法，而不是获取它们，这也是为什么编译器在“未曾明确表示转型”或“未曾指定特殊标记”情况下，仍然允许向上转型的原因  </p><h3 id="再论组合和继承"><a href="#再论组合和继承" class="headerlink" title="再论组合和继承"></a>再论组合和继承</h3><p>&emsp;&emsp;在面向对象时，生成和使用程序代码最有可能的方法就是直接将数据和方法包装进一个类中，并使用该类的对象，也可以运用组合和继承使用现有类来开发新的类，而继承技术其实是不太常用，即使在学习过程中，过多的强调继承，对于这个技术，也是要谨慎使用，那在一个场合下如何确定你应该使用继承还是组合呢？一个最清晰的判断方法就是要问一问你自己是否需要从新类向基类进行向上转型，如果必须向上转型，则继承是必要的，如果不需要，最好使用组合  </p><h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p>&emsp;&emsp;根据上下文关系，java的关键字final含义存在着细微的区别，但通常它指的是“这是无法改变的”，不想改变可能出于两个理由：设计和效率，由于这两个理由相差很远，所以关键字final有可能被误用</p><h3 id="final数据"><a href="#final数据" class="headerlink" title="final数据"></a>final数据</h3><p>&emsp;&emsp;很多编程语言都有某种方法，来向编译器告知一块数据是恒定不变的，有时数据的恒定不变是很有用的，比如  </p><ol><li>一个永不改变的编译时常量  </li><li><p>一个在运行时被初始化的值，而你不希望它被改变<br>&emsp;&emsp;对于编译器常量这种情况，编译器可以将该常量带入任何可能用到它的计算式中，也就是说，可以在编译时执行计算，这样减轻了运行时的负担，在java中，这类常量必须是基本数据类型，并且以关键字final表示，在对这个常量进行定义时，必须对其进行赋值<br>&emsp;&emsp;一个既是static又是final的域只占据一段不能改变的存储空间<br>&emsp;&emsp;当对对象引用而不是基本类型引用final时，含义有一些令人迷惑，对于基本变量，final使其数值恒定不变，而对于对象引用，final使其引用恒定不变，一旦引用被初始化指向一个对象，就无法再将它改为指向另一个对象，然而对象自身是可以被修改的，java并没有提供使任何对象恒定不变的途径（但可以编写类以取得使对象恒定不变的效果），这一个限制也适用数组，它也是对象<br>&emsp;&emsp;还有一个要注意的是，我们不能因为某数据是final的就认为在编译时就可以知道它的值，但是我们知道一旦这个数据被初始化之后就恒定不变，所以说，final关键字修饰的数据，是在数据被初始化之后保持不变  </p><h3 id="空白final"><a href="#空白final" class="headerlink" title="空白final"></a>空白final</h3><p>&emsp;&emsp;java允许生成“空白final” 所谓空白final是被声明为final，但是又为给定初值的域，无论什么情况，编译器确保空白final在使用之前必须被初始化，但是空白final在关键字final的使用上提供了更大的灵活性，为此一个类中的final域可以做到根据对象而不同，却又保持着恒定不变的特性  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package xyz.egbert  </span><br><span class="line">class ProPet&#123;</span><br><span class="line">    private int i;</span><br><span class="line"></span><br><span class="line">    public ProPet(int i) &#123;</span><br><span class="line">        this.i = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class BlankFinal &#123;</span><br><span class="line">    private final int i=0;</span><br><span class="line">    private final int j;</span><br><span class="line">    private final ProPet proPet;</span><br><span class="line"></span><br><span class="line">    public BlankFinal()&#123;</span><br><span class="line">        this.j=0;</span><br><span class="line">        this.proPet=new ProPet(1);</span><br><span class="line">    &#125;</span><br><span class="line">    public BlankFinal(int x)&#123;</span><br><span class="line">        this.j=x;</span><br><span class="line">        this.proPet=new ProPet(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~~~ </span><br><span class="line">从上面代码示例中可以看到，必须在域定义处或者每个构造器内对final进行赋值，否则IDE工具会提示编译错误，进行源码的编译时也会发生编译失败  </span><br><span class="line">### final参数 ###</span><br><span class="line">&amp;emsp;&amp;emsp;java允许在参数列表以声明的方式将指数指名为final，这意味着你无法在方法中更改参数引用所指向的对象</span><br><span class="line">### final方法 ###</span><br><span class="line">&amp;emsp;&amp;emsp;使用final方法的原因有两个，第一个原因是把方法锁定，以防任何继承类修改它的含义，这是出于设计的考虑，想要确保在继承中使方法行为保存不变，并且不会被覆盖  </span><br><span class="line">在过去第二个原因是效率，在java的早期实现中，如果将一个方法指名为final,就是同意编译器将针对该方法的所有调用都转为内嵌调用，但是在最近的java版本中，已经不再需要使用final方法进行优化了，事实上，这种做法正逐渐受到阻止</span><br><span class="line">#### final和private关键字 ####</span><br><span class="line">&amp;emsp;&amp;emsp;类中的所有private方法都隐式地指定为final的，由于无法取用private方法，所以也就无法覆盖它，可以给private添加final修饰词，但这并不能给该方法增加任何额外的意义</span><br><span class="line">这一问题会造成困扰，我们知道final修饰的方法禁止了继承类的覆盖，如果在继承类中重写基类的final方法，则会引发编译错误，它会提示你这个方法以及在基类中被定义了，可是如果你试图覆盖一个private方法（隐含是final的），似乎是奏效的，而且编译器也不会给出错误信息</span><br></pre></td></tr></table></figure><pre><code>package xyz.egbertday;public class Type {    private final void f(){        System.out.print(&quot;Type&quot;);    }}public class SubType extends Type{    public void f(){        System.out.print(&quot;subType&quot;);    }    public static void main(String[] args){        SubType subType=new SubType();        subType.f();        Type type=subType;        //type.f();    }}</code></pre><p>~~~</p></li></ol><p>&emsp;&emsp;”覆盖”只是在某个方法是<strong>基类的接口</strong>的一部分时才会出现，即，必须能将一个对象向上转型为它的基类型并调用相同的方法，如果某个方法为private,它就不是基类的接口的一部分，它仅是一些隐藏于类中的程序代码，只不过是具有相同的名字而已，但如果在导出类中以相似的名称生成为一个public，protected或者包访问权限方法的话，该方法就不会产生在基类中出现的“仅具有相同名称”的情况，此时你并没有覆盖该方法，仅是生成了一个新的方法，由于private方法无法触及而且能够有效隐藏，所有<strong>除了把它看成因为它所归属的累的组织结构的原因而存在外，其他任何事物都不需要考虑到它</strong>  </p><h3 id="final类"><a href="#final类" class="headerlink" title="final类"></a>final类</h3><p>&emsp;&emsp;当将某个类整体定义成final时，就表明了你不打算继承该类，而且也不允许别人这么做，换句话说，出于某种考虑，你对该类的设计永不需要做任何改动，或者出于安全的考虑，你不希望它有子类</p><h2 id="初始化和类的加载"><a href="#初始化和类的加载" class="headerlink" title="初始化和类的加载"></a>初始化和类的加载</h2><p>&emsp;&emsp;在很多传统语言，程序是作为启动过程的一部分立刻被加载的，然后初始化，紧接着程序开始运行    ，这些语言的初始化必须小心控制，以确保定义为static的东西，其初始化的顺序不会造成麻烦<br>&emsp;&emsp;java就不会出现这种问题，因为它采用了不同的加载方式，我喜欢称为（动态加载），加载是众多变得更加容易的动作之一，因为<strong>java中的所有事物都是对象</strong>，请记住，<strong>每个类的编译代码都存在与它自己的独立文件中</strong>    该文件之一在需要使用程序时才会被加载，一般来说，类的代码在初次使用时才加载，这通常是指加载发生在类的第一个对象被创建之时，也会发生当访问static域或static方法时，也会发生加载<br>&emsp;&emsp;初次使用之处也是static初始化发生之处，所有的static对象和static代码都会在加载时依程序中的顺序（即，定义类时的书写顺序）而依次初始化，当然，定义为static的东西只会被初始化一次 </p><h3 id="继承和初始化"><a href="#继承和初始化" class="headerlink" title="继承和初始化"></a>继承和初始化</h3><p>导出类的对象创建过程就是，依继承链向上一次进行加载，加载完成之后，根基类中的static初始化即会被执行，然后是下一个导出类，以此类推，这种方式很重要，因为导出类的static初始化可能会依赖于基类成员能否被正确初始化<br>&emsp;&emsp;至此，必要的类都被加载完毕，对象就可以被创建了，首先，对象中所有的基本类型都被设为默认值，对象引用都被设为null——这是通过将对象内存设为二进制零值而一举生成的，然后，基类的构造器就会被调用，它是被自动调用的，但也可以用super来指定对基类构造器的调用，基类构造器和导出类的构造器一样，以同样的顺序来经历相同的过程，在基类构造器完成之后，实例变量按其次序依次被初始化，然后构造器的其余部分被执行  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;继承和组合都能从现有类型生成新类型，组合一般是将现有类型作为新类型底层实现的一部分加以复用，而继承复用的是接口<br>&emsp;&emsp;在使用继承时，由于导出类具有基类接口，因此它可以向上转型至基类，这对多态来讲至关重要<br>&emsp;&emsp;尽管面向对象编程对继承极力强调，但是开始一个设计时，一般有限选择使用组合（或者可能是代理），只有确实有必要时才使用继承，因为组合更具有灵活性，此外对成员类型使用继承技巧的添加技巧，可以在运行时改变那些成员对象的类型和行为，因此可以在运行时改变组合而成的对象的行为<br>&emsp;&emsp;在设计一个系统时，目标应该是找到或者创建某些类，其中每个类都有具体的用途，而且既不会太大（包含太多的功能而难以复用）。也不会太小（不添加其他功能就不能用），如果你的设计过于复杂，通过将现有类拆分为更小的部分而添加更多的对象，通常这是有帮助的                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;复用代码是java众多引人注目的功能之一，但要想成为极具革命性的语言，仅仅能够复制代码并对
      
    
    </summary>
    
      <category term="学习心得" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>访问权限控制</title>
    <link href="http://yoursite.com/2018/10/06/%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
    <id>http://yoursite.com/2018/10/06/访问权限控制/</id>
    <published>2018-10-06T06:39:23.000Z</published>
    <updated>2018-10-10T09:00:35.830Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>访问控制（或隐藏具体实现）与“最初的实现并不恰当”有关  </p></blockquote><p>几乎所有的代码某些部分经过一段时间再回头看，可能会发现有更好的方式来去实现相同的功能，这正是重构的原动力之一，重构或者重写代码，以使得它更可读，更易理解，更具有可维护性<br>&emsp;&emsp;但是，在这种修改和完善代码的愿望下，也存在着巨大的压力，通常总会有一些消费者（客户端程序员）需要你的代码在某些方面不变，由此产生了面向对象设计中需要考虑的一个基本问题：“如何把变动的事物与保持不变的事物区分开来”<br>这一目标可以通过约定达成，例如，类库的开发者必须保证不得删除任何现有的方法，因为那样会破坏客户端程序员的代码，但是，与之相反的情况更加棘手，在域（数据成员）存在的情况下，类库开发者要怎么知道究竟都有哪些已经被客户端程序员所调用了呢？<br>&emsp;&emsp;为了解决这一问题，java提供了访问权限修饰符，以供类库开发人员指明了哪些是可用的，哪些是不可用的<br>&emsp;&emsp;不过，构件类库的概念已经对于谁有权取用该类库构件的控制问题还是不完善的，其中仍然存在着如何将构件捆绑到一个内聚的类库单元中的问题，对于这一点，java用关键字package加以控制，而访问权限修饰词会因类是存在于一个相同的包还是存在于一个单独的包而受到影响，所以要理解理解访问权限修饰符的全部含义，要先学习如何将类库构件置于包中  </p><h2 id="包：库单元"><a href="#包：库单元" class="headerlink" title="包：库单元"></a>包：库单元</h2><p>&emsp;&emsp;由于名字之间的潜在冲突，在java中对名称空间进行完全控制并为每个类创建唯一的标识符组合就成为了非常重要的事情<br>&emsp;&emsp;当编写一个java源代码文件时，此文件通常被称为编译单元（有时也被称为转译单元），每个编译单元都必须要有一个后缀名.java，而在编译单元内则可以有一个public类，该类的名称必须要与源文件名称相同，否则编译器就不会接受，如果在编译单元之中还有额外的类的话，那么包之外的世界是无法看见这些类的，这是因为他们不是public类，而且他们主要是用来为主public类提供支持的  </p><h3 id="代码组织"><a href="#代码组织" class="headerlink" title="代码组织"></a>代码组织</h3><p>&emsp;&emsp;当编译一个java文件时，在java文件中的每一个类都会有一个输出文件，而输出文件的名称与.java文件的名称相同，只是多了后缀名.class,因此少量的编译.java文件，就会得到大量的<code>.class</code>文件<br>&emsp;&emsp;java可运行程序时一组可以打包并压缩为一个java文档文件（Jar，使用java的jar文档生成器）的.class文件，java解释器负责这些文件的查找，装载和解释<br>&emsp;&emsp;类库实际上是一组类文件，其中每个文件都有一个public类，以及任意数量的非public类，因此每一个文件都有一个构件，如果希望这些构件（每一个都有它们自己的独立的<code>.java</code>和<code>.class</code>文件）从属同一个群组，就可以使用关键字package<br>    package access;<br>&emsp;&emsp;这表明你在声明该编译单元是名为access的类库的一部分，或者换种说法，你正在声明该编译单元中的public类名称位于access名称的保护伞下，任何想要使用该名称的人都必须使用该类库构件的全名或者使用import关键  </p><h3 id="创建独一无二的包名"><a href="#创建独一无二的包名" class="headerlink" title="创建独一无二的包名"></a>创建独一无二的包名</h3><p>&emsp;&emsp;其实一个包从未真正将被打包的东西包装成一个单一的文件，并且一个包可以由许多.class文件构成，也就是说，我们只是定义了类是在哪个命名空间下，通过命名空间和类名唯一地标识这个类，那么情况有点复杂，当我们的程序在运行的时候，应该去哪里找到某个特定类的定义信息（就是<code>.class</code>文件）呢？<br>&emsp;&emsp;为了避免这种情况的发生，一种合乎逻辑的做法就是将特定包内的所有<code>.class</code>文件都置于一个目录下，也就是说，利用操作系统的层次化的文件结构来解决这个问题<br>&emsp;&emsp;将所有文件收入一个子目录还可以解决另外两个问题：创建独一无二的名称已经怎么查找有可能隐藏于目录结构中的某处的类<br>第一个问题是，通过域名反写的形式创建独一无二的类<br>第二个问题是：把package名称分解为你机器上的一个目录，所以java程序运行并需要加载<code>.class</code>文件的时候，它就可以确定<code>.class</code>文件在目录上所处的目录<br>&emsp;&emsp;java解释器的运行过程如下：首先，找到环境变量CLASSPATH，CLASSPATH包含一个或多个目录，用作查找<code>.class</code>文件的根目录，从根目录开始，解释器将包名解析成目录，得到的目录与CLASSPATH中的各个不同的项相连接，解释器就在这些目录下查找与你所要创建的类名称相关的<code>.class</code>文件，所要我们要想使用某个类库，一定要在将类库放在CLASSPATH变量中指定的目录的任意一个，或者也可以将类库的当前目录添加到CLASSPATH变量中，JAR文件有些许变化，必须要在类路径中将JAR文件的实际名称写清楚，而不仅仅只是指出它所在的目录  </p><h2 id="java访问权限修饰符"><a href="#java访问权限修饰符" class="headerlink" title="java访问权限修饰符"></a>java访问权限修饰符</h2><table><thead><tr><th>权限修饰词</th><th>权限说明</th></tr></thead><tbody><tr><td>public</td><td>允许任意的类对其修饰的成员访问</td></tr><tr><td>private</td><td>只有包含该成员的类才能对其访问</td></tr><tr><td>protected</td><td>只有派生类和同包的类才能对其进行访问</td></tr><tr><td>默认包访问权限</td><td>只有同一个类库下的类才能对其访问  </td></tr></tbody></table><p>&emsp;&emsp;我想对访问权限多说一些，对于初学者对访问权限并不是很清楚，即使是工作多年的java工程师对访问权限控制也没有很清晰的认识，即使认知如此，好像也不太影响完成项目的任务，可是我还是想把这些事情讲清楚说明白些<br>&emsp;&emsp;我们都知道java是门面向对象的语言，以面向对象的思维编程很符合人类的思维习惯，可是我们应该清楚的是，java之所以有面向对象的特性,要感谢编译器，我们之前描述方法的执行往往是说发送消息给对象，这是面向对象的说法，真正的过程应该是对这个对象的数据执行方法定义的程序，具有过程，比较复杂，这里牵扯到cpu和内存，指令之间的关系，不过我们只需要知道对对象数据进行操作就足够理解权限控制的含义了，由此我们也知道，同一个类型的所有对象的方法代码只有一份，放在方法区，每个对象都有自己独有的数据放在堆中，方法代码和数据分离，理解下面四个问题，就能明白访问权限控制的全部含义</p><ol><li>什么是“权限”？ </li><li>权限是限制谁的？   </li><li>权限可以修饰哪些元素？</li><li>访问权限修饰符是给谁用的<br>&emsp;&emsp;“权限”中文的含义很简单，就是权力的限制，直接讲就是可以做什么<br>&emsp;&emsp;权限是限制其他类的，对于被访问修饰符修饰的元素来说，其他的类对于它来讲，只有三个身份，分别是其他的类，同类库的类，派生的类，对于这三种身份，不同的权限修饰符给与他们的访问权限不同，举例来说，对于protected修饰的元素来说，其他类型的类不能对其访问，同类库和派生类可以对其访问<br>&emsp;&emsp;访问权限修饰符可以修饰哪些元素，类，域和方法<br>&emsp;&emsp;访问权限修饰符是给编译器使用的，编译过程保证了互相调用的正确性，访问权限会被编译器编译进类的字节码文件（<code>.class</code>文件）中，以供编译器编译新代码时作为权限检查的信息来使用<br>&emsp;&emsp;在讲一些小的细节吧，如果A能访问B,B能够访问C,但是A不能访问C,那么A可以“调用”C中的方法吗？答案是不可以，C中的方法能否被访问，要查看调用它的类对于它的权限，但是A却可以通过B来调用C,我喜欢称为委托，也就是说方法的调用是两个类之间的事情，有点绕，但是很有意思<h2 id="接口和实现"><a href="#接口和实现" class="headerlink" title="接口和实现"></a>接口和实现</h2>&emsp;&emsp;访问权限的控制常被称为具体实现的隐藏，把数据和方法包装进类中，以及具体实现的隐藏，常共同被称作时封装，其结果是一个同时用于特征和行为的数据类型<br>&emsp;&emsp;出于两个很重要的原因，访问权限控制的边界划在了数据类型的内部，第一个原因时要设定客户端程序员可以使用和不可以使用的界限，这个原因直接引出了第二个原因，实现接口和实现的分离  <h2 id="类的访问权限"><a href="#类的访问权限" class="headerlink" title="类的访问权限"></a>类的访问权限</h2>&emsp;&emsp;在java中，权限控制符也可以用于确定库中的哪些类对于库的使用者是可用的，如果希望某个客户端程序员能够使用这个类，就使用public来定义这个类，这样做甚至可以控制客户端程序员能否创建一个该类的对象<br>&emsp;&emsp;这里有一些限制  </li><li>每个编译单元（<code>.java</code>文件）都只能有一个public类，这表示，每个编译单元只能有一个公共接口  </li><li>public类必须完全与含有编译单元的文件名相匹配  </li><li>虽然不是很常用，但编译单元内完全不带public类也是可能的，在这种情况下，可以随意对文件命名，但是不建议<br>&emsp;&emsp;还有需要注意的是：类的定义一定不能是private或者protected的，只能是public或者不加任何修饰符的包访问权限</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;访问控制（或隐藏具体实现）与“最初的实现并不恰当”有关  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;几乎所有的代
      
    
    </summary>
    
      <category term="学习心得" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>初始化与清理</title>
    <link href="http://yoursite.com/2018/10/05/%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/"/>
    <id>http://yoursite.com/2018/10/05/初始化与清理/</id>
    <published>2018-10-05T15:57:28.000Z</published>
    <updated>2018-10-10T08:58:46.853Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>随着计算机革命的发展，“不安全”的编程方式已逐渐成为编程代价高昂的主要原因<br>&emsp;&emsp;初始化和清理（cleanup）正是涉及安全的两个问题，许多C程序的错误都源于程序员忘了初始化变量，特别是在使用程序时，如果用户不知道如何初始化库的构件（或者是用户必须要初始化的其他东西）更是如此，清理也是一个特殊问题，当使用一个元素时，它对你不会有什么影响了，所有很容易把它忘掉，这样一来，这个元素占用的资源得不到释放  </p></blockquote><h2 id="用构造器确保初始化"><a href="#用构造器确保初始化" class="headerlink" title="用构造器确保初始化"></a>用构造器确保初始化</h2><p>&emsp;&emsp;假想为每个类都定义一个初始化方法，命名为<code>intialize()</code>好了，所以你在向对象发送消息之前，为了确保对象被恰当地初始化了，你应该先主动去调用这个<code>initialize()</code>方法，可是如果你忘了怎么办呢？如果我们咋创建对象的时候能够自动进行对象的初始化工作就好了，这样就确保了我们创建的对象一定被正确地初始化了<br>&emsp;&emsp;接下来的问题是如何命名这个初始化方法，有两个问题  </p><ol><li>所取的任何名字都可能会与方法名冲突</li><li>调用构造器是编译器的责任，编译器应该要调用这一个方法<br>我们的解决的方法很简单，构造器的名称和类名相同，这是一种约定，即解决了和方法名字的冲突问题，又解决了编译器识别的问题，构建哪个类的对象就调用那个类的与方法名相同的构造函数  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Rock();</span><br></pre></td></tr></table></figure>&emsp;&emsp;上述创建对象的过程可以被拆解成两步，第一步，为对象分配内存空间，第二步，调用相对应的构造函数，理论上讲，“初始化”和“创建”是彼此独立的，然而在java代码中你找不到两者之间的界限，也看不到对构造的显式调用，java将“初始化”和“创建”捆绑在了一起，两者不能分离<br>&emsp;&emsp;构造函数是一种特殊的函数，说特殊，是因为它在对象创建的过程中就被自动调用了，而且只能被调用一次，且构造函数的代码中没有返回值，这与void不同，其实构造函数被调用之后会返回新对象的一个引用，只是我们在构造函数中不写返回类型，这是一种规定，你只需遵守就行了<h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2>&emsp;&emsp;大多数程序设计语言要求为每个方法（在有些语言中经常成为函数）都提供一个独一无二的标识符，在java（和C++）里，构造器是强制重载方法名的一个很重要的一个原因，既然构造器的方法名由类名决定，那就只能有一个构造器，可是如果我想以多种方式来创建一个对象时该怎么办呢？为了让方法名相同而参数不同的构造器同时存在，必须要用到方法的重载  <h3 id="区分方法重载"><a href="#区分方法重载" class="headerlink" title="区分方法重载"></a>区分方法重载</h3>要是有几个方法都要相同的方法，java如何知道你指的是哪个方法呢？其实规则很简单，每个重载的方法都必须要有一个独一无二的参数类型列表，注意返回值类型不作为方法重载的依据，因为如果我们只是利用方法的副作用而不使用方法的返回值的话，编译器还是没办法判断应该调用哪一个方法例如<br> void say(){};<br> String say(){};<br> a.say();<br>&emsp;&emsp;这样你能判断a调用的是哪个方法吗？不能，所有为了避免java的困扰，返回值类型不能作为方法重载的依据<h3 id="涉及基本类型的重载"><a href="#涉及基本类型的重载" class="headerlink" title="涉及基本类型的重载"></a>涉及基本类型的重载</h3>&emsp;&emsp;基本类型的重载是，先找那些方法的参数类型最符合自己类型的方法，如果找不到以此向上提升，注意，有一个特殊，如基本类型为char，先找参数类型为char的方法，若找不到，则直接提升到int类型<h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2>&emsp;&emsp;我觉得《Thinking in java》的作者Bruce Eckel对方法调用解释的很清楚，我们看下他是如何解释代码调用的：<br>&emsp;&emsp;如果有同一个类型的两个对象a,b，如何让才能这两个对象都能调用peel()方法呢？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Banana&#123; void peel(int i)&#123;/* */&#125;&#125;</span><br><span class="line">public class BananaPeel&#123;</span><br><span class="line">   public static void main(String[] args)&#123;</span><br><span class="line">   Banana a=new Banana(),b=new Banana();</span><br><span class="line">   a.peel(1);</span><br><span class="line">   b.peel(2); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>&emsp;&emsp;如果只有一个peel()方法，它如何知道是被a还是被b调用呢？<br>&emsp;&emsp;为了能用简单，面向对象的语法编写代码——即“发送消息给对象”，编译器做了一些某后工作，它暗自把“操作对象的引用”作为第一个参数传递给peel()，所以上述两个方法的调用就变成了这样：<br>    Banana.peel(a,1);<br>    Banana.peel(b,2);<br>&emsp;&emsp;这是内部表示，我们并不能这样写代码，上面这行的意思时，执行Banana类中定义的<code>peel()</code>方法，方法的参数是a,1,这才是代码底层做的事情，不过为了满足我们面向对象的思维，我们使用<code>a.peel()</code>这种形式，而其他的事情，编译器帮我们摆平<br>&emsp;&emsp;如何在方法内部获得对当前对象的引用？由于这个引用是编译器“偷偷”地帮我们加的，所以没有标识符可用，但是为此有一个专门的关键字this,this关键字只能在方法内部使用，表示“调用方法的那个对象”<br>&emsp;&emsp;this关键字的用法：</p><ol><li>可以将当前对象传递给其他方法使用</li><li>在构造器调用构造器时使用<h3 id="static的含义"><a href="#static的含义" class="headerlink" title="static的含义"></a>static的含义</h3>&emsp;&emsp;了解this关键字之后，就能全面理解static(静态)方法的含义了，static方法就是没有this的方法，在static方法的内部不能调用非静态方法，因为那些非静态类的方法都需要this类型的参数，而static方法并不能提供给它们，反过来，非静态类的方法是可以调用静态方法的<br>&emsp;&emsp;有些人认为static方法不是“面向对象的”，因为它的确具有全局函数的语义，使用static方法时，由于不存在this，所有不是通过“向对象发送消息”的方式执行的，这种说法还是有些道理的，所有，如果你的代码中存在大量的static方法，就该重新考虑自己的程序了  <h2 id="清理：终结处理和垃圾回收"><a href="#清理：终结处理和垃圾回收" class="headerlink" title="清理：终结处理和垃圾回收"></a>清理：终结处理和垃圾回收</h2><h2 id="成员初始化"><a href="#成员初始化" class="headerlink" title="成员初始化"></a>成员初始化</h2>&emsp;&emsp;java尽力保证，所有的变量在使用之前都能得到适当的初始化，对于方法的局部变量，java以编译时错误的形式来贯彻这项保证·<h2 id="构造器初始化"><a href="#构造器初始化" class="headerlink" title="构造器初始化"></a>构造器初始化</h2>&emsp;&emsp;可以用构造器来初始化，在运行时刻，可以调用方法或执行某些动作来确认该值，这为编程带来了更大的灵活性，但是要记住，无法阻止自动初始化的进行，它将在构造器被调用之前发生<h3 id="初始化的顺序"><a href="#初始化的顺序" class="headerlink" title="初始化的顺序"></a>初始化的顺序</h3>&emsp;&emsp;在类的内部，变量定义的顺序决定了初始化的顺序，即使变量定义散布于方法定义之间，它们仍然会在任何方法（包括构造器）之前得到初始化<h3 id="静态数据的初始化"><a href="#静态数据的初始化" class="headerlink" title="静态数据的初始化"></a>静态数据的初始化</h3>无论创建多少个对象，静态数据都只占一份存储区域，static关键字不能应用于局部变量，因此它只能作用于域，如果一个域时静态的基本类型域，且也没有对它进行初始化，那么它就会获得基本类型的标准初值，如果它是一个对象，那么它的默认值就是null<br>&emsp;&emsp;静态初始化只有在必要的时刻才会进行，什么是必要时刻？就是一切触发包含静态成员类的加载的行为都是必要时刻<br>&emsp;&emsp;初始化的顺序是先静态变量（如果它们尚未因前面的对象创建过程而被初始化的话，记住静态初始化只会进行一次，那就是在类第一次被加载的时刻）<br>，而后时非静态变量<br>&emsp;&emsp;总结一下对象的创建过程，假设一个Dog类  </li><li>即使没有显式地使用static关键字，构造器实际上也是静态方法，因此，当首次创建Dog对象时（构造器可以看成静态方法），或者Dog类的静态方法被调用时，解释器必须查找类路径，以定位Dog.class文件</li><li>然后载入Dog.class,创建一个Class对象，有关静态初始化的所有动作都会被执行，因此，静态初始化只在Class对象首次加载的时候进行一次</li><li>当用new Dog()创建对象的时候，首先将在堆上为Dog对象分配足够的内存空间</li><li>这块存储空间会被清零，这就自动地将Dog对象中的所有类型数据都设成默认值</li><li>执行所有出现在字段定义初的初始化</li><li>执行构造器  <h3 id="显示的静态初始化"><a href="#显示的静态初始化" class="headerlink" title="显示的静态初始化"></a>显示的静态初始化</h3>&emsp;&emsp;java允许将多个静态初始化动作组织成一个特殊的“静态子句”，有时也叫做静态块，静态块先其他的静态成员一样，也是在类被首次加载的时候被执行一次  <h3 id="非静态实例初始化"><a href="#非静态实例初始化" class="headerlink" title="非静态实例初始化"></a>非静态实例初始化</h3>&emsp;&emsp;非静态实例初始化很像静态块，只是在代码块前面没有static关键字，这种语法对于支持“匿名内部类”的初始化时必须的，但是它也可以使你保证无论使用那个构造器，某些操作都会发生，而且是在构造器执行之前执行  <h2 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h2>&emsp;&emsp;数组只是相同类型的，用一个标识符名称封装到一起的一个对象序列或基本类型数据序列，记住，数组也是对象，在java中除了基本类型 一起皆对象，数据可以通过方括号下标操作符<code>[]</code>来定义和使用，要定义一个数组，只需要在类型名后面加上一对中括号即可<br> int[] a;<br> int a[];<br>&emsp;&emsp;两种格式都一样，我更喜欢第一种方式，上述两种方式都只是让我们拥有一个引用，并且指出了这个引用所代表的数据类型，随便说一句，java是强类型语言，标识符前面的类型往往是为了类型检查的需要<br>&emsp;&emsp;数组类型主要分为两种，一种是基本数据类型数值，一种时引用类型数值，基本数据类型数组内部持有着基本数据类型的值，而引用类型数值元素是引用，如图：</li></ol><p>&emsp;&emsp;所有数组（无论它们的元素时对象还是引用）都有一个固定成员，可以通过它获知数组内包含了多少元素，但不能对其修改，这个成员就是length,数值索引从0开始</p><h3 id="可变参数列表"><a href="#可变参数列表" class="headerlink" title="可变参数列表"></a>可变参数列表</h3><pre><code>void variableList(String... args);</code></pre><p>&emsp;&emsp;上述语法就是从在java SE5新添加的可变参数列表的特性，有了可变参数，就不用显式地编写数组语法了<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">argsList</span><span class="params">(String[] args)</span></span>;</span><br></pre></td></tr></table></figure>，当你指定参数时，编译器实际上会为你去填充数组，你获取的仍旧是一个数组</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;随着计算机革命的发展，“不安全”的编程方式已逐渐成为编程代价高昂的主要原因&lt;br&gt;&amp;emsp;&amp;emsp;初始化和
      
    
    </summary>
    
      <category term="学习心得" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>一切都是对象</title>
    <link href="http://yoursite.com/2018/10/05/%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2018/10/05/一切都是对象/</id>
    <published>2018-10-05T02:40:48.000Z</published>
    <updated>2018-10-05T12:23:03.648Z</updated>
    
    <content type="html"><![CDATA[<h2 id="用引用操作对象"><a href="#用引用操作对象" class="headerlink" title="用引用操作对象"></a>用引用操作对象</h2><p>&emsp;&emsp;每种语言都有自己的操作内存元素的方式，有时候，程序员必须注意将要处理的数据类型是什么。你是直接操作元素，还是用某种基于特殊语法的间间接表示（例如C和C++里的指针）来操作对象<br>&emsp;&emsp;所有的一切在java这里得到了简化，一切都被视为对象，因此可采用单一固定的语法，尽管一切都看作对象，但操作的标识符实际上是对象的一个“引用”（reference）。</p><h2 id="必须由你创建所有对象"><a href="#必须由你创建所有对象" class="headerlink" title="必须由你创建所有对象"></a>必须由你创建所有对象</h2><h3 id="存储到什么地方"><a href="#存储到什么地方" class="headerlink" title="存储到什么地方"></a>存储到什么地方</h3><p>程序运行的时候，对象是怎么进行放置安排的呢？特别是内存时怎样分配的呢？有五个不同的地方可以存储数据  </p><ol><li>寄存器。这是最快的存储区，因为它位于不同于其他存储区的地方——处理器内部，但是寄存器的数量有限，所以寄存器根据需求进行分配，你不能直接控制，也不能在程序中感觉到寄存器存在的任何迹象（一方面，C和C++允许你向编译器建议寄存器的分配方式）  </li><li>堆栈：位于通用RAM(随机访问存储器)中，但通过堆栈指针可以从处理器那里获得直接支持，堆栈指针若向下移动，则分配新的内存，若向上移动，则释放那些内存，这是一种快速有效的分配存储方法，创建程序时，Java系统必须知道存储在堆栈内所有的确切生命周期，以便上下移动堆栈指针，这一约束限制了程序的灵活性，所以虽然某些java数据存储在堆栈中——特别是对象引用，但是java对象并不存储于其中  </li><li>堆，一种通用的内存池（也位于RAM区），用于存放所有的java对象，堆不同于堆栈的好处是：编译器不需要知道存储的数据在堆中存活多少时间，因此，在堆中分配有很大的灵活性  </li><li>常量存储：常量值通常直接存放在程序代码内部，这样做是安全的，因为它们永远不会被改变，有时，在嵌入式系统中，常量本身和其他部分分割离开，所以在这种情况下，可以选择将其存放在ROM（只读存储器）中  </li><li>非RAM存储。如果数据完全存活于程序之外，那么它可以不受程序的任何控制，在程序没有运行时也可以存在，其中两个基本的例子时流对象和持久化对象  </li></ol><h3 id="特例：基本类型"><a href="#特例：基本类型" class="headerlink" title="特例：基本类型"></a>特例：基本类型</h3><p>&emsp;&emsp;在程序设计中经常用到一系列类型，它们需要特殊对待，可以把它们想象成“基本”类型<br>之所以特殊对待，是因为new将对象存储在“堆”里，故用new创建一个对象——特别是小的，简单的变量，往往不是很有效，因此，对于这些类型，java采取与C和C++相同的方法，也就是说，不用new来创建对象，而是创建一个并非是引用的“自动”变量，这个变量直接存储“值”，并置于堆栈中，因此更加高效<br>&emsp;&emsp;java要确定每种基本类型所占存储空间的大小，它们的大小并不像其他大多数语言那样随机器架构的变化而变化，所以java所编写的程序比其他语言更具有可移植性  </p><h3 id="高精度数字"><a href="#高精度数字" class="headerlink" title="高精度数字"></a>高精度数字</h3><p>&emsp;&emsp;java提供了两个用于高精度计算的类：BigInteger和BigDecimal,可以将它们看成是包装器类，但是它们并没有相应的基本类型，它们都支持任意精度的数字，其实很好理解，因为它们的数据类型使得它们可以接受更多的位来表示数值  </p><h3 id="java中的数组"><a href="#java中的数组" class="headerlink" title="java中的数组"></a>java中的数组</h3><p>&emsp;&emsp;几乎所有的程序设计语言都支持数组，在C和C++中使用数组时危险的，因为它们的数组就是内存块，如果一个程序要访问其自身内存块之外的数组，或在数组初始化前使用内存，将产生难以预料的后果<br>&emsp;&emsp;java的一个主要目标之一就是安全性，java确保数组会被初始化，而且不能在它的范围外被访问，这种范围检查，是以每个数组上少量的内存开销及运行时的范围检查为代价的，但由此换来的是安全性和效率的提高  </p><h2 id="永远不需要销毁对象"><a href="#永远不需要销毁对象" class="headerlink" title="永远不需要销毁对象"></a>永远不需要销毁对象</h2><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>&emsp;&emsp;大多数过程型语言都有作用域(scope)的概念,作用域决定了在其内定义的变量名的可见性和生命周期</p><h3 id="对象的作用域"><a href="#对象的作用域" class="headerlink" title="对象的作用域"></a>对象的作用域</h3><p>&emsp;&emsp;java对象不具备和基本数据类型一样的生命周期，当new创建一个java对象时，它可以存活于作用域之外<br>&emsp;&emsp;如果java让对象一直存在，那么靠什么才能防止这些对象填满内存空间，进而阻塞你的程序呢？这正是C++里可能会发生的问题，这也是java的神奇之处，java有一个垃圾回收器，用来监视用new创建的所有对象，并辨别那些不会再被引用的对象。随后，释放这些对象的内存空间，以便供其他新的对象使用</p><h2 id="创建新的数据类型：类"><a href="#创建新的数据类型：类" class="headerlink" title="创建新的数据类型：类"></a>创建新的数据类型：类</h2><p>&emsp;&emsp;如果一切都是对象，那么是什么决定了某一类对象的外观和行为呢？换句话说，是什么确定了对象的类型</p><h3 id="字段和方法"><a href="#字段和方法" class="headerlink" title="字段和方法"></a>字段和方法</h3><p>&emsp;&emsp;一旦定义了一个类（在java中你所做的全部工作就是定义类，产生那些类的对象，以及发送消息给这些对象）就可以在类中设置两种类型的元素，字段（有时称做数据成员）和方法（有时称作函数成员）  </p><h3 id="基本成员默认值"><a href="#基本成员默认值" class="headerlink" title="基本成员默认值"></a>基本成员默认值</h3><p><table><tr><th>基本类型</th><th>默认值</th></tr><tr><td>boolean</td><td>fasle</td></tr><tr><td>char</td><td>‘\u0000’(null)</td></tr><tr><td>byte</td><td>(byte)0</td></tr><tr><td>short</td><td>(short)0</td></tr><tr><td>int</td><td>0</td></tr><tr><td>long</td><td>0L</td></tr><tr><td>float</td><td>0.0f</td></tr><tr><td>double</td><td>0.0d</td></tr></table></p><h2 id="方法，参数和返回值"><a href="#方法，参数和返回值" class="headerlink" title="方法，参数和返回值"></a>方法，参数和返回值</h2><p>&emsp;&emsp;返回类型描述的是在调用方法之后从方法返回的值，参数列表给出了要传递个方法的信息的类型和名称，方法名和参数列表（它们合起来被称为“方法签名”），唯一地标识出某个方法</p><h2 id="java程序"><a href="#java程序" class="headerlink" title="java程序"></a>java程序</h2><h3 id="名字的可见性"><a href="#名字的可见性" class="headerlink" title="名字的可见性"></a>名字的可见性</h3><p>&emsp;&emsp;名字管理对任何程序设计语言都是一个重要的问题，如果在程序的某个模块里使用了一个名字，而其他人在这个程序的另一个模块里也使用了相同的名字，那么怎么区分这两个名字并防止二者互相冲突<br>&emsp;&emsp;java采用了一种全新的方法来避免上述的问题。为了给每一个类库生成不会与其他名字混淆的名字，java设计者希望程序员反过来使用自己的internet域名</p><h3 id="运用其他构件"><a href="#运用其他构件" class="headerlink" title="运用其他构件"></a>运用其他构件</h3><p>&emsp;&emsp;如果想在自己的程序使用预先定义好的类，那么编译器就必须知道怎么定位它们，当然这个类可能就在发生调用的那个<strong>源文件</strong>中，在这种情况下，就可以直接使用这个类<br>&emsp;&emsp;如果那个类位于其他文件中呢？又会怎样？编译器没有那么聪明知道你要使用的类应该在哪里查找，所以你要明确地告诉编译器你想要的类是什么，import指示编译器导入一个包，也就是一个类库</p><h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><p>&emsp;&emsp;通常来说，当创建类时，就是在描述那个类的对象的外观和行为，除非用new创建那个类的对象，否则，实际上并未获得任何对象，执行new来创建对象时，数据存储空间才被分配，其方法才供外部调用<br>&emsp;&emsp;有两种情况是上述方法无法解决的  </p><ol><li>只想为某特定域分配单一存储空间，而不去考虑究竟要创建多少对象吗，甚至根本就不创建对象</li><li>希望某个方法不与包含它的类的任何对象关联在一起，也就是说，寄生不创建对象，也能调用这个方法<br>&emsp;&emsp;通过static关键字可以满足这两方面的要求，有些面向对象的语言采用类数据和类方法两个术语，代表那些数据和方法是作为整个类，而不是类的某个特定对象而存在的<br>&emsp;&emsp;尽管当static作用在某个字段时，肯定会改变数据创建的方式（因为一个static字段对每一个类来说都只是一份存储空间，而非static字段则是每个对象有一个存储空间），但是如果static作用于方法上，差别就没有那么大   <h3 id="编译和运行"><a href="#编译和运行" class="headerlink" title="编译和运行"></a>编译和运行</h3>&emsp;&emsp;要编译，运行一个程序，首先必须要有一个java开发环境，目前，有相当多的第三方厂商提供开发环境，我们当前使用的是SUN免费提供的JDK（java Developer’s Kit）开发环境为例<br>&emsp;&emsp;安装好JDK之后，还要设定好路径信息，以确保计算机能够找到javac和java这两个文件  </li></ol><h2 id="注释和嵌入式文档"><a href="#注释和嵌入式文档" class="headerlink" title="注释和嵌入式文档"></a>注释和嵌入式文档</h2><p>先来看一下注释，在java中有三种方式的注释  </p><ol><li>单行注释 //</li><li>多行注释 /**/</li><li>文档注释 /<strong>  </strong>/   <h3 id="注释文档"><a href="#注释文档" class="headerlink" title="注释文档"></a>注释文档</h3>&emsp;&emsp;文档撰写的最大问题，大概就是对文档的维护了，如果文档与代码是分离的，修改代码时，同时也要修改相应的文档，相当的麻烦啊，解决办法很简单，就是将代码和文档“链接”起来，为了达到这个目的，最简单的方法就是将所有的东西都放在同一个文件内，为了实现这个目的，就必须使用一种特使的注释语法来标记文档，此外还需要一个能够提取文档信息的工具<br>&emsp;&emsp;javadoc就是这样的一个工具，它是jdk安装的一部分，它采用了java编译器的某些技术，查找程序内特殊注释标签，它不仅解析由这些标签标记的信息，也将毗邻的类名或方法名提取出来，因此，我们可以用最少的工作量，生成相当好的程序文档，生成的文档是HTML格式<br>&emsp;&emsp;需要注意的是，能够生成文档的工具不止javadoc，使用时应该要遵守对应工具的语法规则，不过，如果没有什么特别的需求，javadoc已经很好了<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3>使用javadoc的方式有两种   </li></ol><ol><li>一种是HTML,可在文档注释中直接写HTML，并没有什么特殊的，只是要注意不要在嵌入式HTML重使用标题标签，因为javadoc会插入自己的标题，而你的标题可能会同它们冲突  </li><li>一种是使用注释标签下面是这些标签的一些示例</li></ol><table><thead><tr><th>标签</th><th>语法</th><th>描述</th></tr></thead><tbody><tr><td>@see</td><td>@see classname<br>@see classname<br>@see fully-qualfied-classname#method-nam</td><td>会在生成的文档中添加一个具有超链接的“see also”</td></tr><tr><td>{@link package.class#member label}</td><td></td><td>该标签与@see及其类似，只是它用于行内，并且文档使用“label”作为超链接文本而不是“see also”</td></tr><tr><td>{@docRoot}</td><td></td><td>该标签产生到文档根目录的相对路径，用于文档树页面的显式超链接</td></tr><tr><td>{@inheritDoc}</td><td></td><td>该标签从当前这个类的最直接的基类中继承相关文档到当前的文档注释</td></tr><tr><td>@version</td><td>@version version-information</td><td>版本信息</td></tr><tr><td>@author</td><td>@author author-information</td><td>作者信息</td></tr><tr><td>@since</td><td></td><td>允许你指定程序代码最早使用的版本，可以在HTML,java文档中看到它被用来指定所用的JDK版本的情况</td></tr><tr><td>@param</td><td>@param param-name discripton</td><td>可以多次使用这个标签，大约每个参数都有一个这样的标签</td></tr><tr><td>@return</td><td>return description</td><td>用来描述返回值的含义</td></tr><tr><td>@throws</td><td>@throws fully-qualified-class-name descripton</td><td>可以多次使用，异常的全限定名和引发异常的原因</td></tr><tr><td>@deprecated</td><td></td><td>该标签用于指出一些旧特性已由改进的新特性所取代，建议用户不要再使用这些旧特性</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;用引用操作对象&quot;&gt;&lt;a href=&quot;#用引用操作对象&quot; class=&quot;headerlink&quot; title=&quot;用引用操作对象&quot;&gt;&lt;/a&gt;用引用操作对象&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;每种语言都有自己的操作内存元素的方式，有时候，程序员必须注意将要处理的数据类
      
    
    </summary>
    
      <category term="学习心得" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>对象导论</title>
    <link href="http://yoursite.com/2018/10/04/%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%AE%BA/"/>
    <id>http://yoursite.com/2018/10/04/对象导论/</id>
    <published>2018-10-04T14:19:11.000Z</published>
    <updated>2018-10-04T20:15:43.428Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-1抽象过程"><a href="#1-1抽象过程" class="headerlink" title="1.1抽象过程"></a>1.1抽象过程</h2><p>&emsp;&emsp;所有的编程语言都提供抽象机制，汇编语言是对底层机器的轻微抽象，接着出现的所谓“命令式”语言（如FORTRAN,BASIC，C等）都是对汇编语言的抽象，这些语言在汇编语言的基础上有很大的改进，但是它们所做的主要抽象都是基于计算机的结果，而不是基于所要解决的问题的结构来考虑，程序员必须要建立起在机器模型（位于解空间内，这是你对问题建模的地方。例如计算机）和实际待解问题的模型（位于“解空间”内，这是问题存在的地方，例如一项业务）之间的关联，建立这种映射是费时的，而且这不属于编程语言固有的功能，这使得程序难以编写，并且维护代价高，业务逻辑可读性不强<br>&emsp;&emsp;面向对象允许根据问题来描述问题，而不是根据运行解决方案的计算机来描述问题<br>但它仍然与计算机有联系，每个对象看起来就像一台微型计算机——它具有状态，还具有操作，用户可以要求对象执行这些操作，如果要对现实世界中的对象作类比，那么说它们都具有特性和行为似乎不错</p><p>Alan Kay总结一个面向对象编程语言应该具有的5个特性  </p><ol><li>万物皆为对象。将对象视为奇特的变量，它可以存储数据，除此之外，你还可以要求它在自身上执行操作，理论上讲，你可以抽取待解空间的任何概念化构件（狗，建筑物，服务等），使其表示为程序中的对象  </li><li>程序是对象的集合，它们之间通过发送消息来告知彼此所要做的事情  </li><li>每个对象都有自己的由其他对象所构成的存储  </li><li>每个对象都拥有其类型。  </li><li>某一特定类型的所有对象都可以接收同样的消息</li></ol><p>Booch对对象提出了一个更加简洁的描述：对象具有状态（内部数据），行为（方法）和标识（每个对象都可以唯一地与其他对象区分开来，具体来说，就是每个对象在内存中都具有一个唯一的地址）</p><h2 id="每个对象都有一个接口"><a href="#每个对象都有一个接口" class="headerlink" title="每个对象都有一个接口"></a>每个对象都有一个接口</h2><p>&emsp;&emsp;所有的对象都是唯一的，但同时也是具有相同的特性和行为的对象所归属的一部分。<br>&emsp;&emsp;创建抽象数据类型（类）是面向对象程序设计的基本概念之一，抽象数据类型的运行方式与内置（built-in）类型几乎完全一致：你可以创建某一类型的变量（按照面向对象的说法，称其为对象或者实例），然后操作这些变量（称其为发送消息或请求）对象就知道要做什么。<br>每个对象都属于定义了特性和行为的某一特定的类<br>&emsp;&emsp;因为类描述了具有相同特性（数据元素）和行为（功能）的对象的集合，所以一个类实际上就是一个数据类型，例如所有浮点型数字具有相同的特性和行为集合。二者之间的差异在于，程序员通过定义类来适应问题，而不再被迫只能使用现有的用来表示机器的存储单元上的数据类型，可以根据需求，通过添加新的数据类型来扩展编程语言。<br>&emsp;&emsp;一旦类被建立，就可以随心所欲地创建类的任意的对象，然后去操作它们，就像它们是存在于你的待解空间中的元素一样，事实上，面向对象程序设计的挑战之一，就是问题空间的元素和解空间的对象之间创建一对一的映射。<br>&emsp;&emsp;但是怎样才能获得一个有用的对象呢？必须有某种方式产生对对象的请求，使对象完成各种任务。<strong>每个对象都只能满足某些请求，这些请求由对象的接口（interface）,决定接口的便是类型</strong>。<br>&emsp;&emsp;<strong>接口确定了对某一特定对象所能发出的请求</strong>，但是，在程序中必须有满足这些请求的代码，这些代码与<strong>隐藏的数据</strong>一起构成了实现，当向对象发送请求的过程通常被概括为：向某个对象吧“发送消息”（产生请求），这个对象便知道此消息的目的，然后执行相应的代码  </p><h2 id="每个对象都提供服务"><a href="#每个对象都提供服务" class="headerlink" title="每个对象都提供服务"></a>每个对象都提供服务</h2><p>&emsp;&emsp;当试图开发或试图理解一个程序设计时，更好的方法之一就是将<strong>对象想象为“服务的提供者</strong>”，程序本身将向用户提供服务，它将通过调用其他对象提供的服务来实现这一目的，你的目标就是去创建（或者最好是在现有的代码库中寻找）能够提供理想的服务来解决问题的一系列对象<br>&emsp;&emsp;将对象看作服务提供者还有一个附加的好处，<strong>它有助于提高对象的内聚性</strong>，内聚性是软件设计的基本质量之一，在良好的面向对象设计中，每个对象都可以很好地完成一项任务，但是它并不试图做更多的事情<br>&emsp;&emsp;将对象作为服务提供者看待是一种伟大的简化工具，这不仅在设计过程中有用，而且对于其他人试图理解你的代码或重用某个对象也是有帮助的。  </p><h2 id="被隐藏的具体实现"><a href="#被隐藏的具体实现" class="headerlink" title="被隐藏的具体实现"></a>被隐藏的具体实现</h2><p>&emsp;&emsp;将程序开发人员按照角色分为类创建者（那些创建新数据类型的程序员）和客户端程序员（那些在其应用中使用数据类型的类消费着）是大有裨益的<br>&emsp;&emsp;客户端程序员的目标是收集各种用来实现快速开放的类<br>&emsp;&emsp;类创建者的目标是构建类，这种类只向客户端程序员暴露必须的部分，而隐藏其他部分<br>&emsp;&emsp;为什么要对部分实现加以隐藏呢？因为被隐藏的部分通常代表对象内部脆弱的部分，它们很容易被粗心的或是不知情的客户端程序员所毁坏，所以隐藏起来可以减少bug，这也意味着类创建着可以对这些隐藏的部分进行修改，而不用担心对其他任何人造成影响<br>&emsp;&emsp;在相互关系中，具有关系所涉及的各方都遵守的边界是非常重要的事情，当创建一个类库时，就建立了与客户端程序员之间的关系，如果所有类成员都任何人都是可用的，那么客户端程序员就可以对类做任何事情，而不受任何约束，即使你希望客户端程序员不要去直接操作你的类中的某些成员，但是如果没有任何访问控制，将无法阻止此事发生，所有东西都将赤裸裸地暴露于世人面前。<br>&emsp;&emsp;因此控制访问的第一个存在的原因就是让客户端程序员无法触及它们不应该触及的部分——这些部分对数据类型的内部操作是必需的，但并不是用户解决特定问题所需的接口的一部分<br>&emsp;&emsp;控制访问的第二个存在的原因是运行库设计者可以改变类内部的工作方式而不担心会影响到客户端程序员，如果接口和实现可以清晰地分离并得以保护，那么你就可以轻而易举地完成这项工作<br>&emsp;&emsp;java用三个关键字在类的内部设定边界：public,private,protected,这些访问指定词(access specifier)决定了紧跟在其后被定义的元素可以被谁使用<br>java还有一种默认的访问权限，当没有使用前面提到的任何访问指定词时，它将发挥作用，这种权限通常被称为包访问权限  </p><h2 id="复用具体实现"><a href="#复用具体实现" class="headerlink" title="复用具体实现"></a>复用具体实现</h2><p>&emsp;&emsp;一旦类被创建并被测试完，那么它就应该代表一个有用的代码单元<br>&emsp;&emsp;最简单地复用某个类的方法就是直接使用类的一个对象，此外也可以将那个类的一个对象置于某个全新的类中，我们称其为“创建一个成员对象”，新的类可以由任意数量，任意类型的某个对象以任意可以实现新的类中想要的功能的方式组成，因为是使用现有的类合成新的类，所以这种概念被称为组合（compression）,如果组合是动态发生的，那么它通常被称为聚合（aggregaton）。组合经常被视为“has-a”（拥有）关系。<br>组合带来了极大的灵活性，新类的成员对象通常被声明为pravate,使得使用新类的客户端程序员不能访问它，这也使得你可以在不干扰现有客户端代码的情况下，修改这些成员，也可以在运行时修改这些成员对象，以实现动态修改程序的行为  </p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>&emsp;&emsp;在创建了一个类之后，即使另一个新类与其具有相同的功能，难道我们还要再重新创建一个新的类型吗？如果我们能够以现有的类为基础，复制它，然后通过添加或者修改这个副本来创建新类那就好了（当然，继承的底层实现并没有对基类进行复制，而是在导出类中保存了一个指向基类的引用），通过继承既可以达到这样的效果<br>&emsp;&emsp;类型不仅仅只是描述了一个对象集合上的约束条件，同时还有与其他类型之间的关系，两个类型的行为可以有相同的特性和行为，但是其中一个类型可能比另一个类型含义更多的特性，并且可以处理更多的信息（或以不同方式处理信息），继承使用基类和导出类的概念表示了这种类型之间的相似性，一个基类包含其所有导出类所共享的特性和行为，可以创建一个基类来表示系统中某些对象的核心概念<br>&emsp;&emsp;当继承现有类型时，也就创造了新的类型，这个类型不仅包括现有类型的所有成员（尽管private被隐藏起啦，并且不能访问）而且更重要的是它复制了基类的接口，也就是说，所有可以发送给基类对象的消息同时也可以发送给导出类对象<br>&emsp;&emsp;由于基类和导出类具有相同的基础接口，所有伴随此接口的必定有某些具体实行，也就是说，当对象接收到特定消息时，必须有某些代码去执行，如果只是简单地继承一个类而不去做其他事情，这意味着导出类的对象不仅与基类具有相同的类型，而且还拥有着相同的行为<br>&emsp;&emsp;有两种办法可以使基类和导出类产生差异，第一中方法非常直接，直接在导出类中添加新方法，这些方法并不是基类接口的一部分，这意味着基类不能满足你的所有需求，因此要添加更多的方法，但是，应该仔细考虑是否存在基类也需要这种方法的可能性，这种发现和迭代过程是开发当中经常会发生的<br>&emsp;&emsp;第二种也是最重要的一种导出类和基类之间产生差异的方法是改变继承至基类的方法，这被称为覆盖（overriding）有些书上也叫“改写”（我并不是很赞成这种叫法，因为我们实际上并没有去触碰基类中的接口方法，因此这种叫法比较奇怪）  </p><h3 id="“是一个”与“像一个”"><a href="#“是一个”与“像一个”" class="headerlink" title="“是一个”与“像一个”"></a>“是一个”与“像一个”</h3><p>&emsp;&emsp;对于继承可能会引发某种争论：继承应该只覆盖基类的方法（而并不添加在基类中不存在的新方法），如果这样做，就意味着导出类和基类是完全相同的类型，结果一个导出类对象可以完全替代一个基类对象因为它们具有完全相同的接口（虽然接口的实现可能不同），这种方式被称为“纯粹替代”，导出类与基类之间的关系被称为is-a(是一个)关系<br>&emsp;&emsp;有时必须在导出类中添加新的接口元素，这样也就扩展了接口，这个新的类型仍然可以替代基类，但是这种替代并不完美，因为基类无法访问新添加的方法，这种情况我们称为is-like-a(像是一个)关系  </p><h2 id="伴随多态的可互换对象"><a href="#伴随多态的可互换对象" class="headerlink" title="伴随多态的可互换对象"></a>伴随多态的可互换对象</h2><p>&emsp;&emsp;在处理类型的层次结构时，经常想把一个对象不当做它所属的特定类型来看待，而是将其当作其基类的对象来看待，这使得人们可以写出不依赖特定类型的代码<br>&emsp;&emsp;但是，在试图将导出类的对象当作其泛型化基类对象来看待时，仍然存在一个问题，如果某个方法要让泛型化的对象执行自身的接口实现时应该怎么办？编译器在编译时是不可能知道应该执行哪段代码的，这就是关键所在，虽然我们在编译代码的时候不知道也不关心我们发送给对象的消息会使得哪段代码被执行，但是对象会依据自身的具体类型来执行恰当的代码，那么这是怎么实现的呢？<br>&emsp;&emsp;一个非面向对象编程的编译器产生的函数调用会引起所谓的前期绑定，这样就意味着编译器将产生一个具体函数名字的调用，而运行时将这个调用解析到将要执行的代码的绝对地址<br>&emsp;&emsp;然而在OOP中，程序直到运行时才能够确定代码的地址，为了解决这个问题，面向对象的语言使用了后期绑定的概念，当向对象发送消息时，被调用代码直到运行才能确定，编译器确保了调用方法的存在，并对调用参数和返回值执行类型检查（无法通过此类保证的语言被称为弱类型语言，比如javascript）<br>&emsp;&emsp;为了执行后期绑定，java使用了一段特殊的代码来替代绝对地址调用（JVM的工作），这段代码使用在对象中存储的信息来计算方法体的地址（反射概念），这样，根据这一小段代码的内容，每个对象都可以具有不同的行为表现，当向一个对象发送消息时，该对象就能够知道这条消息应该做些什么（JVM通过一小段代码实行java语言后期绑定的特性，虽然相比非面向对象语言来说，牺牲了性能，可是却带来了编程上极大的灵活性和低耦合，与其相比，这段性能的牺牲是微不足道的）</p><h2 id="单根继承结构"><a href="#单根继承结构" class="headerlink" title="单根继承结构"></a>单根继承结构</h2><p>&emsp;&emsp;单根继承结构中的所有对象都具有一个公共的接口，所以它们归根到底都是相同的基本类型<br>&emsp;&emsp;单根继承结构保证了所有对象都具备某些功能，因此，在你的系统中可以对这些对象执行某些基本操作，例如垃圾回收机制，在进行垃圾回收时就是将所有的对象当作同一种类型</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>&emsp;&emsp;通常来说，如果你不知道咋解决某个问题时需要多少个对象，或者它们将存活多久，那么juice不可能知道该如何存储这些对象，如何才能知道需要多少空间来创建这些对象呢？<br>答案是你也可能不知道，因为这类信息只有在程序运行时才能够获得<br>&emsp;&emsp;大部分的面向对象语言，解决这些问题，就是创建另一种新的数据类型，这种新的对象类型持有对其他对象的引用，在java中，这通常被称为容器（也可以被称为集合）的新对象，在任何需要时都可以扩充自己以容纳于你置于其中的所有东西，因此不需要知道未来将会把多少个对象置于容器中，只需要创建一个容器对象昂，然后让它处理所有细节<br>&emsp;&emsp;java在标准类型中包含有大量的容器，从设计的观点来看，真正需要只有一个可被操作，从而解决问题的序列，如果单一类型的容器可以满足所有的需要，那么就没有理由设计不同类型的序列了，然而还是需要对象容器有所选择，这有两个原因  </p><ol><li>不同的容器提供了不同类型的接口和外部行为  </li><li>不同的容器对某些操作具有不同的效率  <h3 id="参数化类型"><a href="#参数化类型" class="headerlink" title="参数化类型"></a>参数化类型</h3>在java SE5出现之前，容器存储的对象都只具有java中的通用类型：Object,要使用这样的容器，只需在其中置入对象的引用，稍后还可以将它们取回，但是由于容器只存储Object，所以当将对象引用置入容器时，它必须被向上转型为Object，因此就丢失了身份，所以当把它取回时，就获取了一个对Object的引用，而不是对置入时那个对象的引用<br>&emsp;&emsp;怎样将它变回先前置入容器时的具有实用接口的对象呢？（其实更准确的说是将对象的引用类型转变为放置前更具体的特定类型，转型实际上分为两种，一种是对基本数据类型进行转型，这种方式的转型除了将引用类型转型之外还会对基本类型数据的底层结构进行改写，另一种是对引用对象进行转型，这种方式的转型只是对引用类型进行转型，使得对象所指向的类型发生改变，对象内部的数据并没有发生变化，向下转型时危险的，需要特别小心）<br>&emsp;&emsp;向下转型和运行需要额外的运行时间，也需要程序员付出更多的心血，如果创建这样的一个容器，它知道自己所保存对象的类型，从而不需要向下转型以及消除犯错的可能，这样不是更有意义吗？这种解决方案被称为参数化类型机制<br>&emsp;&emsp;Java SE5的重大变化之一就是增加了参数化类型，在java中它被称为泛型，一对尖括号，中间时类型信息  <h2 id="对象的创建和生命周期"><a href="#对象的创建和生命周期" class="headerlink" title="对象的创建和生命周期"></a>对象的创建和生命周期</h2>&emsp;&emsp;在使用对象时，最关键的问题之一便是对象的创建和销毁，每个对象为了生存都需要资源，尤其是内存，当我们不再需要一个对象时，它必须要被清理掉，使其占有的资源得到释放<br>&emsp;&emsp;现在的问题是 怎样创建对象？对象的数据位于何处？对象何时应该被销毁？因为当处理完某个对象之后，系统的某个部分可能还在处理它，这就是对象的生命周期<br>&emsp;&emsp;第一种方式：我们先来看看其他编程语言是如何管理对象的生命周期的，C++认为效率控制是最重要的议题，所以给了程序员选择的权利，为了追求执行速度，对象的存储空间和生命周期可以在编写程序时确定，也就是所对象的存储位置和生命周期由程序员来决定，在某些情况下这样控制是有价值的，但是，也牺牲了灵活性，而且，一旦，程序员在设计当中对对象的处理不够谨慎，内存泄漏是常发生的事情<br>&emsp;&emsp;第二方式是在被称为堆（heap）的内存区域（内存池）中动态地创建对象，在这种方式中，直到运行时才知道需要多少个对象，它的生命周期如何，以及它们的具体类型是什么，这些问题的答案只能在程序运行相关代码被执行的那一刻才确定，如果需要一个新对象，可以在需要的时刻直接在堆中创建，因为存储空间是运行时被动态的管理的，所以需要大量的时间在堆中分配存储空间（因为在堆中存放对象的数据相较于在栈中会涉及跟多的算法，比如可分配空间查找，可分配空间大小与对象数据大小比较），这可能要远大于在堆栈中创建空间的时间，在堆栈（栈）中创建和释放存储空间通常各需要一条汇编指令即可，分别对应将栈顶指针的下移和上移<br>&emsp;&emsp;java完全采用了动态内存分配方式，创建一个对象很简单，使用new关键字即可，至于对象存储在堆中的哪个位置，完全不需要考虑，JVM虚拟机会帮我们完成一切<br>&emsp;&emsp;还有个议题，就是对象的生命周期，对于允许在堆栈（栈）上创建对象的语言，编译器可以确定对象的存活时间，并可以自动销毁它，然后，如果在堆中创建的对象，编译器就会对它的生命周期一无所知，而java提供了被称为“垃圾收集器”的机制，它可以自动发现对象何时不再被使用，并继而销毁它，它减少了程序员以前必须考虑的议题和必须编写的代码，更重要的是，垃圾回收器提供了更高层次的保障，可以避免暗藏的内存泄漏的问题<h2 id="异常处理：处理错误"><a href="#异常处理：处理错误" class="headerlink" title="异常处理：处理错误"></a>异常处理：处理错误</h2>&emsp;&emsp;自从编程语言面世以来，错误处理就始终是最困难的问题之一，因为设计一个良好的错误处理机制非常困难，所以许多语言直接忽略掉了这个问题，将其交给程序设计库去处理，而这些设计库的作者提出的方法也不彻底，所以，大部分错误处理机制的主要问题在于，它们都依靠程序员的警惕性，这种警惕性来自于一种共同约定，而不是编程语言所强制的<br>&emsp;&emsp;异常处理将错误处理直接置于编程语言中，有时甚至置于操作系统中，异常是一种对象，它从错误发生的地点被“抛出”，并被专门设计用来处理特定类型错误的相应的异常处理器“捕获”，异常处理器就像是与程序正常执行路径并行的，在错误发生时执行的另一条路径，因为它是另一条完全分离的执行路径。所以它不会干扰到程序的正常运行，这往往使得代码编写变得简单，因为不需要被迫定期检测错误，此外，被抛出的异常不像方法返回的错误值和方法设置的用来表示错误条件的标志位那样可以被忽略，异常不能被忽略，所以它保证一定会在某个地方会得到处理<br>&emsp;&emsp;java一开始就内置了异常处理，而且强制你必须使用它，如果没有编写正确的异常处理代码，那么就会得到一条编译时的错误信息<h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2>&emsp;&emsp;在计算机编程中有一个基本概念，就是同一时刻处理多个任务的思想，许多程序设计问题都要求，程序能够停下正在做的工作，转而处理某个其他问题，然后在返回主进程，有许多方法可以实行按这个目的，最初，程序员用所掌握的有关机器底层的知识来编写中断服务程序，主进程的挂起是通过硬件中断来触发，这种方式难度大，移植性差<br>&emsp;&emsp;有时中断对处理时间性强的任务是必要的，不过对于大量的问题，我们只是想要把问题切分成多个可独立运行的部分（任务）从而提高程序的相应能力，在程序中，这些彼此独立运行的部分被称为线程，上述概念被称为“并发”<br>&emsp;&emsp;通常，线程只是一种为单一处理器分配执行时间的手段，但是如果操作系统有多处理器，那么每个任务都可以被指派给不同的处理器，而且它们时真正的在并发执行，在语言级别上，多线程所带来的便利之一时程序员不必关系机器上是有多个处理器还是单个<br>&emsp;&emsp;所有这些都使的并发看起来相当简单，但是有一个问题：共享资源</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-1抽象过程&quot;&gt;&lt;a href=&quot;#1-1抽象过程&quot; class=&quot;headerlink&quot; title=&quot;1.1抽象过程&quot;&gt;&lt;/a&gt;1.1抽象过程&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;所有的编程语言都提供抽象机制，汇编语言是对底层机器的轻微抽象，接着出现的所谓
      
    
    </summary>
    
      <category term="学习心得" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Node.js参考网站</title>
    <link href="http://yoursite.com/2018/10/04/Node-js%E5%8F%82%E8%80%83%E7%BD%91%E7%AB%99/"/>
    <id>http://yoursite.com/2018/10/04/Node-js参考网站/</id>
    <published>2018-10-04T03:47:09.000Z</published>
    <updated>2018-10-04T03:57:58.023Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="学习心得" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="Node.js" scheme="http://yoursite.com/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript参考网站</title>
    <link href="http://yoursite.com/2018/10/04/JavaScript%E5%8F%82%E8%80%83%E7%BD%91%E7%AB%99/"/>
    <id>http://yoursite.com/2018/10/04/JavaScript参考网站/</id>
    <published>2018-10-04T03:44:44.000Z</published>
    <updated>2018-10-04T03:55:51.589Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="学习心得" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>CSS参考网站</title>
    <link href="http://yoursite.com/2018/10/04/CSS%E5%8F%82%E8%80%83%E7%BD%91%E7%AB%99/"/>
    <id>http://yoursite.com/2018/10/04/CSS参考网站/</id>
    <published>2018-10-04T03:44:00.000Z</published>
    <updated>2018-10-04T03:52:57.876Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="学习心得" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>HTML5参考网站</title>
    <link href="http://yoursite.com/2018/10/04/HTML5%E5%8F%82%E8%80%83%E7%BD%91%E7%AB%99/"/>
    <id>http://yoursite.com/2018/10/04/HTML5参考网站/</id>
    <published>2018-10-04T03:43:43.000Z</published>
    <updated>2018-10-04T03:55:22.506Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="学习心得" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="HTML5" scheme="http://yoursite.com/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>JVM参考网站</title>
    <link href="http://yoursite.com/2018/10/04/JVM%E5%8F%82%E8%80%83%E7%BD%91%E7%AB%99/"/>
    <id>http://yoursite.com/2018/10/04/JVM参考网站/</id>
    <published>2018-10-04T03:43:15.000Z</published>
    <updated>2018-10-04T03:56:39.212Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="学习心得" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Docker参考网站</title>
    <link href="http://yoursite.com/2018/10/04/Docker%E5%8F%82%E8%80%83%E7%BD%91%E7%AB%99/"/>
    <id>http://yoursite.com/2018/10/04/Docker参考网站/</id>
    <published>2018-10-04T03:42:44.000Z</published>
    <updated>2018-10-04T03:53:26.212Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="学习心得" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Linux操作系统参考网站</title>
    <link href="http://yoursite.com/2018/10/04/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%82%E8%80%83%E7%BD%91%E7%AB%99/"/>
    <id>http://yoursite.com/2018/10/04/Linux操作系统参考网站/</id>
    <published>2018-10-04T03:42:24.000Z</published>
    <updated>2018-10-04T03:57:07.752Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="学习心得" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
</feed>
