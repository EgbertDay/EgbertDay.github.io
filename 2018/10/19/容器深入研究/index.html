<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>容器深入研究 | 代海峰</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="完整的容器分类法填充容器虽然容器打印问题解决了，容器的填充仍然像Arrays一样面临着同样的问题，就像Arrays一样，相应的Collections类也有一些实用的static方法，其中包括fill(),与Arrays一样，此fill()方法也是只复制同一个对象引用来填充整个容器，并且只对List对象有用，但是所产生的列表可以传递给构造器或addAll()方法1234567891011121314">
<meta name="keywords" content="Java">
<meta property="og:type" content="article">
<meta property="og:title" content="容器深入研究">
<meta property="og:url" content="http://yoursite.com/2018/10/19/容器深入研究/index.html">
<meta property="og:site_name" content="代海峰">
<meta property="og:description" content="完整的容器分类法填充容器虽然容器打印问题解决了，容器的填充仍然像Arrays一样面临着同样的问题，就像Arrays一样，相应的Collections类也有一些实用的static方法，其中包括fill(),与Arrays一样，此fill()方法也是只复制同一个对象引用来填充整个容器，并且只对List对象有用，但是所产生的列表可以传递给构造器或addAll()方法1234567891011121314">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-10-21T19:30:00.438Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="容器深入研究">
<meta name="twitter:description" content="完整的容器分类法填充容器虽然容器打印问题解决了，容器的填充仍然像Arrays一样面临着同样的问题，就像Arrays一样，相应的Collections类也有一些实用的static方法，其中包括fill(),与Arrays一样，此fill()方法也是只复制同一个对象引用来填充整个容器，并且只对List对象有用，但是所产生的列表可以传递给构造器或addAll()方法1234567891011121314">
  
    <link rel="alternate" href="/atom.xml" title="代海峰" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">代海峰</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">个人博客</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-容器深入研究" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/19/容器深入研究/" class="article-date">
  <time datetime="2018-10-19T14:05:34.000Z" itemprop="datePublished">2018-10-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习心得/">学习心得</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      容器深入研究
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="完整的容器分类法"><a href="#完整的容器分类法" class="headerlink" title="完整的容器分类法"></a>完整的容器分类法</h2><h2 id="填充容器"><a href="#填充容器" class="headerlink" title="填充容器"></a>填充容器</h2><p>虽然容器打印问题解决了，容器的填充仍然像Arrays一样面临着同样的问题，就像Arrays一样，相应的Collections类也有一些实用的static方法，其中包括fill(),与Arrays一样，此fill()方法也是只复制同一个对象引用来填充整个容器，并且只对List对象有用，但是所产生的列表可以传递给构造器或addAll()方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringAddress</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String s;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringAddress</span><span class="params">(String s)</span></span>&#123;s=s;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">super</span>.toString()+s;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FillingLists</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;StringAddress&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Collections.nCopies(<span class="number">4</span>, <span class="keyword">new</span> StringAddress(<span class="string">"Hello"</span>)));</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        Collections.fill(list,<span class="keyword">new</span> StringAddress(<span class="string">"world"</span>));</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">~~~上面这个例子展示了用对单个对象的引用来填充Collection的方式，第一种是使用Collections.nCopies()创建传递给构造器的List，这里填充的是ArrayList</span><br><span class="line">StringAddress的toString()调用了它的基类Object的toString()方法，这个方法返回的是该类的名字，后面紧跟着该对象的散列码的十六进制表示（通过hashCode()产生的），从输出中你可以看到所有引用都是指向的同一个对象，这在第二个方法被调用之后也是同样如此，fill()方法的作用有限，因为它只能替换已经在List中存在的元素，而不能添加新的元素</span><br><span class="line">### 一种Generator解决方案 ###</span><br><span class="line">**事实上，所有的Collection子类型都有一个接收另一个Collection对象的构造器，用所接收的Collection对象中的元素来填充新的容器**，为了更好地创建测试数据，我们需要做的是创建接受Generator和quantity数值并将它们当作参数的类</span><br><span class="line">**这个类使用Generator在容器中放置所需要的对象，然后所产生的容器可以传递给任何Collection的构造器**，这个构造器会把其中的数据复制到自身中，addAll()方法是所有Collection子类型的一部分，它也可以用来组装现有的Collection</span><br><span class="line">**泛型便利方法可以减少在使用类时所必需的类型检查**</span><br><span class="line">CollectionData是适配器设计模式的一个实例，它将Generator适配到Collection的构造器上</span><br><span class="line">~~~java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionData</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CollectionData</span><span class="params">(Generator&lt;T&gt; gen,<span class="keyword">int</span> quantity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;quantity;i++) &#123;</span><br><span class="line">           add(gen.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">CollectionData&lt;T&gt; <span class="title">list</span><span class="params">(Generator&lt;T&gt; gen,<span class="keyword">int</span> quantity)</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span>  <span class="keyword">new</span> CollectionData&lt;&gt;(gen,quantity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Map生成器"><a href="#Map生成器" class="headerlink" title="Map生成器"></a>Map生成器</h3><p>我们可以对Map使用相同的方法，但是这需要一个Pair类，因为为了组装Map,每次调用Generator的next()方法都必须产生一个对象对（一个键和一个值）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> K k;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V v;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(K k,V v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.k=k;</span><br><span class="line">        <span class="keyword">this</span>.v=v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>适配器现在可以使用不同的Generator，Iterator和常量值的组合来填充Map初始化对象了,你可以使用单一的Generator&lt;pair&lt;K,V&gt;&gt;,两个分离的Generator，一个Generator和一个常量值，一个Iterable和一个Generator，随你的心情定制<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapData</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapData</span><span class="params">(Generator&lt;Pair&lt;K,V&gt;&gt; gen,<span class="keyword">int</span> qantity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;qantity;i++) &#123;</span><br><span class="line">            put(gen.next().k, gen.next().v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapData</span><span class="params">(Generator&lt;K&gt; genK,Generator&lt;V&gt; genV,<span class="keyword">int</span> quantity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;quantity;i++)&#123;</span><br><span class="line">           put(genK.next(),genV.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapData</span><span class="params">(Generator&lt;K&gt; genK,V value,<span class="keyword">int</span> quantity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;quantity;i++)&#123;</span><br><span class="line">            put(genK.next(),value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapData</span><span class="params">(Iterable&lt;Pair&lt;K,V&gt;&gt; it,<span class="keyword">int</span> quantity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Pair&lt;K,V&gt; pair:it)&#123;</span><br><span class="line">            put(pair.k,pair.v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapData</span><span class="params">(Iterable&lt;K&gt; itK,Generator&lt;V&gt; genV)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(K key:itK)&#123;</span><br><span class="line">            put(key,genV.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="function">MapData&lt;K,V&gt; <span class="title">map</span><span class="params">(Generator&lt;Pair&lt;K,V&gt;&gt; gen,<span class="keyword">int</span> quantity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MapData&lt;&gt;(gen,quantity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="function">MapData&lt;K,V&gt; <span class="title">map</span><span class="params">(Generator&lt;K&gt; genK,Generator&lt;V&gt; genV,<span class="keyword">int</span> quantity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> MapData&lt;&gt;(genK,genV,quantity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="使用Abstrcat类"><a href="#使用Abstrcat类" class="headerlink" title="使用Abstrcat类"></a>使用Abstrcat类</h3><p>对于产生用于容器的测试数据问题，另一种解决方式是创建定制的Collection和Map实现，每个java.util容器都有其自己的Abstract类,它们提供了该容器的部分实现，因此你必须做的只是去实现那些产生想要容器所需的方法，如果所产生的容器是只读的，就像它通常用的测试数据那样，那么你需要提供的方法数量将减到最少<br>尽管在在比例中不是特别需要，但下面的的剞劂方案还是提供了一个机会来演示另一种设计模式：享元。你可以在普通的解决方案中需要过多的对象，后者产生普通对象太占空间时使用享元，享元使得对象的一部分可以被具体化，因此，与对象中的所有事物都包含在对象内部不同，我们可以在更加高效的外部表中查找对象的一部分或者整体（或者同某些其他节省空间的计算来产生对象的一部分或整体）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Countries</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String[][] DATA=&#123;</span><br><span class="line">            &#123;<span class="string">"ANGDAL"</span>,<span class="string">"Luanda"</span>&#125;,&#123;<span class="string">"NIID"</span>,<span class="string">"asdasd"</span>&#125;,&#123;<span class="string">"sdasdasd"</span>,<span class="string">"asdasdasd"</span>&#125;,</span><br><span class="line">            &#123;<span class="string">"asdasdasd"</span>,<span class="string">"adsdfasda"</span>&#125;,&#123;<span class="string">"GUPOOAD"</span>,<span class="string">"sdfsdf"</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyWeightMap</span> <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">String</span>,<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//创建一个嵌套的内部类Entry以提供EntrySet使用</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">String</span>,<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> index;</span><br><span class="line">            Entry(<span class="keyword">int</span> index)&#123;<span class="keyword">this</span>.index=index;&#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> DATA[index][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> DATA[index][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">setValue</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> DATA[index][<span class="number">0</span>].equals(o);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> DATA[index][<span class="number">0</span>].hashCode();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">String</span>,<span class="title">String</span>&gt;&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">            EntrySet(<span class="keyword">int</span> size)&#123;</span><br><span class="line">                <span class="keyword">if</span>(size&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">this</span>.size=<span class="number">0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(size&gt;DATA.length)&#123;</span><br><span class="line">                     <span class="keyword">this</span>.size=DATA.length;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">this</span>.size=size;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Iter</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">String</span>,<span class="title">String</span>&gt;&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">private</span> Entry entry=<span class="keyword">new</span> Entry(-<span class="number">1</span>);</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> entry.index&lt;size-<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> Map.<span class="function">Entry&lt;String, String&gt; <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    entry.index++;</span><br><span class="line">                    <span class="keyword">return</span> entry;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Iter();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Set&lt;Map.Entry&lt;String,String&gt;&gt; entries=<span class="keyword">new</span> EntrySet(DATA.length);</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet() &#123;</span><br><span class="line">            <span class="keyword">return</span> entries;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Map&lt;String,String&gt; <span class="title">select</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FlyWeightMap()&#123;</span><br><span class="line">            <span class="keyword">public</span> Set&lt;Map.Entry&lt;String,String&gt;&gt; entrySet()&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> EntrySet(size);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;String,String&gt; map=<span class="keyword">new</span> FlyWeightMap();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String,String&gt; <span class="title">map</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String,String&gt; <span class="title">capitals</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> select(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> List&lt;String&gt; names=<span class="keyword">new</span> ArrayList&lt;String&gt;(map.keySet());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">names</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> names;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">names</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;String&gt;(select(size).keySet());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>二维数组String DATA是public的，因此可以在其他地方使用，FlyweightMap必须实现entrySet()方法，它需要定制的Set实现和定制的Map.Entry类，这里正是享元的部分，每个Map.Entry对象只存储了它的索引，而不是实际的值和键，当你调用getKey()和getValue()得时候它们会使用该索引来返回恰当的DATA元素，，EntrySet可以确保它的size不会大于DATA<br>你可以在EntrySet.Iterator中看到享元的其他部分实现，与为DATA中的每个数据对都创建Map.Entry对象不同，每个迭代器只有一个Map.Entry,<strong>Entry对象被用作数据的视窗</strong>，它只包含在静态字符串数组的引用，<strong>你每次调用迭代器的next()方法时，Entry中的index都会递增，使其指向下一个元素对，然后从next()返回该Iterator所持有的单一的Entry对象</strong></p>
<h2 id="Collection的功能方法"><a href="#Collection的功能方法" class="headerlink" title="Collection的功能方法"></a>Collection的功能方法</h2><p>下面列出了可以通过Collection执行的所有操作（不包括从Object继承的方法），因此，它们也是可通过Set和List执行的所有方法（List有额外的功能），Map不是继承自Collection的</p>
<table>
<thead>
<tr>
<th></th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean add(T)</td>
<td>确保容器持有具有泛型类型T的参数，如果没有将此参数添加进容器，则返回false（这是“可选”的方法）</td>
</tr>
<tr>
<td>boolean addAll(Collection<t>)</t></td>
<td>添加参数中的所有元素，只要添加了任意元素就返回true（可选的）</td>
</tr>
<tr>
<td>void clear()</td>
<td>移除容器中的所有元素（可选）</td>
</tr>
<tr>
<td>boolean contains(T)</td>
<td>如果容器已经持有具有泛型类型T此参数，则返回true</td>
</tr>
<tr>
<td>Boolean containsAll(Collection<t>)</t></td>
<td>如果容器持有此参数中的所有元素，则返回true</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>容器中没有元素返回true</td>
</tr>
<tr>
<td>Iterator<t> iterator()</t></td>
<td>返回一个Iterator<t>,可以遍历容器中的元素</t></td>
</tr>
<tr>
<td>Boolean remove(Object)</td>
<td>如果参数在容器内，则移除该元素的一个实例，如果做了移除动作，则返回true（可选）</td>
</tr>
<tr>
<td>Boolean removeAll(Collection&lt;?&gt;)</td>
<td>移除参数中的所有元素，只要有移除动作发生就返回true（可选）</td>
</tr>
<tr>
<td>Boolean retainAll(Collection&lt;?&gt;)</td>
<td>只保存参数中的元素（应用集合论的“交集”概念），只要Collection发生了改变就返回true(可选)</td>
</tr>
<tr>
<td>int size()</td>
<td>返回容器中保存的元素个数</td>
</tr>
<tr>
<td>Object[] toArray()</td>
<td>返回一个数组，该数组包含容器中的所有元素</td>
</tr>
<tr>
<td><t> T[] toArray(T[] a)</t></td>
<td>返回一个数组，该数组包含容器中的所有元素，返回结果的运行是类型与，参数数组类型相同，而不是单纯的Object</td>
</tr>
</tbody>
</table>
<p>注意上面的方法不包括随机访问所选择元素的get()方法，因为Collection包括了Set，而Set是自己维护内部顺序的（这使得随机访问变得没有意义），因此，如果想检查Collection的元素，就必须使用迭代器</p>
<h2 id="可选操作"><a href="#可选操作" class="headerlink" title="可选操作"></a>可选操作</h2><p>什么是可选操作？就是接口声明的，但是实现类并不一定支持其实现的方法就是可选操作<br>执行各种不同的添加和移除的方法在Collection接口中都是可选操作，这意味着实现类并不一定选需要为这些方法提供功能定义（记住是不一定需要提供功能定义，但是必须提供实现，因为实现接口中声明的方法一定要有实现，实现可以什么都不做，也可以直接抛出一个UnsupportedException异常）<br>这是一种很不寻常的接口定义方式，<strong>接口是面向对象设计中的契约</strong>，它声明了“无论你选择任何实现该接口，我保证你可以向该接口发送这些消息”，但是可选操作违反了这个基本原则，它声明调用某些方法将不会执行任何有意义的行为，相反，它会抛出异常，这看起来好像是编译期的类型安全好像被抛弃了，因为编译期的类型检查就是为了运行期程序的正常执行<br>但是事情并不那么糟糕，如果一个操作是可选的，编译器仍然后要求你只能调用该接口中的方法，这样动态语言不同，<strong>动态语言可以在任何对象上调用任何方法，并且可以在运行时发现某个特定方法是否可以工作</strong>，另外将Collection当作参数接受的大部分方法只会从该Collection中读取，而Collection的读取都是不可选的<br><strong>为什么你会讲方法定义为可选的呢？那是因为这样做可以防止在设计中出现接口爆炸的情况</strong>，容器类型的其他设计看起来总是在描述每个主题的各种变体，而最终患上了令人困惑的接口过剩症，<strong>这种方式可以实现java容器类库的一个重要目标：容器应该是易学易用的（我们假定这样的一种情形，如果我们的Collection方法只声明了较少的方法，那么当我们需要具有某个特性的容器类时，我们必须在类库中添加具有这些特性的接口，这就造成了接口膨胀，而且当我们进行客户端编程的时候，要时刻区分那些容器类都实现了那些接口，这时我们不能仅仅将其向上转型为Collection类型了，因为Collection类型中仅有少量的方法可调用），未获支持的操作是一种特例，可以延迟到需要时才出现，但是，这种方式能够工作</strong><br>而且这种设计留下了一个后门，如果你想要创建新的Collection，但是没有为Collection接口中的所有方法都提供有意义的支持，那么它仍旧适合现有的类库<br>未获支持的异常只有在运行时才能探测到，因此它们表示动态类型检查<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Unsupported</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String msg,List&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">        Collection&lt;String&gt; c=list;</span><br><span class="line">        Collection&lt;String&gt; subList=list.subList(<span class="number">1</span>,<span class="number">8</span>);</span><br><span class="line">        Collection&lt;String&gt; c2=<span class="keyword">new</span> ArrayList&lt;&gt;(subList);</span><br><span class="line">        <span class="keyword">try</span>&#123; c.retainAll(subList); &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"retain"</span>+e); &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">try</span>&#123; c.remove(subList); &#125;<span class="keyword">catch</span>(Exception e)&#123; </span><br><span class="line">            System.out.println(<span class="string">"remove"</span>+e); &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">try</span>&#123; c.clear(); &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"clear"</span>+e); &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span>&#123; c.add(<span class="string">"x"</span>); &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"add"</span>+e); &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">try</span>&#123; c.addAll(c2); &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"addAll"</span>+e); &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">try</span>&#123; list.set(<span class="number">0</span>,<span class="string">"x"</span>); &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"List.set"</span>+e); &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list= Arrays.asList(<span class="string">"A B C D E F G H I "</span>.split(<span class="string">" "</span>));</span><br><span class="line">        test(<span class="string">"modifiable"</span>,<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">        test(<span class="string">"asList"</span>,list);</span><br><span class="line">        test(<span class="string">"unmodifiableList"</span>, Collections.unmodifiableList(<span class="keyword">new</span> ArrayList&lt;&gt;(list))); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最常见的未获支持的操作，都来源于背后由固定尺寸的数据结构支持的容器<br>我们看上面的一个例子。Arrays.asList()返回的容器对象就是以传入的数组对象为其底层的数据结构为基础提供容器的功能，因为我们知道，数组尺寸大小固定，所以对这个容器进行的增删都是未获支持的（容器的增删操作定义了执行这些操作时，容器的size必须改变，因为数组的length不可修改，所有，这样的容器自然不能进行增删操作了，不然就违反了容器原则）<br>但是我们将一个Arrays.asList（）返回的容器作为构造器的参数传递给ArrayList时，却发现了此时可以对这个容器进行增删操作了，这是因为，这样的方式会产生新的尺寸可调的底层数据结构。Collections类的“不可修改” 的方法将容器包装到了一个代理，只要进行任何试图修改容器的操作，这个代理都会产生一个UssupportedOperationException异常<br>最后一个方法set()比较有意思，对于Arrays.asList()返回的容器可以调用的，因为这个操作并不会改变尺寸，只是修改了某个位置元素而已，而对于Collections.unmodifiableLis()返回的容器只读，任何的写操作都不支持<br>最后，如果你要编写一个接受Collection类型的方法，其文档应该指定那些可选操作必须实现</p>
<h2 id="List的功能方法"><a href="#List的功能方法" class="headerlink" title="List的功能方法"></a>List的功能方法</h2><p>List继承了Collection接口，又添加了本身的一些接口方法，因此每一个实现了List接口的List容器实现都可以调用这些方法，这些方法可以查看api，见名知义，另外要注意的一个实现类LinkedList这个实现类不仅实现了List接口，还实现了其他的接口，所有具有普通List所不具有的特性和方法，如addFrist(),addLast(),removeFrist()等…,具体api请参见Queue接口</p>
<h2 id="Set和存储顺序"><a href="#Set和存储顺序" class="headerlink" title="Set和存储顺序"></a>Set和存储顺序</h2><table>
<thead>
<tr>
<th></th>
<th>接口或Set容器实现类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Set(interface)</td>
<td>放在Set中的每一个元素都必须是唯一的，因为Set不保存重复元素，加入Set的元素必须定义equals()方法以确保对象的唯一性，set与Collection有完全一样的接口，<strong>Set接口不保证维护元素的次序</strong></td>
</tr>
<tr>
<td>HashSet*</td>
<td>为快速查找设计的Set，存入HashSet的元素必须定义hashCode()</td>
</tr>
<tr>
<td>TreeSet</td>
<td>保持次序的Set，底层为树结构，使用它可以从Set中提取有序的方法，元素必须实现Comparable接口</td>
</tr>
<tr>
<td>LinkedHashSet</td>
<td>具有HashSet的查询速度，其内部使用链表维护元素的顺序（插入顺序），于是在使用迭代器遍历Set时，结果会按元素插入的次序显示，也必须定义hashCode()</td>
</tr>
</tbody>
</table>
<p>在HashSet上打星号，表示如无特殊的要求，这个应该是我们的首选<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SetType</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SetType</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;i=n;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o <span class="keyword">instanceof</span> SetType &amp;&amp; (i==((SetType) o).i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="string">"SetType"</span>+i; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashType</span> <span class="keyword">extends</span> <span class="title">SetType</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashType</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;<span class="keyword">super</span>(n);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hasCode</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeType</span> <span class="keyword">extends</span> <span class="title">SetType</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">TreeType</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeType</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;<span class="keyword">super</span>(n);&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(@NotNull TreeType o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (o.i&lt;i)? -<span class="number">1</span>:((o.i==<span class="number">0</span>)? <span class="number">0</span>:<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypesForSets</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Set&lt;T&gt; <span class="title">fillSet</span><span class="params">(Set&lt;T&gt; set,Class&lt;T&gt;  type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                set.add(type.getConstructor(<span class="keyword">int</span>.class).newInstance(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> set;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(Set&lt;T&gt; set,Class&lt;T&gt; type)</span></span>&#123;</span><br><span class="line">        fillSet(set,type);</span><br><span class="line">        fillSet(set,type);</span><br><span class="line">        fillSet(set,type);</span><br><span class="line">        System.out.println(set);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        test(<span class="keyword">new</span> HashSet&lt;HashType&gt;(),HashType.class);</span><br><span class="line">        test(<span class="keyword">new</span> LinkedHashSet&lt;HashType&gt;(),HashType.class);</span><br><span class="line">        test(<span class="keyword">new</span> TreeSet&lt;TreeType&gt;(),TreeType.class);</span><br><span class="line"></span><br><span class="line">        test(<span class="keyword">new</span> HashSet&lt;SetType&gt;(),SetType.class);</span><br><span class="line">        test(<span class="keyword">new</span> HashSet&lt;TreeType&gt;(),TreeType.class);</span><br><span class="line">        test(<span class="keyword">new</span> LinkedHashSet&lt;TreeType&gt;(),TreeType.class);</span><br><span class="line">        test(<span class="keyword">new</span> LinkedHashSet&lt;SetType&gt;(),SetType.class);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test(<span class="keyword">new</span> TreeSet&lt;HashType&gt;(), HashType.class);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            test(<span class="keyword">new</span> TreeSet&lt;SetType&gt;(),SetType.class);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果我们尝试着将没有恰当地支持必需的操作的类型用于需要这些方法的Set，那么将会有大麻烦，对于没有定义hashCode()的SetType或SetType,如果将它们放置到任何散列实现中都会产生重复值，这样就违背了Set的基本契约，这是相当烦人的，更烦人的是不会有任何的运行时错误，这是因为默认的hashCode()是合法的，即使它不正确<br>如果我们尝试着将没有实现Comparable的对象添加进TreeSet中，这会在运行期抛出异常，因为TreeSet的方法在内部会检测对象是否实现了Comparable</p>
<h3 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h3><p>SortedSet接口的唯一实现TreeSet,这个接口提供了一些附加的功能</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>comparator()</td>
<td>返回Comparator，或者返回null,表示以自然方式排序</td>
</tr>
<tr>
<td>T first()</td>
<td>返回容器的第一个元素</td>
</tr>
<tr>
<td>T last()</td>
<td>返回容器的最后一个元素</td>
</tr>
<tr>
<td>SortedSet<t> subSet(T fromElement,T toElement)</t></td>
<td>生成此Set的子集，范围从fromElement(包含)到toElement(不包含)</td>
</tr>
<tr>
<td>SortedSet<t>  headSet(T toElement)</t></td>
<td>由小于ToElement的元素组成的子集</td>
</tr>
<tr>
<td>SortedSet<t> tailSet(T fromElement</t></td>
<td>由大于或等于fromElement的元素组成的子集</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sorted</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SortedSet&lt;String&gt; set=<span class="keyword">new</span> TreeSet&lt;String&gt;();</span><br><span class="line">        Collections.addAll(set,<span class="string">"one two three"</span>.split(<span class="string">" "</span>));</span><br><span class="line">        System.out.println(set);</span><br><span class="line">        String low=set.first();</span><br><span class="line">        String high=set.last();</span><br><span class="line">        Iterator&lt;String&gt; it=set.iterator();</span><br><span class="line">        SortedSet&lt;String&gt; toFromSubSet=set.subSet(low,high);</span><br><span class="line">        SortedSet&lt;String&gt; headSubSet=set.headSet(high);</span><br><span class="line">        SortedSet&lt;String&gt; tailSubSet=set.tailSet(low);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>除了并发应用，Queue在java SE5中只有两个实现是LinkedList和PriorityQueue,它们的差异在于排序行为而不是性能<br>下面是涉及Queue实现的大部分操作的基本示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueBehavior</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count =<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(Queue&lt;T&gt; queue, Generator&lt;T&gt; gen)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">            queue.offer(gen.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(queue.peek()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(queue.remove()+<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Gen</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">        String[] s=<span class="string">"one two three four five six "</span>.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> s[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        test(<span class="keyword">new</span> LinkedList&lt;String&gt;(),<span class="keyword">new</span> Gen());</span><br><span class="line">        test(<span class="keyword">new</span> PriorityQueue&lt;String&gt;(),<span class="keyword">new</span> Gen());</span><br><span class="line">        test(<span class="keyword">new</span> ArrayBlockingQueue&lt;String&gt;(count),<span class="keyword">new</span> Gen());</span><br><span class="line">        test(<span class="keyword">new</span> LinkedBlockingQueue&lt;String&gt;(count),<span class="keyword">new</span> Gen());</span><br><span class="line">        test(<span class="keyword">new</span> ConcurrentLinkedQueue&lt;String&gt;(),<span class="keyword">new</span> Gen());</span><br><span class="line">        test(<span class="keyword">new</span> PriorityBlockingQueue&lt;String&gt;(),<span class="keyword">new</span> Gen());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h3><p>优先队列就是从一端插入，从另一端取出，而取出的顺序是按优先级的，所以元素要实现Comparable，我们看下一个简单的toDo列表的问题<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToDolist</span> <span class="keyword">extends</span> <span class="title">PriorityQueue</span>&lt;<span class="title">ToDolist</span>.<span class="title">ToDoItem</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ToDoItem</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ToDoItem</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">char</span> primary;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> secondary;</span><br><span class="line">        <span class="keyword">private</span> String item；</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ToDoItem</span><span class="params">(String item,<span class="keyword">char</span> primary,<span class="keyword">int</span> secondary)</span></span>&#123;</span><br><span class="line">            primary=primary;</span><br><span class="line">            secondary=secondary;</span><br><span class="line">            item=item;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(@NotNull ToDolist.ToDoItem o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(primary&gt;o.primary)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(primary==o.primary)&#123;</span><br><span class="line">                <span class="keyword">if</span>(secondary&gt;o.secondary)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(secondary==o.secondary)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String td,<span class="keyword">char</span> pri,<span class="keyword">int</span> sec)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.add(<span class="keyword">new</span> ToDoItem(td,pri,sec));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ToDolist toDolist=<span class="keyword">new</span> ToDolist();</span><br><span class="line">        toDolist.add(<span class="string">"Empty"</span>,<span class="string">'C'</span>,<span class="number">4</span>);</span><br><span class="line">        toDolist.add(<span class="string">"Feed Dog"</span>,<span class="string">'A'</span>,<span class="number">2</span>);</span><br><span class="line">        toDolist.add(<span class="string">"Empty"</span>,<span class="string">'B'</span>,<span class="number">7</span>);</span><br><span class="line">        toDolist.add(<span class="string">"Empty"</span>,<span class="string">'C'</span>,<span class="number">3</span>);</span><br><span class="line">        toDolist.add(<span class="string">"Empty"</span>,<span class="string">'A'</span>,<span class="number">1</span>);</span><br><span class="line">        toDolist.add(<span class="string">"Empty"</span>,<span class="string">'B'</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(!toDolist.isEmpty())&#123;</span><br><span class="line">            System.out.println(toDolist.remove());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h3><p><strong>双端队列就像是一个队列，但是你可以在任何一端添加或移除元素，在LinkedList中包含了双端队列的方法，但在java标准类库没有任何显式的用于双向队列的接口</strong>，因此你无法将一个LinkedList向上转型到Deque这样的接口（没有这样的接口），但是，你可以使用组合来创建一个Deque，并直接从LinkedList中暴露相关的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Deque</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;T&gt; deque=<span class="keyword">new</span> LinkedList&lt;T&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFrist</span><span class="params">(T item)</span></span>&#123;deque.addFirst(item);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(T item)</span></span>&#123;deque.addLast(item);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFrits</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> deque.getFirst();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span></span>&#123;<span class="keyword">return</span>  deque.getLast();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">removeFrist</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> deque.removeFirst();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">removeLast</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> deque.removeLast();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> deque.size();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> deque.toString();&#125;</span><br><span class="line">    <span class="comment">//other method</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实双端队列在程序中使用的并不是很多，因为我们也很少有需求需要在两端放入元素并取出它们</p>
<h2 id="理解Map"><a href="#理解Map" class="headerlink" title="理解Map"></a>理解Map</h2><p>映射表（关联数组）的基本思想是它维护键值关联，因此你可以使用键来查找值，标准的java类库包含了Map的几种基本实现。包括HashMap,TreeMap,LinedHashMap,WeakHashMap,ConcurretHashMap,IdentityHashMap,它们都有同样的基本接口Map，但是行为特性各不相同，这表现在效率，键值对的保存及呈现次序，对象的保存周期，映射表如何在多线程程序中工作和如何判定“键”等价性的策略等方面<br>我们先观察关联数组是如何创建的，下面是一个极其简单的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AssociativeArray</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[][] pairs;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">AssociativeArray</span><span class="params">(<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        pairs=<span class="keyword">new</span> Object[length][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key,V value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;=pairs.length)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException();</span><br><span class="line">        &#125;</span><br><span class="line">       pairs[index++]=<span class="keyword">new</span> Object[]&#123;key,value&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pairs[i][<span class="number">0</span>].equals(key))&#123;</span><br><span class="line">                <span class="keyword">return</span> (V)pairs[i][<span class="number">0</span>];</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuilder stb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line">            stb.append(pairs[i][<span class="number">0</span>]);</span><br><span class="line">            stb.append(<span class="string">":"</span>);</span><br><span class="line">            stb.append(pairs[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的例子是个很简单的Map实现，主要实现了put()和get(),而且是以Object数组为底层数据结构，并且不可自动调整尺寸的，这个例子看看就好</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>性能是映射表中的一个重要问题，当在get()中使用线性搜索时，执行速度会相当地慢，而这正是HashMap提高速度的地方，HashMap使用了特殊的值称作散列码，来取代对键的缓慢搜索，散列码是相对唯一的，，它通过对象的某些信息进行转换而成的，hashCode()是根类Object的方法，因此所有java对象都能产生散列码，HashMap就是使用对象的hashCode()进行快速搜索的，此方法能够显著提高速度<br>我们看下Map的各种实现</p>
<table>
<thead>
<tr>
<th>实现类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>HashMap</td>
<td>Map是基于散列表的实现（它取代了MaoTable）插入和查询“键值对”的开销是固定的，可以通过构造器设置容量和负载因子，以调整性能</td>
</tr>
<tr>
<td>LinkdHashMap</td>
<td>类似与HashMap，但是迭代遍历它时，取得“键值对”的顺序是其插入次序，或者是最近最少使用（LRU）的次序，只是比HashMap慢一点，而在迭代访问时反而更快，因为它使用链表维护内部次序</td>
</tr>
<tr>
<td>TreeMap</td>
<td>基于红黑树的实现，查看“键”或“键值对”时，它们会被排序（次序又Comparable或Comparator决定），TreeMap的特点在于，所得到的结果是经过排序的，TreeMap是唯一的带有SubMap()方法的Map，它可以返回一个子树</td>
</tr>
<tr>
<td>weakHashMap</td>
<td>弱键（weak key）映射，允许释放映射所指向的对象，这是为了解决某类特殊问题而设计的，如果映射之外没有引用指向某个“键”，则此“键”可以被垃圾回收器回收</td>
</tr>
<tr>
<td>ConcurrentHashMap</td>
<td>一种线程安全的Map，它不涉及同步加锁，我们将在“并发”中讨论它</td>
</tr>
<tr>
<td>IdentityHashMap</td>
<td>使用==代替equals()对“键”进行比较的散列映射，专为解决特殊问题而设计的</td>
</tr>
</tbody>
</table>
<p>对Map中使用的键的要求和对Set中的元素要求是一样的，任何键都要具有equals()方法，如果键被用于散列Map，则对象要有恰当的hashCode(),如果键被用于TreeMap，则它必须要实现Comparable<br>下面是Map接口的可用操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Maps</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printKeys</span><span class="params">(Map&lt;Integer,String&gt; map)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Size="</span>+map.size());</span><br><span class="line">        System.out.println(<span class="string">"Keys"</span>+map.keySet());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Map&lt;Integer,String&gt; map)</span></span>&#123;</span><br><span class="line">        System.out.println(map.getClass().getSimpleName());</span><br><span class="line">        map.putAll(<span class="keyword">new</span> CountringMapData(<span class="number">25</span>));</span><br><span class="line">        printKeys(map);</span><br><span class="line">        System.out.println(<span class="string">"values:"</span>+map.values());</span><br><span class="line">        System.out.println(map.containsKey(<span class="number">11</span>));</span><br><span class="line">        System.out.println(map.get(<span class="number">11</span>));</span><br><span class="line">        System.out.println(map.containsValue(<span class="string">"F0"</span>));</span><br><span class="line">        Iterator&lt;Integer&gt; keyIt=map.keySet().iterator();</span><br><span class="line">        Integer key=keyIt.next();</span><br><span class="line">        map.remove(key);</span><br><span class="line">        printKeys(map);</span><br><span class="line">        map.clear();</span><br><span class="line">        System.out.println(map.isEmpty());</span><br><span class="line">        map.putAll(<span class="keyword">new</span> CountringMapData(<span class="number">25</span>));</span><br><span class="line">        map.keySet().removeAll(map.keySet());</span><br><span class="line">        System.out.println(map.isEmpty());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="SortedMap"><a href="#SortedMap" class="headerlink" title="SortedMap"></a>SortedMap</h3><p>使用SortedMap(TreeMap是现阶段的唯一实现)，可用确保键处于排序状态，这使得它具有额外的功能，这些功能都是由SortedMap的接口提供的<br>Comparator comparator()返回当前Map使用的Comparator，或者返回null<br>T firstKey()返回Map中的第一个元素<br>T lastKey()返回Map中的最后一个元素<br>SortedMap subMap(fromKey,toKey)，SortedMap headMap(toKey) SortedMap tailMap(fromKey) 生成此Map的一个子集</p>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>为了提高速度，LinkedHashSet散列了所有元素，但是在遍历键值对时，却又以元素的插入顺序返回键值对，此外，可以构造器中设定LinkedhashMap，使之采用基于访问最近最少量（LRU）算法，于是没有被访问过的（可被看做需要删除的）元素就会出现在队列的前面，对于需要定期清理元素以节省空间的程序来说，此功能使得程序很容易得以实现，下面的例子演示了LinkedHashMap的这两个特点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMapDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        LinkedHashMap&lt;Integer,String&gt; linkedMap=<span class="keyword">new</span> LinkedHashMap&lt;&gt;(<span class="keyword">new</span> CountringMapData(<span class="number">25</span>));</span><br><span class="line">        System.out.println(linkedMap);</span><br><span class="line">        <span class="comment">//least-recent-used-order</span></span><br><span class="line">        linkedMap=<span class="keyword">new</span> LinkedHashMap&lt;&gt;(<span class="number">16</span>,<span class="number">0.75f</span>,<span class="keyword">true</span>);</span><br><span class="line">        linkedMap.putAll(<span class="keyword">new</span> CountringMapData(<span class="number">25</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">            linkedMap.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(linkedMap);</span><br><span class="line">        linkedMap.get(<span class="number">0</span>);</span><br><span class="line">        System.out.println(linkedMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的例子可以看出，可通过设定容器的容量和负载因子来调整容器的性能和行为</p>
<h2 id="散列和散列码"><a href="#散列和散列码" class="headerlink" title="散列和散列码"></a>散列和散列码</h2><p>使用标准类型的类当作HashMap的键来使用，是很好用的，因为这些类库在设计时，已经重新实现了一个比较恰当的hashCode()和equals()方法，但是如果自己创建的类，就有可能忘记在其中放置必需的方法，这通常会引起很大的错误<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Groundhog</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Groundhog</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;number=number;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">"GroundHog#"</span>+number;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Prediction</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand=<span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">shadow</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> rand.nextDouble()&gt;<span class="number">0.5</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(shadow())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Six more weeks of winter"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Early Spring"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDetecter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Groundhog&gt; <span class="function"><span class="keyword">void</span> <span class="title">detectSpring</span> <span class="params">(Class&lt;T&gt; type)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Constructor&lt;T&gt; ghog=type.getConstructor(<span class="keyword">int</span>.class);</span><br><span class="line">        Map&lt;Groundhog,Prediction&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            map.put(ghog.newInstance(i),<span class="keyword">new</span> Prediction());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        Groundhog gh=<span class="keyword">new</span> Groundhog(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">"looking up prediction for "</span> +gh);</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(gh))&#123;</span><br><span class="line">            System.out.println(map.get(gh));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"not found"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		            detectSpring(Groundhog.class);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的示例很简单，创建一个Map容器，将Groundhog(土拨鼠)与Prediction（天气预报）关联起来，可是这个示例是不工作的，当我们创建一个土拨鼠new Groundhog(3)时，是无法找到这个键的，根本原因是Groundhog继承了Object的hashCode()方法，而它默认是使用的对象的地址计算散列码，因此由Groundhog(3)生成的一个实例的散列码和第二个生成的实例的散列码并不相同，记住一点的是散列码的作用是查找（快速定位）<br>因此你可能会认为只要编写恰当的hashCode()就可以了，但是它仍然无法正常运行，除非你同时覆盖equals()方法，它也是Object的一部分，HashMap使用equals()判断当前的键是否与表中存在的键相同，继承自Object的equals()默认以对象的地址为判断依据<br>正确的equals()方法必须满足下列5个条件</p>
<ol>
<li>自反性：对于任意的x x.equals(x)一定返回true</li>
<li>对称性：任意的x,y 如果x.equals(y)返回true，则y.equals(x)一定返回true;</li>
<li>传递性：任意的x,y,z, x,equals(y) y.equals(z),则x.equals(z)</li>
<li>一致性：任意的x,y 如果对象中用于等价比较的信息没有改变，那么无论调用x.equals()多少次，返回的结果应该保持一致</li>
<li>对于任何不是null的x x.equals(null)返回false</li>
</ol>
<p>再次强调，默认的Object.equals()比较的是对象地址，因此，如果要将自己的类作为HashMap的键，一定要同时覆盖hashCode()和equals()</p>
<h3 id="理解hashCode"><a href="#理解hashCode" class="headerlink" title="理解hashCode()"></a>理解hashCode()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MapEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> K k;</span><br><span class="line">    <span class="keyword">private</span> V v;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapEntry</span><span class="params">(K key,V value)</span></span>&#123;</span><br><span class="line">        k=key;</span><br><span class="line">        v=value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v=value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShowMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;K&gt; listK=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;V&gt; listV=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key,V value)</span></span>&#123;</span><br><span class="line">        V oldValue=get(key);</span><br><span class="line">        <span class="keyword">if</span>(!listK.contains(key))&#123;</span><br><span class="line">            listK.add(key);</span><br><span class="line">            listV.add(value);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            listV.set(listK.indexOf(key),value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span></span>&#123;<span class="comment">//key is type Object not K</span></span><br><span class="line">        <span class="keyword">if</span>(!listK.contains(key))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> listV.get(listK.indexOf(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">        Set&lt;Map.Entry&lt;K, V&gt;&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Iterator&lt;K&gt; itk = listK.iterator();</span><br><span class="line">        Iterator&lt;V&gt; itV = listV.iterator();</span><br><span class="line">        <span class="keyword">while</span> (itk.hasNext()) &#123;</span><br><span class="line">            set.add(<span class="keyword">new</span> MapEntry&lt;K,V&gt;(itk.next(), itV.next()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> set;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">         SlowMap&lt;String,String&gt; m=<span class="keyword">new</span> SlowMap&lt;&gt;();</span><br><span class="line">         m.putAll(Countries.capitals(<span class="number">15</span>));</span><br><span class="line">         System.out.println(m);</span><br><span class="line">         System.out.println(m.entrySet());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面一个例子，最值得注意的问题，我觉得在定义get(Object o)方法的时候，我们期望的是get(K key)但是在这里是不可以的，提示说both motehed have same erasure,这是我感到疑惑的地方，我们知道在同一个类中，方法签名相同是不被允许的，但是这里通过在子类定义与基类中涉及泛型的方法签名相同的方法也是不被允许的，即使它们都被擦除为Object也不可以，这是为什么？<br>上面这个Map的实现并不好，因为<strong>entrySet()方法的调用创建了副本，这样就使得方法调用的效率变低，Map.Entry最好的实现应该是作为窗口通过它我们可以获得键和值，而且我们还应该可以通过这个视图修改底层数据，这些是副本做不到的</strong></p>
<h3 id="为速度而散列"><a href="#为速度而散列" class="headerlink" title="为速度而散列"></a>为速度而散列</h3><p>上面的例子，效率低的另一个原因是，我们搜索键的时候，使用的是线性查询，这种查询方式非常缓慢<br>散列的价值在于速度，散列使得查询得以快速进行，<strong>由于瓶颈在于查询速度，因此解决方案之一就是保持键的排序状态，然后使用Collection.binarySearch()进行查询</strong><br><strong>散列更进一步，它将键保存在某处，以便能够很快找到，存储一组元素最快的数据结构是数组，所以用它来保存键的信息，请留言，这里说的是键的信息，而不是键本身</strong>，这样有一个问题就是，数组尺寸固定的问题，如果我们希望在Map中保存数量不确定的值，这种问题能解决吗？<br>答案就是：数组不保存键本身，因为一旦保存的是键对象本身的话，那么这个数组位置上能保持的元素也只有一个了，其实很好解决，我们通过键对象获得一个数值，这个数值就是散列码，这个散列码表示数组的下标，通过下标将键值对存在这个数组下标位置上的一个容器，那么问题就解决了，任意数量的元素都能存储在Map中，即使hashCode()冲突也能够在数组索引位置上的容器对象上添加新的元素，解决hashCode冲突问题，<br>总结一下，查询一个值的过程是，计算键的hashCode，通过散列码查询数组，找到相应数组位置上的LinkedList，遍历LinkedList使用equals()判断该取LinkedList中存储的哪个元素，这种Map实现的方式使得每次查询只在少量的数据上进行遍历，效率得到提高</p>
<h3 id="覆盖hashCode"><a href="#覆盖hashCode" class="headerlink" title="覆盖hashCode()"></a>覆盖hashCode()</h3><p>如果要使得HashMap的执行效率更佳，那在我们向容器当作添加元素的时候，应该使得元素落在容器的槽位更加均衡才好，桶位下标的产生我们没有办法控制，因为这与HashMap对象的容量有关，而容量的改变与容器的充满程度和负载因子有关，hashCode生成的值经过计算才会生成桶位下标<br>设计hashCode的一个最重要的一个因素是，无论何时，对同一个对象调用hashCode()都应该生成相同的值<br>此外，也不应该使hashCode（）依赖于唯一性的对象信息，比如this，这也是我们在创建一个新类时，总会忽略的可怕问题，使得即使对象的信息描述完全相同，Map却依然将其视为不同的对象<br>基于对象的内容生成散列码是正确的选择<br>另外一个重要的影响因素，好的hashCode()应该产生分布均匀的散列码，否则，HashMap中的某些桶位负载过重，效率也不会更好<br>有一些建议，可以参考网上的资料</p>
<h2 id="选择接口的不同实现"><a href="#选择接口的不同实现" class="headerlink" title="选择接口的不同实现"></a>选择接口的不同实现</h2><p>尽管实际上只有四种容器：List，Set,Map和Queue，但是每种接口都有不止一个版本的实现，如果需要某种接口的功能，如何选择使用哪个实现？<br>容器之间的区别通常归结为由什么在背后“支持”它们，也就是说，所使用的接口是由什么样的数据结构实现的，<br>例如，ArrayList和LinkedList都实现了List接口，ArrayList底层是由数组支持，而LinkedList是由双向链表实现</p>
<h3 id="对List的选择"><a href="#对List的选择" class="headerlink" title="对List的选择"></a>对List的选择</h3><p>随机访问：ArrayList的随机访问要比LinkedList的随机访问要快，因为ArrayList是基于数组实现的，所以随机查找时，可以直接定位到一个对象的位置，而且随机访问速度不太会受到容器尺寸的影响，但是LinkedList的随机访问并不好，因为它是基于链表实现的，随机访问时要通过链表中的对象线性的查找对象的内存地址，所有性能很差，而且会随着尺寸的增大代价变得更加高昂<br>插入和删除，因为Arraylist的底层数组支持的原因，当向ArrayList插入一个元素时，必须创建空间并将它的所有引用先后移动，这种修改内存数据的行为，非常的耗时，但是ArrayList就比较简单，只需要连接两边的元素即可，这种方式的代价是固定的，不会随着尺寸的改变而改变</p>
<h3 id="对Set的选择"><a href="#对Set的选择" class="headerlink" title="对Set的选择"></a>对Set的选择</h3><p>HashSet的性能基本上总是比TreeSet好，特别是在添加和查询元素时，而这两个操作也是总重要的操作，TreeSet存在的唯一原因是它可以维持元素的排序状态，只有当需要一个排好序的Set时，才应该用TreeSet，TreeSet的迭代要比HashSet快、</p>
<h3 id="对Map选择"><a href="#对Map选择" class="headerlink" title="对Map选择"></a>对Map选择</h3><p>HashMap是我们平时应该默认使用的Map，TreeMap和TreeSet一样，是一种创建有序列表的方式，填充完TreeaMap之后，调用keySet()方法获得一个有序列表，LinkedHashSet在插入时比HashMap要慢一点，因为它在维持散列结果的同时也要维持插入顺序，正是由于这个原因，它的迭代速度也更快一些</p>
<h4 id="HashMap的性能因子"><a href="#HashMap的性能因子" class="headerlink" title="HashMap的性能因子"></a>HashMap的性能因子</h4><p>容量：桶位<br>初始容量：表在创建时所拥有的桶位数，HashMap和HashSet都具有允许你指定初始容量的构造器<br>尺寸：表当前存储的项数<br>负载因子：（尺寸/容量）空表的负载因子是0，半满表是0.5,依次类推，负载因子小的表产生冲突的可能性较小，但是会浪费较多的内存空间，也会使得频繁的扩容（这种是典型的空间换时间），HashMap和HashSet都允许你指定初始的负载因子，当达到该负载因子的水平的时候，容器自动增加其容量（桶位），实现的方式是使容量大致加倍，并重新将现有对象分布到新的桶位上（再散列）（HashMap的默认负载因子是0.75）</p>
<h2 id="实用方法"><a href="#实用方法" class="headerlink" title="实用方法"></a>实用方法</h2><p>Java中有大量的容器的卓越的使用方法，它们被称为java.util.Collections的静态方法，常用的方法总结如下</p>
<table>
<thead>
<tr>
<th></th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>checkedCollection(Collection<t> Class<t> type)<br>checkedList(List<t> Class<t> type)<br>checkedSet(Set<t> Class<t> type)<br>checkedMap(Map&lt;K,V&gt;,Class<k> kType,Class<v> vType)</v></k></t></t></t></t></t></t></td>
<td>产生Collection或者Collection子类型动态类型安全的容器，在不可能使用静态检查版本的时使用这些方法</td>
</tr>
<tr>
<td>max(Collection)<br>mix(Collection)</td>
<td>返回参数Collection中最大或最小的元素，采用Comparator比较</td>
</tr>
<tr>
<td>indexOfSubList(List source,List target)</td>
<td>返回target在source中第一次出现的位置，或者找不到返回-1</td>
</tr>
<tr>
<td>lastIndexOfSubList(List source,List target)</td>
<td>返回target在source中最后一次出现的位置，或者找不到返回-1</td>
</tr>
<tr>
<td>replaceAll(List<t>,T oldVal,T newVal)</t></td>
<td>使用newVal替换所有的oldVal</td>
</tr>
<tr>
<td>reverse(List)</td>
<td>逆转所有元素的顺序</td>
</tr>
<tr>
<td>reverseOrder()<br>reverseOrder&lt;Comparator<t>&gt;</t></td>
<td>返回一个Comparator，第二个版本返回一个反序的比较器</td>
</tr>
<tr>
<td>rotate(List,int distance)</td>
<td>所有的元素向后移动distance个位置，后面的元素循环移到前面</td>
</tr>
<tr>
<td>suffle(List)<br>suffle(List,Random)</td>
<td>随机改变元素的顺序</td>
</tr>
<tr>
<td>sort(List)<br> sort&lt;List<t>,Comparator&lt;? super T&gt;&gt;</t></td>
<td>使用List<t>中的自然排序，第二个方法使用比较器的排序</t></td>
</tr>
<tr>
<td>copy(List&lt;? extends T&gt; dist,List&lt;? super T&gt; src)</td>
<td>将src中的元素复制到dist</td>
</tr>
<tr>
<td>swap(List,int i,int j)</td>
<td>交换元素的位置</td>
</tr>
<tr>
<td>fill（List&lt;? super T&gt;,T x）</td>
<td>用对象x替换所有元素</td>
</tr>
<tr>
<td>nCopies(int n,T x)</td>
<td>返回大小为n的List<t>,此List不可改变，其中的引用都指向x</t></td>
</tr>
<tr>
<td>disjoint(Collection,Collection)</td>
<td>当两个集合中没有相同的元素时，返回true</td>
</tr>
<tr>
<td>ferquency(Collection,Object x)</td>
<td>返回Collection中等于x的元素个数</td>
</tr>
<tr>
<td>unmodifiedCollection(Collection)<br>unmodifiedList(List)<br>unmodifiedSet(Set)<br>unmodifiedMap(Map)</td>
<td>生成只读容器</td>
</tr>
<tr>
<td>concurrentCollection(Collection)<br>concurrentList(List)<br>concurrentSet(Set)<br>concurentMap(Map)</td>
<td>生成线程安全的容器</td>
</tr>
</tbody>
</table>
<h2 id="持有引用"><a href="#持有引用" class="headerlink" title="持有引用"></a>持有引用</h2><p>java.lang.ref类库包含了一组类，这些类为垃圾回收器提供了更大的灵活性，当存在可能耗尽内存的大对象时，这次类显得特别有用，有三个继承自抽线类Reference的类，SoftReferenc ,WeakRefrence,PhantomReference,当垃圾回收器正在考察的对象只能通过某个Reference对象才“可获得的”时候，上述这些类给垃圾回收器提供了不同级别的间接指示<br>对象是可获得的（reachable）是值对象能在程序的某处能够找到，不可获得对象，程序不能再访问它们，对这些对象的回收是安全的<br>如果想继续持有某个对象的引用，希望以后还能访问它们，但是也希望能够允许垃圾回收器在内存不足的时候释放它们，这时就可使用Reference对象<br>以Reference对象作为你和普通引用之间的媒介（代理），另外，一定不能有普通的引用指向这个对象，这样就能达到上述的目的，<strong>普通的引用指没有经过Reference对象包装过的引用</strong>，如果垃圾回收器发现某个对象通过引用是可达的，该对象就不会被释放<br>SoftRefenece，WeakReference，PhantomReference由强到弱排列，对应不同级别的“可获得性”，SoftReference用以实现内存敏感的高速缓存，weakReference是为了实现“规范映射”而设计的，，它不妨碍垃圾回收映射的“键”（或“值”），“规范映射”中对象的实例可以在程序的多处被同时使用，以节省内存空间，PhantomReference用于调度回收器的清理工作，它比Java终止机制更灵活<br>使用SoftReference和WeakReferenc时，可以选择是否将它们放入ReferenceQueue(用作垃圾回收前的清理工作的工具)，而PhantomReference只能依赖于ReferenceQueue<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VeryBig</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE=<span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span>[] la =<span class="keyword">new</span> <span class="keyword">long</span>[SIZE];</span><br><span class="line">    <span class="keyword">private</span> String ident;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VeryBig</span><span class="params">(String s)</span></span>&#123;ident=s;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123; <span class="keyword">return</span>  ident; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Finalizing"</span>+ident );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">References</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReferenceQueue&lt;VeryBig&gt; rf=<span class="keyword">new</span> ReferenceQueue();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Reference&lt;? extends VeryBig&gt; inq=rf.poll();</span><br><span class="line">        <span class="keyword">if</span>(inq!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"In Queue"</span>+inq.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size=<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(args.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            size=<span class="keyword">new</span> Integer(args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LinkedList&lt;SoftReference&lt;VeryBig&gt;&gt; sa=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            sa.add(<span class="keyword">new</span> SoftReference&lt;VeryBig&gt;(<span class="keyword">new</span> VeryBig(<span class="string">"Soft"</span>+i),rf));</span><br><span class="line">            System.out.println(<span class="string">"Just created"</span>+sa.getLast());</span><br><span class="line">            checkQueue();</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedList&lt;WeakReference&lt;VeryBig&gt;&gt; wa=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            wa.add(<span class="keyword">new</span> WeakReference&lt;VeryBig&gt;(<span class="keyword">new</span> VeryBig(<span class="string">"Weak"</span>+i),rf));</span><br><span class="line">            System.out.println(<span class="string">"Just created"</span>+wa.getLast());</span><br><span class="line">            checkQueue();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        SoftReference&lt;VeryBig&gt; s=<span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> VeryBig(<span class="string">"Soft"</span>));</span><br><span class="line">        WeakReference&lt;VeryBig&gt; w=<span class="keyword">new</span> WeakReference&lt;&gt;(<span class="keyword">new</span> VeryBig(<span class="string">"weak"</span>));</span><br><span class="line">        </span><br><span class="line">        System.gc();</span><br><span class="line">        </span><br><span class="line">        LinkedList&lt;PhantomReference&lt;VeryBig&gt;&gt; pa=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            pa.add(<span class="keyword">new</span> PhantomReference&lt;VeryBig&gt;(<span class="keyword">new</span> VeryBig(<span class="string">"Phantom"</span>+i),rf));</span><br><span class="line">            System.out.println(<span class="string">"Just created"</span>+pa.getLast());</span><br><span class="line">            checkQueue();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h3><p>容器类中有一种特殊的Map，即WeakHashMap,它被用来保存WeakReference，它使得规范映射更易于使用，在这种映射中，每个值只保存一份实例以节省存储空间，当程序需要那个“值”的时候，便在映射中查询现有的对象，然后使用它（而不是重新再创建），映射可将值作为其初始化的一部分，不过通常是在需要的时候才生成“值”<br>这是一种节省空间的技术，因为WeakHashMap允许垃圾回收器自动清理键和值，所以它显得十分便利，对于向WeakHashMap添加键和值的操作，则没有什么特殊的要求，映射会自动使用WeakReference包装它们，允许清理元素的触发条件是，不再需要此键，如下所示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Element</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String ident;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Element</span><span class="params">(String id)</span></span>&#123;ident=id;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span>  ident;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> ident.hashCode();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o <span class="keyword">instanceof</span>  Element &amp;&amp; ident==((Element)o).ident;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fianlzie</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Finalizing"</span>+getClass().getSimpleName()+ident);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Element</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Key</span><span class="params">(String id)</span></span>&#123;<span class="keyword">super</span>(id);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Value</span> <span class="keyword">extends</span>  <span class="title">Element</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Value</span><span class="params">(String id)</span></span>&#123;<span class="keyword">super</span>(id);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CanonicalMapping</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size=<span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">if</span>(args.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            size=<span class="keyword">new</span> Integer(args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        Key[]  keys=<span class="keyword">new</span> Key[size];</span><br><span class="line">        WeakHashMap&lt;Key,Value&gt; wm=<span class="keyword">new</span> WeakHashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">           Key k=<span class="keyword">new</span> Key(Integer.toString(i));</span><br><span class="line">           Value v=<span class="keyword">new</span> Value(Integer.toString(i));</span><br><span class="line">           <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">               keys[i]=k;<span class="comment">//save as "real"  reference</span></span><br><span class="line">           &#125;</span><br><span class="line">           wm.put(k,v);</span><br><span class="line">        &#125;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/19/容器深入研究/" data-id="cjnzuy0bm002628rz8elytlj2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/10/19/Java-I-O系统/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Java I/O系统
        
      </div>
    </a>
  
  
    <a href="/2018/10/19/数组/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">数组</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/学习心得/">学习心得</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML5/">HTML5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Maven/">Maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Oracle/">Oracle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Servlet-JSP/">Servlet&JSP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-MVC/">Spring MVC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-boot/">Spring boot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-cloud/">Spring cloud</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/HTML5/" style="font-size: 10px;">HTML5</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/Node-js/" style="font-size: 10px;">Node.js</a> <a href="/tags/Oracle/" style="font-size: 10px;">Oracle</a> <a href="/tags/Servlet-JSP/" style="font-size: 10px;">Servlet&JSP</a> <a href="/tags/Spring/" style="font-size: 10px;">Spring</a> <a href="/tags/Spring-MVC/" style="font-size: 10px;">Spring MVC</a> <a href="/tags/Spring-boot/" style="font-size: 10px;">Spring boot</a> <a href="/tags/Spring-cloud/" style="font-size: 10px;">Spring cloud</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/11/02/Servlets/">Servlets</a>
          </li>
        
          <li>
            <a href="/2018/10/27/并发/">并发</a>
          </li>
        
          <li>
            <a href="/2018/10/19/注解/">注解</a>
          </li>
        
          <li>
            <a href="/2018/10/19/枚举类型/">枚举类型</a>
          </li>
        
          <li>
            <a href="/2018/10/19/Java-I-O系统/">Java I/O系统</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 EgbertDay<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>