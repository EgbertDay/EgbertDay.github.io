<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Java I/O系统 | 代海峰</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="创建一个好的输入/输出(I/O)系统是一项困难的事情，挑战似乎来自于要涵盖所有的可能性，不仅存在各种I/O源端和想要与之通信的接收器（文件，控制台，网络链接等），而且还需要以各种不同的方式与它们进行通信（顺序，随机缓存，缓冲，二进制，按行，按字等）自从Java 1.0版本以来，java的I/O类库发生了明显改变，在原本面向字节的类中添加了面向字符和基于Unicode的类，在JDK1.4中，添加了n">
<meta name="keywords" content="Java">
<meta property="og:type" content="article">
<meta property="og:title" content="Java I&#x2F;O系统">
<meta property="og:url" content="http://yoursite.com/2018/10/19/Java-I-O系统/index.html">
<meta property="og:site_name" content="代海峰">
<meta property="og:description" content="创建一个好的输入/输出(I/O)系统是一项困难的事情，挑战似乎来自于要涵盖所有的可能性，不仅存在各种I/O源端和想要与之通信的接收器（文件，控制台，网络链接等），而且还需要以各种不同的方式与它们进行通信（顺序，随机缓存，缓冲，二进制，按行，按字等）自从Java 1.0版本以来，java的I/O类库发生了明显改变，在原本面向字节的类中添加了面向字符和基于Unicode的类，在JDK1.4中，添加了n">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-10-25T14:22:55.404Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java I&#x2F;O系统">
<meta name="twitter:description" content="创建一个好的输入/输出(I/O)系统是一项困难的事情，挑战似乎来自于要涵盖所有的可能性，不仅存在各种I/O源端和想要与之通信的接收器（文件，控制台，网络链接等），而且还需要以各种不同的方式与它们进行通信（顺序，随机缓存，缓冲，二进制，按行，按字等）自从Java 1.0版本以来，java的I/O类库发生了明显改变，在原本面向字节的类中添加了面向字符和基于Unicode的类，在JDK1.4中，添加了n">
  
    <link rel="alternate" href="/atom.xml" title="代海峰" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">代海峰</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">个人博客</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Java-I-O系统" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/19/Java-I-O系统/" class="article-date">
  <time datetime="2018-10-19T14:06:30.000Z" itemprop="datePublished">2018-10-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习心得/">学习心得</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java I/O系统
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>创建一个好的输入/输出(I/O)系统是一项困难的事情，挑战似乎来自于要涵盖所有的可能性，不仅存在各种I/O源端和想要与之通信的接收器（文件，控制台，网络链接等），而且还需要以各种不同的方式与它们进行通信（顺序，随机缓存，缓冲，二进制，按行，按字等）<br>自从Java 1.0版本以来，java的I/O类库发生了明显改变，在原本面向字节的类中添加了面向字符和基于Unicode的类，在JDK1.4中，添加了nio类（对于“新I/O”来说，这是一个从现在起我们将会使用多年的名称，即使它们在JDK1.4就被引用了）添加进来是为了改善性能和功能， 因此，在充分理解Java I/O系统以便正确运用它们之前，我们需要学习相当数量的类，另外，很有必要理解I/O类型的演化过程</p>
<h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><p>File是一个实用类库工具，它可以帮助我们处理文件目录问题<br>File(文件)类的名字有一定的误导性，我们可能以为它指代的是文件，实际上并非如此，它既能表示一个特定文件的名称，又能代表一个目录下的一组文件的名称，实际上，FilePath（文件路径）这个名称可能更适合它</p>
<h3 id="目录列表器"><a href="#目录列表器" class="headerlink" title="目录列表器"></a>目录列表器</h3><p>假如我们想要查看一个目录列表，可以用两种方式来使用File对象，如果我们调用不带参数的list()方法，便可以获得此File对象包含的全部列表，然而，如果我们想要获得一个受限列表，例如，想要获得所有扩展名为.java的文件，那么我们就要使用到“目录过滤器”，这个类会告诉我们怎样显示符合条件的File对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      String[] fileNames;</span><br><span class="line">      File path=<span class="keyword">new</span> File(<span class="string">"."</span>);</span><br><span class="line">      <span class="keyword">if</span>(args.length==<span class="number">0</span>)&#123;</span><br><span class="line">          fileNames=path.list();</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          fileNames=path.list(<span class="keyword">new</span> DirFilter(args[<span class="number">0</span>]));</span><br><span class="line">      &#125;</span><br><span class="line">        Arrays.sort(fileNames,String.CASE_INSENSITIVE_ORDER);</span><br><span class="line">      <span class="keyword">for</span>(String fileName:fileNames)&#123;</span><br><span class="line">          System.out.println(fileName);</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DirFilter</span> <span class="keyword">implements</span> <span class="title">FilenameFilter</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String regex;</span><br><span class="line">    Pattern pattern=Pattern.compile(regex);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DirFilter</span><span class="params">(String regex)</span></span>&#123;regex=regex;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pattern.matcher(name).matches();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>DirFile这个类存在的唯一原因就是提供accept()方法给List()方法使用，使用list()可回调accept()，进而选择以决定那些文件被包含在列表中，因此，这种结构也常常被称作回调</strong>，更具体的说，这是一个策略模式的例子，因为list()实现了基本功能，而按照FilenamFilter的形式提供这个策略，以便完善list()在提供服务是所需的算法，因为list()接受FilenameFilter对象作为参数，这意味着我们可以 传递实现了FilenameFilter接口的任何类的对象</p>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>这个例子使用匿名内部类进行改写，首先创建一个filter()方法，它会返回一个指向FilenameFilter的引用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirList2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FilenameFilter <span class="title">filter</span><span class="params">(<span class="keyword">final</span> String regex)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FilenameFilter() &#123;</span><br><span class="line">            Pattern pattern=Pattern.compile(regex);</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> pattern.matcher(name).matches();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String[] fileNames;</span><br><span class="line">        File path=<span class="keyword">new</span> File(<span class="string">"."</span>);</span><br><span class="line">        <span class="keyword">if</span>(args.length==<span class="number">0</span>)&#123;</span><br><span class="line">            fileNames=path.list();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            fileNames = path.list(filter(args[<span class="number">0</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意传递给filter的参数必须是final的，这个在匿名内部类是必需的，这样它才能使用来自该类范围之外的对象</strong><br>这个设计有所改进，因为现在FilenameFilter类紧密地和DirFilter2绑定到一起，然而，我们可以进一步修改该方法，定义一个作为list()参数的匿名内部类，这样程序会变得更小<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirList3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span></span>&#123;<span class="comment">//传递给匿名内部类的参数使用final修饰</span></span><br><span class="line">        String[] fileNames;</span><br><span class="line">        File path= <span class="keyword">new</span> File(<span class="string">"."</span>);</span><br><span class="line">        <span class="keyword">if</span>(args.length==<span class="number">0</span>)&#123;</span><br><span class="line">            fileNames=path.list();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            fileNames=path.list(<span class="keyword">new</span> FilenameFilter() &#123;</span><br><span class="line">                Pattern pattern=Pattern.compile(args[<span class="number">0</span>]);</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> pattern.matcher(name).matches();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(String fileName:fileNames)&#123;</span><br><span class="line">            System.out.println(fileName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="目录实用工具"><a href="#目录实用工具" class="headerlink" title="目录实用工具"></a>目录实用工具</h3><p>程序设计中的一项常见的任务就是在文件集上执行操作，这些文件要么在本地目录中，要么遍布于整个目录树中，如果你有一种工具能够为你产生这个文件集，那么它会非常有用，下面的实用工具类就是通过使用list()方法产生由本地目录中的文件构成的File对象数组，或者通过使用walk()方法产生给目录下的由整个目录树中所有的文件构成的List<file>（File文件比对象更有用，因为File对象包含更多信息），下面的这些文件时基于你的正则表达式被选中的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Directory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> File[] local(File dir,<span class="keyword">final</span> String regex)&#123;</span><br><span class="line">        <span class="keyword">return</span> dir.listFiles(<span class="keyword">new</span> FilenameFilter() &#123;</span><br><span class="line">            Pattern pattern=Pattern.compile(regex);</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> pattern.matcher(name).matches();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> File[] local(String path,String regex)&#123;</span><br><span class="line">        <span class="keyword">return</span> local(<span class="keyword">new</span> File(path),regex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeInfo</span> <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">File</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> List&lt;File&gt; files =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">public</span> List&lt;File&gt; dirs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="meta">@NotNull</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Iterator&lt;File&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> files.iterator();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">(TreeInfo other)</span></span>&#123;</span><br><span class="line">            files.addAll(other.files);</span><br><span class="line">            dirs.addAll(other.dirs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"dirs"</span>+PPrint.pformat(dirs)+<span class="string">"\n\nfiles"</span>+PPrint.pformat(files);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeInfo <span class="title">walk</span><span class="params">(File start,String regex)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  recurseDirs(start,regex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeInfo <span class="title">walk</span><span class="params">(String path,String regex)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  recurseDirs(<span class="keyword">new</span> File(path),regex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeInfo <span class="title">walk</span><span class="params">(File start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> recurseDirs(start,<span class="string">".*"</span>);<span class="comment">//Everything</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeInfo <span class="title">walk</span><span class="params">(String startPath)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  recurseDirs(<span class="keyword">new</span> File(startPath),<span class="string">".*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> TreeInfo <span class="title">recurseDirs</span><span class="params">(File startDir,String regex)</span></span>&#123;</span><br><span class="line">        TreeInfo result = <span class="keyword">new</span> TreeInfo();</span><br><span class="line">        <span class="keyword">for</span>(File item:startDir.listFiles())&#123;</span><br><span class="line">            <span class="keyword">if</span>(item.isDirectory())&#123;</span><br><span class="line">                result.dirs.add(item);</span><br><span class="line">                recurseDirs(item,regex);<span class="comment">//递归调用</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(item.getName().matches(regex))&#123;</span><br><span class="line">                    result.files.add(item);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></file></p>
<p>上面的代码实现了收集一个目录数的信息，这里使用listFile()产生File数组，这个方法还可以接收一个目录FilenameFilter，我们得到File数组之后，对File数组遍历判断File是目录还是文件，若是目录则递归执行这个方法<br>我们还可以更进一步，创建一个工具，它可以在目录中穿行，并且根据Stratagy对象来处理这些目录中的文件（这是策略模式的另一个示例）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessFile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(File file)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line">    <span class="keyword">private</span> String ext;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProcessFile</span><span class="params">(Strategy strategy,String ext)</span></span>&#123;</span><br><span class="line">        strategy=strategy;</span><br><span class="line">        ext=ext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(args.length==<span class="number">0</span>)&#123;</span><br><span class="line">               processDirectoryTree(<span class="keyword">new</span> File(<span class="string">"."</span>));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(String arg:args)&#123;</span><br><span class="line">                    File fileArg=<span class="keyword">new</span> File(arg);</span><br><span class="line">                    <span class="keyword">if</span>(fileArg.isDirectory())&#123;</span><br><span class="line">                        processDirectoryTree(fileArg);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">if</span>(!arg.endsWith(<span class="string">"."</span>+ext))&#123;</span><br><span class="line">                            arg+=<span class="string">"."</span>+ext;</span><br><span class="line">                            strategy.process(<span class="keyword">new</span> File(arg).getCanonicalFile());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processDirectoryTree</span><span class="params">(File root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(File file:Directory.walk(root.getAbsolutePath(),<span class="string">".*\\."</span>+ext))&#123;</span><br><span class="line">            strategy.process(file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       <span class="keyword">new</span> ProcessFile(<span class="keyword">new</span> ProcessFile.Strategy()&#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">               System.out.println(file.getName());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,<span class="string">"java"</span>).start(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="目录的检查和创建"><a href="#目录的检查和创建" class="headerlink" title="目录的检查和创建"></a>目录的检查和创建</h3><p>File类不仅仅只是代表存在的文件或目录，也可以用File对象来创建新的目录或尚不存在的整个目录路径，我们还可以查看文件的特性（如大小，最后修改日期，读/写），检查某个File对象代表的是文件还是目录，并可以删除文件，下面的示例展示了File类的一些其他的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fileData</span><span class="params">(File f)</span></span>&#123;</span><br><span class="line">        System.out.println(</span><br><span class="line">                <span class="string">"Absolate path"</span>+f.getAbsolutePath()+</span><br><span class="line">                 <span class="string">"\n Can read:"</span>+f.canRead()+</span><br><span class="line">                 <span class="string">"\n Can write"</span>+f.canWrite()+</span><br><span class="line">                 <span class="string">"\n getName"</span>+f.getName()+</span><br><span class="line">                <span class="string">"\n getPath"</span>+f.getPath()+</span><br><span class="line">                 <span class="string">"\n getParent"</span>+f.getParent()+</span><br><span class="line">                 <span class="string">"\n length"</span>+f.length()+</span><br><span class="line">                 <span class="string">"\n lastModified"</span>+f.lastModified()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args.length&lt;<span class="number">1</span>)</span><br><span class="line">            usage();</span><br><span class="line">        <span class="keyword">if</span> (args[<span class="number">0</span>].equals(<span class="string">"-r"</span>))&#123;</span><br><span class="line">            <span class="keyword">if</span>(args.length!=<span class="number">3</span>)</span><br><span class="line">                usage();</span><br><span class="line">            File old=<span class="keyword">new</span> File(args[<span class="number">1</span>]);</span><br><span class="line">            File rname=<span class="keyword">new</span> File(args[<span class="number">2</span>]);</span><br><span class="line">            old.renameTo(rname);</span><br><span class="line">            fileData(old);</span><br><span class="line">            fileData(rname);</span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">//exit main</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> del=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(args[<span class="number">0</span>].equals(<span class="string">"-d"</span>))&#123;</span><br><span class="line">            count++;</span><br><span class="line">            del=<span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">while</span>(++count &lt; args.length)&#123;</span><br><span class="line">            File f=<span class="keyword">new</span> File(args[count]);</span><br><span class="line">            <span class="keyword">if</span>(f.exists())&#123;</span><br><span class="line">                System.out.println(f+<span class="string">" exsits"</span>);</span><br><span class="line">                <span class="keyword">if</span> (del)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"deleting..."</span>+f);</span><br><span class="line">                    f.delete();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(!del)&#123;</span><br><span class="line">                    f.mkdir();</span><br><span class="line">                    System.out.println(<span class="string">"Create"</span>+f);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            fileData(f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>renameTo()，用来将一个文件重命名（或移动）到由参数所指示的另一个完全不同的新路径（也就是另一个File对象），</p>
<h2 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h2><p><strong>编程语言的I/O类库中经常使用流这个概念，它代表任何又能及产出数据的数据源对象或者有能力接收数据的接收端对象，流屏蔽了实际的I/O设备中处理数据的细节</strong><br>java类库的I/O类分为输入和输出两部分，可以在java的JDK文档里的层次结构中查看到，<strong>通过继承，任何自InputStreanm或Reader派生而来的类都含有名字为read的基本方法</strong>，用于读取单个字节或者字节数组，同样，任何自OutputStream或Writer派生而来的类都包含有名为write()的基本方法，用于写单个字节或者字节数组，但是，我们通常不会用到这些方法，它们之所以存在是因为别的类可以使用它们，以便提供更有用的接口，因此，我们还少使用单一的类来创建流对象，而是通过叠加多个对象来提供期望的功能，这就是装饰器设计模式，java的流类库让人困惑的一点就是：创建单一的结果流却需要创建多个对象<br>按照这些类的功能对它们进行分类，在java1.0中，类库的设计者首先限定与输入有关的所有类都应该从InputStream继承，而与输出有关的类都应该从OutputStream继承</p>
<h3 id="InputStream类型"><a href="#InputStream类型" class="headerlink" title="InputStream类型"></a>InputStream类型</h3><p>InputStream的作用就是用来表示那些从不同数据源产生输入的类，这些数据源包括</p>
<ol>
<li>字节数组</li>
<li>String对象</li>
<li>文件</li>
<li>“管道”</li>
<li>一个由其他种类的流组成的序列，以便我们可以将它们收集合并到一个流内</li>
<li>其他数据源，如Internet连接等</li>
</ol>
<p><strong>每一种数据源都有相应的InputStream</strong>，另外，FilterInputStream也属于一种InputStream，为“装饰器”类提供基类，其中“装饰器”可以把有用的属性和接口与输入流连接在一起<br>|：InputStream类型：|</p>
<table>
<thead>
<tr>
<th></th>
<th>:类:</th>
<th>：功能：</th>
<th>：构造器参数/如何使用：</th>
</tr>
</thead>
<tbody>
<tr>
<td>ByteArrayInputStream</td>
<td>允许将内存的缓冲区当作InputStream使用</td>
<td>缓冲区，字节将从中取出<br>作为一种数据源：将其与FilterInputStrea对象相连以提供有用的接口</td>
</tr>
<tr>
<td>StringInputStream</td>
<td>将String转换成InputStream</td>
<td>字符串，底层实现实际使用StringBuffer<br>作为一种数据源：将其与FilterInputStream对象相连以提供有用的接口</td>
</tr>
<tr>
<td>FileInputStream</td>
<td>用于从文件中读取信息</td>
<td>字符串：表示文件名，文件或FileDescriptor对象<br>作为一种数据源：将其与FilterInputStream对象相连以提供有用的接口</td>
</tr>
<tr>
<td>PipedInputStream</td>
<td>产生用于写入相关PipedInputStream的数据，实现“管道化”概念</td>
<td>PipedOutputStream<br>作为多线程中数据源：将其与FilterInputStream对象相连以提供有用的接口</td>
</tr>
<tr>
<td>SequenceInputStream</td>
<td>将两个或多个InputStream对象转换成单一的InputStream</td>
<td>两个InputStream对象或一个容纳InputStream对象的容器Enumation<br>作为一种数据源，将其与FilterInputStream对象相连以提供有用的接口</td>
</tr>
<tr>
<td>FilterInputStream</td>
<td>抽象类，作为“装饰器”的接口，其中“装饰器”为其他的类提供有用的功能</td>
<td>详情查看实现FilterInputStream的类</td>
</tr>
</tbody>
</table>
<h3 id="OutputStream类型"><a href="#OutputStream类型" class="headerlink" title="OutputStream类型"></a>OutputStream类型</h3><p>该类别决定了输出所要去往的目标：字节数组（但不是String，不过你当然可以用字节数组自己创建），文件或管道<br>另外，FilterOutputStream为“装饰器”类提供了一个基类，“装饰器”类把属性或者有用的接口与输出流连接了起来<br>|：OutputStream类型：|</p>
<table>
<thead>
<tr>
<th></th>
<th>：类：</th>
<th>：功能：</th>
<th>：构造器参数/如何使用：</th>
</tr>
</thead>
<tbody>
<tr>
<td>ByteArrayOutoputStream</td>
<td>在内存中创建缓冲区，所有送往“流”的数据都要放置在此缓冲区内</td>
<td>缓冲区初始化尺寸（可选的）<br>用于指定数据的目的地：将其与FilterOutputStream对象相连以提供有用接口</td>
</tr>
<tr>
<td>FileOutputStream</td>
<td>用于将信息写至文件</td>
<td>字符串，表示文件名，文件或者FileDiscriptor<br>指定数据的目的地：将其与FilterOutputStream对象相连以提供有用接口</td>
</tr>
<tr>
<td>PipeOutputStream</td>
<td>任何写入其中的信息都会自动作为相关PipedInputStream的输出，实现”管道化”概念</td>
<td>PidedInputStream<br>指定用于多线程的数据的目的地：将其与FilterOutStream对象相连以提供有用的接口</td>
</tr>
<tr>
<td>FilterOutputStream</td>
<td>抽象类，作为“装饰器”的接口，其中“装饰器”为其他OutputStream提供有用的功能</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="添加属性和有用的接口"><a href="#添加属性和有用的接口" class="headerlink" title="添加属性和有用的接口"></a>添加属性和有用的接口</h2><p><strong>java的I/O类库需要多种不同功能的组合，这正是装饰器模式的理由所在</strong>，这也正是java I/O类库中存在filter（过滤器）类的原因所在，抽象类filter是所有装饰器类的基类，装饰器必须具有和它所装饰的对象相同的接口，但也可以扩展接口，而这种情况只发生在个别的filter类中<br>装饰器的一个缺点，在编写代码的时候，它给了我们很大的灵活性（因为我们很容易混合和匹配属性），但是它同时也增加了代码的复杂性，Java I/O类库操作不便的原因在于:我们必须创建很多类——“核心”I/O类型加上所有的装饰器，才能得到我们所需要单个I/O对象<br>FilterInputStream和FilterOutputStream是用来提供装饰器类接口以控制特定输入流和输出流的两个类，它们的名字不是很直观，它们是直接子I/O类库中的InputStream和OutPutStream派生而来，这两个类是装饰器的必要条件（以便能为所有正在被修饰的对象提供通用的接口）</p>
<h3 id="通过FilterInputStream和InputStream读取数据"><a href="#通过FilterInputStream和InputStream读取数据" class="headerlink" title="通过FilterInputStream和InputStream读取数据"></a>通过FilterInputStream和InputStream读取数据</h3><p>FilterInputStream类能够完成两件完全不同的事情，其中，DataInputStream允许我们读取不同的基本类型数据以及String对象（所有方法都以“read”开头，例如readByte(),readFloat()等等）搭配相应的DataOutPutStream，我们可以通过数据“流”将基本类型的数据从一个地方迁移到另一个地方<br>其他FilterInputStream类则在内部修改InputStream的行为方式：是否缓冲，是否保留它所读过的行（允许我们查询行数或设置行数），以及是否把单一字符推回输入流等等，最后两个类看起来就像是为了创建一个编译器（它们被添加进来可能是为了对“用java构建编译器”实验提供支持），因此我们在一般的编程不会用到它们<br>|:FilterInputStream:|</p>
<table>
<thead>
<tr>
<th></th>
<th>：类：</th>
<th>：功能：</th>
<th>：构造器参数/如何使用：</th>
</tr>
</thead>
<tbody>
<tr>
<td>DataInputStream</td>
<td>与DataOutputStream搭配使用，因此我们可以按照可移植方式从流读取基本数据类型（int,cahr,long等）</td>
<td>InputStream<br>包含用于读取基本类型数据的全部接口</td>
</tr>
<tr>
<td>BufferInputStream</td>
<td>使用它可以防止每次读取都得进行实际写操作，代表“使用缓冲区”</td>
<td>InputStream<br>本质上不提供接口，只不过是向进程中添加缓冲区所必需的，与接口对象搭配</td>
</tr>
<tr>
<td>LineNubmberInputStream</td>
<td>跟踪输入流中的行为，可调用getLineNumber()和setLineNumber(int)</td>
<td>InputStream<br>仅增加了行号，因此可能要与接口对象搭配使用</td>
</tr>
<tr>
<td>PushbackInputStream</td>
<td>具有“能弹出一个字节的缓冲区”，因此可以将读到的最后一个字符回退</td>
<td>InputStream<br>通常作为编译器的扫描器，之所以包含在内是因为java编译器的需要，我们可能永远不会用到</td>
</tr>
</tbody>
</table>
<h3 id="通过FilterOutputStream和OutputStream写入数据"><a href="#通过FilterOutputStream和OutputStream写入数据" class="headerlink" title="通过FilterOutputStream和OutputStream写入数据"></a>通过FilterOutputStream和OutputStream写入数据</h3><p>与DataInputStream对应的是DateOutPut，它可以将各种基本类型数据以及String对象格式化输出到“流”中，这样以来，任何在机器上的人任何DataInputStream都能读取它们，所有方法都是以“write”开头，例如writeByte().writeFloat()等<br>PrintStream最初的目的便是为了可以以可视化格式打印所有的基本类型以及String对象，这和DataOutputStream不同，后者的目的是将数据元素置入“流”中，使得DataInputStream能够可移植地重构它们<br>PrintStream内有两个重要的方法：print(),println(),对它们进行重载，以便可打印出各种数据类型，print()和println()之间的差异，后者是在操作完毕后添加一个换行符<br>PrintStream可能会有一些问题，因为它们捕捉了所有的IOExceptions（因此，我们必须使用checkError()自行检测错误状态，如果出现错误它返回true），另外，PrintStrea也未完全国际化，不能以平台无关的方式处理换行动作（这些问题在printWriter得到了解决）<br>BuferredOutputStream是一个修改过的OutputStream，它对数据流使用缓冲技术，因此当每次向流写入时，不必每次都进行实际的物理写动作，所以在进行输出时，我们可能更经常的使用它</p>
<p>|:FilterOutputStream:|</p>
<table>
<thead>
<tr>
<th></th>
<th>：类：</th>
<th>：功能：</th>
<th>：构造器参数/如何使用：</th>
</tr>
</thead>
<tbody>
<tr>
<td>DataOutputStream</td>
<td>与DataInputStream搭配使用，因此可以按照可移植方式向流中写入基本类型数据（int char long等）</td>
<td>OutputStream<br></td>
</tr>
</tbody>
</table>
<p>包含用于写入基本类型数据的全部接口<br>PrintStream|用于产生格式化输出，其中DataOutStream处理数据的存储，PrintStream处理显示|OutputStream<br>可以用boolean值指示是否在每次换行时清空缓冲区（可选的）应该是对OutputStream对象的“final”封装，可能会经常使用它<br>BufferedOutputStream|使用它以避免每次发送数据时都要进行实际的写操作，代表“使用缓冲区”可以调用flush()清空缓冲区|OutputStream可以指定缓冲区大小（可选）<br>本质上并不提供接口，只不过是向进程中添加缓冲区所必需的，与接口对象搭配</p>
<h2 id="Reader和Writer"><a href="#Reader和Writer" class="headerlink" title="Reader和Writer"></a>Reader和Writer</h2><p>java1.1对基本的I/O流类型进行了重大的修改，当我们初次看到Reader和Writer类时，可能会认为这两个类时取代InputStream和OutputStream的类，但实际上并不是如此，尽管员I/O类库中的一些类已经被废弃，但是InputStream和OutputStream在以面向字节形式的I/O中仍可以提供极其有价值的功能，Reader和Writer则提供兼容Unicode与面向字符的I/O功能，另外：</p>
<ol>
<li>java1.1向InputStream和OutputStream继承结构中添加了一些新类，所有显然这两个类时不会被取代的</li>
<li>有时我们必须要把来自于“字节”层次结构中的类和“字符”层次结构中的类结合起来使用，为了实现这个目的，就要使用“适配器（adapter）”类：InputStreamReader可以将InputStream转换为Reader，而OutStreamWriter可以把OutputStream转换为Writer<br>设计Reader和Writer继承层次结构主要是为了国际化，老的I/O流继承层次结构仅支持8位字节流，并且不能很好地处理16位的Unicode字符，由于Unicode用于字符国际化（java本身的char也是16位的Unicode），所以添加Reader和Writer继承层次结构是为了在所以的I/O操作中都支持Unicode，另外，新类库的设计使得它的操作比旧类库更快<h3 id="数据的来源和去处"><a href="#数据的来源和去处" class="headerlink" title="数据的来源和去处"></a>数据的来源和去处</h3>几乎所有原始的java I/O流类都有相应的Reader和Writer类来提供天然的Unicode操作<br>然而在某些场合，面向字节的InputStream和OutputStream才是正确的解决方案，特别是，java.util,zip类库就是面向字节的而不是面向字符的，因此，最明智的做法是尽量尝试使用Reader和Writer，一旦程序代码无法编译成功，我们就会发现自己不得不使用面向字节的类型<br>下面展示了两个继承结构中，信息的来源和去处（即数据物理上来自哪里及去向哪里）之间的对应关系</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>来源与去处：java 1.0类</th>
<th>相应的java 1.1类</th>
</tr>
</thead>
<tbody>
<tr>
<td>InputStream</td>
<td>Reader<br>适配器：InputStreamReader</td>
</tr>
<tr>
<td>OutputStream</td>
<td>Writer<br>适配器：OutputStreamWriter</td>
</tr>
<tr>
<td>FileInputStream</td>
<td>FileReader</td>
</tr>
<tr>
<td>FileOutoutStream</td>
<td>FileWriter</td>
</tr>
<tr>
<td>StringBufferInputStream（已废弃）</td>
<td>StringReader</td>
</tr>
<tr>
<td>无相应的类</td>
<td>StringWriter</td>
</tr>
<tr>
<td>ByteArrayInputStream</td>
<td>CharArrayReader</td>
</tr>
<tr>
<td>ByteArrayOutputStream</td>
<td>CharArrayWriter</td>
</tr>
<tr>
<td>PipedInputStream</td>
<td>PipedReader</td>
</tr>
<tr>
<td>PipedOutputStream</td>
<td>PipedWriter</td>
</tr>
</tbody>
</table>
<h3 id="更改流的行为"><a href="#更改流的行为" class="headerlink" title="更改流的行为"></a>更改流的行为</h3><p>对于InputStream和OutPutStream来说，我们会使用FilterInputStream和FilterOutputStream的装饰器子类来“修改”流，以满足特殊需要。Reader和Writer的类继承层次结构继续沿用相同的思想——但是并不完全相同<br>下表，相对于前一个表格来说，左右之间的对应关系的近似程度更加粗略一些，造成这种差别的主要原因是因为类的组织形式的不同，：尽管BufferedOutputStream是FilterOutputStream的子类，但是BufferedEriter并不是FilterWriter的子类（尽管FilterWriter是抽象类，但是它没有任何子类，把它放在这里也只是把它作为一个占位符，或仅仅让我们不会对它所在的地方产生疑惑），然而这些类的接口却十分相似</p>
<table>
<thead>
<tr>
<th></th>
<th>过滤器： java 1.0类</th>
<th>相应的 Java 1.1类</th>
</tr>
</thead>
<tbody>
<tr>
<td>FilterInputStream</td>
<td>FilterReader</td>
</tr>
<tr>
<td>FilterOutputStream</td>
<td>FilterWriter(抽象类，没有子类)</td>
</tr>
<tr>
<td>BufferedInputStream</td>
<td>BufferedRaeder(也有readLine())</td>
</tr>
<tr>
<td>BufferdeOutStream</td>
<td>BufferedWriter</td>
</tr>
<tr>
<td>DataInputStream</td>
<td>使用DateInputStream（除了当需要使用readLIne()时以外，这时应该使用BufferReader）</td>
</tr>
<tr>
<td>PrintStream</td>
<td>PrintWriter</td>
</tr>
<tr>
<td>LineNumberInputStream(已弃用)</td>
<td>LineNumberReader</td>
</tr>
<tr>
<td>StreamTokenizer</td>
<td>StreamTokenizer（使用接受Reader的构造器）</td>
</tr>
<tr>
<td>PushBackInputStream</td>
<td>PushBackReader</td>
</tr>
</tbody>
</table>
<p>有一点很清楚，无论何时使用readLine(),都不应该使用DataInputStream(这会遭到编译器的强烈反对)，而应该使用BufferedReader,除了这一点，DataInputStream仍是I/O的首先成员</p>
<p>为了更容易过渡到使用PrintWriter,它提供了既能接受Writer对象又能接受任何OutputStream对象的构造器，PrintWriter的格式化接口实际上与PrintStream相同<br>在java Se5中添加了PrintWriter构造器，以简化在将输出写入时的文件创建过程<br>有一种PrintWriter构造器还有一个选项，就是“自动执行清空”选项，如果构造器设置此选项，即每个println()执行之后，便会自动清空</p>
<h3 id="未发生变化的类"><a href="#未发生变化的类" class="headerlink" title="未发生变化的类"></a>未发生变化的类</h3><p>有一些类在java1.0和java 1.1之间则未做改变</p>
<h2 id="以下这些java1-0类在java1-1中没有相应类"><a href="#以下这些java1-0类在java1-1中没有相应类" class="headerlink" title="|以下这些java1.0类在java1.1中没有相应类|"></a>|以下这些java1.0类在java1.1中没有相应类|</h2><p>|DataOutStream|<br>|File|<br>RandomAccessFile|<br>SequenceInputStream|</p>
<h2 id="自我独立的类：RandomAccessFile"><a href="#自我独立的类：RandomAccessFile" class="headerlink" title="自我独立的类：RandomAccessFile"></a>自我独立的类：RandomAccessFile</h2><p>RandomAccessFile适用于由大小已知的记录组成的文件，所以我们可以使用seek()将记录从一处转移到另一处，然后读取或者修改记录，文件中记录的大小不一定相同，只要我们能够确定那些记录有多大以及它们在文件中的位置即可<br>RandomAccessFile不是InputStream或者OutputStream继承层次结构的一部分，除了实现DataInput和DateOutput（DataInputStream和DataOutputStream也实现了这两个接口）两个接口之外，他和这两个继承层次没什么关联，它甚至不使用InputStream和OutputStream类中已有的功能，它是完全独立的类，从头开始编写其所有的方法（大多是本地方法）这么做是因为RandomAccessFile拥有和别的I/O类型本质的不同的行为，因为我们可以在文件内向前或者向后移动，在任何情况下，它都是自我独立的，直接从Object继承<br>从本质上来说，RandomAccessFile的工作方式类似于把DataInputStream和DataOutputStream组合起来，还添加了一些地方，例如getFilePointer(),seek(),length()，另外，其构造器还接受第二个参数用来指示我们只是“随即读”（r）还是“既读又写”（rw）</p>
<h2 id="I-O流的典型用法"><a href="#I-O流的典型用法" class="headerlink" title="I/O流的典型用法"></a>I/O流的典型用法</h2><h3 id="缓冲输入文件"><a href="#缓冲输入文件" class="headerlink" title="缓冲输入文件"></a>缓冲输入文件</h3><p>如果想要打开一个文件用于字符输入，可以使用以String或File对象作为文件名的FileInputReader，为了提高速度，我们希望对那个文件可以缓冲，那么我们将所产生的引用传给一个BuffredReader构造器，由于BufferedReader也提供readLine()方法，所以这是我们最终的对象和进行读取的接口，当readLine()返回null的时候，你就达到了文件的结尾<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedInputFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">read</span> <span class="params">(String fileName)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        BufferedReader br=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(fileName));</span><br><span class="line">        String s;</span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>((s=br.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            sb.append(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.out.println(read(<span class="string">"BufferedInputFlie.java"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="从内存输入"><a href="#从内存输入" class="headerlink" title="从内存输入"></a>从内存输入</h3><p>下面的示例，从BufferedInputFile.read()读入的String结果被用来创建一个StringReader，然后调用read()每次读取一个字符，并将它发送到控制台<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryInput</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        StringReader in=<span class="keyword">new</span> StringReader(BufferedInputFile.read(<span class="string">"MemoryInput.java"</span>));</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">        <span class="keyword">while</span>((c=in.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>)c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~</span><br></pre></td></tr></table></figure></p>
<h3 id="格式化的内存输入"><a href="#格式化的内存输入" class="headerlink" title="格式化的内存输入"></a>格式化的内存输入</h3><p>要读取格式化数据，可以使用DataInputStream,它是一个面向字节的I/O类（不是面向字符的），因此我们必须使用InputStream类而不是Reader类，当然我们可以用InputStream以字节的形式读取任何数据（例如一个文件），不过，在这里我们使用的是字符串<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FormattedMemoryInput</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DataInputStream in = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">                    <span class="keyword">new</span> ByteArrayInputStream(</span><br><span class="line">                            BufferedInputFile.read(<span class="string">"FormattedMemoryInput.java"</span>).getBytes()</span><br><span class="line">                    ));</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                System.out.println((<span class="keyword">char</span>)in.readByte());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.err.println(<span class="string">"end of stream"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果我们一次一个字节地读取字符，那么任何字节的值都是合法的结果，因此返回值不能用来检测输入是否结束，相反，我们可以使用available()方法查看还有多少个可供存取的字符，下面这个例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEOF</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        DataInputStream in=<span class="keyword">new</span> DataInputStream(</span><br><span class="line">                <span class="keyword">new</span> ByteArrayInputStream(</span><br><span class="line">                        BufferedInputFile.read(<span class="string">"TestEOF.java"</span>).getBytes()</span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">while</span>(in.available()!=<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>) (in.read()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意，available()的工作方式会随着所读取的媒介类型的不同而有所不同</strong>，字面意思就是在没有阻塞的情况下所能读取的字节数，对于文件，这意味着整个文件，但是对于不同的类型的流，可能就不是这样，所以要谨慎使用<br>我们也可以通过捕获异常来检测输入的末尾，就像前一个例子，但是，使用异常进行流控制，被认为是对异常特性的错误使用</p>
<h3 id="基本的文件输出"><a href="#基本的文件输出" class="headerlink" title="基本的文件输出"></a>基本的文件输出</h3><p>FileWriter可以向文件写入数据，首先，创建一个与指定文件连接的FileWriter，通常我们会使用BufferedWriter将其包装起来用以缓冲输出（尝试移除此包装来感受对性能的影响——缓冲往往能够显著地添加I/O操作的性能），在本例，为了提供格式化机制，它被装饰成了PrintWriter，按照这种方式创建的数据文件可作为普通文本文件读取<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicFileOutput</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String file=<span class="string">"BasicFileOutput.out"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        BufferedReader in=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> StringReader(</span><br><span class="line">                <span class="keyword">new</span> BufferedInputFile().read(<span class="string">"BasicFileOutput.java"</span>)</span><br><span class="line">        ));</span><br><span class="line">        PrintWriter out=<span class="keyword">new</span> PrintWriter(</span><br><span class="line">          <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(file))</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">int</span> linecount=<span class="number">1</span>;</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span>((line=in.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            out.print(linecount++ +<span class="string">":"</span>+line);</span><br><span class="line">        &#125;</span><br><span class="line">        out.close();<span class="comment">//关闭流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个例子中当文本写入文件时，行号就会增加，注意并未使用到LineNumberInputStream，因为这个类没有太大帮助，所以我们没必要使用它<br>一旦读完输入数据流，readLine()就会返回null,<strong>我们可以看到要为out显示调用close()，如果我们不为所有的输出文件调用close()，就会发现缓冲区内容不会被刷新清空，那么它们也就不完整</strong></p>
<h4 id="文本文件输出的快捷方式"><a href="#文本文件输出的快捷方式" class="headerlink" title="文本文件输出的快捷方式"></a>文本文件输出的快捷方式</h4><p><strong>Java Se5在PrintWriter中添加了一个辅助构造器，使得你不必在每次希望创建文本文件并向其中写入时，都要执行后面所有的装饰工作</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PrintWriter out=<span class="keyword">new</span> PrintWriter(String fileName)</span><br></pre></td></tr></table></figure></p>
<p>你仍然使用了缓冲，只是你不必自己去实现，遗憾的是，其他常见的写入任务都没有这样的快捷方式，但是我们可以创建工具类来使得使用流变得更为简单</p>
<h3 id="存储和恢复数据"><a href="#存储和恢复数据" class="headerlink" title="存储和恢复数据"></a>存储和恢复数据</h3><p>PrintWriter可以对数据进行格式化，以便人们的阅读，但是为了输出可供另一个“流”恢复的数据，我们需要用到DataOutputStream写入数据和DataInputStream恢复数据，当然，这些流可以是任何形式，注意DataOutoutStream和DataInputStream是面向字节的，因此要使用InputStream和OutputStream<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StoringAndRecoveringData</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        DataOutputStream out=<span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> BufferedOutputStream(</span><br><span class="line">                <span class="keyword">new</span> FileOutputStream(<span class="string">"Data.txt"</span>)</span><br><span class="line">        ));</span><br><span class="line">        out.writeDouble(<span class="number">3.14159</span>);</span><br><span class="line">        out.writeUTF(<span class="string">"this is a Pi"</span>);</span><br><span class="line">        out.writeDouble(<span class="number">1.41413</span>);</span><br><span class="line">        out.writeUTF(<span class="string">"Square of pi"</span>);</span><br><span class="line">        out.close();</span><br><span class="line">        DataInputStream in=<span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                <span class="keyword">new</span> FileInputStream(<span class="string">"Data.txt"</span>)</span><br><span class="line">        ));</span><br><span class="line">        System.out.println(in.readDouble());</span><br><span class="line">        System.out.println(in.readUTF());</span><br><span class="line">        System.out.println(in.readDouble());</span><br><span class="line">        System.out.println(in.readUTF());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>如果我们使用DataOutputStream写入数据，Java保证我们可以使用DataInputStream准确地读取数据——无论读和写数据的平台多么不同</strong>这是有价值的，人们曾加花费大量的精力处理特定平台的数据问题，只要两个平台上都有Java，这个问题就不会再发生<br>当我们使用DataOutputStream时，写字符串并且让DataInputStream能够恢复它的唯一可靠的做法就是使用UTF-8编码，在上面的示例中是通过writeUTF()和readUTF()实现的，UTF-8是一种多字节格式，其编码长度更加实际使用的字符集会有所变化，UTF-8将ASCII字符编码成单一字节的形式，而非ASCII字符则编码成两个或三个字节，例如汉字字符，另外字符串的长度存储在UTF-8字符串的前两个字节中（所有也就能知道字符串最长能够保存的字符长度了），但是，writeUTF()和readUTF()使用的是适合于Java的变体，因此我们用一个非java的程序取用writeUTF()所写的字符串时，必须编写一些特殊代码才能正确读取字符串<br>有了DataOutputStream的各种write()方法，我们就可以将字符串和其他数据类型混合，并且可以很容易地使用DataInputStream来恢复它<br>但是为了保证所有的读方法都能够正常工作，我们必须知道流中数据所在的位置和类型，因为极有可能将保存的double数据当成char或者其他类型读取，这会产生问题，有两个解决办法</p>
<ol>
<li>为文件中的数据采用固定的格式，这种方式我们就能够确定每个位置上的数据类型是什么了</li>
<li>将数据的信息保存在文件中，以便能够对其进行解析以确定数据的存放位置<br>但是，对象化和XML可能是最容易存储和读取复杂数据结构的方式<h3 id="读写随机访问文件"><a href="#读写随机访问文件" class="headerlink" title="读写随机访问文件"></a>读写随机访问文件</h3>使用RandomAccessFile，类似组合使用了DataInputStream和DataOutStream(因为它实现了相同的接口：DataInput和DataOutput),并且我们还可以看到使用seek()可以在文件中到处移动，并修改文件中的某个值<br>在使用RandomAccessFile时，你必须知道文件的排版，这样才能正确地操作它，RandomAccessFile拥有读取基本类型和UTF-8字符串的各自具体方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingRandomAccessFile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String file=<span class="string">"rtest.txt"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        RandomAccessFile rf=<span class="keyword">new</span> RandomAccessFile(file,<span class="string">"r"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Value"</span>+i+<span class="string">":"</span>+rf.readDouble());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(rf.readUTF());</span><br><span class="line">        rf.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        RandomAccessFile rf=<span class="keyword">new</span> RandomAccessFile(file,<span class="string">"rw"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">            rf.writeDouble(i*<span class="number">1.414</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        rf.writeUTF(<span class="string">"end of the file"</span>);</span><br><span class="line">        rf.close();</span><br><span class="line">        display();</span><br><span class="line">        rf=<span class="keyword">new</span> RandomAccessFile(file,<span class="string">"w"</span>);</span><br><span class="line">        rf.seek(<span class="number">5</span>*<span class="number">8</span>);</span><br><span class="line">        rf.writeDouble(<span class="number">47.00001</span>);</span><br><span class="line">        rf.close();</span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="管道流"><a href="#管道流" class="headerlink" title="管道流"></a>管道流</h3><p>PipedInputStream,PipedOutputStream,PipedReader和PipedWriter管道流，它们的价值主要用于任务之间的通信</p>
<h2 id="文件读写的工具"><a href="#文件读写的工具" class="headerlink" title="文件读写的工具"></a>文件读写的工具</h2><p>一个很常见的程序化任务就是读取文件到内存，修改，然后再写出，Java I/O类库的问题之一就是：它需要编写相当多的代码去执行这些常用的操作——没有任何基本的帮助功能可以为我们做这一切，更糟糕的是，装饰器会使得要记住如何打开文件变成意见相当困难的事，因此，在我们的类库中添加帮助类就显得相当有意义，这样就很容易地为我们完成这些基本任务，Java Se5在PrintWriter中添加了方便的构造器，因此你可以很方便地打来一个文件进行写入操作，但是，还有很多其他的常见操作是你需要反复执行的，这就使得消除与这些任务相关联的重复代码就显得很有意义<br>我们看下面的一个示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextFile</span> <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">read</span><span class="params">(String fileName)</span></span>&#123;</span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BufferedReader br = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                    <span class="keyword">new</span> FileReader(fileName)</span><br><span class="line">            );</span><br><span class="line">           <span class="keyword">try</span>&#123;</span><br><span class="line">               String s;</span><br><span class="line">               <span class="keyword">while</span>((s=br.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                   sb.append(s);</span><br><span class="line">                   sb.append(<span class="string">"\n"</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">               br.close();</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String fileName,String text)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> File(fileName).getAbsoluteFile());</span><br><span class="line">            out.write(text);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TextFile</span><span class="params">(String fileName,String splitter)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(Arrays.asList(read(fileName).split(splitter)));</span><br><span class="line">        <span class="comment">//正则表达式 split()经常产生一个空字符在第一个位置</span></span><br><span class="line">        <span class="keyword">if</span>(get(<span class="number">0</span>)==<span class="string">""</span>)</span><br><span class="line">            remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TextFile</span><span class="params">(String fileName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(fileName,<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">write</span><span class="params">(String fileName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> File(fileName).getAbsoluteFile());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (String item : <span class="keyword">this</span>) &#123;</span><br><span class="line">                    out.print(item);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                out.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	        String file=read(<span class="string">"TextFile.java"</span>);</span><br><span class="line">	        write(<span class="string">"test.txt"</span>,file);</span><br><span class="line">	        TextFile text=<span class="keyword">new</span> TextFile(<span class="string">"test.txt"</span>);</span><br><span class="line">	        text.write(<span class="string">"text2.txt"</span>);</span><br><span class="line">	        TreeSet&lt;String&gt; words=<span class="keyword">new</span> TreeSet&lt;String&gt;(<span class="keyword">new</span> TextFile(<span class="string">"TextFile.java"</span>,<span class="string">"\n"</span>));</span><br><span class="line">	        System.out.println(words.headSet(<span class="string">"a"</span>));</span><br><span class="line">	  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="读取二进制文件"><a href="#读取二进制文件" class="headerlink" title="读取二进制文件"></a>读取二进制文件</h3><p>这个工具与TextFile类似，因为它简化了读取二进制文件的过程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryFile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] read(File file)<span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        BufferedInputStream in=<span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                <span class="keyword">new</span> FileInputStream(file)</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[in.available()];</span><br><span class="line">            in.read(data);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            in.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] read(String file)<span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> read(<span class="keyword">new</span> File(file));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="标准I-O"><a href="#标准I-O" class="headerlink" title="标准I/O"></a>标准I/O</h2><p>标准I/O这个术语参考的是Unix中“程序所使用的单一信息流”这个概念（在window及其他的操作系统中，也有相似形式的实现）程序的所有输入都可以来自于与标准输入，它的所有输出也可以发送到标准输出，以及所有的错误信息都可以发送到标准错误，<strong>标准I/O的意义在于：我们可以很容易地把程序串联起来，一个程序的标准输出可以成为另一个程序的标准输入</strong></p>
<h3 id="从标准输入中读取"><a href="#从标准输入中读取" class="headerlink" title="从标准输入中读取"></a>从标准输入中读取</h3><p>按照标准I/O模型，java提供了System.io,System.out.System.err,其中System.out，System.err已经事先被包装成PrintStream对象，System.in却是一个未经加工的InputStream,这意味尽管可以立即使用System.out和System.err，但是在读取System.in之前必须对其包装<br>通常我们会使用readLine()一次一行地读取输入，为此，我们将System.in包装成BufferedReader,这里需要使用InputStreamReader把System.in转换成Reader（适配器模式），下面的例子会直接回显你输入的每一行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Echo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        InputStreamReader inr=<span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line">        BufferedReader br=<span class="keyword">new</span> BufferedReader(inr);</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span>((s=br.readLine())!=<span class="keyword">null</span> &amp;&amp; s.length()!=<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//ctrl+z终止程序运行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="将System-out转换成PrintWriter"><a href="#将System-out转换成PrintWriter" class="headerlink" title="将System.out转换成PrintWriter"></a>将System.out转换成PrintWriter</h3><p>System.out是一个PrintStrem，而PrintStream是一个OutputStream，而PrintWriter可以接受一个OutputStream作为参数的构造器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeSystemOut</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        PrintWriter out =<span class="keyword">new</span> PrintWriter(System.out,<span class="keyword">true</span>);</span><br><span class="line">        out.println(<span class="string">"hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>重要的是构造器的第二个参数，将其设置成true，以便开启自动清空功能，否则，你可能看不到输出</p>
<h3 id="标准I-O的重定向"><a href="#标准I-O的重定向" class="headerlink" title="标准I/O的重定向"></a>标准I/O的重定向</h3><p><strong>java的System类提供了一些简单的静态方法调用，以允许我们对标准输入，输出，和错误I/O流进行重定向</strong><br>setIn(InputStream)<br>setOut(PrintStream)<br>setErr(printStream)<br>（使用场景之一）如果我们突然开始在显示器上创建大量输出，而这些输出滚动的太快以至于无法阅读时，重定向输出就显得极为有用，对于我们向重复测试某个特定用户的输入序列的命令行程序来说重定向输入就很有价值，下面演示了这个方法的使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Redirecting</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        PrintStream console=System.out;</span><br><span class="line">        BufferedInputStream in=<span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"Redirecting.java"</span>));</span><br><span class="line">        PrintStream out=<span class="keyword">new</span> PrintStream(<span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"test.out"</span>)));</span><br><span class="line">        System.setIn(in);</span><br><span class="line">        System.setOut(out);</span><br><span class="line">        System.setErr(out);</span><br><span class="line">        BufferedReader br= <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));<span class="comment">//这里就是上面的in变量</span></span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span>((s=br.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(s);<span class="comment">//将数据写入标准输出，标准输出已经被重新设置过了</span></span><br><span class="line">        &#125;</span><br><span class="line">        out.close();</span><br><span class="line">        System.setOut(console);<span class="comment">//在将原来的标准输出改回来</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的程序很有意思，首先我们先将原来的标准输出的引用用一个引用保存起来留待后面重新设置回来，System的标准输入输出的set方法可以改变成员原来的流，我们从这里也能看到一些事情，标准输入输出在java类库中的设计主要是为了和操作系统进行交互的（我的理解）</p>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>你经常会需要在java内部执行操作系统上的其他程序，并且要控制这些程序的输入和输出，Java类库提供了执行这些操作的类<br>一项常见的任务是运行程序，并将产生的输出发送到控制台<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OSExcuteException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OSExcuteException</span><span class="params">(String why)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(why);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OSExecute</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">command</span><span class="params">(String command)</span><span class="keyword">throws</span> OSExcuteException</span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> err=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Process process=<span class="keyword">new</span> ProcessBuilder(command.split(<span class="string">" "</span>)).start();</span><br><span class="line">            BufferedReader result=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(process.getOutputStream()));</span><br><span class="line">            String s;</span><br><span class="line">            <span class="keyword">while</span>((s=result.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">            BufferedReader errors=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(process.getErrorStream()));</span><br><span class="line">            <span class="keyword">while</span> ((s=errors.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">                err=<span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!command.startsWith(<span class="string">"CMD /C"</span>))&#123;</span><br><span class="line">                command(<span class="string">"CMD /C"</span>+command);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OSExcuteException(<span class="string">"Errors excuting:"</span>+command);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">~~~为了捕获程序执行时产生的标准输出流，你需要调用getOutputStream()，这是因为InputStream是我们可以从中读取信息的流</span><br><span class="line">~~~java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OsExecuteDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            OSExecute.command(<span class="string">"javap OsExecuteDemo"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="新I-O"><a href="#新I-O" class="headerlink" title="新I/O"></a>新I/O</h2><p>JDK1.4的java.nio.*包中引入了新的java I/O类库，其目的是为了提高速度，实际上，旧的I/O包已经使用nio重新实现过，以便充分利用这种速度提高，因此，即使我们不显式地使用nio编写代码，也能从中收益，速度的提高在文件I/O和网络I/O中都可能发生，我们这里只研究前者<br>速度的提高来自于所使用的结构更接近于操作系统执行I/O的方式，通道和缓冲器，<strong>我们可以把它们想像成一个“煤矿”，通道是一个包含数据（煤层）的矿藏，而缓冲器则是派送到矿藏的卡车</strong>，卡车载满煤炭而归，我们再从卡车上获取煤炭<strong>，也就是说，我们并没有直接和通道交互，我们只和缓冲器交互</strong>，并把缓冲区派送到通道，通道要么从缓冲器获取数据，要么向缓冲器发送数据<br><strong>唯一直接与通道打交道的缓冲区是ByteBuffer</strong>,也就是说，可以存储未加工字节的缓冲器，当我们查询JDK文档中的java.nio.ByteBuffer时，<strong>会发现它是相当基础的类，通过告知分配多少存储空间来创建一个ByteBuffer对象，并且还有一个方法选择集，用于以原始的自己形式或基本数据类型输出和读取数据，但是没有办法输出或读取对象，即使是字符串也不行</strong>，这种处理当然很低级，但是，因为这是大多数操作系统中更有效的映射<br>旧I/O类库中有三个类被修改了，用以产生FileChannel，这三个类便是FileOutputStream，FileInputStrea,RandomAccessFile，注意这些是字节操纵流，与底层的nio一致，Reader和Writer这种字符模式不能用以产生通道，但是java.io.channels,Channels类提供了实用方法，用以在通道中产生Reader和Writer<br>下面的代码演示了使用FileChannel和ByteBuffer的方式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetChannel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BSIZE=<span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        FileChannel fc=<span class="keyword">new</span> FileOutputStream(<span class="string">"data.txt"</span>).getChannel();</span><br><span class="line">        fc.write(ByteBuffer.wrap(<span class="string">"Somen text"</span>.getBytes()));</span><br><span class="line">        fc.close();</span><br><span class="line"></span><br><span class="line">        fc=<span class="keyword">new</span> RandomAccessFile(<span class="string">"data.txt"</span>,<span class="string">"rw"</span>).getChannel();</span><br><span class="line">        fc.position(fc.size());<span class="comment">//move to the end</span></span><br><span class="line">        fc.write(ByteBuffer.wrap(<span class="string">"Some more"</span>.getBytes()));</span><br><span class="line">        fc.close();</span><br><span class="line">        fc=<span class="keyword">new</span> FileInputStream(<span class="string">"data.txt"</span>).getChannel();</span><br><span class="line">        ByteBuffer bf=ByteBuffer.allocate(BSIZE);</span><br><span class="line">        fc.read(bf);</span><br><span class="line">        bf.flip();</span><br><span class="line">        <span class="keyword">while</span>(bf.hasRemaining())&#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>) bf.get());<span class="comment">//从ByteBuffer每次只读取一个字节</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>getChannel()产生一个FileChannel，可以向它传送一个用于读写的ByteBuffer<br>将数据存放于ByteBuffer的方法之一是，使用一种“put”方法直接对它们进行填充，填入一个或多个字节，或基本数据类型的值，不过，也可以向上面的例子中那样使用wrap()方法将已存在的字节数组“包装”到ByteBuffer,但如此，就不在复制底层的数组，而是把它作为所产生的ByteBuffer的存储器，我们称之为数组支持的ByteBuffer<br>allocate()是为ByteBuffer分配空间的，可以使用allocationDirect()以产生一个与操作系统更高耦合的“直接”缓冲器，但是，这种分配开销更大，并且其具体实现也随着操作系统的不同而不同，因此我们可以看看程序实际运行时获得直接缓冲器是否可以使我们在速度上获得优势<br><strong>一旦调用了read()来告知FileChannel向ByteBuffer存储字节，就必须调用缓冲器上的flip(),让缓冲器做好让别人读取字节的准备</strong>，如果我们打算使用缓冲器执行进一步的操作，我们也必须调用clear()来为每一个read()做好准备，下面是这些注意要点的示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelCopy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BSIZE=<span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args.length!=<span class="number">2</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"arguments i:sourcefile,destfile"</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        FileChannel in=<span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]).getChannel(),</span><br><span class="line">                    out=<span class="keyword">new</span> FileOutputStream(args[<span class="number">1</span>]).getChannel();</span><br><span class="line">        ByteBuffer buf=ByteBuffer.allocate(BSIZE);</span><br><span class="line">        <span class="keyword">while</span>(in.read(buf)!=-<span class="number">1</span>)&#123;</span><br><span class="line">            buf.flip();<span class="comment">//prepare for writing</span></span><br><span class="line">            out.write(buf);</span><br><span class="line">            buf.clear();<span class="comment">//prepare to reading</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的代码中可以看到，但FileChannel.read()返回“-1”的时候，表示我们已经达到了输入的末尾，每次read()操作之后，就会将数据输入到缓冲器中，flip()则是准备缓冲器以便它的信息可以由write()提取，write()操作之后，信息仍在缓冲器中，接着clear()操作则对所有的内部指针重新安排，以便缓冲器在另一个read()操作期间能够做好接收数据的准备<br>然而上面的那个程序并不是处理此类操作的理想方式，特殊的方法transferTo()和transferFrom()则允许我们将一个通道和另一个通道直接相连，看下面的简单示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferTo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args.length!=<span class="number">2</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"arguments i:sourcefile,destfile"</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        FileChannel in= <span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]).getChannel(),</span><br><span class="line">                out=<span class="keyword">new</span> FileOutputStream(args[<span class="number">1</span>]).getChannel();</span><br><span class="line">        in.transferTo(<span class="number">0</span>,in.size(),out);</span><br><span class="line">        <span class="comment">//or out.transferFrom(in,0，in.size());</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="转换数据"><a href="#转换数据" class="headerlink" title="转换数据"></a>转换数据</h3><p>回过头来看到GetChannel的程序就会发现，为了输出文件的信息，我们必须每次只读取一个字节的数据，然后将每个Byte类型强制转换成char类型，这种方式太过原始了——我们查看java.nio。CharBuffer这个类，将会发现它有一个toString（）方法时这样定义的“返回一个包含缓冲器中所有字符的字符串”，既然ByteBuffer可以看做是具有asCharBuffer()方法的CharBuffer，那么为什么不用它呢？看下面这个例子，如输出语句的第一行所见，这种方式并不能解决问题<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferToText</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  BSIZE=<span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        FileChannel fc=<span class="keyword">new</span> FileOutputStream(<span class="string">"data2.text"</span>).getChannel();</span><br><span class="line">        fc.write(ByteBuffer.wrap(<span class="string">"some text"</span>.getBytes()));</span><br><span class="line">        fc.close();</span><br><span class="line">        fc=<span class="keyword">new</span> FileInputStream(<span class="string">"data2.text"</span>).getChannel();</span><br><span class="line">        ByteBuffer buff=ByteBuffer.allocate(BSIZE);</span><br><span class="line">        fc.read(buff);</span><br><span class="line">        buff.flip();</span><br><span class="line">        <span class="comment">//doesn't work</span></span><br><span class="line">        System.out.println(buff.asCharBuffer());</span><br><span class="line">        <span class="comment">//decode using this.system default charset</span></span><br><span class="line">        buff.rewind();<span class="comment">//</span></span><br><span class="line">        String encoding=System.getProperty(<span class="string">"file.encoding"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Decoded using"</span>+encoding+ Charset.forName(encoding).decode(buff));</span><br><span class="line">        <span class="comment">//or wo could encode with something that will print</span></span><br><span class="line">        fc=<span class="keyword">new</span> FileOutputStream(<span class="string">"data2.text"</span>).getChannel();</span><br><span class="line">        fc.write(ByteBuffer.wrap(<span class="string">"Some text"</span>.getBytes(<span class="string">"UTF-16BE"</span>)));</span><br><span class="line">        fc.close();</span><br><span class="line">        <span class="comment">//now try read again</span></span><br><span class="line">        fc=<span class="keyword">new</span> FileInputStream(<span class="string">"data2.text"</span>).getChannel();</span><br><span class="line">        buff.clear();</span><br><span class="line">        fc.read(buff);</span><br><span class="line">        buff.flip();</span><br><span class="line">        System.out.println(buff.asCharBuffer());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ues a CharBuffer  to write through</span></span><br><span class="line">        fc=<span class="keyword">new</span> FileOutputStream(<span class="string">"data2.text"</span>).getChannel();</span><br><span class="line">        buff=ByteBuffer.allocate(<span class="number">24</span>);<span class="comment">//more than needed</span></span><br><span class="line">        buff.asCharBuffer().put(<span class="string">"some text"</span>);</span><br><span class="line">        fc.write(buff);</span><br><span class="line">        fc.close();</span><br><span class="line">        <span class="comment">//read an display</span></span><br><span class="line">        fc=<span class="keyword">new</span> FileInputStream(<span class="string">"data.text"</span>).getChannel();</span><br><span class="line">        buff.clear();</span><br><span class="line">        fc.read(buff);</span><br><span class="line">        buff.flip();</span><br><span class="line">        System.out.println(buff.asCharBuffer());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>缓冲器容纳的是普通的字节，为了把它们转换成字符，我们要么在输入它们的时候对其进行编码（这样，它们的输出才具有意义），要么在将其从缓冲器输出时对它们进行解码，可以使用java.nio.charset.Charset类实现这些功能，该类提供了把数据编码成各种不同类型的字符集的工具<br>如果我们想要对缓冲器调用rewind()方法（调用这个方法是为了返回数据开始的地方），接着使用平台的默认字符集对数据进行decode()，那么作为结果的CharBuffer可以很好地输出打印到控制台，可以使用System.getProperty(“file.encoding”)发现默认字符集，它会产生代表字符集名称的字符串，把该字符串传送给Charset.forName()用以产生Charset对象，可以用它对字符串进行解码<br>另一个选择是在读该文件的时候，使用能够产生可打印的输出的字符集进行encode()，正如在BufferToText.java中看到的那样，这里，UTF-16BE可以把文本写进文件中，当读取时，我们只需把它转换成CharBuffer，就会产生所期望的文本、<br>最后，让我们看看若是通过CharBuffer向ByteBugffer写入，会发生什么情况，注意我们为ByteBuffer分配了24个字节，既然一个字符需要两个字节，那么一个ByteBuffer足可以容纳12个字符，，但是“some text”只要9个字符，剩余的内容为零的字节仍然由它的tString()所产生的CharBuffer的表示中<br>这样来理解，当我们将数据转换为Byte数组的时候，我们实际上是将这些字符串通过系统默认的方式来进行解码的，当然我们再拿到这些数据的时候，也要以相应的字符集来解码才能得到正确的结果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AvailableCharSets</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SortedMap&lt;String,Charset&gt; charSets=Charset.availableCharsets();</span><br><span class="line">        Iterator&lt;String&gt; it=charSets.keySet().iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            String csName=it.next();</span><br><span class="line">            System.out.print(csName);</span><br><span class="line">            Iterator aliases=charSets.get(csName).aliases().iterator();</span><br><span class="line">            <span class="keyword">if</span>(aliases.hasNext())&#123;</span><br><span class="line">                System.out.print(<span class="string">":"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(aliases.hasNext())&#123;</span><br><span class="line">                System.out.print(aliases.next());<span class="comment">//在这里也说明了迭代器的指针只有在next()方法调用之后才会发生变化</span></span><br><span class="line">                <span class="keyword">if</span>(aliases.hasNext())&#123;</span><br><span class="line">                    System.out.print(<span class="string">", "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码输出的就是java支持的字符集有哪些，关键的代码是Charset.availableCharsets()方法，返回一个Map&lt;String,Charset&gt;关联数组;</p>
<h3 id="获取基本类型"><a href="#获取基本类型" class="headerlink" title="获取基本类型"></a>获取基本类型</h3><p>虽然ByteBuffer只能保存字节类型的数据，但是它具有可以从其所容纳的字节中产生出不同的基本类型值的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BSIZE=<span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ByteBuffer bb=ByteBuffer.allocate(BSIZE);</span><br><span class="line">        <span class="comment">//allocation automatically zeroes the ByteBuffer;</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i++&lt;bb.limit())&#123;</span><br><span class="line">            <span class="keyword">if</span>(bb.get()!=<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.print(<span class="string">"nozero"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">"i="</span>+i);</span><br><span class="line">        bb.rewind();</span><br><span class="line">        <span class="comment">//store and read char array</span></span><br><span class="line">        bb.asCharBuffer().put(<span class="string">"howdy"</span>);</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="keyword">while</span>((c= bb.getChar())!=<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.print(c+<span class="string">"  "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        bb.rewind();</span><br><span class="line">        <span class="comment">//store and read a short</span></span><br><span class="line">        bb.asShortBuffer().put((<span class="keyword">short</span>)<span class="number">41411</span>);</span><br><span class="line">        System.out.print(bb.getShort());</span><br><span class="line">        bb.rewind();</span><br><span class="line">        <span class="comment">//store and read a int;</span></span><br><span class="line">        bb.asIntBuffer().put(<span class="number">193972342</span>);</span><br><span class="line">        System.out.print(bb.getInt());</span><br><span class="line">        <span class="comment">//.......................</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在分配一个ByteBuffer之后，可以通过检测它的值来查看缓冲器的分配方式是否将其内容自动清零——它确实是这样做了<br><strong>向缓冲器插入基本类型数据的最简单的方法是：利用asCharBuffer()，asShortBuffer()等获得该缓冲器的一个视图</strong>，然后利用试图的put()方法，取出数据是调用相应的get()方法即可</p>
<h3 id="视图缓冲器"><a href="#视图缓冲器" class="headerlink" title="视图缓冲器"></a>视图缓冲器</h3><p><strong>视图缓冲器（view buffer）可以让我们通过某个特定的基本数据类型的视窗查看其底层的ByteBuffer,ByteBuffer依然是实际存储数据的地方</strong>，对视图的修改都会映射成为对ByteBuffer中数据的修改，这使得我们可以很方便地向ByteBuffer插入数据，试图还允许我们从ByteBuffer一次一个地（与ByteBuffer所支持的方法相同）或者成批地（放入数组中）读取基本类型值，下面这个例子，通过IntBuffer操作ByteBuffer中的int型视图<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntBufferDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BSIZE=<span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ByteBuffer bb= ByteBuffer.allocate(BSIZE);</span><br><span class="line">        IntBuffer ib=bb.asIntBuffer();</span><br><span class="line">        ib.put(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">11</span>,<span class="number">42</span>,<span class="number">33</span>,<span class="number">45</span>,<span class="number">25</span>,<span class="number">24</span>,<span class="number">4354</span>,<span class="number">34</span>&#125;);</span><br><span class="line">        <span class="comment">//absolute location read and write</span></span><br><span class="line">        System.out.print(ib.get(<span class="number">3</span>));</span><br><span class="line">        ib.put(<span class="number">3</span>,<span class="number">1811</span>);</span><br><span class="line">        ib.flip();</span><br><span class="line">        <span class="keyword">while</span>(ib.hasRemaining())&#123;</span><br><span class="line">            <span class="keyword">int</span> i=ib.get();</span><br><span class="line">            System.out.print(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一旦底层的ByteBuffer通过视图缓冲器填满了整数或者其他的基本类型时，就可以直接被写到通道中了，正像从通道中读取那样容易，然后使用视图缓冲器可以把任何数据都转换成某一特定的基本类型，下面的例子，通过在同一个ByteBuffer上建立不同的视图缓冲器，将同一字节序列翻译成了short,int,float和double类型的数据<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewBuffer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ByteBuffer bb= ByteBuffer.wrap(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="string">'a'</span>&#125;);</span><br><span class="line">        bb.rewind();</span><br><span class="line">        System.out.print(<span class="string">"Byte buffer"</span>);</span><br><span class="line">        <span class="keyword">while</span>(bb.hasRemaining())&#123;</span><br><span class="line">            System.out.print(bb.position()+<span class="string">"-&gt;"</span>+bb.get());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        CharBuffer cb=((ByteBuffer)(bb.rewind())).asCharBuffer();</span><br><span class="line">        System.out.print(<span class="string">"Char Buffer"</span>);</span><br><span class="line">        <span class="keyword">while</span>(cb.hasRemaining())&#123;</span><br><span class="line">            System.out.print(cb.position()+<span class="string">"-&gt;"</span>+cb.get());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//...................</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>###$ 字节存放次序 ####<br>不同的机器可能会使得不同的字节排序方法来存储数据，“big endian”(高位优先)将最重要的字节存放在地址最低的存储单元，而“little endian”（低位优先），则是将最重要的字节放在地址最高的存储器单元，当存储量大于1个字节的时候，就要考虑字节的顺序问题了，ByteBuffer是以高位优先的形式存储数据的，并且数据在网上传送时也常常使用高位优先的形式，我们也可以使用ByteOrder.GIG_ENDISN或ByteOrder.LITTLE_EBDIAN的order()方法改变ByteBuffer的字节排序方式</p>
<h3 id="用缓冲器操纵数据"><a href="#用缓冲器操纵数据" class="headerlink" title="用缓冲器操纵数据"></a>用缓冲器操纵数据</h3><p>我们怎么把字节数组写到文件中去的呢？我们可以使用ByteBuffer.warp()方法将数组包装起来，然后用getChannel方法在fileOutputStream上打开一个通道，接着将来自于ByteBuffer的数据写到FileChannel中<br>注意，<strong>ByteBuffer是将数据移进移出的唯一方式</strong>，并且我们只能创建一个独立的基本类型缓冲器，或者使用“as”方法从ByteBuffer中获得，也就是说，我们不能把基本类型的缓冲器转换为ByteBuffer，然而，由于我们可以经由视图缓冲器将基本类型数据移进移出ByteBuffer，所以这也不是什么真正的限制了</p>
<h3 id="缓冲器的细节"><a href="#缓冲器的细节" class="headerlink" title="缓冲器的细节"></a>缓冲器的细节</h3><p>**Buffer由数据和可以高效地访问及操纵这些数据的四个索引组成，这四个索引是：mark(标记)，position（位置），limit（界限）和capacity（容量），下面是用于设置和复位索引以及查询它们值的方法</p>
<table>
<thead>
<tr>
<th></th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>capacity()</td>
<td>返回缓冲区容量</td>
</tr>
<tr>
<td>clear()</td>
<td>清空缓冲区，将position设为0，limit设置为容量，我们可以调用此方法复写缓冲区</td>
</tr>
<tr>
<td>flip()</td>
<td>将limit设置诶position，position设置为0，此方法用于准备从缓冲区读写已经写入的数据</td>
</tr>
<tr>
<td>limit()</td>
<td>返回limit的值</td>
</tr>
<tr>
<td>limit(int lim)</td>
<td>设置limit的值</td>
</tr>
<tr>
<td>mark()</td>
<td>将mark设置为position</td>
</tr>
<tr>
<td>position()</td>
<td>返回position的值</td>
</tr>
<tr>
<td>position(int pos)</td>
<td>设置position</td>
</tr>
<tr>
<td>ramaining()</td>
<td>返回（limit-position）</td>
</tr>
<tr>
<td>hasRemaining()</td>
<td>若有介于position和limit之间的元素，则返回true</td>
</tr>
</tbody>
</table>
<p>在缓冲器中插入和提取数据的方法会更新这些索引，用于反映所发生的变化<br>下面的示例用了一个很简单的算法（交换相邻字符），以对CharBuffer中的字符进行编码(scramble)和译码(unscramble)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingBuffers</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">symmetricScramble</span><span class="params">(CharBuffer buff)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(buff.hasRemaining())&#123;</span><br><span class="line">            <span class="keyword">char</span> c1=buff.get();</span><br><span class="line">            <span class="keyword">char</span> c2=buff.get();</span><br><span class="line">            buff.reset();</span><br><span class="line">            buff.put(c2).put(c1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] data=<span class="string">"UsingBuffers"</span>.toCharArray();</span><br><span class="line">        ByteBuffer bb=ByteBuffer.allocate(data.length*<span class="number">2</span>);</span><br><span class="line">        CharBuffer cb=bb.asCharBuffer();</span><br><span class="line">        cb.put(data);</span><br><span class="line">        System.out.print(cb.rewind());</span><br><span class="line">        symmetricScramble(cb);</span><br><span class="line">        System.out.print(cb.rewind());</span><br><span class="line">        symmetricScramble(cb);</span><br><span class="line">        System.out.print(cb.rewind());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果了解到Buffer类（ByteBuffer,CharBuffer等）的内存及索引控制机制，那么对于Buffer类的读写问题变的很简单，首先当我们创建Buffer类时，pos指针为0，lim指针和cap指针指向最后一个元素，<strong>进行相对的get()和put()方法调用是，pos指针会发生变化，注意，如果调用绝对的get()和put()方法pos指针不会发生变化</strong>，当我们开始循环迭代的时候，mar指针会记下当前的pos指针所在的位置，这个mar本来就是作为标记存在的，<strong>当调用reset()方法的时候，pos将会改变为mar的值</strong>，还有一点需要注意的是，<strong>如果打印缓冲器，只能打印limit和position之间的内容，因此如果要显示缓冲器的全部内容，必须使用rewind()把position设置成缓冲器开始位置</strong></p>
<h3 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h3><p>内存映射文件允许我们创建和修改那些因为太大而不能放入内存的文件，有了内存映射文件，我们就可以假定整个文件都放在了内存中，而且可以完全把它当作非常大的数组来访问，这种方法极大地简化了用于修改文件的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LargeMeppedFiles</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> length=<span class="number">0x8FFFFFF</span>;<span class="comment">//128M</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        MappedByteBuffer out=<span class="keyword">new</span> RandomAccessFile(<span class="string">"test.dat"</span>,<span class="string">"rw"</span>).getChannel().map(</span><br><span class="line">                FileChannel.MapMode.READ_WRITE,<span class="number">0</span>,length</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            out.put((<span class="keyword">byte</span>)<span class="string">'x'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Finished writing"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=length/<span class="number">2</span>;i&lt;length/<span class="number">2</span>+<span class="number">6</span>;i++)&#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>)out.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们通过通道调用map()产生MappedByteBuffer,这是一种特殊类型的直接缓冲器，<strong>注意，我们必须指定映射文件最初的位置和映射区域的长度，这意味着我们可以映射某个大文件的较小部分</strong><br>MppedByteBuffer由ByteBuffer继承而来，因此它具有ByteBuffer的所有方法，这里我们仅仅展示了简单的get()和set()方法，但是我们同样可以是asCharBuffer()等这样的方法</p>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>尽管“旧”的I/O流在用nio实现后性能有所提高，但是“映射文件访问”往往可以更加显著地加快速度<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MappedIO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> numofInts=<span class="number">4000000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> numofubuffInts=<span class="number">2000000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Tester</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Tester</span><span class="params">(String name)</span></span>&#123;name=name;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(name+<span class="string">":"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> start=System.nanoTime();</span><br><span class="line">                test();</span><br><span class="line">                <span class="keyword">long</span> end=System.nanoTime();</span><br><span class="line">                System.out.format(<span class="string">"%.2f\n"</span>,(end-start)/<span class="number">1.0e9</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span><span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//测试组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Tester[] tests=&#123;</span><br><span class="line">      <span class="keyword">new</span> Tester(<span class="string">"Stream Write"</span>)&#123;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">              DataOutputStream dos=<span class="keyword">new</span> DataOutputStream(</span><br><span class="line">                <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(</span><br><span class="line">                        <span class="keyword">new</span> File(<span class="string">"temp.tmp"</span>)</span><br><span class="line">                ))</span><br><span class="line">              );</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; ,</span><br><span class="line">      <span class="keyword">new</span> Tester(<span class="string">"Mapped write"</span>)&#123;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">              FileChannel fc=<span class="keyword">new</span> RandomAccessFile(<span class="string">"temp.tmp"</span>,<span class="string">"rw"</span>).getChannel();</span><br><span class="line">              IntBuffer buff=fc.map(FileChannel.MapMode.READ_WRITE,<span class="number">0</span>,numofInts).asIntBuffer();</span><br><span class="line">              <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numofInts;i++)&#123;</span><br><span class="line">                  buff.put(i);</span><br><span class="line">              &#125;</span><br><span class="line">              fc.close();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; ,</span><br><span class="line">      <span class="keyword">new</span> Tester(<span class="string">"Stream read"</span>)&#123;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">              DataInputStream in=<span class="keyword">new</span> DataInputStream(</span><br><span class="line">                      <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                              <span class="keyword">new</span> FileInputStream(<span class="string">"temp.tmp"</span>)));</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numofInts;i++)&#123;</span><br><span class="line">              in.readInt();</span><br><span class="line">          &#125;</span><br><span class="line">          in.close();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">new</span> Tester(<span class="string">"Mapped read"</span>)&#123;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">              FileChannel fc=<span class="keyword">new</span> FileInputStream(<span class="string">"temp.tmp"</span>).getChannel();</span><br><span class="line">              IntBuffer buff=fc.map(FileChannel.MapMode.READ_ONLY,<span class="number">0</span>,fc.size()).asIntBuffer();</span><br><span class="line">              <span class="keyword">while</span>(buff.hasRemaining())&#123;</span><br><span class="line">                  buff.get();</span><br><span class="line">              &#125;</span><br><span class="line">              fc.close();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">new</span> Tester(<span class="string">"Stream Read/Write"</span>)&#123;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">             RandomAccessFile raf=<span class="keyword">new</span> RandomAccessFile(<span class="string">"temp.tmp"</span>,<span class="string">"rw"</span>);</span><br><span class="line">             raf.writeInt(<span class="number">1</span>);</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numofubuffInts;i++)&#123;</span><br><span class="line">                 raf.seek(raf.length()-<span class="number">4</span>);</span><br><span class="line">                 raf.writeInt(raf.readInt());</span><br><span class="line">             &#125;</span><br><span class="line">             raf.close();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">new</span> Tester(<span class="string">"Mapped Read/write"</span>)&#123;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">              FileChannel fc=<span class="keyword">new</span> RandomAccessFile(<span class="string">"temp.tmp"</span>,<span class="string">"rw"</span>).getChannel();</span><br><span class="line">              IntBuffer buff=fc.map(FileChannel.MapMode.READ_WRITE,<span class="number">0</span>,fc.size()).asIntBuffer();</span><br><span class="line">              <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numofubuffInts;i++)&#123;</span><br><span class="line">                  buff.put(buff.get(i-<span class="number">1</span>));</span><br><span class="line">              &#125;</span><br><span class="line">              fc.close();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Tester tester:tests)&#123;</span><br><span class="line">            tester.runTest();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行上述代码结果会发现“映射写”似乎要使用FileOutputSream。但是映射文件的所有输出使用RandomAccessFile性能更好<br>我们一般建议使用映射进行文件的读写性能更好，即使建立这样的代码代价会稍大</p>
<h3 id="文件加锁"><a href="#文件加锁" class="headerlink" title="文件加锁"></a>文件加锁</h3><p><strong>文件加锁机制，它允许我们同步访问作为共享资源的文件</strong>，不过，竞争同一文件的两个线程可能在不同的java虚拟机上，或者一个是java进程，另一个是操作系统的其他本地进程，<strong>文件锁对其他的操作系统进程是可见的，因为java的文件加锁直接映射到了本地操作系统的加锁工具</strong><br>下面是一个关于文件加锁的简单例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileLocking</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        FileOutputStream fos=<span class="keyword">new</span> FileOutputStream(<span class="string">"file.txt"</span>);</span><br><span class="line">        FileLock fl=fos.getChannel().tryLock();</span><br><span class="line">        <span class="keyword">if</span>(fl!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"locked file"</span>);</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">            fl.release();</span><br><span class="line">            System.out.println(<span class="string">"Release Lock"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过对FileChannel调用tryLock()或lock()，就可以获得整个文件的FileLock（SocketChannel,DatagramChannel和ServerSocketChannel不需要加锁，因为它们是从单进程实体继承而来，我们通常不再两个进程之间共享网络socket）<br>tryLock()是非阻塞的，它设法获取锁，但是如果不能获得（当其他一些进程以及持有相同的锁，并且不共享时），它将直接返回<br>lock()是阻塞式的，它要阻塞进程直至获得锁可以获得<br>也可以使用下面的方法对文件的一部分上锁<br>    tryLock(long position,long size,boolean shared)<br>或<br>    lock(long position,long size,boolean shared)<br>其中的加锁区域有size-position决定，第三个参数指定是否是共享锁<br>无参数的加锁方式将根据文件的尺寸的变化而变化，但是具有固定尺寸的锁不随文件尺寸的变化而变化，也就是说，如果你获得了某一区域上的锁，当文件增大超出position+size时，那么超出的部分不会被锁定，无参数的加锁是对整个文件加锁，即使文件增大也是如此<br>对独占锁或者共享锁的支持必须由底层的操作系统提供，如果操作系统不支持共享锁并为每一请求都创建一个锁，那么它就会使用独占锁，锁的类型（独占或者共享）可以通过FileLock.isShared()进行查询</p>
<h4 id="对映射文件的部分加锁"><a href="#对映射文件的部分加锁" class="headerlink" title="对映射文件的部分加锁"></a>对映射文件的部分加锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockingMappedFiles</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LENGTH=<span class="number">0x8FFFFFF</span>;<span class="comment">//128M</span></span><br><span class="line">    <span class="keyword">static</span> FileChannel fc;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        fc=<span class="keyword">new</span> RandomAccessFile(<span class="string">"text.dat"</span>,<span class="string">"rw"</span>).getChannel();</span><br><span class="line">        MappedByteBuffer out=fc.map(FileChannel.MapMode.READ_WRITE,<span class="number">0</span>,LENGTH);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;LENGTH;i++)&#123;</span><br><span class="line">            out.put((<span class="keyword">byte</span>) <span class="string">'x'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> LockAndModify(out,<span class="number">0</span>,LENGTH/<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">new</span> LockAndModify(out, LENGTH/<span class="number">2</span>,LENGTH/<span class="number">2</span>+LENGTH/<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LockAndModify</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> ByteBuffer buff;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> start,end;</span><br><span class="line">        LockAndModify(ByteBuffer buff,<span class="keyword">int</span> start,<span class="keyword">int</span> end)&#123;</span><br><span class="line">            <span class="keyword">this</span>.buff=buff;</span><br><span class="line">            <span class="keyword">this</span>.start=start;</span><br><span class="line">            buff.limit(end);</span><br><span class="line">            buff.position(start);</span><br><span class="line">            <span class="keyword">this</span>.buff=buff.slice();</span><br><span class="line">            start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                FileLock fl = fc.lock(start, end, <span class="keyword">false</span>);</span><br><span class="line">                System.out.println(<span class="string">"locked"</span>+start+<span class="string">"to"</span>+end);</span><br><span class="line">                <span class="keyword">while</span>(buff.position()&lt;buff.limit()-<span class="number">1</span>)&#123;</span><br><span class="line">                    buff.put((<span class="keyword">byte</span>)(buff.get()+<span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                fl.release();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><p>java I/O类型支持读写压缩格式的数据流，你可以使用它们对其他I/O类进行封装，以提供压缩功能<br>这些类都不是从Reader和Writer类派生而来，而是属于InputStream和OtputStream继承层次结构的一部分，这样做是因为压缩类库是按字节方式而不是字符方式处理的，不过有时我们可能需要被迫要混合使用着两种类型的数据流（注意我们可以使用InputStreamReader和OutputStreamWriter在两种类型之间方便地进行转换）</p>
<table>
<thead>
<tr>
<th></th>
<th>压缩类</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>CheckedInputStream</td>
<td>getCheckSum()为任何InputStream产生效验和（不仅是解压缩）</td>
</tr>
<tr>
<td>CheckedOutputStream</td>
<td>getCheckSum()为任何OutputStream产生效验和（不仅是压缩）</td>
</tr>
<tr>
<td>DeflaterOutputStream</td>
<td>压缩类的基类</td>
</tr>
<tr>
<td>ZipOutputStream</td>
<td>一个DeflaterOutputStream，用于将数据压缩成Zip文件格式</td>
</tr>
<tr>
<td>GZIPOutputStream</td>
<td>一个DeflaterOutputStream，用于将数据压缩成GZip文件格式</td>
</tr>
<tr>
<td>InflaterInputStream</td>
<td>解压缩类的基类</td>
</tr>
<tr>
<td>ZipInputStream</td>
<td>一个InflaterInputStream，用于解压缩Zip文件格式的数据</td>
</tr>
<tr>
<td>GZIPInputStream</td>
<td>一个InflaterInputStream，用于解压缩GZip文件格式的数据</td>
</tr>
</tbody>
</table>
<h3 id="用GZIP进行简单压缩"><a href="#用GZIP进行简单压缩" class="headerlink" title="用GZIP进行简单压缩"></a>用GZIP进行简单压缩</h3><p>GZIP接口非常简单，如果我们只想对单个数据流（而不是一系列互异数据）进行压缩，那么它可能是比较合适的选择，下面是对单个文件进行压缩的例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GZIPCompress</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args.length==<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(</span><br><span class="line">                    <span class="string">"usage:\nGIZPcompress file\n"</span>+</span><br><span class="line">                     <span class="string">"\tUses GZIP compression to compress"</span>+</span><br><span class="line">                     <span class="string">"the file to test.gz"</span></span><br><span class="line">            );</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        BufferedReader in=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"args[0]"</span>));</span><br><span class="line">        BufferedOutputStream out=<span class="keyword">new</span> BufferedOutputStream(</span><br><span class="line">                <span class="keyword">new</span> GZIPOutputStream(</span><br><span class="line">                        <span class="keyword">new</span> FileOutputStream(<span class="string">"test.gz"</span>)</span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">        <span class="keyword">while</span>((c=in.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            out.write(c);</span><br><span class="line">        &#125;</span><br><span class="line">        in.close();</span><br><span class="line">        out.close();</span><br><span class="line">        System.out.println(<span class="string">"reading file"</span>);</span><br><span class="line"></span><br><span class="line">        BufferedReader in2=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(</span><br><span class="line">                <span class="keyword">new</span> GZIPInputStream(</span><br><span class="line">                        <span class="keyword">new</span> FileInputStream(<span class="string">"test.gz"</span>))));</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span>((s=in2.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>压缩类的使用非常直观，直接将输出流封装成GZIPOutputStream或ZIPOutputStream，并将输入流封装成GZIPInputStream或ZIPINputStream即可，其他的操作就是通常的I/O读写</p>
<h3 id="用Zip进行多文件保存"><a href="#用Zip进行多文件保存" class="headerlink" title="用Zip进行多文件保存"></a>用Zip进行多文件保存</h3><p>支持Zip格式的Java库更加全面，利用该库可以方便地保存多个文件，它甚至有一个独立的类，使得读取Zip文件更加方便，这个类库使用标准Zip格式，所有能与当前那些可通过因特网下载的压缩工具很好地协作，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZIpCompress</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        FileOutputStream f =<span class="keyword">new</span> FileOutputStream(<span class="string">"test.zip"</span>);</span><br><span class="line">        CheckedOutputStream csum=<span class="keyword">new</span> CheckedOutputStream(f,<span class="keyword">new</span> Adler32());</span><br><span class="line">        ZipOutputStream zos=<span class="keyword">new</span> ZipOutputStream(csum);</span><br><span class="line">        BufferedOutputStream out=<span class="keyword">new</span> BufferedOutputStream(zos);</span><br><span class="line">        zos.setComment(<span class="string">"A test of java Zipping"</span>);</span><br><span class="line">        <span class="keyword">for</span>(String arg:args)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Writing file"</span>+arg);</span><br><span class="line">            BufferedReader in=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(arg));</span><br><span class="line">            zos.putNextEntry(<span class="keyword">new</span> ZipEntry(arg));</span><br><span class="line">            <span class="keyword">int</span> c;</span><br><span class="line">            <span class="keyword">while</span>((c=in.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">                out.write(c);</span><br><span class="line">            &#125;</span><br><span class="line">            in.close();</span><br><span class="line">            out.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        out.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Checksum"</span>+csum.getChecksum().getValue());</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"Reading file"</span>);</span><br><span class="line">        FileInputStream fi=<span class="keyword">new</span> FileInputStream(<span class="string">"text.zip"</span>);</span><br><span class="line">        CheckedInputStream csum1=<span class="keyword">new</span> CheckedInputStream(fi,<span class="keyword">new</span> Adler32());</span><br><span class="line">        ZipInputStream in2=<span class="keyword">new</span> ZipInputStream(csum1);</span><br><span class="line">        BufferedInputStream bis=<span class="keyword">new</span> BufferedInputStream(in2);</span><br><span class="line">        ZipEntry ze;</span><br><span class="line">        <span class="keyword">while</span>((ze=in2.getNextEntry())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           System.out.println(<span class="string">"Reading file"</span>+ze);</span><br><span class="line">           <span class="keyword">int</span> x;</span><br><span class="line">           <span class="keyword">while</span>((x=bis.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">               System.out.println(x);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(args.length==<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Checksum"</span>+csum1.getChecksum().getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        bis.close();</span><br><span class="line">        ZipFile zf=<span class="keyword">new</span> ZipFile(<span class="string">"test.zip"</span>);</span><br><span class="line">        Enumeration e=zf.entries();</span><br><span class="line">        <span class="keyword">while</span>(e.hasMoreElements())&#123;</span><br><span class="line">            ZipEntry ze2=(ZipEntry) e.nextElement();</span><br><span class="line">            System.out.println(<span class="string">"File"</span>+ze2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码有几个注意的地方，使用Checksum类来计算和校验文件的校验和的方法，共有两种Checksum类型，Adler32(更快)和CRC32(慢一些，但更准确)<br>对于每个呀加人压缩档案的文件，必须调用PutNextEntry()，并将其传递给一个ZipEntry对象,ZipEntry对象包含一个功能很广泛的接口，允许你获取和设置Zip文件内该特定项上所有可利用的数据，包括：名字，压缩的和未压缩的文件大小，日期，CRC校验和，额外字段数据，注解，压缩方法以及它是否是一个目录入口等等，然后尽管Zip格式提供了设置密码的方式，但是java的Zip类库不提供这些方法的支持<br>为了能够解压缩文件，ZipInputStream提供了getNextEntry()方法返回下一个ZipEntry（如果存在的话），解压缩文件有个更简便的方法，使用ZipFile对象读取文件，该对象有一个entries()方法用来向ZipEntries返回一个Enumeration<br>为了读取校验和，必须拥有对与之相关联的Checksum的访问权限，在这里保留了CheckedOutputStream和CheckedInputStream对象的引用，但是，也可以值保留一个执行Checksum对象的引用<br>Zip流中有个令人困惑的方法setComment()，我们可以在写文件时写注释，但没有任何方法恢复ZipInpuStream内的注释，似乎只能通过ZipEntry才能以逐条方式完全支持注释的获取</p>
<h3 id="java档案文件"><a href="#java档案文件" class="headerlink" title="java档案文件"></a>java档案文件</h3><p>Zip格式也被应用于JAR(java ARchive java文档文件)文件格式中在，这种文件格式就像Zip一样，可以将一组文件压缩到单一压缩文件中<br>jar文件是跨平台的，jar文件非常有用，一次请求可以获取多个文件，因为压缩的原因使得传输时间也变得更短，而且还可以在每个条目上添加数字签名<br><strong>一个jar文件由一组压缩文件构成，同时还有一张描述所有文件的“文件清单”</strong>（可以自行创建文件清单，也可以由jar程序自动生成），在jdk文档中可以找到与Jar文件清单更多的资料<br>我们看下在命令行中如何使用jar程序</p>
<p>jar [options] destination [manifest] inputfile(s)<br>其中option只是一个字母集合（不必输入任何“-”或者其他任何标识符），以下是这些选项字符在Unix和Linux系统中的tar文件也具有相同的意义<br>|选项|功能说明|<br>——-|——–<br>c|创建一个新的或空的压缩文档<br>f|列出目录表<br>x|解压所有文件<br>x file|解压该文件<br>f|意指：“我打算指定一个文件名”，如果没有用这个选项，jar假设所有的输入都来自于标准输入<br>或者在创建一个文件时，输出对象也假设为标准输出<br>m|表示第一个参数将是用户自建的清单文件的名字<br>v|产生详细输出，描述jar所做的工作<br>O|只存储文件，不压缩文件（用来创建一个可放在类路径的Jar文档）<br>M|不自动创建文件清单</p>
<p>如果压缩到Jar文件的众多文件中包含多个子目录，那么该子目录会自动被添加到Jar文件中，且包括该子目录的所有子目录，路径信息也会被保留</p>
<h2 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h2><p>当你创建对象的时候，只要你需要，它就一致存在，但是在程序终止时，无论如何它都不会继续存在，尽管这么做是有意义的，但是仍然在某些情况下，如果对象能够在程序不运行的情况下继续存在并保存其信息，那就非常有用，当下次程序运行时，该对象被重建并拥有信息与上次运行它时的信息是相同的（当然，我们可以通过将信息写入文件或数据库达到同样的目的）<br>java的对象序列化将那些实现了Serializabel接口的对象转换成一个字节序列，并能够在以后将这个字节序列完全恢复为原来的对象，这一过程甚至可以通过网络进行，这意味着序列化能够自动弥补不同操作系统之间的差异，也就是说，可以在运行window系统的计算机上创建对象，将其序列化，通过网络将它发送给一台运行Unix系统的计算机，然后在那里准确地重新组装，而却不必担心数据在不同的机器上表示会不同<br>对象的序列化很有趣，因为利用它可以实现轻量级持久性，“持久性”意味着一个对象的生命周期不取决与程序是否正在执行，通过将一个持久化对象写入磁盘，然后在重新调用程序是恢复该对象，就能实现持久化的效果<br>对象必须在程序中显式地序列化（seialize）和反序列化还原（deserialize）（更严格的持久化机制，例如Hibernate或者MyBatis）<br>对象的序列化概念加入到语言中是为了支持两种主要特性<br>一是java的远程方法调用（Remote method invocation RMI）<strong>它使存活在其他计算机上的对象使用起来就像是存活于本机上一样，当向远程对象发送消息时，需要通过对象序列化来传输参数和返回值</strong><br>再者，对java Beans设计来说，对象的序列化也是必需，使用一个Bean时，一般情况下是在设计阶段对它的状态信息进行配置，这种状态信息必须保存下来，并在程序启动时进行后期恢复，这种具体工作也是由对象序列化完成的<br>只要对象实现类Serializable标记接口，对象的序列化就很简单，查看API可以看到标准类库中很多对象都实现了这个接口<br>如何序列化一个对象？<br>首先要创建某种OutpuStream，将其封在在ObjectOutputStream对象中，这时调用writeObject()即可将对象序列化，并将其发送给OutputStream（对象序列化是基于字节的，因要使用InputStream和OutputStream继承层次结构）将一个序列还原为一个对象，和往常一样，需要将InputStream封装到一个ObjectInputStream内，调用readObject()方法，获得一个指向根类Object的引用，所以必须向下转型才能设置它们<br>对象序列化特别“聪明”的地方是它不仅保存了对象的“全景图”，而且能追踪对象内所包含的所有引用，并保存那些对象，接着又能对对象内的每个这样的引用进行追踪，依此类推，这种情况被称为“对象网”<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Data</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n=n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> Integer.toString(n);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worm</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand= <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="keyword">private</span>  Data[] datas=<span class="keyword">new</span> Data[]&#123;</span><br><span class="line">           <span class="keyword">new</span> Data(rand.nextInt()),</span><br><span class="line">           <span class="keyword">new</span> Data(rand.nextInt()),</span><br><span class="line">           <span class="keyword">new</span> Data(rand.nextInt())</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">private</span> Worm next;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> c;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Worm</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">char</span> x)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"constructor:"</span>+i);</span><br><span class="line">        c=x;</span><br><span class="line">        <span class="keyword">if</span>(--i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">           next=<span class="keyword">new</span> Worm(i,(<span class="keyword">char</span>)(x+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Worm</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Default constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuilder result=<span class="keyword">new</span> StringBuilder(<span class="string">":"</span>);</span><br><span class="line">        result.append(c);</span><br><span class="line">        result.append(<span class="string">"("</span>);</span><br><span class="line">        <span class="keyword">for</span>(Data data:datas)&#123;</span><br><span class="line">            result.append(data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            result.append(next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException,ClassNotFoundException</span>&#123;</span><br><span class="line">        Worm w=<span class="keyword">new</span> Worm(<span class="number">6</span>,<span class="string">'a'</span>);</span><br><span class="line">        System.out.println(<span class="string">"w="</span>+w);</span><br><span class="line">        ObjectOutputStream out=<span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"worm.out"</span>));</span><br><span class="line">        out.writeObject(<span class="string">"Worm strorage\n"</span>);</span><br><span class="line">        out.writeObject(w);</span><br><span class="line">        out.close();</span><br><span class="line">        ObjectInputStream in=<span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span>  FileInputStream(<span class="string">"worm.out"</span>));</span><br><span class="line">        String s=(String) in.readObject();</span><br><span class="line">        Worm w2=(Worm)in.readObject();</span><br><span class="line">        System.out.println(s+<span class="string">"w2+"</span>+w2);</span><br><span class="line">        ByteArrayOutputStream bout=<span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream out2=<span class="keyword">new</span> ObjectOutputStream(bout);</span><br><span class="line">        out2.writeObject(<span class="string">"Worm storage\n"</span>);</span><br><span class="line">        out2.writeObject(w);</span><br><span class="line">        out.flush();</span><br><span class="line">        ObjectInputStream in2=<span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">                <span class="keyword">new</span> ByteArrayInputStream(bout.toByteArray()));</span><br><span class="line">        s=(String)in2.readObject();</span><br><span class="line">        Worm w3=(Worm)in2.readObject();</span><br><span class="line">        System.out.println(s+<span class="string">"w="</span>+w3);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行此程序可以看到，被还原的对象确实包含了原对象的所有链接（对象内的所有对象引用数组即下潜到最后一个对象（可以称为对象网或对象树））<br>对象的还原过程没有调用任何构造器，整个对象都是通过从InputStream中取得数据恢复而来的</p>
<h3 id="寻找类"><a href="#寻找类" class="headerlink" title="寻找类"></a>寻找类</h3><p>将一个对象从它的序列化状态中恢复出来，有那些工作是必须的呢？假如我们将一个对象序列化，并通过网络将其作为文件传送给另一台计算机，那么，另一台计算机上的程序可以只利用该文件内容来还原这个对象吗？答案是no<br>原因也很容易理解，对象的序列化数据中一点会有保留其类型的信息，所有在进行反序列化的时候吗，输出流一定会去获取这个对象序列化的类型信息，当知道了对象的类型之后，虚拟机将会在本地寻找其.class文件加载该Class,如果已经加载或能够在类路径下找到（找到之后加载），接下来的反序列化将会很容易的进行，但是如果找不到，就会抛出ClassNotFoundException异常，所有如果进行可靠的反序列化一定要在类路径下能找到该对象的字节码文件</p>
<h3 id="序列化的控制"><a href="#序列化的控制" class="headerlink" title="序列化的控制"></a>序列化的控制</h3><p>序列化可以进行更加细粒度的控制，例如，出于安全的考虑，你不希望对象的某一部分被序列化，或者一个对象被还原以后，某个子对象需要重新创建，从而不比将该子对象序列化<br>Externalizable接口——代替实现Serializable接口——来对序列化过程进行控制，这个Externalizable接口继承了Sericalizbale接口，同时也添加了两个方法，writeExternal()和readExternal()方法，这两个方法会在序列化和反序列化还原的过程中被自动调用以便执行一些特殊操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blip1</span> <span class="keyword">implements</span> <span class="title">Externalizable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Blip1</span><span class="params">()</span></span>&#123;<span class="comment">//构造器不是public</span></span><br><span class="line">        System.out.println(<span class="string">"Blip1 Constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Blip1.writeExternal"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Blip1.readExternal"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blip2</span> <span class="keyword">implements</span> <span class="title">Externalizable</span></span>&#123;</span><br><span class="line">    Blip2()&#123;</span><br><span class="line">        System.out.println(<span class="string">"Blip2 Constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Blip2 writeExrternal"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Blip2.readExternal"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Blips</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException,ClassNotFoundException</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"constructing Objeects:"</span>);</span><br><span class="line">        Blip1 b1=<span class="keyword">new</span> Blip1();</span><br><span class="line">        Blip2 b2=<span class="keyword">new</span> Blip2();</span><br><span class="line"></span><br><span class="line">        ObjectOutputStream out=<span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">                <span class="keyword">new</span> FileOutputStream(<span class="string">"Bilps.out"</span>));</span><br><span class="line">        System.out.println(<span class="string">"saving Objects"</span>);</span><br><span class="line">        out.writeObject(b1);</span><br><span class="line">        out.writeObject(b2);</span><br><span class="line">        out.close();</span><br><span class="line"></span><br><span class="line">        ObjectInputStream in=<span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">                <span class="keyword">new</span> FileInputStream(<span class="string">"Blips.out"</span>));</span><br><span class="line">        System.out.println(<span class="string">"recovering b1"</span>);</span><br><span class="line">        b1=(Blip1)in.readObject();</span><br><span class="line">        <span class="comment">//System.out.println("recovering b2");</span></span><br><span class="line">        <span class="comment">//b2=(Blip2)in.readObject();//因为Blip2的构造器不是公共的所以在恢复对象时会发发生异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的例子很简单，Blip1和Blip2都实现了Externalizable接口，并通过ObjectOutputStream和ObjectInputStream读写<br>关于Externalizable接口有一些需要注意的地方，当我们通过readObject恢复对象的时候，与Sericalizabel最大的不同是，对于Serializable对象，对象是完全以它的存储的二进制为基础来构造的，而不调用构造器，而对于一个EXternalizable对象，所有默认的构造器都会被调用（包括在字段定义是的初始化），然后才调用readExternalizabel(),必须注意一点的是——所有默认的构造器都会被调用，才能使Externalizable对象产生正确的行为，<br>看看上面的代码，Blip2和Blip1最大的不同是Blip2的构造器不是public的，因此在readObject()方法时，因为要调用Blip2的构造器，所以对于ObjectOutStream是没有访问权的，这里也能猜到，对对象构造器访问的代码一定会在readObject()方法的内部被调用了，这也能说明为什么Blips和Blip2同包，访问Blip2的构造器也会抛出异常，因为访问者是ObjectOutputStream而不是Blips，所以要想正确的被反序列（当然要反序列化，不然为什么要对对象进行序列化呢？ 哈哈）实现Externalizable接口的类的构造器一定要是public“公共的”<br>关于实现了Externalizable接口的对象是如何实现的序列化的，看看下面的一个示例就很清楚了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Blip3</span> <span class="keyword">implements</span> <span class="title">Externalizable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">private</span> String s;<span class="comment">//no Initialization</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Blip3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Blip3 constructor"</span>);</span><br><span class="line">        <span class="comment">//s,i not initialized</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Blip3</span><span class="params">(String x,<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Blip3(String x,int a)"</span>);</span><br><span class="line">        s=x;</span><br><span class="line">        i=a;</span><br><span class="line">        <span class="comment">//s &amp; i only  initialized in non-default constructor</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> s+i;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Blip3.writeExternal"</span>);</span><br><span class="line">        out.writeObject(s);</span><br><span class="line">        out.writeObject(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Blip3.readExternal"</span>);</span><br><span class="line">        s=(String) in.readObject();</span><br><span class="line">        i=(Integer)in.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException,ClassNotFoundException</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Constructing Objects:"</span>);</span><br><span class="line">        Blip3 b3=<span class="keyword">new</span> Blip3(<span class="string">"A String"</span>,<span class="number">47</span>);</span><br><span class="line">        System.out.println(b3);</span><br><span class="line">        ObjectOutputStream out=<span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">                <span class="keyword">new</span> FileOutputStream(<span class="string">"Blip3.out"</span>));</span><br><span class="line">        System.out.println(<span class="string">"Saving Objects"</span>);</span><br><span class="line">        out.writeObject(b3);</span><br><span class="line">        out.close();</span><br><span class="line">        ObjectInputStream in=<span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">                <span class="keyword">new</span> FileInputStream(<span class="string">"Blip3.out"</span>));</span><br><span class="line">        System.out.println(<span class="string">"recovering Objects"</span>);</span><br><span class="line">        b3=(Blip3) in.readObject();</span><br><span class="line">        System.out.println(b3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的示例中我们能够看到，实现了Externalizable接口的对象是如何实现序列化和反序列化的，当我们调用writeObject()方法的时候，ObjectOutputStream记录了对象的类型信息，之后调用writeExternal()方法，在writeExternal，我们可以任意的将关于对象的属性信息记录在ObjectOutputStream中（也就是说对象信息的保存可以个性化定制），这样关于这个对象的所有应该知道的信息，我们都保存了下来，当我们调用readObjetc()方法进行反序列化的时候，首先查看这个对象的类型信息，加载—&gt;调用默认构造器（创建实例对象）—&gt;调用readExternal（对象的属性进行初始化）<br>从这里我们也可以看出使用Externalizabel接口和Serializable接口的序列化和反序列化机制是不同的</p>
<h3 id="transient-瞬时-关键字"><a href="#transient-瞬时-关键字" class="headerlink" title="transient(瞬时)关键字"></a>transient(瞬时)关键字</h3><p>当我们对序列化进行控制时，可能某个特定子对象不想让java的序列化机制自动保存与恢复，如果子对象表示的是我们不希望将其序列化的敏感信息，即使对象中的这些信息是private属性，一经序列化处理，人们就可以通过读取文件或者拦截网络传输的方式来访问它<br>有一种办法可以防止对象的敏感信息部分被序列化，就是将类实现问Extrenalizable,如前面所示，这样一来，（没有任何东西可以自动序列化），并且可以在writeExternal()内部只对所需部分进行显式地初始化<br>然而，如果我们正在操作的是一个Serializable对象，那么所有序列化操作都会自动进行，为了能够予以控制，可以用transient“瞬时”关键字逐个字段地关闭序列化，它的意思是：“不用麻烦你保存或恢复数据——我自己会处理”，其实transients关键字的特性实现只是给了编译器或者虚拟机一个提示，由虚拟机来去实现忽略子对象的序列化而已<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Login</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Date date=<span class="keyword">new</span> Date();</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String password;<span class="comment">//添加了关键字transient</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Login</span><span class="params">(String name,String pwd)</span></span>&#123;</span><br><span class="line">        username=name;</span><br><span class="line">        password=pwd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"login info:\n"</span>+<span class="string">"username:"</span>+username+<span class="string">"\n"</span>+</span><br><span class="line">                <span class="string">"date:"</span>+date+<span class="string">"\n"</span>+</span><br><span class="line">                <span class="string">"password:"</span>+password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException,ClassNotFoundException,InterruptedException</span>&#123;</span><br><span class="line">        Login a=<span class="keyword">new</span> Login(<span class="string">"Hulk"</span>,<span class="string">"myliitepony"</span>);</span><br><span class="line">        System.out.println(<span class="string">"login a="</span>+a);</span><br><span class="line">        ObjectOutputStream out=<span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">                <span class="keyword">new</span> FileOutputStream(<span class="string">"login.out"</span>));</span><br><span class="line">        out.writeObject(a);</span><br><span class="line">        out.close();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        ObjectInputStream in=<span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">                <span class="keyword">new</span> FileInputStream(<span class="string">"login.out"</span>));</span><br><span class="line">        a=(Login) in.readObject();</span><br><span class="line">        System.out.println(<span class="string">"recovering Object at"</span>+<span class="keyword">new</span> Date());</span><br><span class="line">        System.out.println(<span class="string">"login a="</span>+a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>简单例子，password由关键字transient修饰</p>
<h3 id="Externalizable的替代方案"><a href="#Externalizable的替代方案" class="headerlink" title="Externalizable的替代方案"></a>Externalizable的替代方案</h3><p>如果不是坚持要使用Externalizable的话，那么还有一种方法，我们可以实现Serialzable接口，然后添加（注意是“添加”而非“覆盖”或“实现”）名为writeObject()和ReadObject()的方法，这样一旦对象被序列化或者反序列化还原，就会自动地分别调用这两个方法，也是就是说，只要提供了这两个方法，就会使用它们而不是默认的序列化机制<br><strong>这些方法必须要有正确的方法签名</strong><br>    private void writeObject(ObjectOutpuStream stream)<br>    private void readObject(ObjectInputStream stream)<br>上面的这些方法很令人疑惑，首先这些方法被声明为private，也就是说这些方法是有这个类的其他成员来调用的，但是实际上我们并没有从这个类的其他方法中调用它们，而是ObjectOutputStream和ObjectInoutStream的writeObject()和readObject()方法调用了你的对象的writeObject（）和readObject()方法，但是为什么ObjectOuputStream和ObjectInputStream能够访问你类中的private()方法的？我们只能假设这正是序列化神奇的地方（真想骂人啊）<br>所以我个人不推荐这种方式，因为：</p>
<ol>
<li>这种方式违背了访问控制权限机制，</li>
<li>你添加的WriteObject和readObject()方法必须要有正确的方法前面并且是private的（我们无法保证不会犯错，而且错误产生时我们也是毫无察觉的，编译器并不会提醒我们），</li>
<li>实现Externalizable接口就可以完全达到这个目的了，我们为何要选择这种方式来控制序列化呢？<h3 id="使用“持久性”"><a href="#使用“持久性”" class="headerlink" title="使用“持久性”"></a>使用“持久性”</h3>一个比较诱人的使用序列化技术的想法是：存储程序的一些状态，以便我们随后可以很容易地将程序恢复到当前状态，但是我们能够这样做之前，必须回答几个问题<br>如果我们将两个对象——他们都具有指向第三个对象的引用——进行序列化，会发生什么？当我们从它们的序列化状态恢复这两个对象时，第三个对象会只出现一次吗？<br>如果我们将这两个对象序列化成独立的文件，然后在代码的不同部分对它们进行反序列化还原，又会怎样呢？<br>下面这个例子说明这些问题<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> <span class="keyword">implements</span>  <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> House perferenceHouse;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name,House h)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.perferenceHouse=h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name+<span class="string">"["</span>+<span class="keyword">super</span>.toString()+<span class="string">"],"</span>+perferenceHouse+<span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException,ClassNotFoundException</span>&#123;</span><br><span class="line">        House house=<span class="keyword">new</span> House();</span><br><span class="line">        List&lt;Animal&gt; animals=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        animals.add(<span class="keyword">new</span> Animal(<span class="string">"Boson the dog"</span>,house));</span><br><span class="line">        animals.add(<span class="keyword">new</span> Animal(<span class="string">"Ralph  the hamster"</span>,house));</span><br><span class="line">        animals.add(<span class="keyword">new</span> Animal(<span class="string">"Molly the cat"</span>,house));</span><br><span class="line">        System.out.println(<span class="string">"animals:"</span>+animals);</span><br><span class="line"></span><br><span class="line">        ByteArrayOutputStream buf1=<span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream out1 =<span class="keyword">new</span> ObjectOutputStream(buf1);</span><br><span class="line">        out1.writeObject(animals);</span><br><span class="line">        out1.writeObject(animals);<span class="comment">//write a 2nd set</span></span><br><span class="line"></span><br><span class="line">        ByteArrayOutputStream buf2=<span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream out2=<span class="keyword">new</span> ObjectOutputStream(buf2);</span><br><span class="line">        out2.writeObject(animals);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//now get them back</span></span><br><span class="line">        ObjectInputStream in1=<span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">                <span class="keyword">new</span> ByteArrayInputStream(buf1.toByteArray()));</span><br><span class="line">        ObjectInputStream in2=<span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">                <span class="keyword">new</span> ByteArrayInputStream(buf2.toByteArray()));</span><br><span class="line">        List animals1=(List) in1.readObject(),</span><br><span class="line">             animals2=(List) in1.readObject(),</span><br><span class="line">             animals3=(List) in2.readObject();</span><br><span class="line">        System.out.print(</span><br><span class="line">                <span class="string">"animals1:"</span>+animals1+<span class="string">"\n"</span>+</span><br><span class="line">                <span class="string">"animals2:"</span>+animals2+<span class="string">"\n"</span>+</span><br><span class="line">                 <span class="string">"animals3:"</span>+animals3);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>运行上面的程序我们能够得出这样的结论，当我们在同一个流中写入两个对象时，当取出时，这两个恢复的对象将会指向同样的引用，也就是说对象链接是一样的，但是当我们将对象保存在不同的流时，恢复对象时，这两个对象的对象树保存在不同的内存地址中，两个对象之间没有任何关联<br>（我猜测，在序列化对象时，可能会将对象的内存地址的信息也保存下来，比如对象的引用中就有关于对象内存地址的信息，待序列化对象的引用同样也会有内存地址的信息，因此在反序列化时，会查看序列化中保存的对象内存地址以判断待反序列化对象与其他序列化对象之间的关系，当反序列化之后会进行正确的链接，这就能说明了animals1和animal2的toString返回的信息完全一样（指向同样的内存地址，包括子对象也是如此））<br><strong>如果我们想要保存系统状态，最安全的做法是将其作为“原子”操作进行序列化</strong>，如果我们序列化了某些东西，再去其他的一些工作，再来序列化更多的东西，如此等等，那么将无法安全地保存系统状态，取而代之的是，将构成系统状态的所有对象都置入单一容器内，并在一个操作中将该容器直接写出，然后同样只需一次方法调用，既可以将其恢复（原因是，当我们分步进行序列化的期间，你所保存的对象状态可能已经发生了变化，序列化保存的信息已经“过时了”）</p>
<h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><p><strong>对象序列化的一个重要的限制就是它只是java的解决方案</strong>只有java程序才能反序列化这种对象，一种更具有操作性的解决方案是将数据转换为xml格式，这可以使其被各种各样的平台和语言使用<br>你可以使用java的标准类库中的javax.xml.*，也可以使用开源的XOM类库，使用方法很简单，就是为对象建立一个文档对象模型（Document）这里是通过节点层次结构来表示对象的信息的，然后将其写入输出流即可，这里不讲</p>
<h2 id="Preferences"><a href="#Preferences" class="headerlink" title="Preferences"></a>Preferences</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreferencesDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Preferences prefs= Preferences.userNodeForPackage(PreferencesDemo.class);</span><br><span class="line">        prefs.put(<span class="string">"location"</span>,<span class="string">"oz"</span>);</span><br><span class="line">        prefs.put(<span class="string">"Footwear"</span>,<span class="string">"Ruby Slippers"</span>);</span><br><span class="line">        prefs.putInt(<span class="string">"Companions"</span>,<span class="number">4</span>);</span><br><span class="line">        prefs.putBoolean(<span class="string">"Ara there witches"</span>,<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">int</span> usageCount=prefs.getInt(<span class="string">"usageCount"</span>,<span class="number">0</span>);</span><br><span class="line">        usageCount++;</span><br><span class="line">        prefs.putInt(<span class="string">"UsageCount"</span>,usageCount);</span><br><span class="line">        <span class="keyword">for</span>(String key:prefs.keys())&#123;</span><br><span class="line">            System.out.println(key+<span class="string">":"</span>+prefs.get(key,<span class="keyword">null</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//you musy always provide a default value</span></span><br><span class="line">        System.out.println(<span class="string">"how many companions does Derothy havs?"</span></span><br><span class="line">        + prefs.getInt(<span class="string">"Companions"</span>,<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/19/Java-I-O系统/" data-id="cjnzv2psx003hcorzm29tvxfl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/10/19/枚举类型/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          枚举类型
        
      </div>
    </a>
  
  
    <a href="/2018/10/19/容器深入研究/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">容器深入研究</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/学习心得/">学习心得</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML5/">HTML5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Maven/">Maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Oracle/">Oracle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Servlet-JSP/">Servlet&JSP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-MVC/">Spring MVC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-boot/">Spring boot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-cloud/">Spring cloud</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/HTML5/" style="font-size: 10px;">HTML5</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/Node-js/" style="font-size: 10px;">Node.js</a> <a href="/tags/Oracle/" style="font-size: 10px;">Oracle</a> <a href="/tags/Servlet-JSP/" style="font-size: 10px;">Servlet&JSP</a> <a href="/tags/Spring/" style="font-size: 10px;">Spring</a> <a href="/tags/Spring-MVC/" style="font-size: 10px;">Spring MVC</a> <a href="/tags/Spring-boot/" style="font-size: 10px;">Spring boot</a> <a href="/tags/Spring-cloud/" style="font-size: 10px;">Spring cloud</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/11/02/Servlets/">Servlets</a>
          </li>
        
          <li>
            <a href="/2018/10/27/并发/">并发</a>
          </li>
        
          <li>
            <a href="/2018/10/19/注解/">注解</a>
          </li>
        
          <li>
            <a href="/2018/10/19/枚举类型/">枚举类型</a>
          </li>
        
          <li>
            <a href="/2018/10/19/Java-I-O系统/">Java I/O系统</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 EgbertDay<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>