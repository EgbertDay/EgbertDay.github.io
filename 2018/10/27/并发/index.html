<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>并发 | 代海峰</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="基本的线程机制并发编程使得我们可以将程序划分为多个分离，独立运行的任务，通过使用多线程机制，这些独立任务（也被称为子任务）中的每一个都将由执行线程来驱动，一个线程就是在进程中的一个单一的顺序控制流，因此，单个进程可以拥有多个并发执行的任务，但是你的程序使得每个任务都好像有其自己的CPU一样，其地城机制划分CPU时间，但通常你不必考虑它线程模型为编程带来了便利，它简化了在单一程序中同时交织在一起的多">
<meta name="keywords" content="Java">
<meta property="og:type" content="article">
<meta property="og:title" content="并发">
<meta property="og:url" content="http://yoursite.com/2018/10/27/并发/index.html">
<meta property="og:site_name" content="代海峰">
<meta property="og:description" content="基本的线程机制并发编程使得我们可以将程序划分为多个分离，独立运行的任务，通过使用多线程机制，这些独立任务（也被称为子任务）中的每一个都将由执行线程来驱动，一个线程就是在进程中的一个单一的顺序控制流，因此，单个进程可以拥有多个并发执行的任务，但是你的程序使得每个任务都好像有其自己的CPU一样，其地城机制划分CPU时间，但通常你不必考虑它线程模型为编程带来了便利，它简化了在单一程序中同时交织在一起的多">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-10-29T22:14:16.988Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="并发">
<meta name="twitter:description" content="基本的线程机制并发编程使得我们可以将程序划分为多个分离，独立运行的任务，通过使用多线程机制，这些独立任务（也被称为子任务）中的每一个都将由执行线程来驱动，一个线程就是在进程中的一个单一的顺序控制流，因此，单个进程可以拥有多个并发执行的任务，但是你的程序使得每个任务都好像有其自己的CPU一样，其地城机制划分CPU时间，但通常你不必考虑它线程模型为编程带来了便利，它简化了在单一程序中同时交织在一起的多">
  
    <link rel="alternate" href="/atom.xml" title="代海峰" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">代海峰</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">个人博客</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-并发" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/27/并发/" class="article-date">
  <time datetime="2018-10-27T06:39:53.000Z" itemprop="datePublished">2018-10-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习心得/">学习心得</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      并发
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="基本的线程机制"><a href="#基本的线程机制" class="headerlink" title="基本的线程机制"></a>基本的线程机制</h2><p>并发编程使得我们可以将程序划分为多个分离，独立运行的任务，通过使用多线程机制，这些独立任务（也被称为子任务）中的每一个都将由执行线程来驱动，一个线程就是在进程中的一个单一的顺序控制流，因此，单个进程可以拥有多个并发执行的任务，但是你的程序使得每个任务都好像有其自己的CPU一样，其地城机制划分CPU时间，但通常你不必考虑它<br>线程模型为编程带来了便利，它简化了在单一程序中同时交织在一起的多个操作的处理，在使用线程时，CPU将轮流给每个任务分配其占用时间，每个任务都觉得自己在一直占用CPU，但实际上CPU时间是划分成片段分配给了所有的任务（例外情况是程序确实运行在多CPU之上），<strong>线程的一大好处是可以使用你从这个层次抽身出来，即代码不必知道它是运行在具有一个还是多个CPU的机器上，所以，使用线程机制是一种建立透明的，可扩展的程序的方法</strong>，如线运行的太慢，为机器添加CPU就能很容易地加快程序的运行速度，多任务和多线程往往是使用多处理器系统的最合理方式</p>
<h3 id="定义任务"><a href="#定义任务" class="headerlink" title="定义任务"></a>定义任务</h3><p><strong>线程可以驱动任务，因此你需要一种描述任务的方式，这可以由Runnable接口来提供，</strong>要想定义任务，只需实现这个接口并实现run()方法，使得该任务可以执行你的命令<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LiftOff</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> countDown=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">int</span> taskCounter=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id =taskCounter++;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LiftOff</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LiftOff</span><span class="params">(<span class="keyword">int</span> countDown)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.countDown=countDown;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">status</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"#"</span>+id+<span class="string">"("</span>+</span><br><span class="line">                (countDown&gt;<span class="number">0</span>?countDown:<span class="string">"LiftDown!"</span>)+<span class="string">"),"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(countDown-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(status());</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>任务的run()方法通常总会有某种形式的循环（这也是我们编写多线程的惯例，使得线程一直保持存在，并在获得时间片的时候，重新做某些条件检查），使得线程一直运行下去直到不再需要，所以要设定跳出循环的条件（一种选择是直接从run()返回），通常，run()被写成无限循环的形式，这就意味着，除非有某个条件使得run()终结，否则它将永远运行下去<br>在run()中对静态方法Thread.yield()调用是对<strong>线程调度器</strong>（java线程机制的一部分，可以将CPU从一个线程转移给另一个线程）的一种建议，它声明：“我已经执行完生命周期中最重要的部分了，此刻正是切换给其他任务执行一段时间的大好时机”，这完全是选择性的，但是这里使用它是因为它会在这些示例中产生更加有趣的输出:你更可能会看到任务换进换出的证据</p>
<p>看下面的一个例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        LiftOff launch=<span class="keyword">new</span> LiftOff();</span><br><span class="line">        launch.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>这例子中的run()不是由单独的线程驱动的</strong>，它是在main方法中直接调用的（实际上，这里仍然使用了线程，即总是分配给main()的那个线程）<br><strong>当从Runnable导出一个类时，它必须具有run()方法，但是这个方法并无特殊之处——它不会缠身任何内在的线程能力，要实现线程的行为，你必须显式地将一个任务附着到线程上</strong></p>
<h3 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h3><p>将Runnable对象转变为工作任务的传统方式是把它提交给一个Thread构造器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Thread t=<span class="keyword">new</span> Thread(<span class="keyword">new</span> LiftOff());</span><br><span class="line">        t.start();</span><br><span class="line">        System.out.println(<span class="string">"waiting for LiftOff"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Thread构造器只需要一个Runnable对象，调用Thread对象的start()方法为该线程执行必要的初始化操作，然后调用Runnable的run()方法，以便在这个新线程中启动该任务，尽管start()方法看起来是产生了一个对长期运行方法的调用，但是从输出中可以看到，start()迅速地返回了，因此你仍旧可以执行main()线程中的其他操作，main()和LiftOff.run()是程序中与其他贤臣“同时”执行的代码<br>你可以很容易地添加更多的线程去驱动更多的任务<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoreBasicThreads</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> LiftOff()).start();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"waiting for liftdowm"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当main()创建Thread对象时，它并没有捕获任何这些对象的引用，每个Thread都“注册”了它自己，因此确实有一个对它的引用，而且在它的任务退出其run()并死亡之前，垃圾回收器是无法清除它的，因此一个线程会创建一个但多的执行线程，在对start()的调用之后，它仍旧会继续存在                                                                                                                                   </p>
<h3 id="使用Executor"><a href="#使用Executor" class="headerlink" title="使用Executor"></a>使用Executor</h3><p>Java SE5的java.util.concurrennt包中的执行器（Executor）将为你管理Thread对象，从而简化了并发编程，Executor在客户端和任务执行之间提供了一个间接层，与客户端直接执行任务不同，这个中介对象将执行任务，Executor允许你管理异步任务的执行，而无须显式地管理线程的生命周期，Executor在java SE5/6中是启动任务的优选方法<br>我们使用executor来代替上面例子中显式地创建Thread对象，LiftOff对象知道如何运行具体的任务，与命令模式一眼，它暴露了要执行的单一方法，<strong>ExecutorService（具有服务生命周期的Executor，例如关闭）知道如何创建恰当的上下文来执行Runnable</strong>,下面的示例中，CachedThreadPool将为每个任务都创建一个线程，注意，ExecutorService对象是使用静态的Excutors的方法创建的额，这个方法可以确定其Executor类型<br>非常常见的情况是，单个的Executor被用来创建和管理系统中所有的任务<br>对shutdown()方法的调用可以防止新任务被提交给这个Executor，当前线程（在本例中，即驱动main()的线程）将继续运行在shutdown()被调用之前提交的所有任务，这个程序将在Executor中所有任务完成之后尽快提出<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachedThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> LiftOff());</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以很容易地将前面的实例中的CachedThreadPool替换成不同类型的Executor，下面是FixedThreadPool使用了有限的线程集来执行所提交的任务<br>有了FixedThreadPool，你就可以一次性地预先执行代价高昂的线程分配，因而也就可以限制线程的数量了，这可以节省时间，因为你不用为每一个任务都固定地付出创建线程的开销<br><strong>注意，在任何线程池中，现有的线程在可能的情况下，都会被自动复用</strong><br>尽管在线程学习中，我们将使用CachedThreadPool，但是也应当考虑在产生线程的代码中使用FixedTheadPool，CachedThreadPool在程序执行过程中通常会创建与所需数量相同的线程，然后它在回收旧线程时停止创建新线程，因此它是合理的Executor的首选，只有当这种方式会引发问题时，你才需要切换到FixedThreadPool<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FixedThreadpool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] ars)</span></span>&#123;</span><br><span class="line">        ExecutorService exec= Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> LiftOff());</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也可以使用SingleThreadPool,SingleThreadPool就像是线程数量为1的FixedThreadPool,这对于你希望在另一个线程中连续运行的任何事物来说，都是很有用的，如果想SingleThreadPool提交了多个任务，那么这些任务将排队，每个任务都会在下一个任务开始之前结束，因此，SingleThreadPool会序列化所有提交给它的额任务，并会维护它自己（隐藏）的悬挂任务队列<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ExecutorService exec= Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> LiftOff());</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="从任务中产生返回值"><a href="#从任务中产生返回值" class="headerlink" title="从任务中产生返回值"></a>从任务中产生返回值</h3><p>Runnable是执行工作的独立任务，但是它不返回任何值，如果你希望任务在完成时能够返回一个值，那么可以实现Callable接口而不是Runnable接口，在java SE5中引入的Callable是一中具有类型参数的泛型，它的类型参数表示的是从方法call()(而不是run())中返回的值，并且必须使用ExecutorService.sumbit()方法调用它<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        ArrayList&lt;Future&lt;String&gt;&gt; results=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            results.add(exec.submit(<span class="keyword">new</span> TaskWithResult(i)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Future&lt;String&gt; fs:results)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                System.out.println(fs.get());</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                System.out.println(e);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(ExecutionException e)&#123;</span><br><span class="line">                System.out.println(e);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                exec.shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>sumbit()方法会产生Future对象，它用Callable返回结果的特定类型进行参数化，你可以isDone()方法来查询Future是否已经完成，当任务完成时，它具有一个结果，你可以调用get()方法来获取该结果，你也可以不用isDone()进行检查就直接调用get()，在这种情况下，get()将阻塞，直至结果准备就绪，你还可以在试图调用get()来获取结果之前，先调用具有超时的get()或者调用isDone()来查看任务是否完成</p>
<h3 id="休眠"><a href="#休眠" class="headerlink" title="休眠"></a>休眠</h3><p>影响任务行为的一种简单的方法就是调用sleep(),它将使任务中止执行给定的时间<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepingTask</span>  <span class="keyword">extends</span> <span class="title">LiftOff</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(countDown-- &gt;<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(status());</span><br><span class="line">                <span class="comment">//Old-style</span></span><br><span class="line">                <span class="comment">//Thread.sleep(100)</span></span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            System.err.println(<span class="string">"Interrupted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> SleepingTask());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>对sleep()的调用可以抛出InterruptedException异常，它在run()中被捕获，因为异常不能跨线程传播会mai(),所以你需要在本地处理所有在任务内部产生的异常</strong><br>java SE5引入了更加显式的sleep()版本，作为TimeUtil类的一部分，这个方法允许你指定sleep()延迟的时间单元，因此可以提供更好的阅读性</p>
<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>线程的优先级将线程的重要性传递给了调度器，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimplePriorities</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>  countDown=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">double</span> d;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> priority;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimplePriorities</span><span class="params">(<span class="keyword">int</span> priority)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.priority=priority;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread()+<span class="string">":"</span>+countDown;<span class="comment">//Thread.currentThread()返回Thread之后调用它的toString()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         Thread.currentThread().setPriority(priority);<span class="comment">//设置执行当前线程的优先级</span></span><br><span class="line">         <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">100000</span>;i++)&#123;</span><br><span class="line">                 d+=(Math.PI+Math.E)/(<span class="keyword">double</span>)i;</span><br><span class="line">                 <span class="keyword">if</span>(i%<span class="number">1000</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                     Thread.yield();</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             System.out.println(<span class="keyword">this</span>);</span><br><span class="line">             <span class="keyword">if</span>(--countDown==<span class="number">0</span>)</span><br><span class="line">                 <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">           exec.execute(<span class="keyword">new</span> SimplePriorities(Thread.MIN_PRIORITY));</span><br><span class="line">        &#125;</span><br><span class="line">        exec.execute(<span class="keyword">new</span> SimplePriorities(Thread.MAX_PRIORITY));</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-6 10,mian]:5</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-6 10,mian]:4</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-6 10,mian]:3</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-6 10,mian]:2</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-6 10,mian]:1</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-3 1,mian]:5</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-2 10,mian]:5</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-1 10,mian]:5</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-5 10,mian]:5</span></span><br><span class="line"><span class="comment">Thread[pool-1-thread-4 10,mian]:5</span></span><br><span class="line"><span class="comment">.....</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<p>通过上面程序的输出，我们能够看出来，优先级越高的线程，所分配得的时间片越多，注意，优先级的设定是在run()的开头部分设定，在构造器中设置它们不会有任何好处，因为Executor在此刻还没有开始执行任务（也就是说，只有在执行run（）时任务才被传递给一个线程，在此之前它是不知道哪个线程将会执行它），我们也知道通过调用Thread.currentthread()来获得对<strong>驱动</strong>（理解驱动的概念）该任务的Threa的引用<br>尽管JDK有10个优先级，但它与多数操作系统都不能映射的很好，比如windows有7个优先级且不是固定的，所有这种映射关系也不是固定的，对于不同的操作系统来说，唯一可一直的方法是当调整优先级的时候，只使用MAX_PRIORITYY，NORM_PRIORITY,MIN_PRIORITYY三种</p>
<h3 id="让步"><a href="#让步" class="headerlink" title="让步"></a>让步</h3><p>如果知道已经完成了在run()方法的循环的一次迭代过程中所需的工作，就可以给线程调度机制一个暗示；你的工作已经做的差不多了，可以让别的线程使用CPU了，这个暗示将通过调用yield()方法来作出（不过只是个暗示，没有任何机制保证它将会被采纳），当调用yield()时，你也是在建议具有相同优先级的其他线程可以运行，yield()可以使得任务之间产生良好的处理机制，但是不要依赖yield(),实际上，yield经常被滥用</p>
<h3 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h3><p>所谓后台（daemon）线程，是指在程序运行的时候在后台提供的一种通用服务的线程，并且这种线程并不属于程序中不可或缺的部分，因此，当所有的非后台线程结束时，程序也就终止了，同时还会杀死进程中的所有后台线程，反过来说，只要有任何非后台线程还在运行，程序就不会终止，比如，执行main()就是一个非后台线程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDaemons</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">                System.out.println(Thread.currentThread()+<span class="string">" "</span>+<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"sleep() interrupted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            Thread daemon=<span class="keyword">new</span> Thread(<span class="keyword">new</span> SimpleDaemons());</span><br><span class="line">            daemon.setDaemon(<span class="keyword">true</span>);<span class="comment">//must call before start</span></span><br><span class="line">            daemon.start();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"All daemon started"</span>);</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">175</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的例子一旦main()完成其工作，就没什么能阻止程序终止了，因为除了后台线程外，已经没有什么线程在运行了<br>SimpleDaemons.java创建了显式的线程，以便可以显式设置它们的标志，通过编写定制的ThreadFactory可以定制由Executor创建的线程的属性（后台，优先级，名称）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(@NotNull Runnable r)</span> </span>&#123;</span><br><span class="line">        Thread t=<span class="keyword">new</span> Thread(r);</span><br><span class="line">        t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在你可用一个全新的DeamnoThreadFactory作为参数传递给Executors.newCachedThreadPool()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeamonFromFactory</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                TimeUnit.MICROSECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">                System.out.println(Thread.currentThread()+<span class="string">" "</span>+<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Interrupted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//接受ThreadFactory参数用来创建新的线程</span></span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool(<span class="keyword">new</span> DaemonThreadFactory());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> DeamonFromFactory());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以通过调用isDaeamon()方法来确定线程是否是一个后台线程，如果是一个后台线程，那么它创建的任何线程将被自动设置成后台线程<br>Daemon线程被设置成后台线程，然后派生出许多子线程，这些线程并没有被显式地设置为后台模式，不过它们的确是后台线程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DaemponSpawn</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Daemon</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Thread[] t=<span class="keyword">new</span> Thread[<span class="number">10</span>];</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            t[i]=<span class="keyword">new</span> Thread(<span class="keyword">new</span> DaemponSpawn());</span><br><span class="line">            t[i].start();</span><br><span class="line">            System.out.println(<span class="string">"DaemonSpawn"</span>+i+<span class="string">"  started"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t.length;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">"t["</span>+i+<span class="string">"].isDaemon()="</span>+t[i].isDaemon());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Daemons</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Thread d=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Daemon());</span><br><span class="line">        d.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        d.start();</span><br><span class="line">        System.out.println(<span class="string">"d,isDaemon()="</span>+d.isDaemon());</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你应该意识到后台线程在不执行finally子句的情况下就会终止其run()方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ADaemon</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">          System.out.println(<span class="string">"Starting Daemon"</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Exiting via InterruptedException"</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"this should always run?"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeamonsDonotRunFinally</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Thread t=<span class="keyword">new</span> Thread(<span class="keyword">new</span> ADaemon());</span><br><span class="line">        t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output</span></span><br><span class="line"><span class="comment">Starting ADaemon</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
<p>当你运行这个程序时，将会看到finally子句就不会执行但是如果你注释掉对setDaemon的调用，就会看到finally子句将会执行<br>这种行为是对的，因为，当一个后台非后台线程终止时，后台线程会“突然”终止，因此一旦main()退出，jav就会立即关闭所有的后台进程，而不会有任何你希望出现的确认形式，因为你不能以优雅的方式关闭后台线程，所以它们几乎不是一种好的思想，非后台线程的Executor通常是一种更好的方式，因为Executor控制的所有任务可以同时被关闭，这种关闭时以有序的方式进行的</p>
<h3 id="编码的变体"><a href="#编码的变体" class="headerlink" title="编码的变体"></a>编码的变体</h3><p>当目前位置，在你所看到的示例中，任务类都实现了Runnable，在非常简单的情况下，你可能会希望使用直接从Thread继承这种可替换的方式，就像下面这样<br>你可以通过调用适当的Thread构造器为Thread对象赋予具体的名字这个名字可以通过使用getName()获得<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> countDown=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> threadCount=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(Integer.toString(++threadCount));</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"#"</span>+getName()+<span class="string">"("</span>+countDown+<span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span>(--countDown==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> SimpleThread();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另一种可能会看到的惯用法是自管理的Runnable,自管理的代码看起来好像晦涩难懂一些，但是好处就会可以继承其他的类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelfManaged</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> countDown=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> Thread t=<span class="keyword">new</span> Thread(<span class="keyword">this</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SelfManaged</span><span class="params">()</span></span>&#123;t.start();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName()+<span class="string">"("</span>+countDown+<span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>);</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> SimpleThread();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意。start()方法是在构造器中调用的，这个示例比较简单，因此可能是安全的，但是我们知道构造器应该尽量简单的只是做一些初始化的工作，在构造器中调用start()，这意味着任务是访问一个不稳定的对象（对象在全部执行完初始化动作时才是稳定的），这也是优选Executor而不是Thread的原因<br>有时通过使用内部类来将线程代码隐藏在类中将会很有用，其中的一个原因是，当你使用内部类的任务类的代码时，外围类的对象已经创建好了<br>下面看这些示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="comment">//Using a named Inner class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerThread1</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> countDown=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> Inner inner;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        Inner(String name)&#123;</span><br><span class="line">            <span class="keyword">super</span>(name);</span><br><span class="line">            start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">if</span>(--countDown==<span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    sleep(<span class="number">10</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                System.out.println(<span class="string">"Interrupted"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getName()+<span class="string">":"</span>+countDown;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InnerThread1</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        inner=<span class="keyword">new</span> Inner(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Using a anonymous inner class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> countDown=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> Thread t;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InnerThread2</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        t=<span class="keyword">new</span> Thread(name)&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">                        <span class="keyword">if</span> (-countDown == <span class="number">0</span>)</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"Interrupted"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Thread.currentThread().getName()+<span class="string">"("</span>+countDown+<span class="string">")"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Using a named Runnable Implementation</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerRunnable1</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> countDown=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> Inner inner;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InnerRunnable1</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Inner(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        Inner(String name)&#123;</span><br><span class="line">            t=<span class="keyword">new</span> Thread(<span class="keyword">this</span>,name);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">if</span> (--countDown == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                System.out.println(<span class="string">"interrupted"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> t.getName() + <span class="string">"("</span> + countDown + <span class="string">")"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Using an anonymous Runnable implementation</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerRunnable2</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> countDown=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> Thread t;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InnerRunnable2</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        t=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">                        <span class="keyword">if</span> (--countDown == <span class="number">0</span>)</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"Interrupted"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Thread.currentThread().getName()+<span class="string">"("</span>+countDown+<span class="string">")"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,name);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//a separator method to run some code as a task</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadMethod</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> countDown=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> Thread t;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadMethod</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runTask</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="keyword">null</span>)&#123;</span><br><span class="line">            t=<span class="keyword">new</span> Thread(name)&#123;</span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                  <span class="keyword">try</span>&#123;</span><br><span class="line">                      <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                          System.out.println(<span class="keyword">this</span>);</span><br><span class="line">                          <span class="keyword">if</span>(--countDown==<span class="number">0</span>)</span><br><span class="line">                              <span class="keyword">return</span>;</span><br><span class="line">                          sleep(<span class="number">10</span>);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                        System.out.println(<span class="string">"interrupted"</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">                  <span class="keyword">return</span> getName()+<span class="string">"("</span>+countDown+<span class="string">")"</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadVariations</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> InnerThread1(<span class="string">"InnerThread1"</span>);</span><br><span class="line">        <span class="keyword">new</span> InnerThread2(<span class="string">"InnerThread2"</span>);</span><br><span class="line">        <span class="keyword">new</span> InnerRunnable1(<span class="string">"InnerRunnable1"</span>);</span><br><span class="line">        <span class="keyword">new</span> InnerRunnable2(<span class="string">"InnerRunnable2"</span>);</span><br><span class="line">        <span class="keyword">new</span> ThreadMethod(<span class="string">"ThreadMethod"</span>).runTask();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p>在java中，你可以选择如何实现并发编程，并且这个选择会令人困惑，这个问题通常来自于用来描述并发程序技术的术语，特别是涉及线程的那些<br>当目前位置，你应该能够看到要执行的任务和驱动它的线程之间的差异这个差异在java类库尤为明显，因为你对Thread类实际没有任何控制权（并且这种隔离在使用执行器时更加明显，因为执行器将替你处理线程的创建和管理），你创建任务，并通过某种方式讲一个线程附着在任务上，以使得这个线程可以执行任务<br>在java中，Thread类本身不执行任何操作，它只是驱动赋予它的任务，但是线程研究中总是不变的使用“线程执行这项或那项任务”这样的语言，因此，你得到的印象就是“线程就是任务”这种错误的想法，线程与任务之间有一种明显的“是一个”关系，这会诱使人这样想“我应该从Thread中继承一个任务”，哈哈，这些想法都是错的<br>从概念上讲，我们希望创建独立于其他任务的任务，因此我们应该能够定义任何，然后说“开始”，并且不用操心其细节，<strong>但是在物理上，创建线程可能会代价高昂，因此必须保存并管理它们，这样，从现实的角度看，将任务从线程中分离出来时有意义的</strong><br>为了澄清这些讨论，我们接下来，将尝试着在描述将要执行的工作时使用术语“任务”，只有在引用到驱动任务的具体机制是，才使用“线程”</p>
<h3 id="加入一个线程"><a href="#加入一个线程" class="headerlink" title="加入一个线程"></a>加入一个线程</h3><p>一个线程可以在其他线程上调用join()方法，其效果是等待一段时间直到第二个线程结束才继续执行，如果某个线程是在另一个线程t上调用t.join()，此线程将被挂起，直到目标线程结束才恢复（即isAlive()返回false）<br>也可以在调用join()时带上一个超时参数（单位可以是毫秒，或者毫秒和纳秒），这样如果目标线程在这段时间到期时还没有结束的话，join()方法总能返回<br>对join()方法的调用可以被中断，做法是在调用线程上调用interrupt()方法，这时需要用到try{}catch(){}<br>下面演示这些操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sleeper</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> duration;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sleeper</span><span class="params">(String name,<span class="keyword">int</span> sleepTime)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        duration=sleepTime;</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sleep(duration);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            System.out.println(getName()+<span class="string">"was interrupted"</span></span><br><span class="line">            +<span class="string">"isInterrupted()"</span>+isInterrupted());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(getName()+<span class="string">"has awakened"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Joiner</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Sleeper sleeper;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Joiner</span><span class="params">(String name,Sleeper sleeper)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.sleeper=sleeper;</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sleeper.join();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"interrupted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(getName()+<span class="string">"join completed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Joining</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Sleeper sleepy=<span class="keyword">new</span> Sleeper(<span class="string">"Sleepy"</span>,<span class="number">1500</span>);</span><br><span class="line">        Sleeper grumpy=<span class="keyword">new</span> Sleeper(<span class="string">"Grumpy"</span>,<span class="number">1500</span>);</span><br><span class="line">        Joiner dopey=<span class="keyword">new</span> Joiner(<span class="string">"Dopey"</span>,sleepy);</span><br><span class="line">        Joiner doc=<span class="keyword">new</span> Joiner(<span class="string">"Doc"</span>,grumpy);</span><br><span class="line">        grumpy.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output</span></span><br><span class="line"><span class="comment">Grumpy was interrupted isInterrupted() false isInterrupted()总是返回false</span></span><br><span class="line"><span class="comment">Doc join completed</span></span><br><span class="line"><span class="comment">Sleepy has awakened</span></span><br><span class="line"><span class="comment">Dppey join completed</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
<p>Sleepy是一个Thread类型，我们通过向其构造器传入一个休眠的时间参数，让它休眠一段时间，sleep()方法有可能在指定时间返回，也可能被中断，在catch子句中，将根据IsInterrupted()的返回值报告这个中断，当另一个线程在该线程上调用interrupt()时，将给线程设定一个标识，标识这个线程的中断状态，然而异常被捕获时将清理这个标志，所以在catch子句中，在异常被捕获的时候这个标志总是为假，除了异常之外，这个标志还可用于其他情况，比如线程可能会检测其中断状态<br>Joiner线程将通过在Sleep对象上调用join()方法来等待Sleeper醒来，在main()中，每个Sleeper都有个Joiner,这可以从输出中发现，如果sleeper被中断或者正常结束，Joiner将和Sleeper一同结束<br>注意Java SE5de java.util.concurrent类库包含诸如CyclicBarrier,这样的工具，可能比最初的线程类型的join()更加合适</p>
<h3 id="创建有响应的用户界面"><a href="#创建有响应的用户界面" class="headerlink" title="创建有响应的用户界面"></a>创建有响应的用户界面</h3><h3 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h3><p>线程组持有线程的一个集合</p>
<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p>由于线程的本质特性，使得你不能捕获从线程中逃逸的异常，一旦异常逃逸出任务的run()方法它就会向外传播到控制台，除非你才有特殊的步骤捕获这种错误的异常，在java SE5之前，你需要线程组来捕获这些异常，现在你可以使用Executor来解决这个问题，因此你不再需要了解线程组的知识了<br>我们看下面的两个代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        exec.execute(<span class="keyword">new</span> ExceptionThread());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的程序运行之后会打印出栈信息<br>下面我们试着将上面关于线程的代码放在main()所在线程的try{}catch()里面看看会发生什么<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NaiaveExceptionHandling</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">            exec.execute(<span class="keyword">new</span> ExceptionThread());</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Exception has been handled"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果和上面一样，异常也是未被捕获<br><strong>为了解决这个问题，我们修改Executor产生线程的方式，Thread.UncaughtExceptionHandler是java SE5的新接口，它运行你在每个Thread对象上都附着一个异常处理器，Thread.UncaughtExceptionHandler.uncaughtException()会在线程因未捕获的异常而临近死亡时被调用</strong><br>为了使用它，我们创建一个新类型的ThreadFactory,它将在每个新创建的Thread对象上附着一个Threaed.UncaughtExceptionHandler,我们将这个工厂传递给Executors创建新的ExcutorService的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.jetbrains.annotations.NotNull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个任务将会抛出异常并打印出驱动它的线程和线程上的异常处理器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExceptionThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t=Thread.currentThread();</span><br><span class="line">        System.out.println(<span class="string">"run() by"</span>+t);</span><br><span class="line">        System.out.println(<span class="string">"eh="</span>+t.getUncaughtExceptionHandler());</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个异常处理器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyUncaughtExceptionHandler</span> <span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"caught"</span>+e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线程工厂,new的Thread都附着一个异常处理器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HandlerThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(@NotNull Runnable r)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>+<span class="string">"creating new Thread"</span>);</span><br><span class="line">        Thread t=<span class="keyword">new</span> Thread(r);</span><br><span class="line">        t.setUncaughtExceptionHandler(<span class="keyword">new</span> MyUncaughtExceptionHandler());</span><br><span class="line">        System.out.println(</span><br><span class="line">          <span class="string">"eh="</span>+t.getUncaughtExceptionHandler()</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span>  t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnCaptureUncaughtException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool(<span class="keyword">new</span> HandlerThreadFactory());</span><br><span class="line">        exec.execute(<span class="keyword">new</span> ExceptionThread2());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行上面的程序，将会看到任务抛出的异常将会被线程上的异常处理器捕获<br>上面的示例使得你可以按照具体情况逐个地设置处理器，如果你知道将要在代码中处处使用相同的异常处理器，那么更简单的方法是在Thread类中设置一个静态域，并将这个处理器设置为默认的未捕获异常处理器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SettingDefaultHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread.setDefaultUncaughtExceptionHandler(</span><br><span class="line">                <span class="keyword">new</span> MyUncaughtExceptionHandler()</span><br><span class="line">        );</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        exec.execute(<span class="keyword">new</span> ExceptionThread2());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个处理器只有在不存在线程专有的未捕获异常处理器的情况下才会被调用，系统会建厂线程专有版本，如果没有发现，则检查线程组中是否有其专有的unCaughtException()方法，如果还没有，再调用defaultUncaughtExceptionHandler</p>
<h2 id="共享受限资源"><a href="#共享受限资源" class="headerlink" title="共享受限资源"></a>共享受限资源</h2><p>可以把单线程程序当作问题域求解的单一实体，每次只能做一件事，因为只有一个实体，所以永远不用担心诸如“两个实体试图使用同一个资源”的问题<br>有了并发就可以同时做很多事情了，但是，两个或者多个线程彼此互相干涉的问题也就出现了</p>
<h3 id="不正确地访问资源"><a href="#不正确地访问资源" class="headerlink" title="不正确地访问资源"></a>不正确地访问资源</h3><p>考虑下面一个例子，其中一个任务产生偶数，而其他任务消费这些数字，这里消费者任务的唯一工作就是检查偶数的有效性<br>我们先定义一个Intgenerator，即生产者，再定义一个消费者，EvenChecker<br>下面定义了一个抽象类<br>IntGnerator有个cancel()方法，可以修改boolean类型的canceled标志的状态，各个在线程中执行的任务可以通过这个canceled来选择是否终止执行（线程驱动的任务终结），<strong>因为canceled标志是boolean类型的，所以它是原子性的，既诸如赋值和返回值这样的简单操作在发生时没有中断的可能，因此你就不会看到这个域处于只允许这些简单操作的过程的中间状态</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">IntGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> canceled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>&#123;canceled=<span class="keyword">true</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCanceled</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> canceled;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，在本例中可以被撤销的类不是Runnable，而是所有依赖于IntGennerator对象的EvenChceker任务将测试它，以查看他首发已经被撤销了，通过这种方式。共享公共资源的任务可以观察该类的终止信号（这里是canceled），这样就消除所谓竞争条件，即两个或更多的任务竞争响应某个条件，因此产生冲突或者不一致结果的情况，你可以执行考虑并防范系统失败的所有可能途径，例如，一个任务不能依赖另一个任务，因为任务关闭的顺序得不到保证，这里，<strong>通过使任务依赖于非任务对象，我们可以消除潜在的竞争条</strong><br>EvenChecker任务总是读取和测试从其相关的IntGenerator返回的值，注意，如果generator.isCanceled()为true，则run()返回，这将告知EvenChecker.test()中的Excutor该任务完成了，任何EvenChecker任务都可以与其相关联的IntGenerator上调用cancel()，这将导致所有其他使用该IntGenerator的EvenChecker得体地关闭<br>下面的例子执行之后，执行一段时间（经过执行，发现这段时间很短，几乎使得所有的线程执行的任务都退出了）后，会发现EvneGenerator产生了奇数，这在单线程是不可能存在的，但是在多线程中，线程是通过线程调度器取得的时间片段，在执行next()的时候，可能未将next()完之后就切换到其他线程开始继续执行，那么就会使EvenGenerator处于“不恰当”的状态，因此得出结论是如果想要使得多线程能够正常的执行，就必须保证这些共享资源（这里的共享资源是EvenGenerator）必须每一时刻（即使在切换线程前后）都要是“安全”的状态<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvenChecker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IntGenerator generator;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EvenChecker</span><span class="params">(IntGenerator g,<span class="keyword">int</span> ident)</span></span>&#123;</span><br><span class="line">        generator=g;</span><br><span class="line">        id=ident;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!generator.isCanceled())&#123;</span><br><span class="line">            <span class="keyword">int</span> val=generator.next();</span><br><span class="line">            <span class="keyword">if</span>(val%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(val+<span class="string">"note even!"</span>);</span><br><span class="line">                generator.cancel();<span class="comment">//cancels all EvenChecker</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//创建线程池，将任务传递给执行器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(IntGenerator gp,<span class="keyword">int</span> counter)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Press control-c to exit"</span>);</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;counter;i++)&#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> EvenChecker(gp,i));</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(IntGenerator gp)</span></span>&#123;</span><br><span class="line">        test(gp,<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvenGenerator</span> <span class="keyword">extends</span> <span class="title">IntGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentEvenValue=<span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ++currentEvenValue;<span class="comment">//danger point here</span></span><br><span class="line">        ++currentEvenValue;</span><br><span class="line">        <span class="keyword">return</span> currentEvenValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        EvenChecker.test(<span class="keyword">new</span> EvenGenerator());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解决共享资源竞争"><a href="#解决共享资源竞争" class="headerlink" title="解决共享资源竞争"></a>解决共享资源竞争</h3><p>前面的示例展示了使用线程的一个基本问题：你永远不知道一个线程何时在运行，这就导致一个问题，当你的线程开始去执行任务（对共享对象进行访问），此时这个共享对象的状态突然发生预期外的改变（通过其他线程的作用），这个时候你接下来的要访问的共享资源不再是你想要访问的共享资源了，这个时候就有可能会发生问题，我将这种情形解释为：“谁动了我的奶酪”，其实谁动了我的奶酪没有太大关系，重点是，如果这块奶酪依然可以被我享用，OK,其他人拿走了它，但是在我打算吃它的时候，有将它放在原处，没有问题，在我打算吃之前有人在上面加了一颗草莓也没什么太大关系，至少它还是奶酪啊，虽然它的状态发生了变化，也还好，但是如果有人在上面吐了一口水，那我就不能在吃了<br>这就关系到了线程协作问题，每一个线程都应该尽力保证当处理完共享资源的时候，贡献资源的状态应该是正常的<br><strong>对于并发问题，你需要某种方式来防止两个任务访问相同的资源</strong>（如果不加限制，在多处理器中，两个任务同时访问相同的资源是很正常的事情）至少在关键阶段不能出现这种情况<br><strong>防止这种冲突的方法就是当资源被一个任务使用时，在其上加锁，第一个访问某项资源的任务必须锁定这项资源，使得其他任务在其被解锁之前，就无法访问它了，而在其解锁之后，另一个任务就可以锁定并使用它，以此类推</strong><br><strong>基本上所有的并发模式在解决线程冲突问题的时候，都是采用序列化访问共享资源的方案</strong>，着意味着在给定的时刻只允许一个任务可以运行这段代码，<strong>因为锁语句产生了一种互相排斥的效果，所以这种机制常常被称为互斥量（mutex）</strong><br>java提供关键字synchronized的形式，为防止资源冲突提供了内置支持，当任务要执行被synchronized关键字保护的代码片段的时候，它将检查锁是否可用，然后获得锁，执行代码，释放锁<br>共享资源一般是以对象形式存在的内存片段，但也可以是文件hi安，输入和输出端口，或者是打印机，要控制对共享资源的访问，得先把它们包装在一个对象，然后把所有要访问这个资源的方法标记为synchronized<br>synchronized void f()<br>synchronized void g()<br>所有对象都自动含有单一的锁（也称为监视器），当在对象上调用其任意synchronized方法的时候，此对象就会被加锁，这时该对象上的其他synchronized方法只有等到前一个方法调用完毕并释放了锁之后才能被调用<br><strong>对于某个特定对象而言，其所有synchronized方法共享同一个锁</strong>，因此，当一个任务访问f()方法获得锁的时候，其他任务访问g()时也会遭到“拒绝”<br><strong>注意，在使用并发时，将域设置为private是非常重要的，否则，synchronized关键字就不能防止其他任务直接访问域，这样就会产生冲突</strong><br><strong>一个任务可以多次获得对象的锁，</strong>如果一个方法在同一个对象上调用第二个方法，后者又调用了同一个对象上的另一个方法，就会发生这种情况，jvm负责跟着对象被加锁的次数，如果一个对象被解锁（即锁被完全释放），其计数变0，在任务第一次给对象加锁的时候，计数变1，每当这个任务在这个对象上获得锁的时候，计数都会递增，显然，只有首先获得了锁的任务才能继续获取多个锁，每当任务离开一个synchronized方法的时候幂级数递减，当计数为0的时候，锁完全被释放，此时别的任务就可以使用此资源了<br><strong>针对每个类，也有一个锁（作为类的Class对象的一部分），所以synchronized static方法可以在类的范围内防止对static数据的并发访问</strong><br>你应该在什么时候同步呢？可以运用Brian的同步规则</p>
<blockquote>
<p>如果你正在写一个变量，它可能接下来将被另一个线程读取，或者正在读取一个上一次已经被其他线程写过的变量，那么你必须使用同步，并且，读写线程都必须使用相同的监视器锁同步<br><strong>如果你的类中有超过一个方法在处理临界数据，那么你必须同步所有相关的方法</strong>，如果只同步一个方法，那么其他的方法会随意地忽略这个对象锁，并可以在无任何惩罚的情况下被调用，这是很重要的一点，每个访问临界共享资源的方法都必须被同步，否则它们就不会正确地工作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedEvenGenerator</span> <span class="keyword">extends</span> <span class="title">IntGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentEvenValue=<span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span>  <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ++currentEvenValue;<span class="comment">//danger point here</span></span><br><span class="line">        Thread.yield();<span class="comment">//cause failure faster</span></span><br><span class="line">        ++currentEvenValue;</span><br><span class="line">        <span class="keyword">return</span> currentEvenValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        EvenChecker.test(<span class="keyword">new</span> EvenGenerator());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>使用Thread.yield()，以提高在currentEvenValue是奇数状态时上下文切换的可能性。因为互斥防止多个任务同时进入<strong>临界区</strong>，所以这不会产生任何失败</p>
<h4 id="使用显式的Lock对象"><a href="#使用显式的Lock对象" class="headerlink" title="使用显式的Lock对象"></a>使用显式的Lock对象</h4><p>java SE5的java.util.concuurent类库还包含有定义在java.util.concurrent.locks中的显式的互斥机制，Lock对象必须被显式地创建，锁定和释放，因此，它与内建的锁形式相比，代码缺乏优雅性，但是，对于解决某些类型的问题来说，它更灵活<br>下面是使用Lock重写的是SynChronizedEvenGenerator.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutexEvenGenerator</span> <span class="keyword">extends</span> <span class="title">IntGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentEvenValue=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ++currentEvenValue;</span><br><span class="line">            Thread.yield();</span><br><span class="line">            ++currentEvenValue;</span><br><span class="line">            <span class="keyword">return</span> currentEvenValue;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">          lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>MutexEvenGenerator添加了互斥调用的锁，并使用lock()和unlock()方法在next()内部创建临界资源，将这里所示的惯用法内部化是很重要的，紧接着是对lock()的调用，你必须放置在finally子句中带有unlock()的try-finally语句中，注意，return与语句必须在try子句中出现，以确保unlock()不会过早发生，从而将数据暴露给了第二个任务<br>尽管try-catch所需的代码比synchronized关键字多，但是这也代表了显示的Lock对象的优点之一：<strong>如果在使用synchronized关键字时，某些事物失败了，那么就会抛出一个异常，但是你没有机会去做任何清理工作，以维护系统使其处于良好状态，有了显式的Lock对象，你就可以使用finally子句将系统维护在正确的状态了</strong><br>一般情况下我们还是使用synchronized,因为代码量少，并且用户错误出现的可能性也会降低，因此通常只有在解决特殊问题时，才使用显式的Lock对象，例如，用synchronized关键字不能尝试着获取锁且最终获取锁会失败，或者尝试着获取锁一段时间，然后释放它，要实现这些，你必须使用concurrent类库<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AttemptLocking</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">untimed</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> captured=lock.tryLock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"tryLock()"</span>+captured);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(captured)&#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timed</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> captured=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            captured=lock.tryLock(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"tryLock(2.TimeUnit.SECONDS)"</span>+</span><br><span class="line">            captured);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(captured)&#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> AttemptLocking al=<span class="keyword">new</span> AttemptLocking();</span><br><span class="line">        al.untimed();<span class="comment">//true---lock is available;</span></span><br><span class="line">        al.timed();<span class="comment">//true --- lock is available;</span></span><br><span class="line">        <span class="comment">//Now create s separate task to grap the lock</span></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            &#123;setDaemon(<span class="keyword">true</span>);&#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                al.lock.lock();</span><br><span class="line">                System.out.println(<span class="string">"acquired"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        Thread.yield();</span><br><span class="line">        al.untimed();<span class="comment">//false--lock grabbed by task</span></span><br><span class="line">        al.timed();<span class="comment">//false--lock grabbed by task</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="原子性与易变性"><a href="#原子性与易变性" class="headerlink" title="原子性与易变性"></a>原子性与易变性</h3><p>在关于java线程的讨论中，一个不正常的知识是：“原子操作不需要进行同步控制”，原子操作是不能被线程调度机制中断的操作，一旦操作开始，那么它一定可以在可能发生的“上下文切换”前（切换到其他线程执行）执行完毕，依赖原子性是很棘手且危险的，记住，如果你是一个并发专家，你才应该使用原子性来替代同步，否则不要去考虑<br>了解原子性是很有用的，并且知道原子性与其他高级技术一道，在java.util.concurrent类库中已经实现了某些更加巧妙的构件，但是要坚决抵挡住完全依赖自己的能力去进行处理的这种欲望<br>原子性可以应用于除了long和double之外的所有基本类型之上的“简单操作”对于读取和写入除long和double之外的基本类型变量这样的操作，可以保证它们会被当作不可分（原子）的操作来操作内存，但是JVM可以将64位（long和double变量）的读取和写入当作两个分离的32位操作来执行，这就产生了在读取和写入的操作中间发生上下文切换，从而导致不同的任务可以看到不正常结果的可能性（有时这被称为“字撕裂”），因为你可能看到部分被修改的数值，当你定义long和double变量时，如果使用volatile关键字，就会获得（简单的赋值和返回操作的）原子性，不同的JVM可以任意地保证提供更强的保证，但是你不应该依赖于平台相关的特性<br>在多处理器系统（现在以多核处理器的形式出现，即在单个芯片上有多个CPU）上，相对于单线程系统而言，可视性问题远比原子性问题多得多，一个任务做出的修改，<strong>即使在不中断的意义上讲是原子性的，对其他任务也可能是不可视的，（例如，修改只是暂时性地存储在本地处理器的缓存上），因此不同的任务对应用有不同的视图，另一方面，同步机制强制在处理器系统中，一个任务做出的修改必须在应用中是可视的，如果没有同步机制，那么修改时可视就无法确定</strong><br><strong>volatile关键字还确保了应用中的可视性，如果你讲一个域声明为volatile的，那么只要对这个域产生了写操作，那么所有的写操作都可以看到这个修改，即使使用了本地缓存，情况也确实如此</strong>，volatile域会被写入到<strong>主存</strong>中，而读取操作就发生在<strong>主存</strong>上<br><strong>理解原子性和易变性是不同的概念这一点很重要</strong>，在非volatile域上的原子操作不必刷新到主存中去，因此其他读取该域的任务也不必看到这个新值，如果多个任务在同时访问某个域，那么这个域应该是volatile的，否则这个域就应该只能经由同步访问（也就是说，原子性只是保证了操作的完整性，而并不能保证在这些操作完成之后，其他的任务能够看到这些操作所做的修改），<strong>同步会导致向主存刷新</strong>，因此，如果一个域完全由synchronizied方法或语句块来防护（synchronized起到了两个效果，原子性和可视性都能得到保证），那就不必将其设置为valatile的<br><strong>一个任务所做的任何写操作对这个任务来说都是可视的，因此如果它只需要在这个任务内部可视，那么你就不需要将其设置为volatile</strong>(记住的是，每个任务或者说线程都对自己的操作是可视的，也就是说，我知道我做过那些事情，以及这些操作完成之后的，域的状态是什么，我都能获悉，所有对应我自己独有的域，不需要与其他任务共享的域来说，我不需要使用volatile关键字修饰域使得别的任务能够立即看到我做操作的结果，当操作结束之后不必刷新到主存，只要我自己能够看到它就可以)<br>当一个域的值依赖于它之前的值时（也就是说下次的计算要能获得上次正确的数），例如递增一个计数器，volatile就无法工作，如果某个域的值受到其他域的值的限制，那么valatile也无法工作，例如Range类的lower和upper边界就必须遵循lower&lt;upper<br>使用volatile而不是synchronized的唯一安全的情况是类中只有一个可变的域，再次提醒，你的第一选择是synchronized关键字，这是最安全的方式，而尝试其他任何方式都是有风险的<br>什么才属原子操作？对域中的值做赋值和返回操作通常都是原子性的，但是在java中<br>i++;<br>i+=2;<br>都不是原子性的，上述这些操作实际被分成了几个指令，因此在获取和放置指令之间，另一个任务可能会修改这个域，所有这些操作都不是原子性的<br>如果你盲目的使用原子性概念，那么你就会看到下面程序中的getValue()符合上面的描述<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicityTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> i;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">evenIncrement</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            evenIncrement();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ExecutorService exec=Executors.newCachedThreadPool();</span><br><span class="line">        AtomicityTest at=<span class="keyword">new</span> AtomicityTest();</span><br><span class="line">        exec.execute(at);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> val=at.getValue();</span><br><span class="line">            <span class="keyword">if</span> (val% <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(val);</span><br><span class="line">                System.exit(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的程序当找到奇数就终止，<strong>虽然reture i 确实是原子性的，但是缺乏同步（同步的意思也就是我拿到数据的时候和你的数据要保持一致，这就是同步的概念）使得其数值可以处在不稳定的中间状态时被读取，除此之外，由于i也不是volatile的，因此还存在可视性的问题，getValue()和evenIncrument()必须都是synchronized的</strong>，<br>第二个示例，考虑一些更简单的事情，一个产生序列数字的类，每当nextSerialNumber()被调用的时候，它必须向调用者返回唯一的值<br>SerialNumberGenerator很简单，如果在C++中serialNumber++这种递增操作是原子性的，因为C++递增可以作为一条微处理器指令来实现，但是在java，这种递增操作却不是，这里设立了一个读一个写操作，（我的理解是，本质上应该说这是JVM虚拟机造成的，对于相同意图的操作，各虚拟机的实现是不同的，因此也就造成了，相同的操作在不同的语言中的原子性不同）<br>基本上，如果一个域可能会被多个任务同时访问，或者这些任务中至少有一个是写入任务，那么你就应该将这个域设置为volatile的，如果你将一个域设置成volatile，那么它就会告诉编译器不要执行任何移出（原文写到是移除，我觉得应该是写错了）读取和写入操作的优化，这些操作的目的是用线程中的局部变量维护对这个域的精确同步。实际上，读取和写入都是针对内存的，而却没有被缓存，但是<strong>，volatile并不能对递增不是原子性操作这一事实产生影响</strong><br>我们从这两个例子得出的经验是，原子性操作并不会导致同步，原子性只保证操作是完整不可分的，但是多个任务的视图不一定相同<br>volatile导致了同步，但是不能保证操作的原子性<br>也就是为什么我们synchronized是我们并发编程的首选，因为这个关键字既保证了原子性，又保证了同步<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialNumberGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> serialNumber=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextSerialNumber</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serialNumber++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了测试SerialNumberGenerator，我们需要不会耗尽内存的集（Set）下面例子的CricularSet就是这样一个集合，这个例子很简单，我们创建了多个线程竞争序列数，判断集合中有无线程取到的序列数，如果没有，则将产生的序列数放入数组，如果集合中包含了该任务产生的序列数，那么说明了之前的线程产生的序列数和现在线程拿到的序列数相同了，如果nextSerialNumber()的操作是原子性的，不会发生这种情况，<strong>得出结论就是volatile保证了同步但是不能保证操作的原子性</strong><br>对基本类型的读取和赋值操作被认为是安全的原子性操作，但是，正如在AtomicityTest.java中看到的，当对象处于不稳定状态时，仍然很可能使用原子性来访问它们，对这个问题的假设是棘手和危险的，最明智的做法是遵循同步规则<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CricularSet</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CricularSet</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        array=<span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        len=size;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            array[i]=-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        array[index]=i;</span><br><span class="line">        <span class="comment">//wrap index and write over old element</span></span><br><span class="line">        index=++index%len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i]==val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialNumberChecker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CricularSet serials=<span class="keyword">new</span> CricularSet(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialChecker</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">               <span class="keyword">int</span> serial=SerialNumberGenerator.nextSerialNumber();</span><br><span class="line">               <span class="keyword">if</span>(serials.contains(serial))&#123;</span><br><span class="line">                   System.out.println(<span class="string">"Duplicate:"</span>+serial);</span><br><span class="line">                   System.exit(<span class="number">1</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               serials.add(serial);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;SIZE;i++)&#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> SerialChecker());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(args.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Integer(args[<span class="number">0</span>]));</span><br><span class="line">            System.out.println(<span class="string">"no duplicates detected"</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h3><p>Java SE5引入了诸如AtomicInteger,AtomicLong,AtomicReference等特殊的原子性变量类，它们提供了下面形式的原子性条件更新操作<br>boolean comparaAndSet(expectedValue,updateValue)<br>这些类被调整为可以使用在某些现代处理器上的可获得的，并且是在机器级别上的原子类，因此使用它们时，通常不需要担心，对于常规编程来说，它们很少会派上用场，但是涉及性能调优上，它们就大有用武之地了，例如，我们可以使用AtomicInteger来重写AtomicityTest.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Time;</span><br><span class="line"><span class="keyword">import</span> java.util.Timer;</span><br><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger i=<span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> i.get();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">evenIncrement</span><span class="params">()</span></span>&#123;i.addAndGet(<span class="number">2</span>);&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">           evenIncrement();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Timer().schedule(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.err.println(<span class="string">"Aborting"</span>);</span><br><span class="line">                System.exit(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">5000</span>);</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        AtomicIntegerTest ait=<span class="keyword">new</span> AtomicIntegerTest();</span><br><span class="line">        exec.execute(ait);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> val=ait.getValue();</span><br><span class="line">            <span class="keyword">if</span>(val%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(val);</span><br><span class="line">                System.exit(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们通过使用AtomicInterger而消除了synchronized关键字，因为这个程序不会失败，所以我们添加了一个Timer，以便在5秒后终结程序<br>Atomic类被设计的目的主要是为了重建java.util.concurrent中的类，因此只有在特殊情况下才会使用它们，通常依赖锁更安全一些（要么使用synchronized关键字或者显式的Lock）</p>
<h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p><strong>有时，你只是希望防止多个线程同时访问方法内部的部分代码而不是防止整个方法，通过这种方式分离出来的代码段被称为临界区（critical section）</strong>，它也是使用synchronized建立的，这里synchronized被用来指定某个对象，此对象的锁可以被用来对花括号内的代码进行同步的控制<br>    synchronized(synObject){<br>      //this code can be accessed<br>      //by only one task at a time<br>    }<br>这样被称为同步块，在进入此段代码前，必须得到synObject对象的锁，如果其他线程已经得到了这个锁，那么就得等到锁被释放以后，才能进入临界区<br>通过同步块，而不是对整个方法进行同步控制，可以使得多个任务访问对象的时间性能得到显著的提升<br>下面的例子演示了，如何将一个非保护类型的类，在其他类的保护和控制之下，应用于多线程的环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line">package xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">class Pair&#123;</span><br><span class="line">    private int x;</span><br><span class="line">    private int y;</span><br><span class="line">    public Pair(int x,int y)&#123;</span><br><span class="line">        this.x=x;</span><br><span class="line">        this.y=y;</span><br><span class="line">    &#125;</span><br><span class="line">    public Pair()&#123;this.x=0;this.y=0;&#125;</span><br><span class="line">    public int getX()&#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getY()&#123;</span><br><span class="line">        return y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void incrementX()&#123;x++;&#125;</span><br><span class="line">    public void incrementY()&#123;y++;&#125;</span><br><span class="line">    public String toString()&#123;</span><br><span class="line">        return &quot;x:&quot;+x+&quot;,y:&quot;+y;</span><br><span class="line">    &#125;</span><br><span class="line">    public class PairValuesNoEqualException</span><br><span class="line">    extends Exception&#123;</span><br><span class="line">        public PairValuesNoEqualException()&#123;</span><br><span class="line">            super(&quot;Pair values not equals&quot;+Pair.this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void checkState()throws PairValuesNoEqualException&#123;</span><br><span class="line">        if(x!=y)&#123;</span><br><span class="line">            throw new PairValuesNoEqualException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract class PairManager&#123;</span><br><span class="line">    AtomicInteger checkcounter=new AtomicInteger(0);</span><br><span class="line">    protected Pair pair=new Pair();</span><br><span class="line">    private List&lt;Pair&gt; storage= Collections.synchronizedList(new ArrayList&lt;Pair&gt;());</span><br><span class="line">    public synchronized Pair getPair()&#123;</span><br><span class="line">        return new Pair(pair.getX(),pair.getY());</span><br><span class="line">    &#125;</span><br><span class="line">    protected void store(Pair pair)&#123;</span><br><span class="line">        storage.add(pair);</span><br><span class="line">        try&#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(50);//在这里故意增加了持有锁的时间</span><br><span class="line">        &#125;catch(InterruptedException e)&#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract void increment();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PairManager1 extends PairManager&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public synchronized  void increment() &#123;</span><br><span class="line">       pair.incrementX();</span><br><span class="line">       pair.incrementY();</span><br><span class="line">       store(getPair());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PairManager2 extends PairManager&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void increment() &#123;</span><br><span class="line">        Pair temp;</span><br><span class="line">        synchronized (this)&#123;</span><br><span class="line">           pair.incrementX();</span><br><span class="line">           pair.incrementY();</span><br><span class="line">           temp=getPair();</span><br><span class="line">        &#125;</span><br><span class="line">        store(temp);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PairManipulator implements Runnable&#123;</span><br><span class="line">    private PairManager pm;</span><br><span class="line">    public PairManipulator(PairManager pm)&#123;</span><br><span class="line">        this.pm=pm;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            pm.increment();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String toString()&#123;</span><br><span class="line">        return &quot;Pair:&quot;+pm.getPair()+&quot;checkCouter=&quot;+pm.checkcounter.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PairChecker implements Runnable&#123;</span><br><span class="line">    private PairManager pm;</span><br><span class="line">    public PairChecker(PairManager pm)&#123;</span><br><span class="line">        this.pm=pm;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                pm.checkcounter.incrementAndGet();</span><br><span class="line">                pm.getPair().checkState();</span><br><span class="line">            &#125;catch(Pair.PairValuesNoEqualException e)&#123;</span><br><span class="line">                System.out.println(&quot;NoEqual&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class CriticalSection &#123;</span><br><span class="line">    static void testApproaches(PairManager pman1,PairManager pman2)&#123;</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        PairManipulator pm1=new PairManipulator(pman1);</span><br><span class="line">        PairManipulator pm2=new PairManipulator(pman2);</span><br><span class="line">        PairChecker pc1=new PairChecker(pman1);</span><br><span class="line">        PairChecker pc2=new PairChecker(pman2);</span><br><span class="line">        exec.execute(pm1);</span><br><span class="line">        exec.execute(pm2);</span><br><span class="line">        exec.execute(pc1);</span><br><span class="line">        exec.execute(pc2);</span><br><span class="line">        try&#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(500);</span><br><span class="line">        &#125;catch(InterruptedException e)&#123;</span><br><span class="line">            System.out.println(&quot;Sleep interrupted&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;pm1:&quot;+pm1+&quot;\npm2&quot;+pm2);</span><br><span class="line">        System.exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main()&#123;</span><br><span class="line">        PairManager pman1=new PairManager1();</span><br><span class="line">        PairManager pman2=new PairManager2();</span><br><span class="line">        testApproaches(pman1,pman2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的例子Pair不是线程安全的，因为它的约束条件（虽然是任意的）需要两个变量维持成相同的值，，在本例中，自增加操作不是线程安全的，并且因为没有任何方法被标记为synchronzied，所以不能保证一个Pair对象在多个线程中不会被破环<br>想象这样一种情况，<strong>你有一个非线程安全的Pair类，而你需要在一个线程安全的环境中去使用它，通过创建PairManager类可以做到这一点</strong>，PairManager持有一个Pair对象并控制它的一切访问，注意唯一public方法是getPair(),它是同步的（它也应当是同步的，要想在线程安全的情况下访问一个线程不安全的对象，此时必须保证访问这个对象的时候，对于这个类的视图必须是最新且是状态是正常的）,对于抽象方法increment()，对于同步的控制将在子类的实现中进行处理，<strong>我们可以看到在子类实现的方法中添加了synchronized关键字，因为不属于方法签名的一部分，所有这是被允许的</strong><br>store()方法将一个Pair对象添加到了synchronizedArrayList中，所以这个方法是安全的，不需要进行防护<br>PairManager1和PairManager2对increment()的实现不同，一个是对整个方法进行同步控制，一个是对方法的一部分进行同步控，PairMainpulate被创建来测试这两个不同实现，而PairCheck是在另一个任务中执行，为了跟踪可以运行测试的额度，PairChecker在每次成功时都会递增checkcounter<br>每次运行的结果都会不一样，但一般的来说，对于PairChecker的检查频率，PairManager1.increment()没有PairManager2.increment()多（因为前者持有锁的时间比较长，对于getPair()的调用也需要获得锁，因此，相同的时间，它获取锁的次数就少），后者采用的是同步块进行同步，所以对象不加锁的时间更长，这也是宁愿使用同步控制块而不是对整个方法进行同步控制的典型原因，使得其他线程能够更多地访问（在安全的情况下尽可能多）<br>结论就是，不要让一个方法持有锁的时间过长，这样会增加其他的线程访问这个类其他synchronized方法（包含持有锁的方法本身）的等待时间，性能大打折扣<br>解决方案就是，只在方法内部对那些访问线程不安全的类的方法进行同步，对线程安全的类的访问不加同步控制，上面的例子，Pair是非线程安全的类，对它的访问，incrementX()和incrementY()加上synchronized访问控制，对线程安全的synchronizedArrayList的add()方法不加同步控制<br>你也可以使用显示的Lock对象来创建临界区,下面的两个例子简单看下就好<br>//synchronized the entire method<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExplicitPairManager1</span> <span class="keyword">extends</span> <span class="title">PairManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            pair.incrementX();</span><br><span class="line">            pair.incrementY();</span><br><span class="line">            store(getPair());</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>//Use a critical section<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExplicitPairManager2</span> <span class="keyword">extends</span> <span class="title">PairManager</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">           lock.lock();</span><br><span class="line">           pair.incrementX();</span><br><span class="line">           pair.incrementY();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        store(getPair());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="在其他对象上同步"><a href="#在其他对象上同步" class="headerlink" title="在其他对象上同步"></a>在其他对象上同步</h3><p>synchronized块必须给定一个在其上进行同步的对象，并且最合理的方式，使用其方式正在被调用的当前对象，synchronized(this)<br><strong>有时必须在另一个对象上同步，但是如果你要这么做，就必须确保所有相关的任务都是在同一个对象上同步的</strong><br>下面演示了两个任务可以同时进入同一个对象，只要这两个对象上的方法是在不同的锁上同步的即可<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DualSynch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object synObject=<span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span>  <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">"f()"</span>);</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (synObject)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">                System.out.println(<span class="string">"g()"</span>);</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> DualSynch dualSynch=<span class="keyword">new</span> DualSynch();</span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">               dualSynch.f();</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        dualSynch.g();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从输出可以看出，因为对不同的对象进行同步，所有这两个方法的执行是同时进行的，没有任何一一个方法阻塞了另一个方法</p>
<h3 id="线程本地存储"><a href="#线程本地存储" class="headerlink" title="线程本地存储"></a>线程本地存储</h3><p><strong>防止线程在共享资源上产生冲突的第二种方式是根除对变量的共享</strong>，线程本地存储是一种自动化机制，可以为使用相同变量的每个不同的线程都创建不同的存储，因此如果你有5个线程都要使用变量x所表示的对象，那线程本地存储会产生5个用于x的不同的存储块，主要是它们使得你可以将状态与线程关联起来<br>创建和管理线程本地存储可以由java.lang.ThreadLocal类来实现，如下所示、<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Accessor</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Accessor</span><span class="params">(<span class="keyword">int</span> ident)</span></span>&#123;<span class="keyword">this</span>.id=ident;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">            ThreadLocalVariableHolder.increment();</span><br><span class="line">            System.out.println(<span class="keyword">this</span>);</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"#"</span>+id+<span class="string">":"</span>+</span><br><span class="line">                ThreadLocalVariableHolder.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalVariableHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; value=</span><br><span class="line">            <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;()&#123;</span><br><span class="line">               <span class="keyword">private</span> Random rand=<span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">               <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Integer <span class="title">initialValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">                   <span class="keyword">return</span> rand.nextInt(<span class="number">1000</span>);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</span><br><span class="line">        value.set(value.get()+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> value.get();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> Accessor(i));</span><br><span class="line">        &#125;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);<span class="comment">//run for a while</span></span><br><span class="line">        exec.shutdownNow();<span class="comment">//all Accessors will quit</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output</span></span><br><span class="line"><span class="comment">#0:953</span></span><br><span class="line"><span class="comment">#1:823</span></span><br><span class="line"><span class="comment">#2:834</span></span><br><span class="line"><span class="comment">#3:453</span></span><br><span class="line"><span class="comment">#4:324</span></span><br><span class="line"><span class="comment">#0:954</span></span><br><span class="line"><span class="comment">#1:824</span></span><br><span class="line"><span class="comment">#2:835</span></span><br><span class="line"><span class="comment">#3:454</span></span><br><span class="line"><span class="comment">#4:325</span></span><br><span class="line"><span class="comment">....</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
<p>TheadLocal对象通常作为静态域存储，在创建ThreadLocal时，你只能通过get()和set()方法来访问该对象的内容，其中，get()将返回与其线程相关联的对象的副本，而set()方法会将参数插入到其为线程存储的对象中，并返回存储中原有的对象，上面的输出也说明了，ThreadLocal<integer>对象为每一个线程都创建了不同的存储来保存Integer的值，这些值在线程间是不共享的，只对自己的线程可见</integer></p>
<h2 id="终结任务"><a href="#终结任务" class="headerlink" title="终结任务"></a>终结任务</h2><p>我们在前面的示例中看到cancel()和isCancel()方法被放在了一个所有任务都可以看到的类中（也就说canceled变量是共享的，通过这个标志来控制线程的终止，任务结束线程终止），对于这个问题来说，这是一种合理的情况，但是，在某些情况下，任务必须更加突然地终止（在之前的例子中，任务是通过判断条件来终止的）<br>下面是一个仿真程序，花园委员会希望了解每天通过多个大门进入公园的总人数，每个大门都有一个十字转门或某种其他形式的计数器，并且任何一个十字转门的计数值递增时，就表示公园中的总人数的共享计数器也会递增</p>
<h3 id="装饰性花园"><a href="#装饰性花园" class="headerlink" title="装饰性花园"></a>装饰性花园</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Count</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Random rand=<span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">increment</span><span class="params">()</span></span>&#123;<span class="comment">//因为Count是共享资源，所以对它读写要同步</span></span><br><span class="line">        <span class="keyword">int</span> temp=count;</span><br><span class="line">        <span class="keyword">if</span>(rand.nextBoolean())&#123; <span class="comment">//yield half the time</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (count=++temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>&#123;<span class="comment">//同步读取，这样避免获得count变量的中间状态</span></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Entrance</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Count count=<span class="keyword">new</span> Count();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Entrance&gt; enterances=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span>  <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> canceled=<span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">concel</span><span class="params">()</span></span>&#123;canceled=<span class="keyword">true</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Entrance</span><span class="params">(<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id=d;</span><br><span class="line">        enterances.add(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!canceled)&#123;</span><br><span class="line">        <span class="comment">//这里Thinking in java的作者对于number加synchronized是有必要的,因为它创建了5个任务实体交给线程去执行，也就是说每个线程与一个任务相关联，它只执行和它相关联的任务，所以就对每个Runnable（既Entrance）没有产生竞争，产生竞争的是Count，而不是任务</span></span><br><span class="line">        可以先看main()方法中创建线程的方式就可以明了 </span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">                ++number;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>+<span class="string">"   Total: "</span>+count.increment());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"sleep interrupted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Stoping "</span>+<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>&#123;<span class="comment">//加synchronized是没有必要的</span></span><br><span class="line">        <span class="keyword">return</span>  number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Entrance"</span>+id+<span class="string">":"</span>+getValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getTotalCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count.value();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sumEntrances</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Entrance enterance:enterances)&#123;</span><br><span class="line">            sum+=enterance.getValue();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrnametalGargen</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">    <span class="comment">//这里是为每一个线程都创建一个任务实体，也就是说每一个线程去驱动任务实体中的run方法，</span></span><br><span class="line">    <span class="comment">//对于每一个任务实体来说，它不是共享的，因此也就不会产生竞争，像下面这样，</span></span><br><span class="line">    <span class="comment">//就会产生竞争，对任务实体来说，对它的读写才要进行同步</span></span><br><span class="line">    <span class="comment">//            Entrance entrance=new Entrance();</span></span><br><span class="line">    <span class="comment">//            exec.execute(entrance)</span></span><br><span class="line">          exec.execute(<span class="keyword">new</span> Entrance(i));</span><br><span class="line">        &#125;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        Entrance.concel();<span class="comment">//将标志位canceled设为true，使各线程结束运行</span></span><br><span class="line"></span><br><span class="line">        exec.shutdown();</span><br><span class="line">        <span class="comment">//TimeUnit.SECONDS.sleep(1);我在这里可以使主线程再休眠1秒，这样1秒后线程池里就不在有等待终结的线程了（理论上是这样的）</span></span><br><span class="line">        <span class="keyword">if</span>(!exec.awaitTermination(<span class="number">250</span>,TimeUnit.MILLISECONDS))&#123;<span class="comment">//250是设置的一个超时时间，我在上面可以多加1秒的时间</span></span><br><span class="line">            System.out.println(<span class="string">"Some tasks ware not terminated!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Total"</span>+Entrance.getTotalCount());</span><br><span class="line">        System.out.println(<span class="string">"Sum of Entrance:"</span>+Entrance.sumEntrances());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用单个Count对象来跟着花园参观者的主总计值，并且将其当作Entrance类中的一个静态域进行存储，Count.increment()和Count.value()都是synchronized的，用来控制对Count的访问，increment()方法使用了Random对象，目的是在从把count读取到temp中，到递增temp并将其存储回count的这段时间里，大约一般的时间产生让步，如果你讲synchronized关键字注释掉，那么程序就会崩溃，因为多个任务将同时访问并修改count（yield()会使问题更快地发生），所有这里对count的操作要是synchronized修饰，即要同步<br>每个Entrance任务都维护着一个本地值number，它包含了通过某个特定入口进入的参观者的数量，这提供了对count对象的双重检查，以确保其记录的参观者数量是正确的，Entrance.run()只是递增number和count对象，然后休眠100毫秒<br>因为Entrance.canceled是一个volatile（保证同步）布尔标志，而它只会被读取和赋值（也就是说这些操作是原子性的）（不会与其他线程域组合在一起读取），所有不需要对其进的访问，就可以安全地操作它，如果你对诸如此类的情况有疑问的话，那么最好总是使用synchronized<br>这个程序在以稳定的方式关闭所有事物方面还有一些小麻烦，其部分原因是为了说明在终止多线程程序时你必须相当小心，而另一部分原因是为了演示interrupt()的值，稍后会学到这个知识<br>在三秒之后，main()向Entrance发送static cancel()消息，然后调用exec对象的shutdown()方法，之后调用exec上的awaitTermination()方法，ExecutorService.awaitTermination()等待每个任务结束，如果所有的任务在超时时间到达之前全部结束，则返回true，否则返回fasle,表示不是所有任务都已经结束，尽管这会导致每个任务都会退出run()，并因此作为任务而终止，但是Entrance对象仍然有效，因为在构造器中，每个Entrance都存储在被称为entrances的静态List<entrance>中，因此，宿命Entrances()仍旧可以工作于这些有效的Entrance对象上（这给了我们启示，要想任务对象在任务结束后仍旧有效，可以用一个引用能够引用到它，这样才不会被垃圾回收机制回收掉）</entrance></p>
<h3 id="在阻塞时终结"><a href="#在阻塞时终结" class="headerlink" title="在阻塞时终结"></a>在阻塞时终结</h3><p>前面的示例中的Entrance.run()在其循环中包含了对sleep的调用，我们知道，sleep()最终将唤醒，上面的示例，当线程“醒来时”，又重新从while开始处检查canceled的标志，以决定是否跳出循环，结束任务，但是，<strong>sleep()的一种情况，它使任务从执行状态变为阻塞状态，而有时你必须终止被阻塞的任务</strong></p>
<h4 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h4><p>一个线程可以处于一下四种状态之一：</p>
<ol>
<li>新建（new）：当下线程被创建时，它只会短暂地处于这种状态，此时它已经分配了必须的系统资源，并执行了初始化，此刻线程已经有资格获得CPU时间了，之后调度器将把这个线程转变为可运行状态或阻塞</li>
<li>就绪（Runnbale）:在这种状态下，只要调度器把时间片分配给线程，线程就可以运行，也就是说，在任意时刻，线程可以运行也可以不运行，只要调度器能分配时间片给线程，它就可以运行，这不同于死亡或阻塞状态</li>
<li>阻塞（Blocked）:线程能够运行，但有某个条件阻止它的运行，当线程处于阻塞状态时，调度器将忽略线程，不会分配线程任何CPU时间，直到线程重新进入就绪状态，它才有可能执行操作</li>
<li>死亡（Dead）：处于死亡或终止状态的线程将不再是可调度的，并且再也不会得到CPU时间，它的任务已经结束，或不再是可运行的，任务死亡的通常方式是从run()返回，但是任务的线程还可以被中断<h4 id="进入阻塞状态"><a href="#进入阻塞状态" class="headerlink" title="进入阻塞状态"></a>进入阻塞状态</h4>一个任务进入阻塞状态，可能有如下原因：</li>
<li>通过调用sleep(milliseconds)使任务进入休眠状态，在这这种情况下，任务在指定的时间内不会运行</li>
<li>你通过调用wait()是线程挂起，直到线程得到notify()或者notifyAll()消息（或者在java SE5的java.util.concurent类库中等价的signal()或signalAll()消息），线程才会进入就绪状态</li>
<li>任务在等待某个输入/输出完成</li>
<li>任务试图在某个对象上调用其同步控制方法，但是对象锁不可用，因为另一个任务已经获取了这个锁<br>在较早的代码中可能会看到suspend()和resume()来阻塞和唤醒线程，但是在现代java中这些方法已经 被废止了（因为可能导致死锁），所以不再讨论，stop()方法也废止了，不需要去研究<br>我们来看看我们的问题：有时你希望能够终止处于阻塞状态的任务。如果对于处于阻塞状态的任务，你不能等待其达到代码中可以检查其状态值这一点，因而决定让他主动地终止，那么你就必须强制这个任务跳出阻塞状态</li>
</ol>
<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>正如你所想象的，在Runnable.run()的方法内部打断它，与等待该方法到达对cancel标志（之前的示例）的测试，或者到达程序员准备好离开该方法的其他地方相比，要棘手一些，当你打断被阻塞的任务时，可能需要清理资源，正因为这一点，在任务的run()方法中间打断，更像是抛出的异常，因此在java线程的这种类型的异常中断中用到异常（这是为什么我们在调用一些使得线程阻塞的方法时总是要捕获异常，以防止线程会在阻塞状态期间被打断之后进行后续资源的清理工作），为了以这种方式终止任务，返回众所周知的良好状态，你必须仔细考虑代码的执行路径，并仔细编写catch子句以争取清除所有事物<br><strong>Thread类包含interrupt()方法，因此你可以终止被阻塞的任务，这个方法将设置线程的中断状态，如果一个线程已经被阻塞，或者试图执行一个阻塞操作，那么设置这个线程的中断状态将抛出InterruptedException</strong>（这里也就明白了，异常并不一定要在阻塞那里被抛出，当已经处于阻塞状态时，中断任务（调用Thread类的interrupt()），会创建异常对象，这些异常对象除了异常信息外，其实虚拟机还初始化了很多关于这个异常的信息，这个异常对象会被包好它的类的异常处理器所捕获到，注意，我们编写的catch语句其实就是在给这个类创建异常处理器而已，剩下的事情编译器会帮我们做），<strong>当抛出异常或者该任务调用Thread.interrupted()时，中断状态将被复位</strong>。正如将会看到的，Thread.interrupted()提供了离开run()循环而不抛出异常的第二种方式<br>为了调用Thread.interrupt()，你必须持有Thread对象，但是新的concurrent类库似乎在避免多Thread对象的直接操作，转而尽量通过Executor来执行所有操作，如果你在Excutor上调用shutdownNow(),那么它将发送一个interrupt()调用给它启动的所有线程，这么做是有意义的，因为当你完成工程中的某一个部分或者整个程序时，通常会希望同时关闭某个特定Executor的所有任务，然而，你有时也希望只中断某个单一任务，如果使用Executor，那么通过调用submit()而不是execute()来启动任务，就可以持有该任务的上下文，summit将返回一个泛型Future&lt;?&gt;,其中有一个为修饰的参数，因此你永远都不会在其上调用get()——持有这个Future的关键是在于你可以在其上调用cancel()，并因此可以使用它来中断某个特定任务，如果你将true传递给cancel()，那么它就会拥有在该线程上调用interrupt()以停止这个线程的权限，因此，cancel()是一种中断由Executor启动的单个线程的方式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.sql.Time;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="comment">//休眠状态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SleepBlocked</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"InterruptedException"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Exiting SleepBlocked.run()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//I/O阻塞</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IOBlocked</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> InputStream in;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IOBlocked</span><span class="params">(InputStream is)</span></span>&#123;in=is;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Waiting for Read():"</span>);</span><br><span class="line">            in.read();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                System.out.println(<span class="string">"Interrupted from blocked I/O"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Exiting IOBlocked.run()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同步阻塞</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SynchronizedBlocked</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;<span class="comment">//never release lock</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SynchronizedBlocked</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;<span class="comment">//匿名线程获得对象锁</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                f();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"trying to call f()"</span>);</span><br><span class="line">        f();</span><br><span class="line">        System.out.println(<span class="string">"Exiting SynchronizedBlocked.run()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interrupting</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Runnable r)</span><span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        Future&lt;?&gt; f=exec.submit(r);</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">"Interrupting"</span>+r.getClass().getName());</span><br><span class="line">        f.cancel(<span class="keyword">true</span>);<span class="comment">//interrupts if running</span></span><br><span class="line">        System.out.println(<span class="string">"Interrupt sent to "</span>+r.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        test(<span class="keyword">new</span> SleepBlocked());</span><br><span class="line">        test(<span class="keyword">new</span> IOBlocked(System.in));</span><br><span class="line">        test(<span class="keyword">new</span> SynchronizedBlocked());</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">"Aborting with System exit(0)"</span>);</span><br><span class="line">        System.exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的每个任务表示了三种不同类型的阻塞，这个程序证明I/O和在synchronized块上的等待是不可中断的，但是浏览代码，可以发现——无论是I/O还是尝试调用synchronzied,都是不需要任何InterruptedException处理器<br>上面的代码有一些注意的，前两个代码很简单，但是为了演示SynchronizedBlocked,我们在任务构造器中创建一个匿名的线程调用f()获得对象锁（这个线程必须区别于为SynchronizedBlocked驱动run()的线程，因为同一个线程可以多次获得某个对象的锁）<br><strong>从输出中可以看到，你能够中断对sleep()的调用（或者任何要求抛出InterruptedException的调用），但是你不能中断正在尝试获得synchronized锁或者试图执行I/O操作的线程</strong>，这一点令人烦恼，特别是在创建执行I/O的任务时，因为这意外这I/O具有锁住你的多线程程序的可能，特别是在基于Web的程序，这更是关乎利害<br>对于这类问题，有一个略显笨拙但确实行之有效的解决方案，即关闭任务在其上发生阻塞的底层资源<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloseResource</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        ServerSocket server=<span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</span><br><span class="line">        InputStream socketInput=<span class="keyword">new</span> Socket(<span class="string">"localhost"</span>,<span class="number">8080</span>).getInputStream();</span><br><span class="line">        exec.execute(<span class="keyword">new</span> IOBlocked(socketInput));</span><br><span class="line">        exec.execute(<span class="keyword">new</span> IOBlocked(System.in));</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">"Shutting down all thread"</span>);</span><br><span class="line">        exec.shutdownNow();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"Closing"</span>+socketInput.getClass().getName());</span><br><span class="line">        socketInput.close();<span class="comment">//Releases blocked thread</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"Colsing"</span>+System.in.getClass().getName());</span><br><span class="line">        System.in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>运行上面程序，可以得知，在shutdownNow()被调用之后已经在两个输入流上调用close()之前的延迟强调的是：一旦底层资源被关闭任务将被解除阻塞</strong><br><strong>幸运的是，java SE5新添加的各种nio类提供了更加人性化的I/O中断，被阻塞的nio通道会自动地相应中断</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousCloseException;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ClosedByInterruptException;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.ServerCloneException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NIOBlocked</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SocketChannel sc;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NIOBlocked</span><span class="params">(SocketChannel sc)</span></span>&#123;<span class="keyword">this</span>.sc=sc;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Writing for read() in "</span>+<span class="keyword">this</span>);</span><br><span class="line">            sc.read(ByteBuffer.allocate(<span class="number">1</span>));</span><br><span class="line">        &#125;<span class="keyword">catch</span>(ClosedByInterruptException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"closedByInterruptException"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (AsynchronousCloseException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"AsynchronousCloseException"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Exiting NIOBlocked.run()"</span>+<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOinterruption</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        ServerSocket server=<span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</span><br><span class="line">        InetSocketAddress isa=<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>,<span class="number">8080</span>);</span><br><span class="line">        SocketChannel sc1=SocketChannel.open(isa);</span><br><span class="line">        SocketChannel sc2=SocketChannel.open(isa);</span><br><span class="line">        Future&lt;?&gt; f=exec.submit(<span class="keyword">new</span> NIOBlocked(sc1));</span><br><span class="line">        exec.execute(<span class="keyword">new</span> NIOBlocked(sc2));</span><br><span class="line">        exec.shutdown();<span class="comment">//无法关闭I/O阻塞的线程</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//produce an interrupt via cancel</span></span><br><span class="line">        f.cancel(<span class="keyword">true</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//release the block by closing the channel</span></span><br><span class="line">        sc2.close();<span class="comment">//你也可以通过关闭底层资源释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="被互斥所阻塞"><a href="#被互斥所阻塞" class="headerlink" title="被互斥所阻塞"></a>被互斥所阻塞</h4><p><strong>就像之前在不可中断的I/O中所观察的那样，无论在任何时候，只要任务以不可中断的方式被阻塞了，那么都有潜在的会锁住程序的可能</strong><br>java SE5并发类库中添加了一个特性，即在ReentrantLock上阻塞的任务具备可以被中断的能力，这与在synchronized方法或者临界区上阻塞的任务完全不同<br>与I/O调用不同，interrupt()可以打断被互斥所阻塞的调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockedMutex</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlockedMutex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();<span class="comment">//总是持有锁不释放</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//this will never be available to a second task</span></span><br><span class="line">            lock.lockInterruptibly();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Interrupted form lock acquisition in f()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blocked2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    BlockedMutex blocked=<span class="keyword">new</span>  BlockedMutex();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"waiting for f() in BlockedMutex"</span>);</span><br><span class="line">        blocked.f();</span><br><span class="line">        System.out.println(<span class="string">"Broken out of blocked call"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interrupting2</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">      Thread t=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Blocked2());</span><br><span class="line">      t.start();</span><br><span class="line">       TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">       System.out.println(<span class="string">"Issuing t.interrupt"</span>);</span><br><span class="line">       t.interrupt();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="检查中断"><a href="#检查中断" class="headerlink" title="检查中断"></a>检查中断</h3><h2 id="线程之间的协作"><a href="#线程之间的协作" class="headerlink" title="线程之间的协作"></a>线程之间的协作</h2><h3 id="wait-和notifyAll"><a href="#wait-和notifyAll" class="headerlink" title="wait()和notifyAll()"></a>wait()和notifyAll()</h3><h3 id="notify-和notifyAll"><a href="#notify-和notifyAll" class="headerlink" title="notify()和notifyAll()"></a>notify()和notifyAll()</h3><h3 id="生产者与消费者"><a href="#生产者与消费者" class="headerlink" title="生产者与消费者"></a>生产者与消费者</h3><h3 id="生产者与消费者队列"><a href="#生产者与消费者队列" class="headerlink" title="生产者与消费者队列"></a>生产者与消费者队列</h3><h3 id="线程之间使用管道进行输入-输出"><a href="#线程之间使用管道进行输入-输出" class="headerlink" title="线程之间使用管道进行输入/输出"></a>线程之间使用管道进行输入/输出</h3><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/27/并发/" data-id="cjnuv3jnl003rucrz48t7gonq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2018/10/19/注解/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">注解</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/学习心得/">学习心得</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML5/">HTML5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Maven/">Maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Oracle/">Oracle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-MVC/">Spring MVC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-boot/">Spring boot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-cloud/">Spring cloud</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/HTML5/" style="font-size: 10px;">HTML5</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/Node-js/" style="font-size: 10px;">Node.js</a> <a href="/tags/Oracle/" style="font-size: 10px;">Oracle</a> <a href="/tags/Spring/" style="font-size: 10px;">Spring</a> <a href="/tags/Spring-MVC/" style="font-size: 10px;">Spring MVC</a> <a href="/tags/Spring-boot/" style="font-size: 10px;">Spring boot</a> <a href="/tags/Spring-cloud/" style="font-size: 10px;">Spring cloud</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/10/27/并发/">并发</a>
          </li>
        
          <li>
            <a href="/2018/10/19/注解/">注解</a>
          </li>
        
          <li>
            <a href="/2018/10/19/枚举类型/">枚举类型</a>
          </li>
        
          <li>
            <a href="/2018/10/19/Java-I-O系统/">Java I/O系统</a>
          </li>
        
          <li>
            <a href="/2018/10/19/容器深入研究/">容器深入研究</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 EgbertDay<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>