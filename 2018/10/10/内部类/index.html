<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>内部类 | 代海峰</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前言&amp;emsp;&amp;emsp;可以将一个类的定义放在另一个类的定义内部，这就是内部类&amp;emsp;&amp;emsp;内部类是一种非常有用的特性，因为它允许你把一些逻辑相关的类组织在一起，并控制内部类的可视性，然而必须要了解，内部类与组合是完全不同的概念，这一点很重要&amp;emsp;&amp;emsp;在最初，内部类看起来就像是一种代码隐藏机制，将类置于其他类的内部，但是，你将会了解到，内部类远不止如此，它了解外围类，并">
<meta name="keywords" content="Java">
<meta property="og:type" content="article">
<meta property="og:title" content="内部类">
<meta property="og:url" content="http://yoursite.com/2018/10/10/内部类/index.html">
<meta property="og:site_name" content="代海峰">
<meta property="og:description" content="前言&amp;emsp;&amp;emsp;可以将一个类的定义放在另一个类的定义内部，这就是内部类&amp;emsp;&amp;emsp;内部类是一种非常有用的特性，因为它允许你把一些逻辑相关的类组织在一起，并控制内部类的可视性，然而必须要了解，内部类与组合是完全不同的概念，这一点很重要&amp;emsp;&amp;emsp;在最初，内部类看起来就像是一种代码隐藏机制，将类置于其他类的内部，但是，你将会了解到，内部类远不止如此，它了解外围类，并">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-10-11T02:33:13.901Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="内部类">
<meta name="twitter:description" content="前言&amp;emsp;&amp;emsp;可以将一个类的定义放在另一个类的定义内部，这就是内部类&amp;emsp;&amp;emsp;内部类是一种非常有用的特性，因为它允许你把一些逻辑相关的类组织在一起，并控制内部类的可视性，然而必须要了解，内部类与组合是完全不同的概念，这一点很重要&amp;emsp;&amp;emsp;在最初，内部类看起来就像是一种代码隐藏机制，将类置于其他类的内部，但是，你将会了解到，内部类远不止如此，它了解外围类，并">
  
    <link rel="alternate" href="/atom.xml" title="代海峰" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">代海峰</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">个人博客</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-内部类" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/10/内部类/" class="article-date">
  <time datetime="2018-10-10T03:44:31.000Z" itemprop="datePublished">2018-10-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习心得/">学习心得</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      内部类
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;<strong>可以将一个类的定义放在另一个类的定义内部，这就是内部类</strong><br>&emsp;&emsp;内部类是一种非常有用的特性，因为它允许你把一些逻辑相关的类组织在一起，并控制内部类的可视性，然而必须要了解，内部类与组合是完全不同的概念，这一点很重要<br>&emsp;&emsp;在最初，内部类看起来就像是一种代码隐藏机制，将类置于其他类的内部，但是，你将会了解到，内部类远不止如此，它了解外围类，并能与之通信，而且你用内部类写出的代码更加优雅而清晰，尽管并不总是如此  </p>
<h2 id="创建内部类"><a href="#创建内部类" class="headerlink" title="创建内部类"></a>创建内部类</h2><p>&emsp;&emsp;创建内部类的方法很简单，就是将类的定义置于外围类的内部<br>&emsp;&emsp;更典型的情况是，外部类将有一个方法，该方法返回一个指向内部类的引用，就像下面看到<code>to()</code>的<code>contens()</code>和一样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel1</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Contents</span></span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> i =<span class="number">11</span>;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> i;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Destination</span></span>&#123;</span><br><span class="line">      <span class="keyword">private</span> String label;</span><br><span class="line">      Destination(String label)&#123;</span><br><span class="line">          <span class="keyword">this</span>.label=label;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function">String <span class="title">readLable</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> label;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Destination <span class="title">to</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Destination(s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Contents <span class="title">conents</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Contents();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ship</span><span class="params">(String dest)</span></span>&#123;</span><br><span class="line">      Contents c=conents();</span><br><span class="line">      Destination d=to(<span class="string">"dest"</span>);</span><br><span class="line">      System.out.print(d.readLable());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      Parcel1 p=<span class="keyword">new</span> Parcel1();</span><br><span class="line">      p.ship(<span class="string">"Tasmania"</span>);</span><br><span class="line">      Parcel1 q=<span class="keyword">new</span> Parcel1();</span><br><span class="line">      Parcel1.Destination d=q.to(<span class="string">"Borneo"</span>);</span><br><span class="line">      Parcel1.Contents c = q.conents();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="链接到外部类"><a href="#链接到外部类" class="headerlink" title="链接到外部类"></a>链接到外部类</h2><p>&emsp;&emsp;到目前为止，内部类似乎还是一种名字隐藏和组织代码的模式，这些很有用，但还不是最引人注目的，它还有其他的用途，<strong>当生成一个内部类的对象时，此对象与制造它的外围类对象（enclosing object）之间就有了一种联系，所以它能访问其外围类的所有成员，而不需要任何特殊条件</strong>，此外，内部类还拥有外围类所有元素的访问权，内部类可以访问其外围类的的方法和字段，就像自己拥有它们似的<br>&emsp;&emsp;内部类自动拥有对其外围类所有成员的访问权，这是怎么做到的呢？当某个对象创建一个内部类对象的时候，此内部类对象必定会秘密捕获一个指向那个外围类对象的引用，然后，在你访问此外围类的成员时，就是用那个引用来选择外围类的成员，幸运的是，编译器会帮我们处理所有的细节，但你现在可以看到：内部类的对象只能在其外围类的对象相关联的情况下才能被创建（就像你应该看到的，在内部类是非static类时），构建内部类对象时，需要一个指向其外围类对象的引用</p>
<h2 id="使用-this和-new"><a href="#使用-this和-new" class="headerlink" title="使用.this和.new"></a>使用.this和.new</h2><p>&emsp;&emsp;<strong>如果你需要生成外部类对象的引用，可以使用外部类的名字后面紧跟原点和this</strong>，这样产生的引用自动地具有正确的类型，这一点在编译期就被知晓并受到检查，因此没有任何运行时开销<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dothis</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;System.out.print(<span class="string">"Dothis.f()"</span>);&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Dothis <span class="title">outer</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Dothis.<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Inner <span class="title">inner</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Inner();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Dothis dt=<span class="keyword">new</span> Dothis();</span><br><span class="line">        Dothis.Inner dti=dt.inner();</span><br><span class="line">        dti.outer().f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;有时你想要告知某些其他对象，去创建其某个内部类的对象，要实现此目的，你必须在new表达式中提供对其他外部类对象的引用，这就需要使用<code>.new</code>语法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DotNew</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        DotNew dotNew=<span class="keyword">new</span> DotNew();</span><br><span class="line">        DotNew.Inner di=dotNew.new Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&amp;emsp；要想创建内部类的对象，你不能按照你想象的方式，去引用外部类的名字DotNew,而是<strong>必须使用外部类的对象来创建内部类对象</strong>，像上面<code>newDot.new Inner()</code>那样,这也解决了内部类名字作用域的问题<br>&emsp;&amp;emsp；<strong>在拥有外部类对象之前是不能创建内部类对象的</strong>，这是因为内部类对象暗暗连接到它的外部类对象上，但是，如果你创建的是嵌套类（静态内部类），那么就不需要对外部类对象的引用  </p>
<h2 id="内部类和向上转型"><a href="#内部类和向上转型" class="headerlink" title="内部类和向上转型"></a>内部类和向上转型</h2><p>&emsp;&amp;emsp；当将内部类向上转型为其基类，尤其是转型为一个接口的时候，内部类就有了用武之地（从实现了某个接口的对象，得到对接口的引用，与向上转型为这个对象的基类，实际上效果是一样的），<strong>这是因为此内部类——某个接口的实现——能够完全不可见，并且不可用</strong>。所得到只是指向基类或则接口的引用，所以能够很方便地隐藏实现细节<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Destination</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">readLabel</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Contents</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parcel</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">PContents</span> <span class="keyword">implements</span> <span class="title">Contents</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> i;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">PDestination</span> <span class="keyword">implements</span> <span class="title">Destination</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String label;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PDestination</span><span class="params">(String toWhere)</span></span>&#123;</span><br><span class="line">            label=toWhere;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">(String s)</span></span>&#123;<span class="keyword">return</span> s;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Destination <span class="title">destination</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PDestination(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PContents();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestParcel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Parcel parcel=<span class="keyword">new</span> Parcel();</span><br><span class="line">        Contents c=parcel.contents();</span><br><span class="line">        <span class="comment">//向下转型为私有的内部类也是不可以的</span></span><br><span class="line">        <span class="comment">//Parcel.PContents pc=parcel.contents();</span></span><br><span class="line">        Destination d= parcel.destination(<span class="string">"tasmania"</span>);</span><br><span class="line">        <span class="comment">//illegal --can't access private class</span></span><br><span class="line">        <span class="comment">//Parcel.PContents ps=parcel.new PContents();</span></span><br><span class="line">        Parcel.PDestination pd=parcel.new PDestination(<span class="string">"同包可访问"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在上面的例子中，内部类PContents是private,所以除了Parcel，没人能够访问它，PDestination是protected的，所以只有Parcel及其子类，还有同包的类能够访问它，这意味着如果客户端程序员想要了解或访问这些成员，那是要受到限制的，实际上，甚至不能向下转型成private内部类（或是protect内部类，除非是继承自它的子类），因为不能访问其名称，就像上面看到的那样，也是，private内部类给类的设计者提供了一种途径，通过这种方式可以完全阻止任何依赖于类型的编码，并且完全隐藏了实现的细节，此外，从客户端程序员的角度来看，由于不嫩访问任何新增的，原本不属于公共接口的方法，所有扩展接口是没有价值的（也就是说我们对于private内部类，我们只能通过可访问的其向上转型的基类或者接口来访问这个内部类，因为同基类接口访问，任何通过内部类添加的新的方法都是无意义的）。这也给java编译器提供了生成更高效代码的机会<br>&emsp;&emsp;总结如下，对内部类的访问权限修饰同样有效，我们仅能对那些有权限访问的内部类进行访问，例如private内部类，我们无法访问（除了包含它的外部类），对于protected内部类，我们只能在外围类的子类或者同包类能访问，但是如果我们对内部类基类的接口具有访问权的时候，内部类还提供了一种机制，通过外围类的方法获得内部类的向上转型的引用，我们就可以对这个引用的接口进行访问，由此得到一个副作用是，通过向上转型的接口访问时对于那些在内部类中新添加的方法，我们是无法调用的</p>
<h2 id="在方法和作用域内的内部类"><a href="#在方法和作用域内的内部类" class="headerlink" title="在方法和作用域内的内部类"></a>在方法和作用域内的内部类</h2><p>&emsp;&emsp;我们还可以在方法里面或者在任意的作用域内定义内部类，这么做有两个理由：</p>
<ol>
<li>你实现了某类型的接口，于是可以创建并返回对其的引用  </li>
<li>你要解决一个复杂的问题，想创建一个类来辅助你解决问题，但是又不希望这个类是公共可用的<br>&emsp;&emsp;在后面的例子里，先前的代码将被修改，以用来实现  </li>
<li>一个定义在方法中的类  </li>
<li>一个定义在作用域内的类，此作用域在方法内部</li>
<li>一个实现接口的匿名类</li>
<li>一个匿名类，它扩展了有非默认构造器的类</li>
<li>一个匿名类，它执行字段初始化</li>
<li>一个匿名类，它通过实例初始化实现构造（匿名类不可能有构造器）<h4 id="在方法的作用域内"><a href="#在方法的作用域内" class="headerlink" title="在方法的作用域内"></a>在方法的作用域内</h4>&emsp;&emsp;在方法的作用域内，创建一个完整的类，这被称作局部内部类  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Destination <span class="title">destination</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">PDestination</span> <span class="keyword">implements</span> <span class="title">Destination</span></span>&#123;</span><br><span class="line">            <span class="keyword">private</span> String label;</span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="title">PDestination</span><span class="params">(String whereTo)</span></span>&#123;</span><br><span class="line">                label=whereTo;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> label;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PDestination(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>PDestination类是<code>destination()</code>方法的一部分，而不是<code>Parcel5</code>的一部分，所以destination()方法之外不能访问PDestination,注意出现在return语句中的向上转型——返回的类型是Destionation的引用，它是PDestination的基类，当然，在destination()中定义了内部PDestination，并不意味着一旦destination()方法执行完毕，PDestination就不可用了<br>&emsp;&emsp;你可以在同一个目录下的任意类中对某个内部类使用类标识符PDestination,这并不会引起命名冲突<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">internalTracking</span><span class="params">(<span class="keyword">boolean</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b)&#123;</span><br><span class="line">            <span class="class"><span class="keyword">class</span> <span class="title">TrackingSlip</span></span>&#123;</span><br><span class="line">                <span class="keyword">private</span> String id;</span><br><span class="line">                TrackingSlip(String s)&#123;</span><br><span class="line">                    id = s;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="function">String <span class="title">getSlip</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> id;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            TrackingSlip ts=<span class="keyword">new</span> TrackingSlip(<span class="string">"slip"</span>);</span><br><span class="line">            String s=ts.getSlip();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//con't use it here out of scope</span></span><br><span class="line">    <span class="comment">//TrackingSlip ts=new TrackingSlip();</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">track</span><span class="params">()</span></span>&#123;internalTracking(<span class="keyword">true</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Parcel6 p=<span class="keyword">new</span> Parcel6();</span><br><span class="line">        p.track();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;<strong>TrackingSlip类被嵌套入if语句的作用域中，这并不是说该类的创建是有条件的，它其实与别的类一起编译过了，然而，在定义TrackingSlip的作用之外，它是不可用的，除此之外，它与普通的类没什么分别</strong></p>
<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Contents() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Parcel7 parcel7=<span class="keyword">new</span> Parcel7();</span><br><span class="line">        Contents c=parcel7.contents();</span><br><span class="line">        c.value();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;contents()方法将返回值的生成与表达式这个返回值啊的类的定义结合在一起了，另外，这个类是匿名的，它没有名字，更糟糕的是：看起来似乎是你正在创建一个Contents对象<br>&emsp;&emsp;这种奇怪的语法指的是：“创建一个继承自Contents的匿名类的对象”，通过new表达式返回的引用被自动向上转型为对Contents的引用，上述匿名类的语法是下述形式的简化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel7b</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Mycontents</span> <span class="keyword">implements</span> <span class="title">Contents</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Mycontents();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在这个匿名内部类中，使用默认的构造器来生成Contents，下面的代码展示的是，如果你的基类需要一个有参数的构造器，应该怎么办？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wrapping</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Wrapping</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; i=x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> i;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel8</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Wrapping <span class="title">wrapping</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Wrapping(x)&#123;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">super</span>.value();</span><br><span class="line">          &#125;  </span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Parcel8 parcel8=<span class="keyword">new</span> Parcel8();</span><br><span class="line">        Wrapping wrapping=<span class="keyword">new</span> Wrapping(<span class="number">2</span>);</span><br><span class="line">        wrapping.value();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;只需要简单传递给基类的构造器即可，尽管Wrapping只是一个具有实现的普通类，但它还是被其导出类当作公共“接口”来使用<br>&emsp;&emsp;<strong>如果定义一个匿名类，并且希望它使用一个在其外部定义的对象，那么编译器会要求并其参数引用是final的</strong><br>&emsp;&emsp;如果只是简单给一个字段，那么普通的字段初始化方法就很好了，但是如果想做一些类似构造器的行为，那该怎么办？在匿名类中不可能含有命名构造器（因为它根本没有名字），但通过实例初始化，就能够达到为匿名内部类创建一个伪构造器的效果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Base</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"Base Constructor,i="</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousConstructor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Base <span class="title">getBase</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Base(x)&#123;</span><br><span class="line">            &#123;System.out.print(<span class="string">"Inside instance initializer"</span>);&#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;System.out.print(<span class="string">"in anonymous f()"</span>);&#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Base base=getBase(<span class="number">10</span>);</span><br><span class="line">        base.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在此例中，不要求变量一定是final的，因为i被传递给匿名类的基类的构造器，它并不会在匿名类内部被直接使用<br>&emsp;&emsp;下面是带实例初始化的“parcel”形式，注意destinaion的参数必须是final的，因为它们是在匿名类内部使用的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel10</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Destination <span class="title">destination</span><span class="params">(<span class="keyword">final</span> String dest,<span class="keyword">final</span> <span class="keyword">float</span> price)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Destination() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> cost;</span><br><span class="line">            &#123;</span><br><span class="line">                cost=Math.round(price);</span><br><span class="line">                <span class="keyword">if</span>(cost&gt;<span class="number">100</span>)</span><br><span class="line">                    System.out.print(<span class="string">"over Budget"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">private</span> String label=dest;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Parcel10 parcel10=<span class="keyword">new</span> Parcel10();</span><br><span class="line">        parcel10.destination(<span class="string">"houston"</span>,<span class="number">100.3f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在实例初始化操作的内部，可以看到有一段代码，它们不能作为字段初始化动作的一部分（就是if语句）所以对于匿名类而言，实例初始化的实际效果就是构造器，当然它受到了限制——<strong>你不能重载实例初始化，所以你仅有一个这样的构造器（实例初始化）</strong><br>&emsp;&emsp;匿名内部类与继承相比有些受限，因为<strong>匿名内部类既可以扩展类，也可以实现接口，但不能两者兼备，而且如果是实现接口，也只能实现一个</strong>  </p>
<h3 id="再访工厂方法"><a href="#再访工厂方法" class="headerlink" title="再访工厂方法"></a>再访工厂方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ServiceFactory</span></span>&#123;</span><br><span class="line">    <span class="function">Service <span class="title">getService</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceImpl1</span> <span class="keyword">implements</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ServiceImpl1</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123; System.out.print(<span class="string">"imple1.m1()"</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123; System.out.print(<span class="string">"impl1.m2()"</span>);&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ServiceFactory serviceFactory=<span class="keyword">new</span> ServiceFactory() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Service <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ServiceImpl1();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceImpl2</span> <span class="keyword">implements</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ServiceImpl2</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123; System.out.print(<span class="string">"imple2.m1()"</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123; System.out.print(<span class="string">"impl2.m2()"</span>);&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ServiceFactory serviceFactory=<span class="keyword">new</span> ServiceFactory() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Service <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ServiceImpl2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factories</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serviceConsumer</span><span class="params">(ServiceFactory factory)</span></span>&#123;</span><br><span class="line">        Service service = factory.getService();</span><br><span class="line">        service.m1();</span><br><span class="line">        service.m2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        serviceConsumer(ServiceImpl1.serviceFactory);</span><br><span class="line">        serviceConsumer(ServiceImpl2.serviceFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<strong>现在用于ServiceImpl1和ServiceImpl2的构造器都可以是private的，并且没有任何必要创建作为工厂的具名类</strong>，另外，你经常需要的是单一的工厂对象，因此在本例中它被创建为Service实现的static域，这样所产生的语法也更具有实际意义</p>
<h2 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h2><p>&emsp;&emsp;如果不需要内部类与外部类对象之间的联系，那么可以将内部类声明为static，这通常称为嵌套类，嵌套类意味着：</p>
<ol>
<li>要创建嵌套类的对象，并不需要其外围类的对象</li>
<li>不能从嵌套类的对象访问非静态的外围类对象<br>&emsp;&emsp;嵌套类与普通的内部类还有一个区别，<strong>普通内部类的字段与方法，只能放在类的外部层次上，所有普通的内部类不能有static数据和static字段，也不能包含嵌套类，但是嵌套类可以包含所有这些东西</strong><br>&emsp;&emsp;我对于上面问题的理解是，因为普通的内部类是依赖于外部类对象的初始化的，只有得到外部类对象的一个引用，内部类才能构建成功，这是内部类的特性，假设，允许内部类有static数据和static字段，当我们调用内部类的一个static成员时，就会引发内部类的加载，而这是不被推荐的行为，为了确保先外部类后内部类的加载和初始化顺序，编译器必须确保普通内部类中不能存在static成员，而static final是常量，在编译过程就已经存在常量池中，所有对常量没有约束，而嵌套类是static的，和外部类除了在命名空间上有些联系，其实可以将其看成一个独立的类，所以它的加载和初始化对外部类不会产生影响  <h3 id="接口内部的类"><a href="#接口内部的类" class="headerlink" title="接口内部的类"></a>接口内部的类</h3>&emsp;&emsp;正常情况下，不能在接口内部放置任何的代码，但嵌套内部类可以作为接口的一部分，你放在接口中的任何类都自动地是public和static的，因为是被static的，只要将嵌套类置于接口的命名空间内，这并不违反接口的规则，你甚至可以砸内部类中实现其外围类  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ClassInInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">howdy</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span>  <span class="title">ClassInInterface</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">howdy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.print(<span class="string">"Howdy!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">            Test test =<span class="keyword">new</span> Test();</span><br><span class="line">            test.howdy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>&emsp;&emsp;如果你想要创建某些公共代码，使得它们可以被某些接口的所有实现所共用，那么使用接口内部的嵌套类会很方便  </p>
<h3 id="从多层嵌套类中访问外部类的成员"><a href="#从多层嵌套类中访问外部类的成员" class="headerlink" title="从多层嵌套类中访问外部类的成员"></a>从多层嵌套类中访问外部类的成员</h3><p>&emsp;&emsp;一个内部类被嵌套多少层并不重要——它能透明地访问所有它所嵌入的外围类的所有成员（不包括静态内部类，静态内部类只能访问外部类的静态成员，和普通的类的访问权限一样）</p>
<h2 id="为什么需要内部类"><a href="#为什么需要内部类" class="headerlink" title="为什么需要内部类"></a>为什么需要内部类</h2><p>&emsp;&emsp;一般来说，内部类继承自某个类或实现某个接口，内部类的代码操作创建它的外围类的对象，所以认为<strong>内部类提供了某种进入外围类的方法</strong><br>&emsp;&emsp;内部类必须要回答的一个问题就是，如果只是需要一个对接口的引用，那么为什么不通过外围类实现那个接口呢？答案是：“如果这能满足要求，那么就应该这么做”，那么内部类实现的接口和外围类实现的这个接口有什么区别呢？答案是：后者不是总能享用到接口带来的便利，有时需要用到接口的实现，所以使用内部类是最吸引人的原因是：<br>&emsp;&emsp;每个接口都能独立地继承自一个（接口的）实现，所以无论外围类是否以及继承了某个（接口的）实现，对于内部类都没有影响<br>&emsp;&emsp;如果没有内部类提供的，可以继承多个具体的或者抽象的类的能力，一些设计与编程的问题就很难解决，从这个角度看，内部类使得多重继承的解决方案变得完美，接口解决了部分问题，而内部类有效地实现了“多重继承”，也就是说吗，内部类允许继承多个非接口类型（类或者抽象类）<br>&emsp;&emsp;使用内部类，还可以获得其他的一些特性：</p>
<ol>
<li>内部类可以有多个实例，每个内部类都有自己的状态信息，并且与其外围类对象的信息相互独立</li>
<li>在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类</li>
<li>创建内部类对象的时刻并不依赖于外围类对象的创建？</li>
<li>内部类并没有让人迷惑的“is-a”问题，它就是一个独立的实体<h3 id="闭包与回调"><a href="#闭包与回调" class="headerlink" title="闭包与回调"></a>闭包与回调</h3>&emsp;&emsp;<strong>闭包（closure）是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域</strong>，通过这个定义，可以看出内部类是面向对象的闭包，因为它不仅包含外围类对象（创建内部类的作用域）的信息，还自动拥有一个指向此外围类对象的引用，在此作用域内，内部类有权操作所有的成员，包括private成员<br>&emsp;&emsp;java做引人争议的问题之一就是，人们认为java应该包含某种指针机制，以允许回调（callback）,通过回调，对象能够携带一些信息，这些信息允许它在稍后的某个时候调用初始的对象，，如果回调是通过指针实现的话，那就期待程序员不会误用指针<br>&emsp;&emsp;通过内部类提供闭包的功能是优良的解决方案，它比指针更灵活，更安全  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Incrementtable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Callee1</span> <span class="keyword">implements</span> <span class="title">Incrementtable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">        System.out.print(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyIncrement</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;System.out.print(<span class="string">"Other operation"</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(MyIncrement mi)</span></span>&#123;mi.increment();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Callee2</span> <span class="keyword">extends</span> <span class="title">MyIncrement</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.increment();</span><br><span class="line">        i++;</span><br><span class="line">        System.out.print(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Closure</span> <span class="keyword">implements</span> <span class="title">Incrementtable</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</span><br><span class="line">            Cellee2.<span class="keyword">this</span>.increment();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Incrementtable <span class="title">getCallbackreference</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Closure();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Caller</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Incrementtable callbackReference;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Caller</span><span class="params">(Incrementtable ic)</span></span>&#123;callbackReference=ic;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">()</span></span>&#123;callbackReference.increment();&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallBack</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Callee1 c1=<span class="keyword">new</span> Callee1();</span><br><span class="line">        Callee2 c2=<span class="keyword">new</span> Callee2();</span><br><span class="line">        MyIncrement.f(c2);</span><br><span class="line">        Caller caller1=<span class="keyword">new</span> Caller(c1);</span><br><span class="line">        Caller caller2=<span class="keyword">new</span> Caller(c2.getCallbackreference());</span><br><span class="line">        caller1.go();</span><br><span class="line">        caller2.go(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>&emsp;&emsp;这个例子进一步展示了外围类实现一个接口与内部类实现此接口之间的区别，就代码而言，Callee1是简单的解决方案，Callee2继承自MyIncrement，后者已经有了一个不同的increment()方法，并且与Incrementable接口期望的increment()方法完全不相关，所以入股Cellee2继承了MyIncrement，就不能为了Incrementable的用途而覆盖increment()方法，于是只能使用内部类独立地实现Incrementable，还要主要，当创建一个内部类时，并没有在外围类的接口中添加东西，也没有修改外围类的接口<br>&emsp;&emsp;主要，在Callee2中除了getCallbackReference()方法之外，其他成员都是private的，要想建立与外部世界的任何连接，interface Incrementable都是必需的，在这里可以看到，interface是如何允许接口与接口的实现完全独立的<br>&emsp;&emsp;内部类Closure实现了InCrementable，以提供一个安全的“钩子（hook）”——而且这个钩子是一个安全的钩子，它只能允许调用者对外围类进行特定的操作</p>
<h3 id="内部类与框架"><a href="#内部类与框架" class="headerlink" title="内部类与框架"></a>内部类与框架</h3><p>&emsp;&emsp;控制框架<br>&emsp;&emsp;应用程序框架（application framework）就是被设计用以解决某类特定问题的一个类或者一组类，要运用某个应用程序框架，通常继承一个或者多个类，并覆盖某些方法，在覆盖后的方法中，编写代码定制应用程序框架提供的通用解决方案，以解决你的特定问题（这是设计模式中模板方法的一个例子）<br>&emsp;&emsp;控制框架是一类特殊的应用程序框架，它用来解决相应时间的需求，主要用来响应时间的系统被称为事件驱动系统，一般来说，我们会考虑使用内部类来设计控制框架系统，原因如下  </p>
<ol>
<li>控制框架的完整实现是由单个的类创建的，从而使得实现的细节被封装了起来，<strong>内部类的用来表示解决问题所需要的不同的动作</strong></li>
<li><strong>内部类能够很容易地访问外围类的任意成员</strong>，所有可以避免这种实现变得笨拙，如果没有这种能力，代码将变得使人讨厌<h2 id="内部类的继承"><a href="#内部类的继承" class="headerlink" title="内部类的继承"></a>内部类的继承</h2>&emsp;&emsp;因为内部类的构造器必须连接到指向其外围类的对象的引用，所有在继承内部类的时候，事情会变得有些复杂，问题在于，那个指向外围类对象的“秘密的”引用必须被初始化<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritInner</span>  <span class="keyword">extends</span> <span class="title">Outer</span>.<span class="title">Inner</span></span>&#123;</span><br><span class="line">    InheritInner(Outer outer)&#123;</span><br><span class="line">        outer.<span class="keyword">super</span>();<span class="comment">//表示的是调用outer的构造器</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Outer outer=<span class="keyword">new</span> Outer();</span><br><span class="line">        InheritInner i = <span class="keyword">new</span> InheritInner(outer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="内部类可以被覆盖吗？"><a href="#内部类可以被覆盖吗？" class="headerlink" title="内部类可以被覆盖吗？"></a>内部类可以被覆盖吗？</h2><p>&emsp;&emsp;如果构建一个内部类，然后继承外部类并重新定义此内部类时，会发生什么？内部类可以被覆盖吗？但是，<strong>“覆盖内部类就像好像它是外围类的一个方法，其实并不起什么作用</strong>”<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Egg</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Yolk y;</span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.print(<span class="string">"Egg.folk()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Egg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"new Egg()"</span>);</span><br><span class="line">        y=<span class="keyword">new</span> Yolk();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigEgg</span> <span class="keyword">extends</span> <span class="title">Egg</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span></span>&#123;System.out.print(<span class="string">"BigEgg.folk()"</span>);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> BigEgg();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//new Egg()</span></span><br><span class="line"><span class="comment">//Egg.folk()</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这说明了一件事情，内部类和外部类其实是两个不同的类，内部类需要外部类对象的引用来创建自己，内部类具有访问外部类成员的权限，<strong>但是当继承一个外部类的时候，并不继承内部类</strong></p>
<h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>前面提到过，可以在方法块里创建局部类，典型的方式是在一个方法的里面创建，<strong>局部内部类不能有访问说明符，因为它不是外围类的一部分，但是它可以访问当前代码块内的常量已经外围类的所有你成员</strong><br>&emsp;&emsp;既然局部内部类的名字在方法外是不可见的，那么我们我什么仍然使用局部内部类而不是匿名类呢？唯一的理由是：<strong>我们需要一个已命名的构造器，或者需要重载构造器，而匿名内部类只能用于实例初始化</strong></p>
<h2 id="内部类标识符"><a href="#内部类标识符" class="headerlink" title="内部类标识符"></a>内部类标识符</h2><p>&emsp;&emsp;由于每个类都会产生一个.class文件,其中包含了如何创建该类型的对象的全部信息（此信息产生一个meta-class，叫做Class对象），内部类也必须生成一个.class文件以包含他们的Class对象的信息。这些名字有严格的规定，外围类的名字，加上“$”,再加上内部类的名字，如果内部类时匿名的，编译器会简单地产生一个数字作为标识符</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/10/内部类/" data-id="cjnj9os9d001cuwrz7hqlq3rs" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/10/10/持有对象/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          持有对象
        
      </div>
    </a>
  
  
    <a href="/2018/10/09/接口/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">接口</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/学习心得/">学习心得</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML5/">HTML5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Maven/">Maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Oracle/">Oracle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-MVC/">Spring MVC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-boot/">Spring boot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-cloud/">Spring cloud</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/HTML5/" style="font-size: 10px;">HTML5</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/Node-js/" style="font-size: 10px;">Node.js</a> <a href="/tags/Oracle/" style="font-size: 10px;">Oracle</a> <a href="/tags/Spring/" style="font-size: 10px;">Spring</a> <a href="/tags/Spring-MVC/" style="font-size: 10px;">Spring MVC</a> <a href="/tags/Spring-boot/" style="font-size: 10px;">Spring boot</a> <a href="/tags/Spring-cloud/" style="font-size: 10px;">Spring cloud</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/10/19/注解/">注解</a>
          </li>
        
          <li>
            <a href="/2018/10/19/枚举类型/">枚举类型</a>
          </li>
        
          <li>
            <a href="/2018/10/19/Java-I-O系统/">Java I/O系统</a>
          </li>
        
          <li>
            <a href="/2018/10/19/容器深入研究/">容器深入研究</a>
          </li>
        
          <li>
            <a href="/2018/10/19/数组/">数组</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 EgbertDay<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>