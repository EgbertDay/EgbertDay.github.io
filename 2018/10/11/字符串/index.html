<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>字符串 | 代海峰</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="不可变String&amp;emsp;&amp;emsp;String对象是不可变的，查看JDK文档，会发现，String类中每一个看起来会修改String值的方法，实际上都是创建了一个全新的String对象，以包含修改后的字符串内容，而最初的String对象纹丝未动，当吧String对象作为方法的参数时，都会复制一份引用，而该引用所指的对象其实一直待在单一的物理位置上，从未动过123456789101112pu">
<meta name="keywords" content="Java">
<meta property="og:type" content="article">
<meta property="og:title" content="字符串">
<meta property="og:url" content="http://yoursite.com/2018/10/11/字符串/index.html">
<meta property="og:site_name" content="代海峰">
<meta property="og:description" content="不可变String&amp;emsp;&amp;emsp;String对象是不可变的，查看JDK文档，会发现，String类中每一个看起来会修改String值的方法，实际上都是创建了一个全新的String对象，以包含修改后的字符串内容，而最初的String对象纹丝未动，当吧String对象作为方法的参数时，都会复制一份引用，而该引用所指的对象其实一直待在单一的物理位置上，从未动过123456789101112pu">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-10-12T05:20:29.109Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="字符串">
<meta name="twitter:description" content="不可变String&amp;emsp;&amp;emsp;String对象是不可变的，查看JDK文档，会发现，String类中每一个看起来会修改String值的方法，实际上都是创建了一个全新的String对象，以包含修改后的字符串内容，而最初的String对象纹丝未动，当吧String对象作为方法的参数时，都会复制一份引用，而该引用所指的对象其实一直待在单一的物理位置上，从未动过123456789101112pu">
  
    <link rel="alternate" href="/atom.xml" title="代海峰" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">代海峰</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">个人博客</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-字符串" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/11/字符串/" class="article-date">
  <time datetime="2018-10-11T11:14:03.000Z" itemprop="datePublished">2018-10-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习心得/">学习心得</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      字符串
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="不可变String"><a href="#不可变String" class="headerlink" title="不可变String"></a>不可变String</h2><p>&emsp;&emsp;String对象是不可变的，查看JDK文档，会发现，String类中每一个看起来会修改String值的方法，实际上都是创建了一个全新的String对象，以包含修改后的字符串内容，而最初的String对象纹丝未动，当吧String对象作为方法的参数时，都会复制一份引用，而该引用所指的对象其实一直待在单一的物理位置上，从未动过<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Immutable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">upcase</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String q=<span class="string">"howdy"</span>;</span><br><span class="line">        System.out.print(q);<span class="comment">//howdy</span></span><br><span class="line">        String qq=upcase(q);</span><br><span class="line">        System.out.print(qq);<span class="comment">//HOWDY</span></span><br><span class="line">        System.out.print(q);<span class="comment">//howdy</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;上例upcase()返回的引用已经指向了一个新的对象了，而原本的q则还在原地<br>&emsp;&emsp;String的这种行为方式其实正是我们想要的，难道我们真的希望upcase()改变参数的行为吗？参数是为该方法提供信息的，而不是先让该方法改变自己的</p>
<h2 id="重载“-”与StringBuilder"><a href="#重载“-”与StringBuilder" class="headerlink" title="重载“+”与StringBuilder"></a>重载“+”与StringBuilder</h2><p>&emsp;&emsp;String对象的不可变性带来了效率的问题，为String对象重载的“+”操作符就是一个例子，重载的意思是，一个操作符在应用于不同的类上，被赋予老特殊的含义<br>&emsp;&emsp;我们经常使用“+”操作进行字符串的拼接，可是由于String对象的不可变性，我们猜想每一次的连接操作都会产生一个新的String对象，若是进行多次的拼接操作，会有大量的中间String对象产生，会造成内存资源的浪费和垃圾回收器的负担，比如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String concatStr=<span class="string">"asdad"</span>+<span class="string">"asdas"</span>+<span class="string">"sfadfdf"</span>+<span class="string">"asdasd"</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;但是当我们使用javap，对上述代码jinx反编译的时候，就会看到，在进行字符拼接的时候，编译器帮我们做了优化，首先new StringBuilder对象，通过append()方法拼接，使用toString()返回一个字符串对象，编译器以及帮我们的源码进行了优化，那么是否我们就确信编译器优化，而毫无考虑的就到处使用“+”操作符进行字符串的拼接操作呢？我们在看一个例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(String str:StringArr[])&#123;</span><br><span class="line">    s+=str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">for</span>(String str:StringArr)&#123;</span><br><span class="line">   sb.append(str);</span><br><span class="line">&#125;</span><br><span class="line">sb.toString();</span><br></pre></td></tr></table></figure></p>
<p>我们在进行javap进行反编译，可知在上面的第一个例子，每次循环内都要创建new StringBuilder(),而第二个例子只创建一次，那么这个例子就可以说明什么时候应该使用StringBuilder来对字符串进行拼接操作了<br>StringBuilder提供了丰富而全面的方法，包括insert(),replace(),subString()甚至reverse(),但是最常用的还是append()a,toString()，还有delete()<br>Stringbuilder是Java SE5引入的，在这之前java用的是StringBuffer,后者是线程安全的，因此开销也会大些  </p>
<h2 id="无意识的递归"><a href="#无意识的递归" class="headerlink" title="无意识的递归"></a>无意识的递归</h2><p>我们一般经常都会调用一个对象的toString()方法，比如容器的打印，实际上也会调用每个元素的toString()方法，若我们想要打印对象的内存地址怎么办呢？下面是一个对象，重新定义了toString()方法，并且打印自己的内存地址<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InfiniteRecursion</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"asdasdas"</span>+<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的定义是对的吗？完全错误，如果我们调用这个对象的toString()方法就会导致递归，因为我们对this也执行了toString()调用，没完没了，正确的方法如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="string">"asdasdas"</span>+<span class="keyword">super</span>.toString();</span><br></pre></td></tr></table></figure></p>
<p>因为这样会调用基类的toString方法，就避免了递归</p>
<h2 id="String上的操作"><a href="#String上的操作" class="headerlink" title="String上的操作"></a>String上的操作</h2><p>下面是String对象具备的一些基本操作  </p>
<table>
<thead>
<tr>
<th>方法</th>
<th>参数，重载版本</th>
<th>应用</th>
</tr>
</thead>
<tbody>
<tr>
<td>构造器</td>
<td>重载版本：默认版本，String，StringBuilder<br>StringBuffer char数组，byte数组</td>
<td>创建String对象</td>
</tr>
<tr>
<td>length()</td>
<td></td>
<td>String中字符的个数</td>
</tr>
<tr>
<td>charAt()</td>
<td>int索引</td>
<td>取得String中该索引位置上的char</td>
</tr>
<tr>
<td>getChars(),getBytes()</td>
<td>要复制部分的起点和终点的索引，<br>复制的目标数组，目标数组，目标数组的起始索引</td>
<td>复制char或byte到一个目标数组中</td>
</tr>
<tr>
<td>toCharArray()</td>
<td></td>
<td>生成一个char[]</td>
</tr>
<tr>
<td>equals(),equalsIgnoreCase()</td>
<td>与之进行比较的String</td>
<td>比较两个String的内容是否相同</td>
</tr>
<tr>
<td>compareTo()</td>
<td>与之进行比较的String</td>
<td>按词典顺序比较String的内容，比较结果为负数，零，正数，注意，大小写不等价</td>
</tr>
<tr>
<td>contains()</td>
<td>要搜索的CharSequence</td>
<td>如果该String对象包含参数的内容，则返回true</td>
</tr>
<tr>
<td>containEquals()</td>
<td>与之进行比较的CharSequence或StringBuffer</td>
<td>如果该String与参数的内容一致，则返回true</td>
</tr>
<tr>
<td>equealsIgnoreCase()</td>
<td>与之进行比较的String</td>
<td>忽略大小写的比较相等性</td>
</tr>
<tr>
<td>regionMatcher()</td>
<td>该String的索引偏移量，另一个String及其索引偏移量，<br>要比较的长度，重载版本增加了“忽略大小写”功能</td>
<td>返回boolean结果，已表明所比较区域是否相等</td>
</tr>
<tr>
<td>StartsWith()</td>
<td>可能的起始String，重载版本在参数中增加了偏移量</td>
<td>返回值为boolean值</td>
</tr>
<tr>
<td>endsWith()</td>
<td>该String可能的后缀String</td>
<td>返回boolean值</td>
</tr>
<tr>
<td>indexOf(),lastIndexOf()</td>
<td>重载版本包括：char，char与起始索引，<br>String，String与起始索引</td>
<td>如果该String并不包含此参数，就返回-1<br>否则返回此参数在String中的起始索引，lastIndexOf()是从后向前搜索</td>
</tr>
<tr>
<td>subString()(subSequence())</td>
<td>重载版本：起始索引;起始索引+终点索引</td>
<td>返回一个新的String，以包含参数指定的字符串</td>
</tr>
<tr>
<td>concat()</td>
<td>要连接的字符串</td>
<td>返回一个新的String对象，内容为原始String连接上参数String</td>
</tr>
<tr>
<td>replace()</td>
<td>要替换掉的字符，用来进行替换的新字符。<br>也可以用一个CharSequence来替换另一个CharSequence</td>
<td>返回替换字符后的新String对象<br>如果，没有替换发生，则返回原始的String对象</td>
</tr>
<tr>
<td>toLowerCase(),toUpCase()</td>
<td></td>
<td>将字符的大小写改变，返回一个新的字符串</td>
</tr>
<tr>
<td>trim()</td>
<td></td>
<td>将字符串两端的空白字符删除</td>
</tr>
<tr>
<td>valueOf()</td>
<td>重载版本：Object;char[];char[],偏移量，与字符个数；<br>boolean；char;int;lang;float;double</td>
<td>返回一个表示参数内容的String</td>
</tr>
<tr>
<td>intern()</td>
<td></td>
<td>为每个唯一的字符序列生成一个且仅生成一个String引用  </td>
</tr>
</tbody>
</table>
<h2 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h2><p>在长久的等待之后，java SE5终于推出了C语言中printf()风格的格式化输出</p>
<h3 id="System-out-format"><a href="#System-out-format" class="headerlink" title="System.out.format"></a>System.out.format</h3><p>java SE5引入的format()方法可用于PrintStream或PrintWriter对象，format()方法模仿C语言的printf()，它只需要一个简单的格式化字符串和一串的参数就可，语法如下.以System.out为例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.format(<span class="string">"Row 1:[%d %f]\n"</span>,x,y);</span><br></pre></td></tr></table></figure></p>
<h3 id="Formatter类"><a href="#Formatter类" class="headerlink" title="Formatter类"></a>Formatter类</h3><p>在java中，所有新的格式化功能都由java.util.Formatter类处理,可以将Formatter看作一个翻译机，它将你的格式化字符串与数据翻译成需要的结果，当你创建一个Formatter对象的时候，可以向其构造器传递一些信息，告诉它最终的结果将向哪里输出  </p>
<h3 id="格式化说明符"><a href="#格式化说明符" class="headerlink" title="格式化说明符"></a>格式化说明符</h3><p>在插入数据时，如果想要控制空格与对齐，你需要更精细复杂的格式修饰符，一下是其抽象的语法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[argument_index$][flags][width].[precision]conversion</span><br></pre></td></tr></table></figure></p>
<p>最常用的是width控制一个域的最小尺寸，数据是右对齐的，可以添加“-”标志来控制对其方向<br>不是所有类型的元素都能用precision，而且不同类型的元素使用precision代表的含义也不相同<br>Formatter转换（conversion）<br>下面包含了最常用的类型转换   </p>
<table>
<thead>
<tr>
<th></th>
<th>：类型转换：</th>
</tr>
</thead>
<tbody>
<tr>
<td>d</td>
<td>整数型（十进制）</td>
</tr>
<tr>
<td>c</td>
<td>unicode字符</td>
</tr>
<tr>
<td>b</td>
<td>Boolean值</td>
</tr>
<tr>
<td>s</td>
<td>String</td>
</tr>
<tr>
<td>f</td>
<td>浮点数（十进制）</td>
</tr>
<tr>
<td>e</td>
<td>浮点数（科学计数）</td>
</tr>
<tr>
<td>x</td>
<td>整数（十六进制）</td>
</tr>
<tr>
<td>h</td>
<td>散列码</td>
</tr>
<tr>
<td>%</td>
<td>字符“%”</td>
</tr>
</tbody>
</table>
<h3 id="String-format"><a href="#String-format" class="headerlink" title="String.format()"></a>String.format()</h3><p>java SE5也参考了C的sprintf()的方法，以生成格式化的String对象，String.format()是一个static方法，它接受与Formatter.format()相同的参数，但返回一个String对象，当你只使用formatter()方法一次的时候，String.format()是个不错的选择，语法 类似如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String result = String.format(<span class="string">"(t%d,q%d) %s"</span>,transcationID,queryID,message);</span><br></pre></td></tr></table></figure></p>
<p>其实在String.format()内部，它是创建一个Formatter对象，然后将你的参数传递给它，不过与其自己做这些事情，不如使用便捷的String.format()代码更清晰易读</p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式是一种强大而灵活的文本处理工具，<strong>使用正则表达式，我们能够以编程的方式，构造复杂的文本，并对输入的字符串进行搜索，一旦找到匹配这些模式的部分，你就能够随心所欲地对它们进行处理</strong>，正则表达式提供了一种完全通用的方式，能够解决各种字符串处理相关的问题，匹配，选择，编辑以及验证</p>
<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>在其他的语言中,\\表示“我想要在表达式中插入一个普通的反斜线，请不要给他任何特殊的意义，而在java中，\\的意思是”我要插入正则表达式的反斜线，”，所以其后的字符具有一个特殊的意义，你想插入一个普通的反斜线，则应该这样\\\\”<br>应用正则表达式最简单的途径，就是利用String类内建的matches()方法<br>String还有一个非常有用的正则表达式工具——split()方法，其功能是“将字符串从正则表达式匹配的地方切开”，split()还有一个重载的版本，它允许你限制字符串分割的次数<br>如果只是需要使用一次正则表达式，那么上面的方法是很方便的吗，但是如果你想对一个正则表达式反复复用，那么非String类型的正则表达式具备更加的性能和功能</p>
<h3 id="创建正则表达式"><a href="#创建正则表达式" class="headerlink" title="创建正则表达式"></a>创建正则表达式</h3><hr>
<table>
<thead>
<tr>
<th></th>
<th>字符</th>
</tr>
</thead>
<tbody>
<tr>
<td>B</td>
<td>指定字符B</td>
</tr>
<tr>
<td>\xhh</td>
<td>十六进制值为0xhh的字符</td>
</tr>
<tr>
<td>\uhhhh</td>
<td>十六进制表示为oxhhhh的Unicode字符</td>
</tr>
<tr>
<td>\n</td>
<td>换行符</td>
</tr>
<tr>
<td>\t</td>
<td>制表符</td>
</tr>
<tr>
<td>\r</td>
<td>回车</td>
</tr>
<tr>
<td>\f</td>
<td>换页</td>
</tr>
<tr>
<td>\e</td>
<td>转义（Escape）</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th></th>
<th>字符类</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>任意字符</td>
</tr>
<tr>
<td>[abc]</td>
<td>包含a,b，c的任何字符（和a</td>
<td>b</td>
<td>c作用相同）</td>
</tr>
<tr>
<td>[^abc]</td>
<td>除了a,b,c之外的任意字符（否定）</td>
</tr>
<tr>
<td>[a-zA-Z]</td>
<td>从a到或从A到Z的任何一个字符</td>
</tr>
<tr>
<td>[abc[hij]]</td>
<td>任意a,b,c,h.i,j的字符（与a</td>
<td>b</td>
<td>c</td>
<td>h</td>
<td>i</td>
<td>j的作用相同）</td>
</tr>
<tr>
<td>[a-z&amp;&amp;[hij]]</td>
<td>任意h,i,j（交集）</td>
</tr>
<tr>
<td>\s</td>
<td>空白符（空格，tab,换行，换页或回车）</td>
</tr>
<tr>
<td>\S</td>
<td>非空白符</td>
</tr>
<tr>
<td>\d</td>
<td>数字[0-9]</td>
</tr>
<tr>
<td>\D</td>
<td>非数字[^0-9]</td>
</tr>
<tr>
<td>\w</td>
<td>词字符[a-zA-Z0-9]</td>
</tr>
<tr>
<td>\w</td>
<td>非词字符[^\w]</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th></th>
<th>逻辑操作符</th>
</tr>
</thead>
<tbody>
<tr>
<td>XY</td>
<td>Y紧跟在X后面</td>
</tr>
<tr>
<td>X</td>
<td>Y</td>
<td>X或Y</td>
</tr>
<tr>
<td>(X)</td>
<td>捕获组（capturing group）可以在表达式中引用\i第一i个捕获组</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th></th>
<th>边界匹配符</th>
</tr>
</thead>
<tbody>
<tr>
<td>^</td>
<td>一行的起始</td>
</tr>
<tr>
<td>$</td>
<td>一行的结束</td>
</tr>
<tr>
<td>\b</td>
<td>非词的边界</td>
</tr>
<tr>
<td>\B</td>
<td>词的边界</td>
</tr>
<tr>
<td>\G</td>
<td>前一个匹配的结束</td>
</tr>
</tbody>
</table>
<h3 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h3><p>量词描述了一个模式吸收输入文本的方式：</p>
<ul>
<li>贪婪型：量词总是贪婪的，除非有其他的选项被设置，贪婪表达式会为所有可能的模式发现尽可能多的匹配，导致此问题的一个典型理由就是假定我们的模式仅能匹配第一个可能的字符组，如果它是贪婪的，那么它就会继续往下匹配  </li>
<li>勉强型：用问好来指定，这个量词匹配满足模式所需最少字符数，因此也称做懒惰的，最少匹配的，非贪婪的，或不贪婪的  </li>
<li>占有型：目前，这种类型的量词只有java语言中才可用，并且也更高级，当正则表达式被应用于字符串时，它会产生相当多的状态，以便在匹配失败时可以回溯，而“占有的”量词并不保存这些中间状态，因此它们可以防止回溯，它们常常用于防止正则表达式失控，因此可以使正则表达式执行起来更有效  </li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>贪婪型</th>
<th>勉强型</th>
<th>占有型</th>
<th>如何匹配</th>
</tr>
</thead>
<tbody>
<tr>
<td>X?</td>
<td>X??</td>
<td>x?+</td>
<td>一个或零个X</td>
</tr>
<tr>
<td>X*</td>
<td>X*?</td>
<td>X*+</td>
<td>零个或者多个X</td>
</tr>
<tr>
<td>X+</td>
<td>X+?</td>
<td>X++</td>
<td>一个或者多个X</td>
</tr>
<tr>
<td>X{n}</td>
<td>X{n}?</td>
<td>X{n}+</td>
<td>恰好n次</td>
</tr>
<tr>
<td>X{n,}</td>
<td>X{n,}?</td>
<td>X{n,}+</td>
<td>至少n次</td>
</tr>
<tr>
<td>X{n,m}</td>
<td>X{n,m}?</td>
<td>X{n,m}+</td>
<td>X至少n次，最多m次</td>
</tr>
</tbody>
</table>
<p>要非常注意的是表达式X必须要用圆括号括起来，以便它能按照我们期望的效果去执行，例如 abc+和（abc）+,前面的表示表示匹配ab，后面跟随1个或者多个c，而(abc)+表示匹配一个或者多个abc<br>接口CharSequence从CharBuffer,String,StringBuffer,StringBuilder类之中抽象出了字符序列的一般化定义<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CharSequenece</span></span>&#123;</span><br><span class="line">  charAt();</span><br><span class="line">  length();</span><br><span class="line">  subSequence(<span class="keyword">int</span> start,<span class="keyword">int</span> end);</span><br><span class="line">  toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此，这些类都实现了接口，多数正则表达式操作都接受CharSequence类型的参数  </p>
<h3 id="Pattern和Matcher"><a href="#Pattern和Matcher" class="headerlink" title="Pattern和Matcher"></a>Pattern和Matcher</h3><p>比起功能有限的String，我们更愿意构造功能强大的正则表达式对象，只需要导入java.util.regex包，然后用static Pattern.compile()方法来编译你的正则表达式即可，它会根据你的String类型的正则表达式生成一个Pattern对象，接下来，把你想要检索的字符串传入Pattern对象的matcher()方法会生成一个Matcher对象，它有很多功能可用，例如它的replaceAll()方法能够将所有匹配的部分替换成你传入的参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRegularExpression</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            System.out.print(<span class="string">"args's count is not right"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String arg:args)&#123;</span><br><span class="line">            Pattern p = Pattern.compile(arg);</span><br><span class="line">            Matcher m = p.matcher(<span class="string">"args[0]"</span>);</span><br><span class="line">            <span class="keyword">while</span>(m.find())&#123;</span><br><span class="line">                System.out.print(m.group()+m.start()+m.end());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Pattern变量表示编译后的正则表达式，我们可以使用编译后的Pattern对象的matcher()方法，加上一个输入字符串，从而共同构造一个Matcher对象，同时Pattern类还提供了一个静态方法<br>    static boolean matcher(String regex,CharSequence input)<br>编译后的Pattern对象还提供了split()方法，它从匹配的regex的地方分割字符串，返回分割后的字符串的一个String数组<br>通过调用Pattern.matcher()方法，我们得到一个Matcher对象，使用Matcher上的方法，我们能够判断各种不同类型的匹配是否成功<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">lookingAt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">find</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> start)</span></span></span><br></pre></td></tr></table></figure></p>
<p>其中的matches()方法用来判断这个输入字符串是否匹配正则表达式，而lonkingAt()则用来判断该字符串（不必是整个字符串）的始部分是否匹配模式<br>find()像迭代器那样向前办理输入字符串，而第二个find(int start),该参数表示字符串中的字符位置，并以其作为搜索的起点</p>
<h3 id="Group-组"><a href="#Group-组" class="headerlink" title="Group(组)"></a>Group(组)</h3><p>组是用括号划分的正则表达式，可以根据组的编号来引用某个组，组号0表示整个表达式，组号1表示被第一对括号括起来的组，依次类推<br>A(B(C))D,这里有三个组，组0是ABCD,组1是BC,组2是C<br>Matcher（匹配器）对象提供了一些列的方法，用来获取与组相关的信息<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">groupCount</span><span class="params">()</span><span class="comment">//返回该匹配器的模式中的分组数量，第0组不算</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">group</span><span class="params">()</span><span class="comment">//返回前一次操作（例如find()）的第0组</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">group</span><span class="params">(<span class="keyword">int</span> i)</span><span class="comment">//返回前一次匹配操作期间指定的组号，如果匹配成功，但是指定的组没有匹配任何输入字符串的任何部分，则会返回null  </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> group)</span><span class="comment">//返回在前一次匹配操作中寻找到的组的起始索引</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">end</span><span class="params">(<span class="keyword">int</span> group)</span><span class="comment">//返回在前一次匹配操作中寻找到的组的最后一个字符索引加1的值</span></span></span><br></pre></td></tr></table></figure></p>
<p>start()和end()会返回前一次匹配操作的第一个字符位置和最后一个字符位置+1，如果匹配失败（或先于一个正在进行的匹配操作去尝试）。调用start()或end()都会产生一个IllegalStatException异常<br>find()可以在输入的任意位置定位正则表达式，而lookingAt()和matches()只有在正则表达式与输入的最开始位置处开始匹配才会成功</p>
<h3 id="Pattern标记"><a href="#Pattern标记" class="headerlink" title="Pattern标记"></a>Pattern标记</h3><p>Pattern的compile()还有另一个版本，它接受一个标记参数，以调整匹配的行为</p>
<pre><code>Pattern.compile(String regex,int flag)
</code></pre><p>其中的flag来自一下Pattern类中的常量  </p>
<table>
<thead>
<tr>
<th></th>
<th>编译标记</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>Pattern.CONON_EQ</td>
<td>两个字符当且仅当它们的完全规范分解相匹配时</td>
</tr>
<tr>
<td>Pattern.CASE.INSENSITIVE(?!)</td>
<td>默认情况下，大小写不敏感的匹配假定只有US-ASCII字符集中的字符才能进行，这个标记允许模式匹配不必考虑大小写（大写或小写），通过指定UNICODE_CASE标记及结合此标记，基于Unicode的大小写不敏感的匹配就可以开启了</td>
</tr>
<tr>
<td>Pattern.COMMENTS(?x)</td>
<td>在这种模式下，空格符将被忽略，并且以“#”开始直到行尾的注释也会被忽略掉，通过嵌入的标记表达式也可以开启Unix的行模式</td>
</tr>
<tr>
<td>Pattern.DOTALL(?s)</td>
<td>在dotall模式中，表达式“.”匹配所有的字符，包括行终结符。默认情况下“.”表达式不匹配行终结符</td>
</tr>
<tr>
<td>Pattern.MULTILINE</td>
<td>在多行模式下，表达式^和$分别匹配一行的开始和结束，^还匹配输入字符串的开始，而$还匹配输入字符串的结尾，默认情况下，这些表达式仅匹配输入的完整的字符串的开始和结束</td>
</tr>
<tr>
<td>Pattern.UNICODE_CASE(?u)</td>
<td>当指定这个标记，并且开启CASE.INSENSITIVE时，大小写不敏感的匹配将按照与Unicode标准相一致的方式进行，默认情况下，大小写不敏感的匹配假定只能在US-ASCII字符集中的字符才能进行  </td>
</tr>
<tr>
<td>Pattern.UNIX_LINES(?d)</td>
<td>在这种模式下，^和$行为中，其识别行终结符\n  </td>
</tr>
</tbody>
</table>
<h3 id="替换操作"><a href="#替换操作" class="headerlink" title="替换操作"></a>替换操作</h3><p>正则表达式特别便于替换文本，它提供了许多方法，replaceFirst(String replaceStr)替换掉第一个匹配成功的部分,replaceAll(String replaceStr)替换掉所有匹配成功的部分。appendReplacement(StringBuffer sbuf,String replaceent)此方法重要，允许你调用其他的方法来生成或处理replacement(replaceFirst()和replaceAll()则只能使用一个固定的字符串)，使得你能够以编程的方式来将目标分割成组，从而具备更强大的替换功能，appendTail(StringBuffer sbuf)，在执行完appendReplacement()之后，调用此方法可以将输入字符串余下的部分复制到sbuf中  </p>
<h3 id="reset"><a href="#reset" class="headerlink" title="reset()"></a>reset()</h3><p>通过reset()方法，可以将现有的Matcher对象应用于一个新的字符序列<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Resetting</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Matcher matcher = Pattern.compile(<span class="string">"[firb[aiu][gx]]"</span>).matcher(<span class="string">"fix the rug with bgs"</span>);</span><br><span class="line">        <span class="keyword">while</span>(matcher.find())&#123;</span><br><span class="line">            System.out.print(matcher.group());</span><br><span class="line">        &#125;</span><br><span class="line">        matcher.reset(<span class="string">"fix the rig rags"</span>);</span><br><span class="line">        <span class="keyword">while</span>(matcher.find())&#123;</span><br><span class="line">            System.out.print(matcher.group());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="正则表达式与I-O"><a href="#正则表达式与I-O" class="headerlink" title="正则表达式与I/O"></a>正则表达式与I/O</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/11/字符串/" data-id="cjnzuy0br002828rzalnah9ta" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/10/12/类型信息/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          类型信息
        
      </div>
    </a>
  
  
    <a href="/2018/10/11/通过异常处理错误/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">通过异常处理错误</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/学习心得/">学习心得</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML5/">HTML5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Maven/">Maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Oracle/">Oracle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Servlet-JSP/">Servlet&JSP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-MVC/">Spring MVC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-boot/">Spring boot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-cloud/">Spring cloud</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/HTML5/" style="font-size: 10px;">HTML5</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/Node-js/" style="font-size: 10px;">Node.js</a> <a href="/tags/Oracle/" style="font-size: 10px;">Oracle</a> <a href="/tags/Servlet-JSP/" style="font-size: 10px;">Servlet&JSP</a> <a href="/tags/Spring/" style="font-size: 10px;">Spring</a> <a href="/tags/Spring-MVC/" style="font-size: 10px;">Spring MVC</a> <a href="/tags/Spring-boot/" style="font-size: 10px;">Spring boot</a> <a href="/tags/Spring-cloud/" style="font-size: 10px;">Spring cloud</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/11/02/Servlets/">Servlets</a>
          </li>
        
          <li>
            <a href="/2018/10/27/并发/">并发</a>
          </li>
        
          <li>
            <a href="/2018/10/19/注解/">注解</a>
          </li>
        
          <li>
            <a href="/2018/10/19/枚举类型/">枚举类型</a>
          </li>
        
          <li>
            <a href="/2018/10/19/Java-I-O系统/">Java I/O系统</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 EgbertDay<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>