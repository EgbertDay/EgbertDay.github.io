<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>泛型 | 代海峰</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前言一般的类和方法，只能使用具体的类型，要么是基本类型，那么是自定义的类，如果要编写可以应用与多种类型的代码，这种刻板的限制对代码的束缚就会很大在面向对象语言中，动态算是一种泛化机制，你可以将方法的掺水设为基类，那么该方法就可以接受从这个基类中导出的任何类作为参数，这样的方法也更加通用些，可以应用的地方也更多些，但是考虑到除了final类不能被扩展，其他任何类都可以被扩展，所以这种灵活性大多时候也">
<meta name="keywords" content="Java">
<meta property="og:type" content="article">
<meta property="og:title" content="泛型">
<meta property="og:url" content="http://yoursite.com/2018/10/14/泛型/index.html">
<meta property="og:site_name" content="代海峰">
<meta property="og:description" content="前言一般的类和方法，只能使用具体的类型，要么是基本类型，那么是自定义的类，如果要编写可以应用与多种类型的代码，这种刻板的限制对代码的束缚就会很大在面向对象语言中，动态算是一种泛化机制，你可以将方法的掺水设为基类，那么该方法就可以接受从这个基类中导出的任何类作为参数，这样的方法也更加通用些，可以应用的地方也更多些，但是考虑到除了final类不能被扩展，其他任何类都可以被扩展，所以这种灵活性大多时候也">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-10-18T17:04:33.749Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="泛型">
<meta name="twitter:description" content="前言一般的类和方法，只能使用具体的类型，要么是基本类型，那么是自定义的类，如果要编写可以应用与多种类型的代码，这种刻板的限制对代码的束缚就会很大在面向对象语言中，动态算是一种泛化机制，你可以将方法的掺水设为基类，那么该方法就可以接受从这个基类中导出的任何类作为参数，这样的方法也更加通用些，可以应用的地方也更多些，但是考虑到除了final类不能被扩展，其他任何类都可以被扩展，所以这种灵活性大多时候也">
  
    <link rel="alternate" href="/atom.xml" title="代海峰" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">代海峰</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">个人博客</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-泛型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/14/泛型/" class="article-date">
  <time datetime="2018-10-14T11:22:59.000Z" itemprop="datePublished">2018-10-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习心得/">学习心得</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      泛型
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一般的类和方法，只能使用具体的类型，要么是基本类型，那么是自定义的类，如果要编写可以应用与多种类型的代码，这种刻板的限制对代码的束缚就会很大<br>在面向对象语言中，动态算是一种泛化机制，你可以将方法的掺水设为基类，那么该方法就可以接受从这个基类中导出的任何类作为参数，这样的方法也更加通用些，可以应用的地方也更多些，但是考虑到除了final类不能被扩展，其他任何类都可以被扩展，所以这种灵活性大多时候也会有一些性能损耗<br>有时候，拘泥于单继承体系，也会使程序受限太多，如果方法的参数是一个接口，而不是一个类，这种限制就放松了很多，因为任何事实现了该接口的类都能满足该方法，这也包括了暂时还不存在的类，这给了客户端程序员一种选择，他可以选择实现一个接口来满足类或方法的<br>可是有时候，即使使用接口，对程序的约束也还是太强了，因为一旦指明了接口，它就要求你的代码必须使用特定的接口，而我们希望达到的目的是编写更通用的代码，要使代码能够用于“某种不具体的类型”而不是具体的接口或类<br>java SE5的重大变化之一，就是泛型的概念，泛型实现了参数化类型的概念，使代码可以应用于多种类型，“泛型”这个术语的意思就是：“适用于多种类型”，<strong>泛型在编程语言出现时，其最初的目的是希望类或方法能够具备更广泛的表达能力</strong>，如何做到这一点的呢？正是实现通过解耦类和方法与所使用的类型之间的解耦，扫后你将会看到，java中的泛型并没有那么高的追求<br>在学习了java的泛型之后，泛型确实是一个很好的补充，在你创建<strong>参数化类型</strong>的一个实例时，编译器会为你负责转型操作，并确保类型的正确性，这是一个进步<br>但是java中的泛型还没有能够做到像C++那样实现了纯粹的泛型，你不要对java的泛型期望太高，在java中使用一个别人已经建好的泛型类型很容易，但是如果自己创建一个泛型实例，就会遇到很多令人吃惊的事情  </p>
<h2 id="与C-d的比较"><a href="#与C-d的比较" class="headerlink" title="与C++d的比较"></a>与C++d的比较</h2><p>java的设计灵感来自于C++,那么先了解C++的泛型机制对理解java泛型有些帮助，了解C++魔板的某些方面，有助于你理解泛型的基础，你可以了解java泛型的局限是什么，已经为什么会有这些限制，最终的目的是帮助理解，java泛型的边界在哪里，理解了边界所在，你才会知道某个技术不能做什么，你才能更好地做到所能做的  </p>
<h2 id="简单泛化"><a href="#简单泛化" class="headerlink" title="简单泛化"></a>简单泛化</h2><p>许多的原因促使了泛型的出现，而最引人注目的一个原因，就是为了创造容器类，我们先来看下一个只能持有单一对象的类，当然这个对象可以明确指定其持有对象的类型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Automobile</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Automobile automobile;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">(Automobile automobile)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.automobile = automobile;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Automobile <span class="title">getAutomobile</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  automobile;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面自定义的容器类Holder，指定了只能存储Automobile这种类型的对象，这个类的可重用性就不怎么样，难道我们要为每一种类型都要创建一个像这样的容器类吗？当然不<br>在java SE5之前我们可以让一个类直接持有Object类型的对象，实际上，我们是使用了关于基类的编程，这要这个类能够应用于这个基类，那么基类的导出类也适用于这个代码，因为导出类本质上也是基类类型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder2</span><span class="params">(Object obj)</span></span>&#123;<span class="keyword">this</span>.obj=obj;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObj</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> obj;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Holder2 holder2=<span class="keyword">new</span> Holder2(<span class="keyword">new</span> Automobile());</span><br><span class="line">        Automobile automobile=(Automobile) holder2.getObj();</span><br><span class="line">        <span class="comment">//特别是这段代码，虽然getObj()返回的实际类型是Automolie类型，我们还是可以做转型操作，编译器才会发现类型转换失败</span></span><br><span class="line">        String s=(String) holder2.getObj();</span><br><span class="line">        holder2.setObj(<span class="string">"Not a Automoblie"</span>);</span><br><span class="line">        String str=(String) holder2.getObj();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~~~在有些情况下，我们确实希望容器具有能持有不同类型的能力，但是，通常情况下，我们希望使用容器来存储一种特定的类型，泛型的主要目的之一就是用来指定容器要持有什么类型的对象，而且由编译器来保证类型的正确性  </span><br><span class="line">因此，与其使用Object，我们更喜欢暂时不指定类型，而是稍后再决定具体使用什么类型，要达到这个目的，需要使用**类型参数**，用尖括号括住，放在类名后面，然后在什么这个类的时候，再用实际的类型替换此类型参数  </span><br><span class="line">~~~java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder3</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder3</span><span class="params">(T a)</span></span>&#123;<span class="keyword">this</span>.a=a;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T a)</span></span>&#123;<span class="keyword">this</span>.a=a;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> a;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Holder3&lt;Automobile&gt; h3=<span class="keyword">new</span> Holder3&lt;&gt;(<span class="keyword">new</span> Automobile());</span><br><span class="line">        Automobile automobile=h3.get();</span><br><span class="line">        <span class="comment">//h3.set(1);</span></span><br><span class="line">        <span class="comment">//h3.set("not a Automoblie");</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当你创建h3对象时，必须指明想要持有什么类型的对象，将其置于尖括号内，然后你就只能在Hold3中存入该类型（或者子类，多态和泛型不冲突，明确指定了泛型类型，那么这个类型的子类型也是该类型，基类与导出类的关系）<br>这就是java泛型的核心概念：告诉编译器想要什么什么类型，然后编译器处理一切   </p>
<h3 id="一个元祖类库"><a href="#一个元祖类库" class="headerlink" title="一个元祖类库"></a>一个元祖类库</h3><p>仅一次方法调用就返回多个对象，我们经常需要这个功能，可是return只能返回一个对象，因此解决办法就是创建一个对象，用它来持有想要返回的多个对象<br>难道我们每次都要创建这样的一个类，指定它能够保存的类型，所有每次需要保存不同类型的元组时，都要创建保存不同类型的类吗？<br>有了泛型，我们不需要这样做，这样一个类保存两种类型的对象，这个类在创建时才指定它需要用到的类型，同时我们在编译期就能确保类型安全<br>这个概念被称为“元组” ，它是将一组对象直接打包存储于其他的一个单一对象，这个容器对象允许读取其中元素，但是不允许向其中存放新的对象，这和对象就被称为<strong>数据传送对象或者信使 </strong><br>通常，元组可以具有任意长度，同时，元组中的对象可以是任意不同的类型，不过我们希望能够为每一个对象指明类型，并且从容器中读取出来时，能够得到正确的类型，看下下面的二维元组，它能够持有两个对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoTuple</span>&lt;<span class="title">A</span>,<span class="title">B</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> A first;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> B second;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TwoTuple</span><span class="params">(A a,B b)</span></span>&#123;</span><br><span class="line">        first=a;</span><br><span class="line">        second=b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">"("</span>+first+second+<span class="string">")"</span>;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>仔细看上面的代码，我们或许会疑惑，上面的代码违反了java编程的安全性原则，first和second应该被声明为private，然后提供getFirst()和getSecond()子类的访问方法才对，让我们看下这个例子的安全性，客户端程序可以读取fisrt和second，然后随心所欲的使用它们，但是，它们却无法赋值给first和second，因为final声明为你提供了相同的安全性，而且这种格式更简洁明了<br>还有另外一个设计考虑，你确实希望客户端程序员改变first或second所引用的对象，如果是这样的话，就强制程序员另外创建一个新的TwoTuple对象<br>我们可以利用继承机制实现长度更长的元组，下面的例子可以看到，增加类型参数是件很简单的事情<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeTuple</span>&lt;<span class="title">A</span>,<span class="title">B</span>,<span class="title">C</span>&gt; <span class="keyword">extends</span> <span class="title">TwoTuple</span>&lt;<span class="title">A</span>,<span class="title">B</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> C third;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreeTuple</span><span class="params">(A a,B b,C c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(a,b);</span><br><span class="line">        third=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">super</span>.toString()+third;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到下面的代码也可以编译通过，这两个代码定义的泛型的导出类是一样的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeTuple</span>&lt;<span class="title">D</span>,<span class="title">E</span>,<span class="title">C</span>&gt; <span class="keyword">extends</span> <span class="title">TwoTuple</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> C third;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreeTuple</span><span class="params">(D a,E b,C c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(a,b);</span><br><span class="line">        third=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">super</span>.toString()+third;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这表明了继承一个泛型类是，基类不一定要添加&lt;A,B&gt;这样的参数类型，导出类添加参数类型即可，实际上我们在定义导出类的泛型类型，而且参数类型只是一个占位符，名称无所谓，只要能够与内部的代码对应就好<br>元组代码测试<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TupleTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TwoTuple&lt;String,Integer&gt; <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span>  <span class="keyword">new</span> TwoTuple&lt;&gt;(<span class="string">"hi"</span>,<span class="number">46</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreeTuple&lt;Automobile,String,Integer&gt; <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span>  <span class="keyword">new</span> ThreeTuple&lt;&gt;(<span class="keyword">new</span> Automobile(),<span class="string">"hi"</span>,<span class="number">46</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      TwoTuple&lt;String,Integer&gt; ttsi=f();</span><br><span class="line">      System.out.print(ttsi);</span><br><span class="line">      ttsi.first=<span class="string">"can't change"</span></span><br><span class="line">      System.out.print(g());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="一个堆栈类"><a href="#一个堆栈类" class="headerlink" title="一个堆栈类"></a>一个堆栈类</h3><p>传统的下推堆栈，在之前的例子，我们是用一个LinkList实现的，LinkedListb本身具备了创建堆栈所需的所有方法<br>现在我们不用LinkedList，来实现自己的内部链式存储机制<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday.generics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedStack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">U</span>&gt;</span>&#123;</span><br><span class="line">        U item;</span><br><span class="line">        Node&lt;U&gt; next;</span><br><span class="line">        Node()&#123;</span><br><span class="line">            item=<span class="keyword">null</span>;</span><br><span class="line">            next=<span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node(U item,Node&lt;U&gt; next)&#123;</span><br><span class="line">            <span class="keyword">this</span>.item=item;</span><br><span class="line">            <span class="keyword">this</span>.next=next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> item==<span class="keyword">null</span> &amp;&amp; next==<span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; top =<span class="keyword">new</span> Node&lt;T&gt;();<span class="comment">//哨兵</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T item)</span></span>&#123;</span><br><span class="line">        top=<span class="keyword">new</span> Node&lt;T&gt;(item,top);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        T result = top.item;</span><br><span class="line">        <span class="keyword">if</span>(!top.end())&#123;</span><br><span class="line">            top=top.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        LinkedStack&lt;String&gt; list=<span class="keyword">new</span> LinkedStack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String s:<span class="string">"Phasers on stun!"</span>.split(<span class="string">" "</span>))&#123;</span><br><span class="line">            list.push(s);</span><br><span class="line">        &#125;</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span>((s=list.pop())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到内部类Node也是一个泛型，它拥有自己的参数类型</p>
<h3 id="RandomList"><a href="#RandomList" class="headerlink" title="RandomList"></a>RandomList</h3><p>作为另一个例子，假设我们需要一个特定类型对象的列表，每次调用其上的select()方法时，它可以随机地选取一个元素，如果我们希望以此构建一个可以应用与各种类型的对象的工具，就需要泛型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;T&gt; storage=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Random random=<span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T item)</span></span>&#123;storage.add(item);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">select</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> storage.get(random.nextInt());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        RandomList&lt;String&gt; rs=<span class="keyword">new</span> RandomList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String s:<span class="string">"the queue broken brown fox"</span>.split(<span class="string">" "</span>))&#123;</span><br><span class="line">            rs.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            System.out.println(rs.select());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>泛型也可以应用于接口，例如生成器，这是一种专门负责创建对象的类，实际上，这是工厂方法设计模式的一种应用，不过，当使用生成器创建新的对象时，它不需要任何参数，而工厂方法需要参数，也就是说，生成器无需额外的信息就知道如何创建对象，<br>一般而言，一个生成器只定义一个方法，该方法用于产生新的对象，在这里就是next()方法<br><code>public interface Generator&lt;T&gt; {
    T next();
}</code><br>首先我们先创建一个Coffee类及其子类，我们将创建一个生成咖啡的生成器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id =counter++;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName()+id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Latte</span> <span class="keyword">extends</span> <span class="title">Coffee</span></span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mocha</span> <span class="keyword">extends</span>  <span class="title">Coffee</span></span>&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cappuccino</span> <span class="keyword">extends</span> <span class="title">Coffee</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Americano</span> <span class="keyword">extends</span> <span class="title">Coffee</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>在创建一个实现了生成器泛型接口和迭代器的coffee生成器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoffeeGenerator</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">Coffee</span>&gt;,<span class="title">Iterable</span>&lt;<span class="title">Coffee</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class[] types=&#123;Latte.class,Cappuccino.class,Americano.class,Mocha.class&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random random=<span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CoffeeGenerator</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CoffeeGenerator</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;size=a;&#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CoffeeIterator</span> <span class="keyword">implements</span>  <span class="title">Iterator</span>&lt;<span class="title">Coffee</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> counter=<span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> counter&gt;<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Coffee <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            counter--;</span><br><span class="line">            <span class="keyword">return</span> CoffeeGenerator.<span class="keyword">this</span>.next();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Coffee&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CoffeeIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Coffee <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Coffee) types[random.nextInt(types.length)].newInstance();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        CoffeeGenerator gen=<span class="keyword">new</span> CoffeeGenerator();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.out.println(gen.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们再来看下实现Generator泛型接口的另一个实现 Fibonacci数列<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fibonacci</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">next</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> fib(count++); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> fib(n-<span class="number">2</span>)+fib(n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们还想要更近一步，编写一个实现了Itearable的Fibonacci生成器，我们的第一个选择是重写这个类，可是我们并不是总能拥有代码的控制权，并且除非必要，我们也不愿重写代码，我们还有另一种选择，那就是创建一个适配器（adapter）来实现所需要的接口，有很多方法可以实现适配器模式，我们先来看看第一种吧，通过继承实现适配<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FibonacciAdapter</span> <span class="keyword">extends</span> <span class="title">Fibonacci</span> <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FibonacciAdapter</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;<span class="keyword">this</span>.n=n;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Integer&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;Integer&gt;()&#123;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> n&gt;<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                n--;</span><br><span class="line">                <span class="keyword">return</span> FibonacciAdapter.<span class="keyword">this</span>.next();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Integer i:<span class="keyword">new</span> FibonacciAdapter(<span class="number">10</span>))&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>泛型可以应用到整个类上，但同样的也可在类中包含参数化方法，这个方法所在的类可以是泛型类，也可以不是，也就是说，是否用于泛型方法，与其所在的类是否是泛型没有关系<br>一个基本的指导原则是：无论何时，只要你能做到，你就应该尽量使用泛型方法，也就是说，如果使用泛型方法可以取代将整个类泛型话，那么就应该值使用泛型方法，因为它可以使事情更清除明白，<strong>另外，对于一个static的方法而言，无法访问类的类型参数，所以，如果static方法需要使用泛型能力的话，就必须称为泛型方法</strong><br><strong>要定义泛型方法，只需要将泛型参数列表置于返回值之前</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericMothed</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">        System.out.println(x.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        GenericMothed gm=<span class="keyword">new</span> GenericMothed();</span><br><span class="line">        gm.f(<span class="string">""</span>);</span><br><span class="line">        gm.f(<span class="number">1</span>);</span><br><span class="line">        gm.f(<span class="number">1.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的GenericMothed类不是泛型类，尽管这个类和其内部的方法可以被同时参数化，<strong>在使用泛型类时，必须在创建对象的时候指定类型参数的值，而使用泛型方法的时候，通常不必指明参数类，因为编译器会为我们找出具体的类型，这被称为类型参数推断（type argument inference）</strong></p>
<h3 id="杠杆利用类型参数推断"><a href="#杠杆利用类型参数推断" class="headerlink" title="杠杆利用类型参数推断"></a>杠杆利用类型参数推断</h3><p>以前我们在使用泛型的时候，总是会抱怨需要向程序中添加更多的代码，现在编译器可以使得我们能够省略到对泛型参数列表的重复了，我们看下之前我们的代码的例子<br>    Map&lt;Person,List&lt;? extends Pet&gt;&gt; map=new HashMap&lt;Person,List&lt;? extends Pet&gt;&gt;();<br>现在可以这样写<br>    Map&lt;Person,List&lt;? extends Pet&gt;&gt; map=new HashMap&lt;&gt;();<br>参数类型推断也可以用在泛型方法中  下面的例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">New</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="function">Map&lt;K,V&gt; <span class="title">map</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HashMap&lt;K,V&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">list</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Map&lt;String,Integer&gt; map=New.map();</span><br><span class="line">        List&lt;String&gt; list=New.list();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>类型参数推断避免了重复的泛型参数列表<br>类型参数推断只对赋值有效，其他时候并不起作用，如果将一个泛型方法调用的结果作为参数，传递给另一个方法，这时编译器并不会执行类型推断，在这种情况下，编译器认为，调用泛型方法后，其返回值被赋给列哦一个Object类型的变量，<br>    f(New.map())//does not compile<br>应该这样说，编译器之所以能够进行类型推断的一个基本的条件是，编译器能够获得泛型参数的信息，将泛型方法的返回值直接赋给一个泛型类引用，可以通过这个泛型类引用的类型参数推断出泛型方法的泛型参数，但是如果将泛型方法的返回值直接传递给一个方法，编译器得不到指导  </p>
<h3 id="显示的类型说明"><a href="#显示的类型说明" class="headerlink" title="显示的类型说明"></a>显示的类型说明</h3><p>在泛型方法中，可以显式地指明类型，不过这种语法比较少见，<strong>要显示地指明类型，必须在点操作符与方法名之间插入尖括号，然后把类型置于尖括号内如果是在定义该方法的类的内部，必须在点操作符之前使用this关键字，如果是使用static的方法，必须在点操作符之前加上类名</strong><br>    f(New.&lt;String,Integer&gt;map());</p>
<h3 id="可变参数列表与泛型方法"><a href="#可变参数列表与泛型方法" class="headerlink" title="可变参数列表与泛型方法"></a>可变参数列表与泛型方法</h3><p>泛型和可变参数列表能够很好地共存<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericVarargs</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">makeList</span><span class="params">(T... args)</span></span>&#123;</span><br><span class="line">        List&lt;T&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(T item:args)&#123;</span><br><span class="line">            list.add(item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; ls=makeList(<span class="string">"A"</span>);</span><br><span class="line">        System.out.println(ls);</span><br><span class="line">        ls=makeList(<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>);</span><br><span class="line">        ls=makeList(<span class="string">"ABCDRFGHIJKMLNOPQRST"</span>.split(<span class="string">""</span>));</span><br><span class="line">        System.out.println(ls);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="用于Generator的泛型方法"><a href="#用于Generator的泛型方法" class="headerlink" title="用于Generator的泛型方法"></a>用于Generator的泛型方法</h3><p>下面的程序为任何类构造一个Generator，只要该类有没默认的构造器，并且构造器可访问<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicGenerator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; type;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BasicGenerator</span><span class="params">(Class&lt;T&gt; type)</span></span>&#123;</span><br><span class="line">        type=type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> type.newInstance();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Generator&lt;T&gt; <span class="title">create</span><span class="params">(Class&lt;T&gt; type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> BasicGenerator&lt;&gt;( type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面我们创建一个具有默认构造器的类，来测试上面的泛型生成器（generator<t>）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id=count++;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CounterObject</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">id</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> id;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">"CounterObject"</span>+id;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicGenertorDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Generator&lt;CounterObject&gt; gen=BasicGenerator.create(CounterObject.class);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            gen.next();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="一个Set实用工具"><a href="#一个Set实用工具" class="headerlink" title="一个Set实用工具"></a>一个Set实用工具</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sets</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Set&lt;T&gt; <span class="title">union</span><span class="params">(Set&lt;T&gt; a,Set&lt;T&gt; b)</span> </span>&#123;</span><br><span class="line">        Set&lt;T&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;(a);</span><br><span class="line">        result.addAll(b);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Set&lt;T&gt; <span class="title">intersection</span><span class="params">(Set&lt;T&gt; a,Set&lt;T&gt; b)</span></span>&#123;</span><br><span class="line">        Set&lt;T&gt; result =<span class="keyword">new</span> HashSet&lt;&gt;(a);</span><br><span class="line">        result.retainAll(b);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Set&lt;T&gt; <span class="title">different</span><span class="params">(Set&lt;T&gt; superSet,Set&lt;T&gt; subSet)</span></span>&#123;</span><br><span class="line">        Set&lt;T&gt; result=<span class="keyword">new</span> HashSet&lt;&gt;(superSet);</span><br><span class="line">        result.removeAll(subSet);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Set&lt;T&gt; <span class="title">complement</span><span class="params">(Set&lt;T&gt; a,Set&lt;T&gt; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> different(union(a,b),intersection(a,b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>泛型还可以应用于内部类和匿名内部类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id =counter++;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Customer</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">"Customer"</span>+id;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Generator&lt;Customer&gt; <span class="title">generator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Generator&lt;Customer&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Customer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Customer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teller</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id=counter++;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Teller</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">"Teller"</span>+id;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Generator&lt;Teller&gt; <span class="title">create</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Generator&lt;Teller&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Teller <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Teller();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="构建复杂模型"><a href="#构建复杂模型" class="headerlink" title="构建复杂模型"></a>构建复杂模型</h2><p>泛型的一个重要好处就是能够简单而安全地创建复杂的模型，例如我们很容易地创建元组列表这样的结构<br>    class TupleList&lt;A,B,C,D&gt; extends List&lt;FourTuple&lt;A,B,C,D&gt;&gt;{}<br>下面这个示例，展示了使用泛型来创建复杂模型是多么简单，即使每个类都作为一个构建块创建，但是其整个还是包含很多部分，在这个例子中，构建一个零售商，它包含走廊，货架和商品<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Product</span><span class="params">(<span class="keyword">int</span> IDNumber,String descr,<span class="keyword">double</span> price)</span></span>&#123;</span><br><span class="line">        id= IDNumber;</span><br><span class="line">        description=descr;</span><br><span class="line">        price=price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id+<span class="string">":"</span>+description+price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">priceChange</span><span class="params">(<span class="keyword">double</span> price)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price=price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Generator&lt;Product&gt; generator=<span class="keyword">new</span> Generator&lt;Product&gt;() &#123;</span><br><span class="line">        <span class="keyword">private</span> Random rand=<span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Product <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Product(rand.nextInt(<span class="number">1000</span>),<span class="string">"Test"</span>,Math.round(rand.nextDouble()*<span class="number">1000</span>)+<span class="number">0.99</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shelf</span> <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">Product</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Shelf</span><span class="params">(<span class="keyword">int</span> nProduct)</span></span>&#123;</span><br><span class="line">        Generators.fill(<span class="keyword">this</span>,Product.generator,nProduct);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Aisle</span> <span class="keyword">extends</span>  <span class="title">ArrayList</span>&lt;<span class="title">Shelf</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Aisle</span><span class="params">(<span class="keyword">int</span> nShives,<span class="keyword">int</span> nProduct)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nShives;i++)&#123;</span><br><span class="line">            add(<span class="keyword">new</span> Shelf(nProduct));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Checkoutstand</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Office</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Store</span> <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">Aisle</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Checkoutstand&gt; checkoutstands= <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Office&gt; offices=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Store</span><span class="params">(<span class="keyword">int</span> nAisles,<span class="keyword">int</span> nShives,<span class="keyword">int</span> nProduct)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nAisles;i++)&#123;</span><br><span class="line">            add(<span class="keyword">new</span> Aisle(nShives,nProduct));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuilder stb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(Aisle aisle:<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(Shelf shelf:aisle)&#123;</span><br><span class="line">                <span class="keyword">for</span>(Product product:shelf)&#123;</span><br><span class="line">                    stb.append(product.toString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="擦除的神秘之处"><a href="#擦除的神秘之处" class="headerlink" title="擦除的神秘之处"></a>擦除的神秘之处</h2><p>当开始真正研究泛型的时候，会发现大量的东西初看起来是没有任何意义的，例如，尽管可以声明ArrayList.class。但是不能声明ArrayList<integer>.class 再看下面的例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErasedTypeEquivalence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Class c1=<span class="keyword">new</span> ArrayList&lt;String&gt;().getClass();</span><br><span class="line">        Class c2=<span class="keyword">new</span> ArrayList&lt;Integer&gt;().getClass();</span><br><span class="line">        System.out.println(c1==c2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></integer></p>
<p>ArrayList<string>与ArrayList<integer>很容易被认为是不同的类型，不同的类型在行为上肯定不同，比如尝试将一个Integer放入一个ArrayLIst<string>中，但是上面的程序确实认为它们是相同的<br>我们再来看一个例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Frob</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quark</span>&lt;<span class="title">Q</span>&gt;</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LostInformation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Map&lt;String,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Quark&lt;Frob&gt; quark=<span class="keyword">new</span> Quark&lt;&gt;();</span><br><span class="line">        System.out.println(Arrays.toString(list.getClass().getTypeParameters()));</span><br><span class="line">        System.out.println(Arrays.toString(map.getClass().getTypeParameters()));</span><br><span class="line">        System.out.println(Arrays.toString(quark.getClass().getTypeParameters()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*output</span></span><br><span class="line"><span class="comment">[E]</span></span><br><span class="line"><span class="comment">[K,V]</span></span><br><span class="line"><span class="comment">[Q]</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></string></integer></string></p>
<p>根据JDK文档的描述，<strong><code>Class.getTypeParameters()</code>将“返回一个TypeVariable对象数组”,表示有泛型声明所声明的类型参数…</strong>，这就好像是在暗示你可能发现参数类型的信息，但是，正是正如我们所看到的，我们发现的只是作为参数占位符的标识符，这并非是有用的信息<br>我的理解是，如果在我们第一次创建泛型类的对象的时候，传递给它的构造器一个参数类型，在这个类加载生成Class对象里能够保存这个参数类型的信息就好了，可是我们看到，事实并不是这样<br>因此，残酷的现实是：<br><strong>在泛型代码内部，无法获得任何关于泛型参数类型的信息</strong><br>你可以知道诸如类型参数标记和泛型类型边界这类的信息——你却无法知道用来创建某个特定实例的实际的类型参数<br>java泛型是使用擦除来实现的，这意味着当你在使用泛型时，任何具体的类型信息都被擦除了</p>
<h3 id="C-的方式"><a href="#C-的方式" class="headerlink" title="C++的方式"></a>C++的方式</h3><p>下面是使用模板的C++示例<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Manipulate</span>&#123;</span></span><br><span class="line"> T obj;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Manipulate(T x)&#123;obj=x;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">mainpulate</span><span class="params">()</span></span>&#123;obj.f();&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasF</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"HasF::f()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  HasF hf;</span><br><span class="line">  manipulate&lt;HasF&gt; manipulate(hf)；</span><br><span class="line">  manipulate.manipulate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*output</span></span><br><span class="line"><span class="comment">HasF::f()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<p>Manipulate类存储了一个类型T的对象，有意思的地方是manipulate()方法，它在obj上调用f(),它怎么知道f()方法时为类型参数T而存在的呢？当你实例化一个模板时，C++编译器将会进行检查，因此在Manipulate<hasf>被实例化的那一刻，它看到HasF拥有一个f()方法，否则，就会得到一个编译器错误，这样类型安全就会得到保障<br>我们可以将上面的代码用java的方式重写一次，可是这会出现问题，因此擦除的原因，代码内部并不清楚参数类型是什么？我们就没办法去编写类似obj.f()这样的代码<br>为了能够调用f()，我们必须帮助泛型类，给定泛型类的边界，以表示编译器只能接受遵循这个边界的类型，有可以保证给泛型关于参数类型的信息，<br>在这里我们重用extends这个关键字<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manipulate</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">HasF</span>&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> T obj;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Manipulate</span><span class="params">(T x)</span></span>&#123;obj=x;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">manipulate</span><span class="params">()</span></span>&#123;obj.f();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></hasf></p>
<p>边界<t extends="" hasf=""> 声明T必须具有类型HasF或者从HasF导出的类，如果情况确实如此，就可以安全地使用obj.f()了<br>我们说泛型参数将擦除到它的第一个边界（它可能会有多个边界），我们还提到了类型参数的擦除，编译器实际上会把类型参数替换为它的擦除，就像上面的例子一样，T擦除到了HasF，就好像在类的声明中用HasF替换了T一样<br>我们有看到了，在上面的一个提过了泛型的例子好像并没有贡献什么好处，只需要很容易地自己去执行擦除，就可以创建没有泛型的类，而且代码也比较泛化，看下一个我们主动执行擦除的例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manipulate</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> HasF obj;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Manipulate</span><span class="params">(HasF x)</span></span>&#123;obj=x;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">manipulate</span><span class="params">()</span></span>&#123;obj.f();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></p>
<p>这给来哦我们很重要的启示，<strong>只有当你希望使用的类型参数比某个具体类型（以及它所有的子类类型）更加“泛化”的时——也就是说，当你希望代码能够跨越多个类工作时，使用泛型才有所帮助</strong><br><strong>但是</strong>，我们也不要认为<t extends="" hasf="">形式的任何东西都是有缺陷的，例如，如果某个类有一个返回T的方法，那么泛型就会非常有用，因为在使用这个泛型类的时候，泛型参数给了编译器提示，编译器很容易会将T转换为我们使用泛型时指定的参数类型，可以帮助我们很轻松的解决返回值的转型问题  </t></p>
<h3 id="迁移兼容性"><a href="#迁移兼容性" class="headerlink" title="迁移兼容性"></a>迁移兼容性</h3><p>为了减少潜在的关于擦除的混淆，你必须清楚地认识到这不是一个语言特性，它是java的泛型实现的一种折中，因为泛型不是java语言出现时就有的组成部分，所以这种折中是必须的，虽然它会让你很痛苦<br>擦除减少了泛型的泛化性，泛型在java中仍然有用，但是不如它们本来设想的那么有用，而原因就是擦除<br>在基于擦除的实现中，泛型类型被当作第二类类型处理，即不能在某些重要的上下文环境中使用的类型，<strong>泛型类型只有在静态类型检查期间才出现，在此之后，程序中的所有泛型类型都被擦除，替换为它们的非泛型上界</strong>，例如List<t>这样的类型注解将被擦除为List,而普通的类型变量在未指定边界的情况下将被擦除为Object<br><strong>擦除的核心动机是它使得泛化的客户端可以用非泛化的类库来使用，反之亦然，这经常被称为“迁移兼容性”</strong> 在现实中，即使程序员只编写泛型代码，他们也必须处理在Java SE5之前编写的非泛化类库，这些类库饿作者可能从没想过要泛化它们的代码，或者可能刚刚接触泛型<br><strong>因此java泛化不仅必须支持向后兼容性，即现有的代码和类文件仍旧合法 </strong>（这句话的意思是，在泛化之前出现的类库，那些代码并没有考虑使用泛化的情况，如果我们为了使用泛化，那么就无法使用之前以及创建好的而且很成熟的类库了，为了增加泛化特性，就要抛弃以往已经被实践所验证的代码库，即使是对现有代码库进行修改这样代价也太大了）</t></p>
<h3 id="擦除的问题"><a href="#擦除的问题" class="headerlink" title="擦除的问题"></a>擦除的问题</h3><p>因此，擦除主要的正当理由是从非泛化代码到泛化代码的转变过程，以及在不随意破坏现有类库的情况下，将泛型融入到java语言，擦除使得现有的非泛型客户端代码能够在不改变的情况下继续使用，直至客户端准备好用泛型重写这些代码，这是一个崇高的动机，因为它不会破坏所有现有的代码<br>擦除的代价是显著的，<strong>泛型不能被显式地被引用至运行时类型的操作之中</strong>，例如转型，instanceOf操作和new表达式，因为所有有关参数的类型信息都丢失了，无论何时，<strong>当你在编写泛型代码的时候，必须时刻提醒自己，你只是看起来好像拥有有关参数的类型信息而已</strong><br>    Foo<cat> foo=new Foo<cat>();<br>class Foo中代码应该知道现在工作于Cat之上，而泛型语法也在强烈地暗示，在整个类的各个地方，类型都在被替换，<strong>但是事实并非如此</strong>，无论何时，当你编写这个代码的时，时刻提醒自己“不，它只是个Object”<br>另外，擦除和迁移兼容性意味着，使用泛型并不是强制的，尽管你可能希望这样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericBasic</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T element;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  T <span class="title">getElement</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> element;&#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setElement</span><span class="params">(T x)</span></span>&#123;element=x;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived1</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">GenericBasic</span>&lt;<span class="title">T</span>&gt;</span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived2</span> <span class="keyword">extends</span> <span class="title">GenericBasic</span></span>&#123;&#125; <span class="comment">//no Warning没有警告</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErasuereAndInheritance</span> </span>&#123;</span><br><span class="line">    Derived2 d2=<span class="keyword">new</span> Derived2();</span><br><span class="line">    Object obj=d2.getElement();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//d2.set(obj) //warning here  在这里警告</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></cat></cat></p>
<h3 id="边界处的动作"><a href="#边界处的动作" class="headerlink" title="边界处的动作"></a>边界处的动作</h3><p>正因为有了擦除，泛型最令人困惑的方面源于这样一个事实，即可以表示没有任何意义的事物 ，例如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayMaker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; type;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayMaker</span><span class="params">(Class&lt;T&gt; type)</span></span>&#123;type=type;&#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    T[] create(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">return</span> (T[])Array.newInstance(type,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ArrayMaker&lt;String&gt; stringMaker=<span class="keyword">new</span> ArrayMaker&lt;&gt;(String.class);</span><br><span class="line">        String[] stringArray=stringMaker.create(<span class="number">10</span>);</span><br><span class="line">        System.out.println(Arrays.toString(stringArray));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[null,null,null,null,null,null,null,null,null,null]</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
<p>即使type被存储为Class<t>,**擦除也意味着它将被存储为Class,没有任何参数，因此，当你使用它的时候，例如在创建数组时，Array.newInstance()实际上并未拥有kind所蕴含的类型信息，因此它不会产生具体的结果，所以必须转型，这将产生一条令你无法满意的警告<br>注意，对于在泛型中创建数组，使用Array.newInstance()是推荐的方式<br>如果我们要创建一个容器而不是一个数组，情况就有些不同了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListMaker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">create</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//指定了参数类型，实际上就是给了编译器的一个指示，以使得编译期的静态类型检查和转型代码的插入</span></span><br><span class="line">        ListMaker&lt;String&gt; listMaker=<span class="keyword">new</span> ListMaker&lt;T&gt;();</span><br><span class="line">        List&lt;String&gt; list=listMaker.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></p>
<p>编译器不会给出任何警告，尽管我们知道在create()内部的new ArrayList<t>的T被移除了——在运行时，这个类的内部没有任何<t>,因此看起来毫无意义，但是如果你遵从这种思路，并将这个表达式改为new ArrayList()编译器就会给出警告<br>是否真的毫无意义呢？如果返回list之前，将某些对象放入其中，就像下面这样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilledListMaker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">create</span><span class="params">(T item,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        List&lt;T&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            list.add(item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        FilledListMaker&lt;String&gt; fl=<span class="keyword">new</span> FilledListMaker&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; list=fl.create(<span class="string">"hello"</span>,<span class="number">4</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></t></p>
<p><strong>即使，编译器无法知道有关create()中的T信息，但是它仍旧可以在编译期确保你放置到result中的对象具有T类型，使其合适ArrayList<t>,因此，即使擦除在方法或者类内部移除了有关实际类型的信息，编译器仍旧可以确保在方法或类中使用的类型的内部一致性</t></strong><br><strong>因为擦除在方法体中移除了类型信息，所以在运行时的问题就是边界，即对象进入和离开方法的地点，这些正是编译器在编译期执行类型检查并插入转型代码的地点</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObj</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> obj;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">(Object obj)</span></span>&#123;obj=obj;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以使用javap-c SimpleHolder反编译这个代码<br>我们再来看下下面的代码，除了类名和添加了类型参数之外，和上面的代码几乎完全一样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericHolder</span> &lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  T <span class="title">getObj</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> obj;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">(T x)</span></span>&#123;obj=x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        GenericHolder&lt;String&gt; gen =<span class="keyword">new</span> GenericHolder&lt;&gt;();</span><br><span class="line">        gen.setObj(<span class="string">"hello"</span>);</span><br><span class="line">        String str=gen.getObj();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们再来反编译上面的代码，可以看出，转型是在调用get()的时候接受检查的，从get()返回之后的转型消失，但是我们还知道传递给set()的值在编译期接收检查<br>从上面的例子，我们可以得出这样的结论，在使用泛型类的时候，指定参数类型信息，其实是给编译器一个指示，通过添加的参数类型信息，编译器在编译过程中，会主动进行类型检查和添加转型代码，但是在运行期，参数类型信息被擦除<br>所以在泛型中的所有动作都发生在边界处——对传递进来的值进行额外的编译期类型检查，并插入对传递出去的值的转型，这有助于我们澄清对擦除的混淆，记住，<strong>边界是发生动作的地方</strong></p>
<h2 id="擦除的补偿"><a href="#擦除的补偿" class="headerlink" title="擦除的补偿"></a>擦除的补偿</h2><p><strong>擦除丢失了在泛型代码中执行某些操作的能力，任何运行是需要知道确切类型信息的操作都无法工作</strong> 如下例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Erased</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE=<span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Object args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args <span class="keyword">instanceof</span> T)&#123;&#125;<span class="comment">//error</span></span><br><span class="line">        <span class="keyword">new</span> T();<span class="comment">//error</span></span><br><span class="line">        T[] array=<span class="keyword">new</span> T[SIZE];<span class="comment">//error</span></span><br><span class="line">        T[] array=(T) <span class="keyword">new</span> Object[SIZE];<span class="comment">//unckecked warning</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>偶尔可以绕开这些问题，<strong>但是有时必须通过引入类型标签来对擦除进行补偿，这意味着你需要显式地传递你的类型的Class对象，以便你可以在类型表达式中使用它</strong><br>如前面的例子中使用instanceof的尝试失败了，因为其类型信息已经被擦除了，如果引入类型标签，就可以转而使用动态的isInstance();<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassTypeCapture</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; type;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassTypeCapture</span><span class="params">(Class&lt;T&gt; type)</span></span>&#123;type=type;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">f</span><span class="params">(Object arg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  type.isInstance(arg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ClassTypeCapture&lt;String&gt; ct=<span class="keyword">new</span> ClassTypeCapture&lt;&gt;(String.class);</span><br><span class="line">        <span class="keyword">boolean</span> b=ct.f(<span class="string">"hello"</span>);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译器将确保类型标签可以匹配任何泛型参数</p>
<h3 id="创建类型实例"><a href="#创建类型实例" class="headerlink" title="创建类型实例"></a>创建类型实例</h3><p><strong>在Erased.java中创建一个new T()的尝试将无法实现，部分原因是因为擦除，而另一部分原因是因为编译器不能验证T具有默认（无参）构造器</strong><br>在C++中，这种操作是很自然且直观的因为它在编译期受到检查<br>java中的解决办法是传递一个工厂对象，并用它来创建新的实例，最便利的工厂对象就是Class对象，因此如果使用类型标签，那么你就可以使用new Instance（）来创建这个类型的新对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassAsFactory</span> &lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T x;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassAsFactory</span><span class="params">(Class&lt;T&gt; type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            x = type.newInstance();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstantiateGenericType</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ClassAsFactory&lt;Employee&gt; fe=<span class="keyword">new</span> ClassAsFactory&lt;&gt;(Employee.class);</span><br><span class="line">        System.out.println(<span class="string">"ClassAsFactory&lt;Employee&gt; succeeded"</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ClassAsFactory&lt;Integer&gt; ci=<span class="keyword">new</span> ClassAsFactory&lt;&gt;(Integer.class);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"ClassAsFactory&lt;Integer&gt; failed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这可以编译，但是会因为ClassAsFactory<integer>而失败，因为Integer没有默认构造器，因为这个错误不是在编译器捕获的，所以这种方式使用泛型创建对象并不太好，我们没有尽最大的努力将错误隔绝在编译期，<br>Sun建议使用显式的工厂，并限制其类型，使得只能接受实现了这个工厂的类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">FactoryI</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo2</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T x;</span><br><span class="line">    <span class="keyword">public</span> &lt;F extends FactoryI&lt;T&gt;&gt; Foo2(F factory)&#123;<span class="comment">//这里是重点，确保传递的参数必须是那些可向上转型为FactoryI的的类型</span></span><br><span class="line">        x=factory.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntegerFactory</span> <span class="keyword">implements</span> <span class="title">FactoryI</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;  <span class="comment">//这些类都实现料Factory接口，使得对象的创建得到了保证</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span>  Integer <span class="title">create</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> Integer(<span class="number">0</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">FactoryI</span>&lt;<span class="title">Widget</span>&gt;</span>&#123;  <span class="comment">//Widget.Factory也是实现了FcatoryI的接口</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Widget <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Widget();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryConstraint</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Foo2&lt;Integer&gt;(<span class="keyword">new</span> IntegerFactory());</span><br><span class="line">        <span class="keyword">new</span> Foo2&lt;Widget&gt;(<span class="keyword">new</span> Widget.Factory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></integer></p>
<p>注意，这确实是传递Class<t>的一种变体，两种方式都传递了工厂对象，Class<t>碰巧是内建的工厂对象，而上面的方式创建了一个显式的工厂对象，但是你却获得了编译器检查<br>另一种方式是模板方法设计模式，在这个示例中，get是模板方法，而create()是在子类中定义的，用来产生子类类型的对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericWithCreate</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> T element;</span><br><span class="line">    GenericWithCreate()&#123;</span><br><span class="line">        element=create();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> T <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Creator</span> <span class="keyword">extends</span> <span class="title">GenericWithCreate</span>&lt;<span class="title">X</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">X <span class="title">create</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> X();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(element.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreatorGeneric</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Creator creator= <span class="keyword">new</span> Creator();<span class="comment">//在创建导出类对象的时候,element就得到了初始化，</span></span><br><span class="line">        creator.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></t></p>
<h3 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h3><p>Erased.java看到，不能创建泛型数组，一般的解决办法是在任何想要创建泛型数组的地方都使用ArrayList<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListOfGeneric</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; array=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T item)</span></span>&#123;</span><br><span class="line">        array.add(item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> array.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是有时你仍然想要创建泛型类型的数组，<br>数组将会跟着它们的实际类型，而这个类型是在数组被创建时确定的，因此，即使gia已经被转型为Generic<integer>[],但是这个信息只存在与编译器，在运行时，它仍然是Object数组，而这将会引起问题，成功创建泛型数组的唯一方式就是创建一个被擦除类型的新数组，然后对其转型<br>因为有了擦除，数组在运行时类型就只能是Object[],如果我们立即将其转型为T[]，那么在编译器该数组的实际类型就会丢失，而编译器可能会错过某些潜在的错误检查，正因这样，最好是在集合内部使用Object[]，然后当你使用数组元素时，添加一个对T的转型，让我们看下面这个例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericArray2</span> &lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] array;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericArray2</span><span class="params">(<span class="keyword">int</span> sz)</span></span>&#123;</span><br><span class="line">        array=<span class="keyword">new</span> Object[sz];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> index,T item)</span></span>&#123;</span><br><span class="line">        array[index]=item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"Unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;<span class="keyword">return</span> (T)array[index];&#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"Unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> T[] rep()&#123;</span><br><span class="line">        <span class="keyword">return</span> (T[])array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        GenericArray2&lt;Integer&gt; gia=<span class="keyword">new</span> GenericArray2&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            gia.put(i,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.out.println(gia.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Integer[] ia=gia.rep();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></integer></p>
<p>初看起来没什么太多变化，只是转型挪了地方，如果没有@SuppressWranings注解，你依然会得到unchecked警告，但是，现在的内部表示是Object而不是T[],<strong>当get()被调用的时，它将对象转型为T,这实际上是正确的类型，因此也是安全的，然而，如果你调用rep()，它还是尝试着将Object数组转型为T[],这仍旧不正确的，将在编译器生成警告，在运行时产生异常，因此，没有任何方式可以推翻底层的数组类型，它只能是Object[],</strong>在内部将array当作Object[]而不是T[]处理的优势是，我们不太可能忘记这个数组的运行时类型，从而意外地引入缺陷（尽管大多数也可能是所有这类缺陷都可以在运行时快速地探测到）<br>对于新代码，应该传递一个类型标记，在这种情况下，GenericArray看起来应该像下面这样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericArrayWithToken</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"Unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericArrayWithToken</span><span class="params">(Class&lt;T&gt; type,<span class="keyword">int</span> sz)</span></span>&#123;</span><br><span class="line">        array=(T[]) Array.newInstance(type,sz);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> index,T item)</span></span>&#123;</span><br><span class="line">        array[index]=item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T[] rep()&#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        GenericArrayWithToken&lt;Integer&gt; gia=<span class="keyword">new</span> GenericArrayWithToken&lt;&gt;(Integer.class,<span class="number">10</span>);</span><br><span class="line">        Integer[] ia=gia.rep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意，Class<t>被传递到构造器，以便从擦除中恢复，使得我们可创建需要的实际类型的数组</t></strong>，由此，也可以看出，rep()返回的数组被Integer[]捕获在运行期也没有问题，因为数组底层是type类型的元素，数组的创建也是以type为元素类型创建的，所以没有任何问题，所有从这里也可以看出来，数组类型和数组元素类型是不相同的两个概念</p>
<h2 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h2><p><strong>边界使得你可以在用于泛型的参数类型上设置限制条件，尽管这样使得你可以强制规定泛型可以应用的类型，但是潜在的一个更重要的效果是你可以按照自己的边界类型调用方法</strong><br><strong>因为擦除移除了类型信息，所有，可以用无界泛型参数调用的方法只是那些可以用Object调用的方法，但是，如果能够将这个参数限制为某个参数子集，那么你就可以用这些类型子集来调用方法，为了执行这种限制，java重用了extends关键字</strong>，对你来说有一点很重要，即要理解extends关键字在泛型边界上下文环境中和在普通情况下所具有的意义是完全不同的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">HasColor</span></span>&#123;</span><br><span class="line">    <span class="function">Color <span class="title">getColor</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Colored</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">HasColor</span>&gt;</span>&#123;</span><br><span class="line">    T item;</span><br><span class="line">    Colored(T item)&#123; item=item;&#125;</span><br><span class="line">    <span class="function">T <span class="title">getItem</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item;&#125;</span><br><span class="line">    <span class="function">Color <span class="title">getColor</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item.getColor();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dimnension</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x,y,z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColoredDimension</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Dimnension</span> &amp; <span class="title">HasColor</span>&gt;</span>&#123;</span><br><span class="line">    T item;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ColoredDimension</span><span class="params">(T item)</span></span>&#123;</span><br><span class="line">        item=item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">getItem</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item;&#125;</span><br><span class="line">    <span class="function">Color <span class="title">getColor</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item.getColor() ;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item.x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span></span>&#123;<span class="keyword">return</span>  item.y;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getZ</span><span class="params">()</span></span>&#123;<span class="keyword">return</span>  item.z;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Weight</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">weight</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solid</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Dimnension</span> &amp; <span class="title">HasColor</span> &amp; <span class="title">Weight</span>&gt;</span>&#123;</span><br><span class="line">    T item;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solid</span><span class="params">(T item)</span></span>&#123;</span><br><span class="line">        item=item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">getItem</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item;&#125;</span><br><span class="line">    <span class="function">Color <span class="title">getColor</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item.getColor();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item.x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">weight</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item.weight();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bounded</span> <span class="keyword">extends</span> <span class="title">Dimnension</span> <span class="keyword">implements</span> <span class="title">HasColor</span>,<span class="title">Weight</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Color <span class="title">getColor</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">weight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicBounds</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Solid&lt;Bounded&gt; solid=<span class="keyword">new</span> Solid&lt;&gt;(<span class="keyword">new</span> Bounded());</span><br><span class="line">        solid.getColor();</span><br><span class="line">        solid.weight();</span><br><span class="line">        solid.getX();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面是一个很简单的一个例子，我们创建里一个泛型类，这个泛型类能够接受的类型必须是 <code>extends Diamension &amp; HasColor &amp; Weight</code>的，这种对参数类型进行限定的方式，因为编译器的静态类型检查，我们可以很安全的使用这些基类或接口的方法<br>下面例子，看看如何在继承的每个层次上添加边界限制<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HoldItem</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    T item;</span><br><span class="line">    HoldItem(T item)&#123;</span><br><span class="line">        item=item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Colored2</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">HasColor</span>&gt; <span class="keyword">extends</span> <span class="title">HoldItem</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    Colored2(T item)&#123;<span class="keyword">super</span>(item);&#125;</span><br><span class="line">    <span class="function">Color <span class="title">getColor</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item.getColor();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColoredDimension2</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Dimnension</span> &amp; <span class="title">HasColor</span>&gt; <span class="keyword">extends</span> <span class="title">Colored</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">      ColoredDimension2(T item)&#123;<span class="keyword">super</span>(item);&#125;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item.x;&#125;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span></span>&#123;<span class="keyword">return</span>  item.y;&#125;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getZ</span><span class="params">()</span></span>&#123;<span class="keyword">return</span>  item.z;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solid2</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Dimnension</span> &amp; <span class="title">HasColor</span> &amp; <span class="title">Weight</span>&gt; <span class="keyword">extends</span> <span class="title">ColoredDimension2</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    Solid2(T item)&#123;<span class="keyword">super</span>(item);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">weight</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item.weight();&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritBounds</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Solid2&lt;Bounded&gt; solid2=<span class="keyword">new</span> Solid2&lt;&gt;(<span class="keyword">new</span> Bounded());</span><br><span class="line">        solid2.getColor();</span><br><span class="line">        solid2.getX();</span><br><span class="line">        solid2.weight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>HoldItem持有一个对象，因此这种行为被继承到了Color2中，它也要求其参数与HasColor一致，</strong>或者说参数类型要与HoldItem的参数限定的保存一致，这样才能继承基类那些涉及到限定参数类型的方法</p>
<h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><p>我们首先先看一下数组的一种特殊行为，可以向导出类型的数组赋予基类型的数据引用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CovariantArrays</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Fruit[] fruits=<span class="keyword">new</span> Apple[<span class="number">10</span>];</span><br><span class="line">        fruits[<span class="number">0</span>] = <span class="keyword">new</span> Apple();</span><br><span class="line">        fruits[<span class="number">1</span>] = <span class="keyword">new</span> Jonathan();</span><br><span class="line">        <span class="comment">//runtime type is Apple[],not Fruit[] or Orange[]</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            fruits[<span class="number">0</span>]=<span class="keyword">new</span> Fruit();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123; System.out.println(e);&#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            fruits[<span class="number">0</span>]=<span class="keyword">new</span> Orange();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;System.out.println(e);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>main()第一行创建了一个Apple数组，并将其赋值给一个Fruit数组引用，这是有意义的，因为Apple也是一种Fruit，因此Apple数组应该也是Fruit数组<br><strong>但是，如果实际的数组类型是Apple[],你应该只能往里面放Apple或者Apple的子类型，这在编译器和运行期都可以工作</strong>，但是请注意，编译器允许你将Fruit放置到这个数组，这对于编译器是有意义的，因为它有一个Fruit引用——它有什么理由拒绝将Fruit对象或者任何从Fruit继承出来的对象呢放置到这个数组中呢？因此，编译期，这是允许的，但是，运行时的数组机制知道它处理的是Apple[],因此会向数组中放置异构类型是抛出异常<br>我的理解是这样的，数组和其他的对象是不同的，数组对象中的元素所在的内存空间就在数组对象的内存空间呢，当数组对象创建完成后数组的内存空间，所保存的元素的类型信息就已经定下来了，不能改变，那么这也保证了数组不能保存异构类型的元素<br>实际上，向上转型不适合用在这里，你真正做的是将一个数组赋值给另一个数组，数组行为应当是它可以持有其他对象，这里只是因为我们能够向上转型而已，所有很明显，数组对象可以保留有关它们包含的对象类型的规则，就好像数组对它们持有的对象是有意识的，因此在编译器检查和运行时检查之间，你不能滥用它们<br>对数组的这种滥用并不那么可怕，因为在运行时可以发现你已经插入了不正确的类型，<strong>但是泛型的主要目标之一就是将这种错误检测移到编译期</strong>，因此当我们试图使用泛型容器来替代数组时，会发生什么？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//compile error</span></span><br><span class="line">List&lt;Fruit&gt; fruit=<span class="keyword">new</span> ArrayList&lt;Apple&gt;()</span><br></pre></td></tr></table></figure></p>
<p>尽管你在第一次阅读这段代码时会认为：“不能讲一个Apple容器赋值给一个Fruit容器”，别忘了，<strong>泛型不仅和容器相关正确的说法是：“不能把一个涉及Apple的泛型赋给一个设计Fruit的泛型</strong>”，如果就像在数组中的情况一样，编译器对代码的了解足够多，可以确定所涉及的容器，那么它可能留有一些余地，但是它不知道任何有关这方面的信息，因此它拒绝向上转型，<strong>实际上，这里也不是向上转型—</strong>—Apple的List不是Fruit的List，Apple的List将持有Apple和Apple的子类型，而Fruit的List将持有任何类型的Fruit,诚然，这包括Apple，一个Apple的List，它仍然是Fruit的List，Apple的List在类型上不等价于Fruit的List,即使Apple是一种Fruit类型，我们还记得运行时类型信息讲过的<code>Class&lt;Number&gt; Nclass=Integer.class</code>会引发编译错误也是这个原因<br><strong>真正的问题是我们在谈容器的类型，而不是容器持有的类型</strong>，与数组不同，泛型没没有内建的协变类型，这是因为数组在语言上是完全定义的，因为可以内建了编译期和运行时的检查，但是，<strong>在使用泛型时，编译器和运行时系统都不知道你想用类型做些什么，以及应该采用什么样的规则</strong><br>但是有时你想要在两个类型之间建立某种类型的向上转型关系，这正是通配符所允许的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericAndCovariance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;? extends Fruit&gt; fruit=<span class="keyword">new</span> ArrayList&lt;Apple&gt;();</span><br><span class="line">        <span class="comment">//fruit.add(new Apple())编译错误</span></span><br><span class="line">        <span class="comment">//fruit.add(new Fruit());</span></span><br><span class="line">        <span class="comment">//fruit.add(new Object());</span></span><br><span class="line">        fruit.add(<span class="keyword">null</span>);<span class="comment">//legal but uninstersting</span></span><br><span class="line">        <span class="comment">// we know that it returns at least Fruit;</span></span><br><span class="line">        Fruit f = fruit.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>fruit类型现在是List&lt;? extends Fruit&gt;,你可以将其读作“具有任何从Fruit继承的类型的列表”，<strong>但是实际上， 并不意味着这个List将持有任何类型的Fruit</strong>，<strong>通配符引用的是明确的类型</strong>，<strong>因此它意味着“某种fruit引用没有指定的具体类型</strong>”，因此这个被赋值的List必须持有诸如Fruit或Apple这样的某种指定类型，但是为了向上转型为fruit，这个类型是什么并没有人关心<br>如果唯一的限制是这个List要持有某种具体的Fruit或Fruit的子类型，但是你实际上并不关系它是什么，那么你能用这样的List做什么呢？如果不知道List持有什么类型，那么你怎样才能安全地向其中添加对象呢？你不能，除非编译器而不是运行时系统可以阻止这种操作的发生（也就是说只有编译器阻止向其中添加对象，你添加对象的行为才是安全的，这也是为什么我们不能向List&lt;? extends Fruit&gt;这种类型的对象添加对象的原因，一切都是为了类型安全，我们无法容忍在添加之后，运行时才发现问题的这种情况的发生）<br>你可能认为，事情变得有点走极端了，因为现在你甚至不能向刚刚声明过将持有Apple对象的List中放置一个Apple对象了，是的，编译器并不知道这一点，List&lt;? extends Fruit&gt;可以合法地指向一个List<orange>,一旦指向这种类型的向上转型，你就会丢失掉向其中传递任何对象的能力，甚至Object也不行<br>一方面，如果你调用一个返回Fruit的方法，则是安全的，因为你知道在这个List中的任何对象都至少具有Fruit类型，因此编译器允许这么做 </orange></p>
<h3 id="编译器有多聪明"><a href="#编译器有多聪明" class="headerlink" title="编译器有多聪明"></a>编译器有多聪明</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompileIntelligence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;? extends Fruit&gt; fruits=<span class="keyword">new</span> ArrayList&lt;Apple&gt;();</span><br><span class="line">        Apple a=(Apple)fruits.get(<span class="number">0</span>);</span><br><span class="line">        fruits.contains(<span class="keyword">new</span> Apple());<span class="comment">//argument is "Object"</span></span><br><span class="line">        fruits.indexOf(<span class="keyword">new</span> Apple()); <span class="comment">//argument is "Object"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以看到，对contains()和indexOf()的调用，这两个方法都接受Apple对象作为参数，而这些调用都可以正常执行，这是否意味着编译器实际上将检查代码，以查看是否有某个特定的方法修改了它的对象？<br>通过查看ArrayList文档，我们发现，编译器并没有那么充满，尽管add()方法接受一个具有泛型参数类型的参数，但是contains()和indexOf()将接受一个Object类型的参数，因此当你指向一个ArrayList&lt;? extends Fruit&gt;时，add()的参数就变成了“？extends Fruit”(我在编辑add()方法的时候，确实IDE会提醒这个方法的参数是“？ extends Fruit”，这里的意思是：这个方法接受Fruit类型及其子类型的参数，从这个描述中看，编译器也不确定，接受的是哪个确切的类型，因为编译器对参数类型的信息了解的并不多，为了类型安全（编译期的静态类型检查），编译器拒绝接受任何类型的参数)<br>在使用contains()和indexOf()时，参数类型是Object，因此不涉及任何通配符，而编译器也将允许这个调用，这意味这个将由泛型类的设计来决定哪些调用是“安全”的，并使用Object类型作为其参数类型，<strong>为了在类型中使用了通配符的情况下禁止这类调用，我们需要在参数列表中使用类型参数</strong><br>我们来做个总结，当我们使用类似&lt;? extends Fruit&gt;这样的类型参数时，泛型类中那些在方法列表中不涉及类型参数的方法可以正常调用，而在参数列表中使用了类型参数的方法将会被编译器禁止调用<br>看下面是一个很简单的例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T item;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">(T item)</span></span>&#123;</span><br><span class="line">        item=item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T item)</span></span>&#123;item=item;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.equals(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Holder&lt;Apple&gt; apple=<span class="keyword">new</span> Holder&lt;&gt;(<span class="keyword">new</span> Apple);</span><br><span class="line">        Apple d=apple.get();</span><br><span class="line">        apple.set(<span class="keyword">new</span> Apple());</span><br><span class="line">        Holder&lt;? extends Fruit&gt; fruit=apple;</span><br><span class="line">        Fruit p=fruit.get();</span><br><span class="line">        d=(Apple) fruit.get();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Orange o = (Orange) fruit.get();<span class="comment">//可以，但是运行时类型转换异常</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//fruit.set(new Orange()); 参数列表中涉及到类型参数的方法不能调用</span></span><br><span class="line">        <span class="comment">//fruit.set(new Apple());</span></span><br><span class="line">        System.out.println(fruit.equals(d));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="逆变"><a href="#逆变" class="headerlink" title="逆变"></a>逆变</h3><p><strong>还可以走另外一条路，即使用超类型通配符，这里，可以声明通配符是由某个特定类的任意基类来界定，方法是指定&lt;? super MyClass&gt;，甚至或者使用类型参数&lt;? extends T&gt;</strong>（尽管你不能对泛型参数给出一个超类型边界，即不能声明<t super="" myclass="">）,<strong>这使得你可以安全地传递一个类型对象到泛型类型中</strong> 看下面一个例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperTypeWildcards</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeTo</span><span class="params">(List&lt;? <span class="keyword">super</span> Apple&gt; apples)</span></span>&#123;</span><br><span class="line">        apples.add(<span class="keyword">new</span> Apple());</span><br><span class="line">        apples.add(<span class="keyword">new</span> Jonathan());</span><br><span class="line">        <span class="comment">//apples.add(new Fruit()); //error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></p>
<p>从这例子看出&lt;? super Apple&gt;表明参数类型被指定为Apple的基类，因此泛型类的那些方法的参数列表就变为&lt;? super Apple&gt;，方法接受的类型是Apple的基类，Apple是下界，这样向这些方法传递Apple及其子类型是安全的，（Apple的基类都能接受，Apple及Apple的子类型更是不在话下）</p>
<p>因此你可能根据如何能够向一个泛型类型“写入”(传递给一个方法)，以及如何能够从一个泛型类型中“读取”（从一个方法中返回），来这手思考子类型边界&lt;? extends MyClass&gt;和超类型边界(&lt;? super MyClass&gt;)<br>超类型边界放松了在可以向方法传递参数上所作的限制<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericWriting</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">writeExact</span><span class="params">(List&lt;T&gt; list,T item)</span></span>&#123;</span><br><span class="line">        list.add(item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">writeWithSuperWildcard</span><span class="params">(List&lt;? <span class="keyword">super</span> T&gt; list,T item)</span></span>&#123;</span><br><span class="line">        list.add(item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> List&lt;Apple&gt; apples= <span class="keyword">new</span> ArrayList&lt;Apple&gt;();</span><br><span class="line">    <span class="keyword">static</span> List&lt;Fruit&gt; fruit =<span class="keyword">new</span> ArrayList&lt;Fruit&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        writeExact(apples,<span class="keyword">new</span> Apple());</span><br><span class="line">        writeExact(fruit,<span class="keyword">new</span> Apple());<span class="comment">//为什么，没有编译错误？</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        writeWithSuperWildcard(apples,<span class="keyword">new</span> Apple());</span><br><span class="line">        writeWithSuperWildcard(fruit,<span class="keyword">new</span> Apple());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        f1();</span><br><span class="line">        f2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在《编程思想》中，writeExact(fruit，new Apple())中指明这种方式有编译错误，found Fruit required Apple,但是为什么，我在编译器中没有发现任何编译错误的提示呢？难道是java之后的版本支持了向List<fruit>类型的引用，传递Apple?<br>回来再研究这个问题<br>下面的例子，作为对协变和通配符的一个复习<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericReading</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">readExact</span><span class="params">(List&lt;T&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> List&lt;Apple&gt; apples=Arrays.asList(<span class="keyword">new</span> Apple());</span><br><span class="line">    <span class="keyword">static</span> List&lt;Fruit&gt; fruits=Arrays.asList(<span class="keyword">new</span> Fruit());</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">     Apple a=readExact(apples);</span><br><span class="line">     Fruit f=readExact(fruits);</span><br><span class="line">     f=readExact(apples);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Reader</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">        <span class="function">T <span class="title">readExact</span><span class="params">(List&lt;T&gt; list)</span></span>&#123; <span class="keyword">return</span> list.get(<span class="number">0</span>);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Reader&lt;Fruit&gt; fruitReader=<span class="keyword">new</span> Reader&lt;&gt;();</span><br><span class="line">        Fruit f=fruitReader.readExact(fruits);</span><br><span class="line">        <span class="comment">//error raedFruit(List&lt;Fruit&gt;) cannot be applied to (Lisy&lt;Apple&gt;)</span></span><br><span class="line">        <span class="comment">//Fruit a=fruitReader.readExact(apples);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CovariantReader</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function">T <span class="title">readCovariant</span><span class="params">(List&lt;? extends T&gt; list)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        CovariantReader&lt;Fruit&gt; convariantRead=<span class="keyword">new</span> CovariantReader&lt;&gt;();</span><br><span class="line">        Fruit f=convariantRead.readCovariant(apples);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        f1();f2();f3()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></fruit></p>
<p>第1个方法readExact()使用了精确类型，因此如果使用了这个没有任何通配符的精确类型，就可以向List中写入和读取这个精确类型，另外，对于返回值，静态的泛型方法readExact()可以有效地“适应”每个方法调用，并能从List<apple>中返回一个Apple，从List<fruit>，返回一个Fruit,就像f1()看到的那样，因此，如果可以摆脱静态泛型方法，那么当只是读取时，就不需要协变类型了<br>但是，如果有个泛型类，那么当你创建这个类的实例时，要为这个类确定参数，就像在f2()中看到的那样，fruitReader实例可以从List<fruit>中读取一个Fruit，因为这就是它的确切类型，但是List<apple>还应该产生一个Fruit对象，而fruitReader不允许这么做<br>为了修正这个问题。CovariantReader.readCovariant()方法将接受List&lt;? extends T&gt;,因此，从这个列表读取一个T是安全的（你知道在这个列表中的所有对象至少是一个T，并且可能是从T导出的某种对象），在f3()中，你可以看到现在可以从List<apple><br>中读取Fruit了</apple></apple></fruit></fruit></apple></p>
<h3 id="无界通配符"><a href="#无界通配符" class="headerlink" title="无界通配符"></a>无界通配符</h3><p>无界通配符&lt;?&gt;看起来意味着“任何事物”，因此使用无界通配符好像等价于使用原生类型，事实上，编译器初看起来是支持这种判断的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnboundWildcards1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> List list1;</span><br><span class="line">    <span class="keyword">static</span> List&lt;?&gt; list2;</span><br><span class="line">    <span class="keyword">static</span> List&lt;? extends Object&gt; list3;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign1</span><span class="params">(List list)</span></span>&#123;</span><br><span class="line">        list1=list;</span><br><span class="line">        list2=list;</span><br><span class="line">        <span class="comment">//list3=list; warning:unchecked coversion</span></span><br><span class="line">        <span class="comment">//found List,Required: List&lt;? extends Object&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign2</span><span class="params">(List&lt;?&gt; list)</span></span>&#123;</span><br><span class="line">        list1=list;</span><br><span class="line">        list2=list;</span><br><span class="line">        list3=list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign3</span><span class="params">(List&lt;? extends Object&gt; list)</span></span>&#123;</span><br><span class="line">        list1=list;</span><br><span class="line">        list2=list;</span><br><span class="line">        list3=list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assign1(<span class="keyword">new</span> ArrayList());</span><br><span class="line">        assign2(<span class="keyword">new</span> ArrayList());</span><br><span class="line">        <span class="comment">//assign3(new ArrayList()); warning unchecked conversion found ArrayList Required:list&lt;? extends Object&gt;</span></span><br><span class="line">        assign1(<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">        assign2(<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">        assign3(<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">        List&lt;?&gt; wildList=<span class="keyword">new</span> ArrayList();</span><br><span class="line">        wildList=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        assign1(wildList);</span><br><span class="line">        assign2(wildList);</span><br><span class="line">        assign3(wildList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有很多情况都和你在这里看到的情况类似，即编译器很少关心使用的原生类型还是&lt;?&gt;。在这种情况中，&lt;?&gt;可以被认为是一种装饰，但是它仍旧是有价值的，<strong>因为实际上，它是在声明：我想要java的泛型来编写这段代码，我在这里并不是要用原生类型，但是在当前这种情况下，泛型参数可以持有任何类型</strong><br>下面一个示例展示了无界通配符的一个重要应用，<strong>当你在处理多个泛型参数时，有时允许一个参数可以是任何类型，因此为其他参数确定某种特定类型的这种能力很重要</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Unboundwildcards2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Map map1；</span><br><span class="line">    <span class="keyword">static</span> Map&lt;?,?&gt; map2;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;String,?&gt; map3;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign1</span><span class="params">(Map map)</span></span>&#123;</span><br><span class="line">        map1=map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign2</span><span class="params">(Map&lt;?,?&gt; map)</span></span>&#123;map2=map;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign3</span><span class="params">(Map&lt;String,?&gt; map)</span></span>&#123;map3=map;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        assign1(<span class="keyword">new</span> HashMap());</span><br><span class="line">        assign2(<span class="keyword">new</span> HashMap());</span><br><span class="line">        <span class="comment">//assign3(new HashMap());//warning</span></span><br><span class="line">        assign1(<span class="keyword">new</span> HashMap&lt;String,Integer&gt;());</span><br><span class="line">        assign2(<span class="keyword">new</span> HashMap&lt;String,Integer&gt;());</span><br><span class="line">        assign3(<span class="keyword">new</span> HashMap&lt;String,Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是，当你拥有的是全部的无界通配符时，就像在Map&lt;?,?&gt;中看到的那样，编译器看起来即无法将其与原生Map区分开了，另外，UnboundWildcard1.java展示了编译器处理List&lt;?&gt;和List&lt;? extends Object&gt;时是不同的<br>令人困惑的是，编译器并非总是关注像List&lt;?&gt;和List之间的这种差异，因此它们看起来就像是相同的事物，因为，事实上，由于泛型参数将擦除到它的第一边界，因此List&lt;?&gt;看起来等价于List<object>，而实际上也是List<object>——除非这些语句都不为真，List世家上表示“持有任何Object类型的原生List”，而List&lt;?&gt;表示“具有某种特定类型的非元素List,只是我们不知道那种类型是什么”<br>编译器何时才会关注原生类型和涉及无界通配符的类型之间的差异呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wildcards</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rawArgs</span><span class="params">(Holder holder,Object args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//holder.set(args);//warning unchecked call to set(T) as a member of the raw Holder</span></span><br><span class="line">       <span class="comment">// holder.set(new Wildcards());//simple warning</span></span><br><span class="line">        Object obj=holder.get();</span><br><span class="line">        <span class="comment">//can't do this; don't have any T</span></span><br><span class="line">        <span class="comment">//T t=holder.get();</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unboundedArgs</span><span class="params">(Holder&lt;?&gt; holder,Object args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//holder.set(args);error注意这里是直接错误而不是警告</span></span><br><span class="line">        <span class="comment">//set(captre of ?) in Holder&lt;capture of ?&gt;</span></span><br><span class="line">        <span class="comment">//can't do this; don't have any T</span></span><br><span class="line">        <span class="comment">//T t=holder.get();</span></span><br><span class="line">        <span class="comment">//ok but type information has been lost</span></span><br><span class="line">        Object obj=holder.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">exact1</span><span class="params">(Holder&lt;T&gt; holder)</span></span>&#123;</span><br><span class="line">        T t= holder.get();</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">exact2</span><span class="params">(Holder&lt;T&gt; holder,T args)</span></span>&#123;</span><br><span class="line">        holder.set(args);</span><br><span class="line">        T t = holder.get();</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">wildSubType</span><span class="params">(Holder&lt;? extends T&gt; holder,T args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//holder.set(args); error</span></span><br><span class="line">        T t= holder.get();</span><br><span class="line">        <span class="keyword">return</span>  t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">wildSupType</span><span class="params">(Holder&lt;? <span class="keyword">super</span> T&gt; holder,T args)</span></span>&#123;</span><br><span class="line">        holder.set(args);</span><br><span class="line">        <span class="comment">//T t=holder.get();error</span></span><br><span class="line">        Object obj=holder.get();<span class="comment">//but type information has been lost</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Holder raw =<span class="keyword">new</span> Holder&lt;Long&gt;();</span><br><span class="line">        <span class="comment">//or</span></span><br><span class="line">        raw=<span class="keyword">new</span> Holder();</span><br><span class="line">        Holder&lt;Long&gt; qualified=<span class="keyword">new</span> Holder&lt;&gt;();</span><br><span class="line">        Holder&lt;?&gt; unbounded=<span class="keyword">new</span> Holder&lt;Long&gt;();</span><br><span class="line">        Holder&lt;? extends Long&gt; bounded=<span class="keyword">new</span> Holder&lt;Long&gt;();</span><br><span class="line">        Long lng=<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">        rawArgs(raw,lng);</span><br><span class="line">        rawArgs(qualified,lng);</span><br><span class="line">        rawArgs(unbounded,lng);</span><br><span class="line">        rawArgs(bounded,lng);</span><br><span class="line"></span><br><span class="line">        unboundedArgs(raw,lng);</span><br><span class="line">        unboundedArgs(qualified,lng);</span><br><span class="line">        unboundedArgs(unbounded,lng);</span><br><span class="line">        unboundedArgs(bounded,lng);</span><br><span class="line"></span><br><span class="line">        Object r1=exact1(raw);<span class="comment">//warnning</span></span><br><span class="line">        Long r2 =exact1(qualified);</span><br><span class="line">        Object r3=exact1(unbounded);<span class="comment">//Must return Object</span></span><br><span class="line">        Long r4=exact1(bounded);</span><br><span class="line"></span><br><span class="line">        Long r5=exact2(raw,lng)<span class="comment">//warning</span></span><br><span class="line">        Long r6 =exact2(qualified,lng);</span><br><span class="line">        <span class="comment">//Long r7 = exact2(unbounded,lng);//Error</span></span><br><span class="line">        <span class="comment">//Long r8=exact2(bounded,lng);//error</span></span><br><span class="line">        <span class="comment">//exact2(Holder&lt;T&gt;,T) cannot be applied</span></span><br><span class="line">        <span class="comment">//to (Holder&lt;capture of ? extends Long&gt;,Long)</span></span><br><span class="line"></span><br><span class="line">        Long r9=wildSubType(raw,lng);<span class="comment">//warnings</span></span><br><span class="line">        <span class="comment">//unchecked conversion form Holder to Holder&lt;? extends Long&gt;</span></span><br><span class="line">        <span class="comment">//unchecked method invocation:</span></span><br><span class="line">        <span class="comment">//wildSubType(Holder&lt;? extends T&gt;,T) is applied to (Holder,Long)</span></span><br><span class="line"></span><br><span class="line">        Long r10=wildSubType(qualified,lng);</span><br><span class="line">        <span class="comment">//ok but can only return Object</span></span><br><span class="line">        Object r11=wildSubType(unbounded,lng);</span><br><span class="line">        Long r12=wildSubType(bounded,lng);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//wildSubType(raw,lng);warnnings</span></span><br><span class="line">        <span class="comment">//unchecked conversion from Holder to Holder&lt;? super Long&gt;</span></span><br><span class="line">        <span class="comment">//nchecked method invocation;</span></span><br><span class="line">        <span class="comment">//wildSupType(Holder&lt;? super T&gt;,T) is applied to (Holder,Long)</span></span><br><span class="line"></span><br><span class="line">        wildSupType(qualified,lng);</span><br><span class="line">        <span class="comment">//wildSupType(unbounded,lng);//error</span></span><br><span class="line">        <span class="comment">//wildSuType(Holder&lt;? super T&gt;,T) cannot be applied to (Holder&lt;Capture of ?&gt;,Long)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//wildSupType(bounded,lng);error</span></span><br><span class="line">        <span class="comment">//wildSpType(Holder&lt;? super T&gt;,T)cannot be applied to (Holder&lt;capture of ? extends Long&gt;,Long )</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></object></object></p>
<p>在rawArgs()中，编译器知道Holder是一个泛型类型，因此即使它在这里表示成一个原生类型，编译器仍然知道向set()传递一个Obeject是不安全的，由于它是原生类型，你可以将任何类型的对象传递给set()，而这个对象将被向上转型为Object，因此无论何时，<strong>只要使用了原生类型，都会放弃编译器检查</strong>，对get()的调用说明了相同的问题，没有任何T类型的睇相，因此结果只能是一个Object<br>人们很自然会开始考虑原生类型Holder和Holder&lt;?&gt;是大致相同的事物，但是unboundArg()强调了它们的不同——它揭示了相同的问题，但是它将这些问题作为错误而不是警告报告，<strong>因为原生Holder将持有任何类型的组合，而Holder&lt;?&gt;将持有具有某种具体类型的同构集合，因此不能只是向其中传递Object</strong><br>在exact1()和exact2()中，你可以看到使用了确切的泛型类型——没有任何通配符，你将看到，exact2和exact1()有不同的限制，因为它有额外的参数<br>在wildSubType()中，在Holder类型上的限制被放松为包括持有任何扩展子T的对象的Holder，这还是意味着如果T是Fruit，那么Holder可以是Holder<apple>,这是合法的，为了防止将Orange()放置到Holder<apple>中，对set()的调用（或者任何接受这个类型参数的方法的调用）都是不允许的，但是，你仍旧知道任何来自Holder&lt;? extends Fruit&gt;的对象至少都是Fruit的，因此get()(任何参数列表不涉及类型参数的方法)的调用都是允许的<br>wildSupType()展示了超类型通配符，因此set()可以接受T,因为任何可以工作于基类的对象都可以多态地作用于导出类（这里就是T），但是尝试着调用get()是没用的，因此由Holder持有的类型可以是任何超类型，因此唯一安全的类型即使Object,但是这样具体的类型信息就会丢失<br>这个例子还展示了对于unbounded()中使用无界通配符能够做什么不能做什么所做出的限制，对于迁移兼容性，rawArgs()将接受所有Holder的不同变体，而不会产生警告，unboundedArgs()方法也可以接受相同的所有类型，尽管如前所示，它在方法体内部处理这些类型的方式并不相同<br><strong>如果向接受“确切”泛型类型（没有通配符）的方法产地一个原生Holder引用，就会得到一个警告，因为确切的参数期望得到在原生类型中并不存在的信息</strong>如果向exact1()传递一个无界引用，就不会有任何可以确定返回类型的类型信息<br>可以看到，exact2()具有更多的限制，因为它希望精确地得到一个Holder<t>，已经一个具有T类型的参数，正因如此，它将产生错误或者警告，除非提供确切的参数，有时，这样做很好，但是如果它过于受限，那么就可以使用通配符，这取决与是否想要从泛型参数中返回类型确定返回值（就像在wildSubType中看到的那样），或者是否想要向泛型参数传递类型确定的参数（就像在wildSupType()中看到的那样）<br>因此使用确切类型来替代通配符的好处是，可以用泛型参数来做更多事，但是使用通配符使得你必须接受范围更宽的参数化类型作为参数，因此，必须逐个情况地权衡利弊，找到更适合你的方法</t></apple></apple></p>
<h3 id="捕获转换"><a href="#捕获转换" class="headerlink" title="捕获转换"></a>捕获转换</h3><p><strong>有一种情况特别需要使用&lt;?&gt;而不是原生类型，如果像一个使用&lt;?&gt;的方法传递原生类型，那么对与编译器来说，可能会推断出实际的参数类型，使得这个方法可以回转并调用另一个使用这个确切类型的方法</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CaptureConversion</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(Holder&lt;T&gt; holdedr)</span></span>&#123;</span><br><span class="line">        T t=holdedr.get();</span><br><span class="line">        System.out.println(t.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">(Holder&lt;?&gt; holder)</span></span>&#123;</span><br><span class="line">        f1(holder);<span class="comment">//call with capture type</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Holder raw = <span class="keyword">new</span> Holder&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//f1(raw);//warnings</span></span><br><span class="line">        f2(raw);<span class="comment">//no warning</span></span><br><span class="line">        Holder rawBasic=<span class="keyword">new</span> Holder();</span><br><span class="line">        rawBasic.set(<span class="keyword">new</span> Object());<span class="comment">//warning</span></span><br><span class="line">        f2(rawBasic);<span class="comment">//no warning</span></span><br><span class="line">        Holder&lt;?&gt; wildcarded=<span class="keyword">new</span> Holder&lt;Double&gt;();</span><br><span class="line">        f2(wildcarded);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output</span></span><br><span class="line"><span class="comment">Integer</span></span><br><span class="line"><span class="comment">Object</span></span><br><span class="line"><span class="comment">Double</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
<p>f1()的参数类型都是确切的，没有通配符或边界，在f2()中，Holder参数是一个无界通配符，因此它看起来是未知的，但是，在f2()中，f1()被调用，而f1()需要一个已知参数，<strong>这里发生的是，参数类型在调用f2()的过程中被捕获，因此它可以在对f1()的调用中被使用</strong><br>你可能想知道，这项技术是否可以用于写入，但是这要求要在床底Holder&lt;?&gt;同时传递以恶搞具体类型，捕获站好只有在这样的情况下才能工作：即在方法内部，你需要使用确切的类型  </p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="任何基本类型都不能作为类型参数"><a href="#任何基本类型都不能作为类型参数" class="headerlink" title="任何基本类型都不能作为类型参数"></a>任何基本类型都不能作为类型参数</h3><h3 id="实现参数化接口"><a href="#实现参数化接口" class="headerlink" title="实现参数化接口"></a>实现参数化接口</h3><p>一个类不能实现一个泛型接口的两种变体，由于擦除的影响，这两个变体会成为相同的接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Payable</span>&lt;<span class="title">T</span>&gt;</span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Payable</span>&lt;<span class="title">Employee</span>&gt;</span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hourly</span> <span class="keyword">extends</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Payable</span>&lt;<span class="title">Hourly</span>&gt;</span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>Hourly不能编译成功，因为擦除会将Payable<eployee>和Payable<hourly>简化成相同的类Payable</hourly></eployee></p>
<h3 id="转型和警告"><a href="#转型和警告" class="headerlink" title="转型和警告"></a>转型和警告</h3><p>使用带有泛型参数的转型或instanceof不会产生任何效果，下面的容器在内部将各个值存储为Object，并在获取这些值时，再将它们转型回T<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FixedSizeStack</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Object[] storage;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FixedSizeStack</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">       storage=<span class="keyword">new</span> Object[size]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T item)</span></span>&#123;storage[index++]=item;&#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> (T)storage[index--];&#125;<span class="comment">//重点在这一行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericCast</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE=<span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        FixedSizeStack&lt;String&gt; strings=<span class="keyword">new</span> FixedSizeStack&lt;&gt;(SIZE);</span><br><span class="line">        <span class="keyword">for</span>(String str:<span class="string">"A B C D E F G H I J"</span>.split(<span class="string">" "</span>))&#123;</span><br><span class="line">            strings.push(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;SIZE;i++)&#123;</span><br><span class="line">            String s=strings.pop();</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果没有@SuppressWranings注解，编译将会产生“unchecked cast”警告,<strong>由于擦除的影响，编译器无法知道这个转型是否是安全的，并且pop()方法实际上没有执行任何转型，这是因为，T被擦除到它的第一个边界，默认情况下是Object，因此pop()实际上只是将Object转型为Object</strong><br><strong>有时，泛型没有消除对转型的需要，就会产生编译器警告，而这个警告是不恰当的，例如</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NeedCasting</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]));</span><br><span class="line">        List&lt;Widget&gt; shape=(List&lt;Widget&gt;)in.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>readObject()无法知道它正在读取的是什么，因此它返回的是必须转型的对象，但是当注释点@SuppressWranings注解，并编译这个程序的时，就会出现下面的警告<br>Note:NeedCasting,java uses unchecked or unsafe operations<br>Note:Recompile with —Xlint:unchecked for detail<br>如果遵循这条指示，使用—Xlint：unchecked来重新编译<br>NeedCasting.java:12: warning:[unckecked] unchecked cast<br>found :java.lang.Object<br>required: java.util.List<widget><br>   List<shape> shapes=(List<widget>)in.readObject();<br>你会被强制要求转型，但是又被告知不应该转型，为了解决这个问题，必须使用在java SE5中引入的新的转型形式，既通过泛型类来转型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NeedCasting</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]));</span><br><span class="line">        <span class="comment">//List&lt;Widget&gt; lw1=List&lt;Widget&gt;.class.cast(in.readObject());</span></span><br><span class="line">        List&lt;Widget&gt; lw2=List.class.cast(in.readObject());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></widget></shape></widget></p>
<p>这里是相当奇怪的</p>
<h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>下面的程序是不能编译的，即使编译它是一种合理的尝试<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseList</span>&lt;<span class="title">W</span>,<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(List&lt;T&gt; v)</span></span>&#123;&#125;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(List&lt;W&gt; v)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于擦除的影响，重载方法将产生相同的类型签名</p>
<h3 id="基类劫持了接口"><a href="#基类劫持了接口" class="headerlink" title="基类劫持了接口"></a>基类劫持了接口</h3><p>假设你有一个Pet类，它可以与其他的Pet类对象进行比较（实现了Comparable接口）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparablePet</span>  <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ComparablePet</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(@NotNull ComparablePet o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对可以与ComparablePet的子类比较的类型进行窄化是有意义的，例如，一个Cat对象就只能与其他Cat对象进行比较<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">ComparablePet</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Cat</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(@NotNull Cat o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>遗憾的是上面代码错误，一旦为Comparable确定了ComparablePet参数，那么其他任何实现类都不能与ComparablePet之外的任何对象比较<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hamster</span> <span class="keyword">extends</span> <span class="title">ComparablePet</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ComparablePet</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(ComparablePet args)</span></span>&#123;<span class="keyword">return</span>  <span class="number">1</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Hasmter说明再次实现ComparablePet中的接口是可能的，只要它们精确地相同，包括参数类型在内</p>
<h2 id="自限定的类型"><a href="#自限定的类型" class="headerlink" title="自限定的类型"></a>自限定的类型</h2><p>在java中，经常出现一个令人费解的惯用法<br>class SelfBound&lt;T extends SelfBound<t>&gt;<br>这就像是两面镜子彼此看着对方产生的炫目感，是一种无限循环，SelfBound接受泛型参数T，而T由一个边界类限定，这个边界就是拥有T作为参数的ShefBound</t></p>
<h3 id="古怪的循环泛型"><a href="#古怪的循环泛型" class="headerlink" title="古怪的循环泛型"></a>古怪的循环泛型</h3><p>我们先从简单的版本入手<br><strong>不能直接继承一个泛型参数，但是，可以继承在其自己的定义中使用这个泛型参数的类</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericType</span>&lt;<span class="title">T</span>&gt;</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuriouslyRecurringGeneric</span> <span class="keyword">extends</span> <span class="title">GenericType</span>&lt;<span class="title">CuriouslyRecurringGeneric</span>&gt;</span>&#123; &#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的例子可以称为“古怪的循环”，<strong>“古怪的循环”是指类相当古怪地出现在自己的基类中这一事实</strong><br>为了理解其含义，努力地大声说“<strong>我正在创建一个新类吗，这个类继承子一个泛型类型，这个泛型类型的接受我的类的名字作为其参数</strong>”，当给出导出类的名字时，<strong>这个泛型基类能够实现什么呢？好吧，java中的泛型关乎参数和返回类型，因此它能够产生使用导出类作为参数和返回类型的积累，它还能将导出类用作其域类型，甚至那些将其擦除为Object的类型</strong><br>下面是一个普通的泛型类,它的方法将接受和产生具有参数类型的对象，还有一个方法将在其存储的域上执行操作（尽管只在这个域上执行Object操作）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicHolder</span> &lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T item;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setItem</span><span class="params">(T item)</span></span>&#123;item=item;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getItem</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(item.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面这个示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubType</span> <span class="keyword">extends</span> <span class="title">BasicHolder</span>&lt;<span class="title">SubType</span>&gt;</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CRWithBasicHolder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">      SubType subType1=<span class="keyword">new</span> SubType();</span><br><span class="line">      SubType subType2=<span class="keyword">new</span> SubType();</span><br><span class="line">      subType1.setItem(subType2);</span><br><span class="line">      SubType subType3=subType1.getItem();</span><br><span class="line">      subType1.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>新类SubType接受的参数和返回的值具有SubType类型而不仅仅是基类Basicholder的类型，这就是CRG(古怪的循环)的本质，<strong>基类用导出类替代其参数</strong>，<strong>这意味着泛型基类变成了一种其所有导出类的公共功能的模版，但是这些功能对于其所有参数和返回值，将使用导出类型，也就是说，在产生的类中将使用确切类型而不是其基类型</strong>，因此，在SubType中，传递给set()的参数和从get()返回的类型都是确切的SubType</p>
<h3 id="自限定"><a href="#自限定" class="headerlink" title="自限定"></a>自限定</h3><p>BasicHolder可以使用任何类型作为其泛型参数，就像下面看到的那样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Other</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicOther</span> <span class="keyword">extends</span> <span class="title">BasicHolder</span>&lt;<span class="title">Other</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        BasicOther b=<span class="keyword">new</span> BasicOther();</span><br><span class="line">        b.setItem(<span class="keyword">new</span> Other());</span><br><span class="line">        Other o=b.getItem();</span><br><span class="line">        b.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>自限定将采取额外的步骤，强制泛型当作其自己的边界参数来使用</strong><br>观察所产生的类可以如何使用以及不可以如何使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelfBounded</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&gt;</span>&#123;</span><br><span class="line">    T element;</span><br><span class="line">    <span class="function">SelfBounded&lt;T&gt; <span class="title">set</span><span class="params">(T arg)</span></span>&#123;</span><br><span class="line">        element=arg;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">A</span>&gt;</span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">A</span>&gt;</span>&#123;&#125;<span class="comment">//also ok</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">C</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">C <span class="title">setAndGet</span><span class="params">(C arg)</span></span>&#123;</span><br><span class="line">        set(arg);</span><br><span class="line">        <span class="keyword">return</span> get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//class E extends SelfBounded&lt;D&gt;&#123;&#125;can't do this</span></span><br><span class="line"><span class="comment">//compile error : Type parameter D is not within its bound</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//also you can do this ,so you can't force the idiom</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelfBounding</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        A a =<span class="keyword">new</span> A();</span><br><span class="line">        a.set(<span class="keyword">new</span> A());</span><br><span class="line">        a=a.set(<span class="keyword">new</span> A()).get();</span><br><span class="line">        a=a.get();</span><br><span class="line"></span><br><span class="line">        C c=<span class="keyword">new</span> C();</span><br><span class="line">        c=c.setAndGet(<span class="keyword">new</span> C());</span><br><span class="line"></span><br><span class="line">        B b=<span class="keyword">new</span> B();</span><br><span class="line">        b.set(<span class="keyword">new</span> A());</span><br><span class="line">        A ba=b.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>自限定所做的，就是要求在继承关系中，像下面这样使用这个类</strong><br>    class A extends SelfBounded<a>{}<br><strong>这会强制要求将正在定义的类当作参数传递给基类</strong><br>从基类的类型参数的表达式也能看的出来</a></p>
<p>&lt;T extends SelfBounded<t>&gt; T表示类型参数，这个参数的类型是其自身类型的导出类<br>自限定的参数有何意义呢？它可以保证类型参数必须与正在被定义的类相同<br>正如你从B类的定义所看到的，还可以从另一个SelfBounded参数的SelfBounded中导出，尽管A类看到的用法是最主要的用法<br>对定义E的尝试说明不能使用不是SelfBounded的类型参数<br>遗憾的是，F可以编译，不会有任何警告，这是比较奇怪的吗？这也说明了自限定惯用法不是可强制执行的，如果它确实很重要，可以要求一个外部工具来确保不会使用原生类型来替代参数化类型<br>注意，可以移除自限定这个限制，这样所有的类仍旧可以编译的，但是E也因此可编译成功<br>其实自限定类型的目的就是限定导出类在继承基类的时候，必须将参数类型替换为导出类（只要是基类的导出类都可以，一般我们惯用的是新建的这个导出类自身来替代参数类型而已，一次泛型类的自限定对于继承自它的类来说，没什么一样，自限定最大的功效就是强制而已）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A2</span> <span class="keyword">extends</span> <span class="title">NotSelfBounded</span>&lt;<span class="title">A</span>&gt;</span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span> <span class="keyword">extends</span> <span class="title">NotSelfBounded</span>&lt;<span class="title">A2</span>&gt;</span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C2</span> <span class="keyword">extends</span> <span class="title">NotSelfBounded</span>&lt;<span class="title">C2</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">C2 <span class="title">getAndSet</span><span class="params">(C2 arg)</span></span>&#123; set(arg);<span class="keyword">return</span> get(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E2</span> <span class="keyword">extends</span> <span class="title">NotSelfBounded</span>&lt;<span class="title">D2</span>&gt;</span>&#123;&#125;<span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotSelfBounded</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T element;</span><br><span class="line">    <span class="function">NotSelfBounded&lt;T&gt; <span class="title">set</span><span class="params">(T arg)</span></span>&#123;</span><br><span class="line">        element=arg;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> element;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></p>
<p>这里E2能够编译，即使D2不在NotSelfBounded继承关系中，因此得出结论：<strong>自限定限制只能强制作用于继承关系</strong>。<br>自限定也可以用在泛型方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelfBoundedMethods</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T extends SelfBounded&lt;T&gt;&gt; <span class="function">T <span class="title">f</span><span class="params">(T arg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arg.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        A a=f(<span class="keyword">new</span> A());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="参数协变"><a href="#参数协变" class="headerlink" title="参数协变"></a>参数协变</h3><p>自限定类型的价值是它可以产生协变参数类型——方法参数类型会随着子类而变化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">OrdinaryGetter</span></span>&#123;</span><br><span class="line">    <span class="function">Base <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">DerivedGetter</span> <span class="keyword">extends</span> <span class="title">OrdinaryGetter</span></span>&#123;</span><br><span class="line">    <span class="function">Derived <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CovariantReturnType</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(DerivedGetter d)</span></span>&#123;</span><br><span class="line">        Derived d2=d.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>DerivedGetter中的get()方法覆盖了OrderinaryGetter中的get()方法，并返回一个从OrderinaryGetter.get()返回类型中导出的类型，尽管这是很合理的，导出类方法应该能够返回比它覆盖的基类方法更具体的类型，但是这在java之前的版本中是不合法的<br>自限定泛型实际上将产生确切的导出类型作为其返回值，就像在get()中看到的那样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GenericGetter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">GenericGetter</span>&lt;<span class="title">T</span>&gt;&gt;</span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Getter</span> <span class="keyword">extends</span> <span class="title">GenericGetter</span>&lt;<span class="title">Getter</span>&gt;</span>&#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsAndGetter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(Getter g)</span></span>&#123;</span><br><span class="line">        Getter result=g.get();</span><br><span class="line">        GenericGetter gg=g.get();<span class="comment">//also the base type</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在非泛代码中，参数类型不能随子类型发生变化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrdinarySetter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Base base)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"OrdinarySetter.set(Base)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedSetter</span> <span class="keyword">extends</span> <span class="title">OrdinarySetter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Derived derived)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"DerivedSetter.set(Derived)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderinaryArguments</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Base base=<span class="keyword">new</span> Base();</span><br><span class="line">        Derived derived=<span class="keyword">new</span> Derived();</span><br><span class="line">        DerivedSetter ds=<span class="keyword">new</span> DerivedSetter();</span><br><span class="line">        ds.set(derived);</span><br><span class="line">        ds.set(base);<span class="comment">//这是重载，不是覆盖，overloade，not overridden</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">DerivedSetter.set(Derived)</span></span><br><span class="line"><span class="comment">OrdinarySetter,set(Base)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
<p>set(Derived)和set(Base)都是合法的，因此DerivdeSetter.set(Derived)方法没有覆盖OrdinarySetter.set(Base)方法，而是重载了它，基类版本的代码依然是可用的<br>但是，在使用自限定类型时，在导出类中只有一个方法，并且这个方法接受导出类而不是基类型为参数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SelfBoundSetter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SelfBoundSetter</span>&lt;<span class="title">T</span>&gt;&gt;</span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">set</span><span class="params">(T arg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Setter</span> <span class="keyword">extends</span> <span class="title">SelfBoundSetter</span>&lt;<span class="title">Setter</span>&gt;</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelfBoundingAndConvariantArguments</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testA</span><span class="params">(Setter s1,Setter s2,SelfBoundSetter sb3)</span></span>&#123;</span><br><span class="line">        s1.set(s2);</span><br><span class="line">        <span class="comment">//s1.set(sb3);  set(Setter) in SelfBoundSetter&lt;Setter&gt;</span></span><br><span class="line">        <span class="comment">//cannot be applied to SelfBoundSetter</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>上面这个例子可以看出，编译器不能识别将基类当作参数传递给setter()的尝试，因为没有任何方法具有这样的签名</strong><br>如果不使用自限定类型，普通的继承机制就会介入，而你将能够重载，就像在非泛型的情况下一样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericSetter</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(T arg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"GenericSetter.set(Base)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedGs</span> <span class="keyword">extends</span> <span class="title">GenericSetter</span>&lt;<span class="title">Base</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Derived derived)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"DerivedGs.set(Derived)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlainGenericInheritance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Base base=<span class="keyword">new</span> Base();</span><br><span class="line">        Derived derived=<span class="keyword">new</span> Derived();</span><br><span class="line">        DerivedGs derivedGs=<span class="keyword">new</span> DerivedGs();</span><br><span class="line">        derivedGs.set(base);</span><br><span class="line">        derivedGs.set(derived);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">GenericSetter.set(Base)</span></span><br><span class="line"><span class="comment">DerivedGs.set(Derived)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
<h2 id="动态类型安全"><a href="#动态类型安全" class="headerlink" title="动态类型安全"></a>动态类型安全</h2><p>因为可以向java SE5之前的代码传递容器，所以旧式代码仍旧有可能破坏你的容器（这句话的意思，向你的容器插入不正确的类型）,java SE5的java.util.Collections中有一组便利的工具，可以解决在这种情况下的类型检查问题，它们是，静态方法checkedCollection(),checkedList(),checkedMap(),checkedSet(),checkedSortedMap()和checkedSortedSet(),这些方法每一个都将会希望动态检查的容器作为第一第一个参数接受，并将你希望强制要求的类型作为第二个参数接受<br>受检查的容器，在你试图插入类型不正确的对象时抛出ClassCastException，这与泛型之前的（原生）容器形成对比，对于后者来说，当你将对象从容器中取出的时候，才会通知你出现了问题，而且你也不知道问题是什么时候造成的，受检查的容器与其不同，当向这个容器插入不良对象的时候我们就立刻知道问题发生了<br>用受检查的容器来看看“将猫插入狗列表中”这个问题，这里oldStyleMethod代表遗留代码，因为它接受原生容器List，而@SuppressWarnings注解对这些遗留代码是必需的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pet</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span>  <span class="title">Pet</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span>  <span class="title">Pet</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckedList</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">oldStyleMethod</span><span class="params">(List probablyDogs)</span></span>&#123;</span><br><span class="line">        probablyDogs.add(<span class="keyword">new</span> Cat());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;Dog&gt; dogs1=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        oldStyleMethod(dogs1);<span class="comment">//Quietyly accepts a Cat//不会抛出异常 也不会警告，因为遗留代码使用了原生类型作为参数</span></span><br><span class="line">        List&lt;Dog&gt; dogs2= Collections.checkedList(<span class="keyword">new</span> ArrayList&lt;Dog&gt;(),Dog.class);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oldStyleMethod(dogs2);<span class="comment">//抛出异常</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//derived Type work fine</span></span><br><span class="line">        List&lt;Pet&gt;  pets=Collections.checkedList(<span class="keyword">new</span> ArrayList&lt;Pet&gt;(),Pet.class);</span><br><span class="line">        pets.add(<span class="keyword">new</span> Dog());</span><br><span class="line">        pets.add(<span class="keyword">new</span> Cat());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行这个程序，会发现向dog1插入Cat没有任何问题，如果问题出现也只会在以后从容器中取出时才会发现，因为遗留代码使用了原生类型而不是泛型类型，向dog2插入一个Cat会立马抛出异常</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>由于擦除的影响，将泛型应用于异常是非常受限的。catch语句不能捕获泛型类型的异常，因为在编译期和运行期都必须知道异常的确切类型，泛型类也不呢个直接或间接继承自Throwable(这将进一步阻止你去定义一个不能捕获的泛型异常)<br>但是，类型参数可能会在一个方法的throws子句中用到，这使得你可以编写随检查型异常的类型而发生变化的泛型代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Processor</span>&lt;<span class="title">T</span>,<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Exception</span>&gt;</span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;T&gt; resultCollector)</span><span class="keyword">throws</span> E</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProcessRuuner</span>&lt;<span class="title">T</span>,<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Exception</span>&gt; <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">Processor</span>&lt;<span class="title">T</span>,<span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">processAll</span><span class="params">()</span><span class="keyword">throws</span> E</span>&#123;</span><br><span class="line">        List&lt;T&gt; resultCollector=<span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Processor&lt;T,E&gt; p:<span class="keyword">this</span>)&#123;</span><br><span class="line">            p.process(resultCollector); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  resultCollector;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Failure1</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Processor1</span> <span class="keyword">implements</span> <span class="title">Processor</span>&lt;<span class="title">String</span>,<span class="title">Failure1</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;String&gt; resultCollector)</span> <span class="keyword">throws</span> Failure1 </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count--&gt;<span class="number">1</span>)</span><br><span class="line">            resultCollector.add(<span class="string">"hep!"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            resultCollector.add(<span class="string">"Ho!"</span>);</span><br><span class="line">        <span class="keyword">if</span>(count&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Failure1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Failuer2</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Processor2</span> <span class="keyword">implements</span>  <span class="title">Processor</span>&lt;<span class="title">Integer</span>,<span class="title">Failuer2</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;Integer&gt; resultCollector)</span> <span class="keyword">throws</span> Failuer2 </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count-- == <span class="number">0</span>)</span><br><span class="line">            resultCollector.add(<span class="number">11</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            resultCollector.add(<span class="number">47</span>);</span><br><span class="line">        <span class="keyword">if</span>(count&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Failuer2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowGenericException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ProcessRuuner&lt;String,Failure1&gt; runner1=<span class="keyword">new</span> ProcessRuuner&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            runner1.add(<span class="keyword">new</span> Processor1());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(runner1.processAll());</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Failure1 e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ProcessRuuner&lt;Integer,Failuer2&gt; runner2 = <span class="keyword">new</span> ProcessRuuner&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            runner2.add(<span class="keyword">new</span> Processor2());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(runner2.processAll());</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Failuer2 e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码是很简单的，虽然看起来很长，说明了异常也可以参数化</p>
<h2 id="混型"><a href="#混型" class="headerlink" title="混型"></a>混型</h2><p>混型（混合的类型，使得这个类型可以混合多个类的能力）随着时间的推移好像拥有无数的含义，<strong>但是其最基本的概念是混合多个类型的能力，以产生一个可以表示混型中所有类型的类</strong>，这往往是你最后的手段，它使得组装多个类型变得简单易行</p>
<h3 id="C-中的混型"><a href="#C-中的混型" class="headerlink" title="C++中的混型"></a>C++中的混型</h3><p>代码不写了，C++中，使用多重继承的最大理由，就是为了使用混型，但是对于混型来说，更有趣，更优雅的方式是使用参数化类型，因为混型就是继承子其类型参数的类，在C++中，可以很容易的创建混型，因为C++能够记住模版参数的类型</p>
<h3 id="与接口混合"><a href="#与接口混合" class="headerlink" title="与接口混合"></a>与接口混合</h3><p>在java中，最常见的解决方案就是使用接口来产生混型的效果,类似这样的吧<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">C</span></span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span></span>;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">C</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mix</span> <span class="keyword">extends</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">B</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="使用装饰器模式"><a href="#使用装饰器模式" class="headerlink" title="使用装饰器模式"></a>使用装饰器模式</h3><p>当你观察混型的使用方式时，你会发现混型概念好像与装饰器模式关系很近，装饰器常用于满足各种可能的组合，而直接子类化会产生过多的类，因此是不实际的<br><strong>装饰器模式使用了分层对象来动态透明地向单个对象添加责任，装饰器是指包装在最初的对象周围的所有对象都具有的基本接口</strong>，某些事物是可装饰的，可以通过是其他类包装在这个可装饰对象的四周，来将功能分层，这使得对装饰器的使用是透明的——无论对象是否被装饰，你都拥有一个可以向对象发送的公共接口集，装饰器也可以添加新的方法，但是正如你所见的，这将是受限的<br><strong>装饰器是使用组合和形式化结构（可装饰物/装饰器层次结构）来实现的</strong>，而混型是基于继承的，因此可以将基于参数化类型的混型当作是一种泛型装饰器机制，这种机制不需要装饰器设计模式的继承结构<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Processor</span>&lt;<span class="title">T</span>,<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Exception</span>&gt;</span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;T&gt; resultCollector)</span><span class="keyword">throws</span> E</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProcessRuuner</span>&lt;<span class="title">T</span>,<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Exception</span>&gt; <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">Processor</span>&lt;<span class="title">T</span>,<span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">processAll</span><span class="params">()</span><span class="keyword">throws</span> E</span>&#123;</span><br><span class="line">        List&lt;T&gt; resultCollector=<span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Processor&lt;T,E&gt; p:<span class="keyword">this</span>)&#123;</span><br><span class="line">            p.process(resultCollector); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  resultCollector;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Failure1</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Processor1</span> <span class="keyword">implements</span> <span class="title">Processor</span>&lt;<span class="title">String</span>,<span class="title">Failure1</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;String&gt; resultCollector)</span> <span class="keyword">throws</span> Failure1 </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count--&gt;<span class="number">1</span>)</span><br><span class="line">            resultCollector.add(<span class="string">"hep!"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            resultCollector.add(<span class="string">"Ho!"</span>);</span><br><span class="line">        <span class="keyword">if</span>(count&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Failure1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Failuer2</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Processor2</span> <span class="keyword">implements</span>  <span class="title">Processor</span>&lt;<span class="title">Integer</span>,<span class="title">Failuer2</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;Integer&gt; resultCollector)</span> <span class="keyword">throws</span> Failuer2 </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count-- == <span class="number">0</span>)</span><br><span class="line">            resultCollector.add(<span class="number">11</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            resultCollector.add(<span class="number">47</span>);</span><br><span class="line">        <span class="keyword">if</span>(count&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Failuer2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowGenericException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ProcessRuuner&lt;String,Failure1&gt; runner1=<span class="keyword">new</span> ProcessRuuner&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            runner1.add(<span class="keyword">new</span> Processor1());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(runner1.processAll());</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Failure1 e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ProcessRuuner&lt;Integer,Failuer2&gt; runner2 = <span class="keyword">new</span> ProcessRuuner&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            runner2.add(<span class="keyword">new</span> Processor2());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(runner2.processAll());</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Failuer2 e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>产生自泛型的类包含所有感兴趣的方法，<strong>但是由使用装饰器所产生的对象类型是最后被装饰的类型，也就是说，尽管可以添加多个层，但是最后一层才是实际的类型，因此只有最后一层的方法时可视的</strong>，而混型的类型是所有被混合到一起的类型，因此对于装饰器来说，其明显的缺陷就是它只能有效地工作于装饰器中的一层（最后一层），而混型方法显然会更自然一些，因此，装饰器只是对由混型提出的问题的一种局限的解决方案</p>
<h3 id="与动态代理混合"><a href="#与动态代理混合" class="headerlink" title="与动态代理混合"></a>与动态代理混合</h3><p><strong>可以使用动态代理来创建一种比装饰器更贴近混型模型的机制，通过使用动态代理，所产生的类的动态类型将会是已经混入的组合类型</strong><br>由于动态代理的限制，每个被混入的类都必须是某个接口的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MixinProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">    Map&lt;String,Object&gt; delegatesByMethod;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mixin</span><span class="params">(TwoTuple&lt;Object,Class&lt;?&gt;&gt;... pairs)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(TwoTuple&lt;Object,Class&lt;?&gt;&gt; pair:pairs)&#123;</span><br><span class="line">          <span class="keyword">for</span>(Method method:pair.second.getMethods())&#123;</span><br><span class="line">              String methodName=method.getName();</span><br><span class="line">              <span class="comment">//the first inferface in the map</span></span><br><span class="line">              <span class="comment">//implements the method</span></span><br><span class="line">              <span class="keyword">if</span>(!delegatesByMethod.containsKey(methodName))&#123;</span><br><span class="line">                  delegatesByMethod.put(methodName,pair.first);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        String methodName=method.getName();</span><br><span class="line">        Object delegate=delegatesByMethod.get(methodName);</span><br><span class="line">        <span class="keyword">return</span> method.invoke(delegate,args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newInstance</span><span class="params">(TwoTuple... pairs)</span></span>&#123;</span><br><span class="line">        Class[] interfaces=<span class="keyword">new</span> Class[pairs.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pairs.length;i++)&#123;</span><br><span class="line">            interfaces[i]=(Class) pairs[i].second</span><br><span class="line">        &#125;</span><br><span class="line">        ClassLoader c1=pairs[<span class="number">0</span>].first.getClass().getClassLoader();</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(c1,interfaces,<span class="keyword">new</span> MixinProxy(pairs));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyMixin</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Object mixin=MixinProxy.newInstance(</span><br><span class="line">                tuple(<span class="keyword">new</span> BasicImp(),Basic.class),tuple(<span class="keyword">new</span> TimeStampedImp(),TimeStamped.class),</span><br><span class="line">                tuple(<span class="keyword">new</span> SerialNumberedImp(),SerialNumbered.class));</span><br><span class="line">        Basic b=(Basic)mixin;<span class="comment">//重点在这里</span></span><br><span class="line">        TimeStamped t=(TimeStamped)mixin;</span><br><span class="line">        SerialNumbered s=(SerialNumbered)mixin;</span><br><span class="line">        b.set(<span class="string">"Hello"</span>);</span><br><span class="line">        b.get();</span><br><span class="line">        t.getStamp();<span class="comment">//重点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为只有动态类型而不是静态类型才包含所有的混入类型，因此这种方式依然不如C++的方式好，因为可以在具有这些类型的对象上调用方法之前，你必须被强制要求向下转型到恰当的类型，但是，它明显更接近于真正的混型</p>
<h2 id="潜在类型机制"><a href="#潜在类型机制" class="headerlink" title="潜在类型机制"></a>潜在类型机制</h2><p>泛型的理想就是能够编写尽可能泛化代码，为了实现这一点，我们需要各种途径来放松带我们代码将要作用的类型所做的限制，同时不丢失静态类型检查的好处，然后，我们就可以编写出无需修改就可以应用于更多情况的代码，即更加“泛化”的代码<br>java泛型看起来是向这一方向迈进了一步，但你编写或使用只是持有对象的泛型时，这些代码可以引用于任何类型，后者，换个角度，“持有器”泛型能够声明：“我不关心你是什么类型”，如果代码不关心它将要作用的类型，那么这种代码就可以真正地被用在任何地方，并因此而相当地泛化<br>还是正如你所看到的那样，<strong>当要在泛型类型上执行操作（即调用Object方法之外的操作）时，就会产生问题，因为擦除要求指定可能会用到的泛型参数的边界，以安全地调用代码中的泛型对象上的具体方法，这是对“泛化”概念 的一种很明显地限制，因为限制了你的泛型类型，使它们继承自特定的类，或者实现特定的接口，在某些情况下，你最终可能会使用普通类或普通接口，因为限定边界的泛型可能会和指定类和接口没有任何区别</strong><br>某些编程语言提供了一种解决方案称为潜在类型机制或结构化参数机制，而更古怪的术语称为“鸭子类型机制”，鸭子理论非常有名，如果“它走起来像鸭子，叫起来像鸭子，那你你就可以将它当作鸭子看待”<br>泛型代码典型地将在泛型类型上调用少量的代码，而且潜在类型机制的语言只要求实现某个方法的子集，而不是某个特定的接口，从而方式了这种限制（并且产生了更加泛化的代码），正由于此，<strong>潜在类型机制使得你可以横跨多个类继承结构，调用不属于某个公共接口的方法，因此，实际上一段代码可以声明：“我不关心你是什么类型，只要你可以speck()和sit()即可</strong>”由于不要求具体类型，因此代码更加泛化<br>潜在类型机制是一种代码组织和复用机制，有了它编写出的代码相对没有它编写出的代码，能够更容易复用，代码组织和复用是所有计算机编程的基本手段，编写一次，多次使用，并在一个位置上保存代码，因为我并未被要求去命名我的代码要操作于其上的确切接口<br><strong>两种支持潜在类型机制的语言实例是Python和C++，Python是动态类型语言（实际上所有的类型检查都发生在运行时），而C++是静态类型语言（类型检查发生在编译期），因此潜在类型机制不要求静态类型还是动态类型检查</strong><br>我们下Python和C++的代码吧，即使你没有学过这两门语言，你也能理解下面代码的概念</p>
<h2 id="对缺乏潜在类型安全机制的补偿"><a href="#对缺乏潜在类型安全机制的补偿" class="headerlink" title="对缺乏潜在类型安全机制的补偿"></a>对缺乏潜在类型安全机制的补偿</h2><p>尽管java不支持潜在类型机制，但是这并不意味着有界泛型代码不能在不同的类型层次结构之间应用，也就是说，我们仍旧可以创建真正的泛型代码，但是这需要付出一些额外的努力</p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>下面的profrom就是用了潜在类型机制<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mime</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walkAgainstTheWind</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span></span>&#123;System.out.println(<span class="string">"pretending to sit"</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushInvisibleWalls</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">"Mime"</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartDog</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;System.out.println(<span class="string">"Woof"</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span></span>&#123;System.out.println(<span class="string">"Sitting"</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reproduct</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommunicateReflectively</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">perform</span><span class="params">(Object specker)</span></span>&#123;</span><br><span class="line">        Class&lt;?&gt; spkr=specker.getClass();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Method m = spkr.getMethod(<span class="string">"speak"</span>);</span><br><span class="line">                m.invoke(specker);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                System.out.println(specker + <span class="string">" cannot speak"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Method m = spkr.getMethod(<span class="string">"sit"</span>);</span><br><span class="line">                m.invoke(specker);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                System.out.println(specker + <span class="string">"cannot sit"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(specker.toString(),e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LatentReflection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        CommunicateReflectively.perform(<span class="keyword">new</span> Mime());</span><br><span class="line">        CommunicateReflectively.perform(<span class="keyword">new</span> SmartDog());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的例子，类完全啊彼此分离的，没有任何公共基类（除了Object）或接口,通过反射，CommunicateReflectively.perform()能够动态地确定所需要的方法是否可用并调用它们，它甚至能够处理Mime只具有一个必须的方法这一事实，并能够部分实现其目标</p>
<h3 id="将一个方法应用于序列"><a href="#将一个方法应用于序列" class="headerlink" title="将一个方法应用于序列"></a>将一个方法应用于序列</h3><p><strong>反射提供了一些有趣的可能性，但是它将所有的类型检查都转移到了运行时，因此在许多情况下并不是我们所希望的，如果能够实现编译器类型检查，这通常更符合要求</strong>，但是有可能实现编译器类型检查和潜在类型机制吗？<br>我们看一个说明这个问题的示例，假设想要创建一个apply()方法，它能够将任何方法应用于谋而序列的所有对象，这是接口看起来并不适合的情况，因为你想要将任何方法应用到一个对象集合，而接口对于描述“任何方法”存在过多的限制，任何用java来实现这个需求呢？<br>最初，我们可以用反射来解决这个问题，由于有JavaSE5的可变参数，这种方法被证明是优雅的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apply</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T ,S extends Iterable&lt;? extends T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(S seq, Method f, Object... args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (T t : seq) &#123;</span><br><span class="line">                f.invoke(t, args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">()</span></span>&#123;System.out.println(<span class="keyword">this</span>+<span class="string">"rotate"</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reSize</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;System.out.println(<span class="keyword">this</span>+<span class="string">"resize"</span>+size);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilledList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">FilledList</span><span class="params">(Class&lt;? extends T&gt; type,<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">              add(type.newInstance());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplyTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        List&lt;Shape&gt;  shapes=<span class="keyword">new</span> FilledList&lt;&gt;(Shape.class,<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            shapes.add(<span class="keyword">new</span> Shape());</span><br><span class="line">        &#125;</span><br><span class="line">        Apply.apply(shapes, Shape.class.getMethod(<span class="string">"rotate()"</span>));</span><br><span class="line">        Apply.apply(shapes,Shape.class.getMethod(<span class="string">"reSize"</span>, <span class="keyword">int</span>.class),<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Square&gt; squares=<span class="keyword">new</span> FilledList&lt;&gt;(Square.class,<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            squares.add(<span class="keyword">new</span> Square());</span><br><span class="line">        &#125;</span><br><span class="line">        Apply.apply(squares,Square.class.getMethod(<span class="string">"retate"</span>));</span><br><span class="line">        Apply.apply(squares,Square.class.getMethod(<span class="string">"reSize"</span>, <span class="keyword">int</span>.class),<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        Apply.apply(<span class="keyword">new</span> FilledList&lt;Shape&gt;(Shape.class,<span class="number">10</span>),Shape.class.getMethod(<span class="string">"retate"</span>));</span><br><span class="line">        Apply.apply(<span class="keyword">new</span> FilledList&lt;Shape&gt;(Square.class,<span class="number">10</span>),Square.class.getMethod(<span class="string">"retate"</span>));</span><br><span class="line">        SimpleQueue&lt;Shape&gt; shapeQ=<span class="keyword">new</span> SimpleQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            shapeQ.add(<span class="keyword">new</span> Shape());</span><br><span class="line">            shapeQ.add(<span class="keyword">new</span> Square());</span><br><span class="line">        &#125;</span><br><span class="line">        Apply.apply(shapeQ,Shape.class.getMethod(<span class="string">"retate"</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们运气很好，因为碰巧在Java中内建了一个由Java容器类库使用的Iterable接口，因此，apply()方法可以接受任何实现了Iterable接口的事物，实际上，它还接受其他任何事物，只要能够使得这些事物是Iterable的就可以了<br>注意，我们必须要使用边界和通配符，以便是Apply和FilledList在所需要的情况下都可以使用，<br><strong>FilledList表示有些进退两难的情况，为了使用某种类型，它必须要有默认的构造器，但是java没有任何方式可以在编译器断言这件事，因此变成了一个运行时问题，确保编译器检查的有个常见的建议是定义一个工厂接口</strong>，它有一个可以生产对象的方法，然后FilledList接受这个接口而不是这个类型标记的“原生工厂（Class对象）”，<strong>但是，大部分的类都是在不了解你的接口的情况下创建的，因此也就没有实现这个接口</strong>，稍后，我们展示一种使用适配器的解决办法<br>使用类型标记是一种合理的折中，错误在运行时报告，所有你要有把握，这些错误将在开发过程的早期出现<br>注意，使用类型标记是java文献推荐的技术，但是也有很多人强烈推荐使用工厂方法让错误在编译器就被发现<br>尽管java解决方案被证明很优雅，但是我们必须知道使用反射（尽管反射在最近的版本中以及明显的改善）可能比非反射的实现要慢一些，因为大多数动作都是在运行时发生的，但是这不应该成为你使用这个解决方案的脚本，至少可以将其作为一种马上就能想到的解决方案  </p>
<h3 id="当你并未碰巧拥有正确的接口时"><a href="#当你并未碰巧拥有正确的接口时" class="headerlink" title="当你并未碰巧拥有正确的接口时"></a>当你并未碰巧拥有正确的接口时</h3><p>我们看到上面的例子，Iterable接口是内建，我们很容易创建容器并使用它，但是如果不存在刚好适合你的需求的接口呢？<br>看下面一个例子，让我们泛化FilledList中的思想，创建一个参数化的方法fill(),它接受一个序列<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fill</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(Collection&lt;T&gt; collection, Class&lt;? extends T&gt; type, <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                collection.add(type.newInstance());</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Contract</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id =counter++;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getSimpleName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TitleTransfer</span> <span class="keyword">extends</span> <span class="title">Contract</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FillTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       List&lt;Contract&gt; contracts=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       Fill.fill(contracts,Contract.class,<span class="number">3</span>);</span><br><span class="line">       Fill.fill(contracts,TitleTransfer.class,<span class="number">2</span>);</span><br><span class="line">       <span class="keyword">for</span>(Contract c:contracts)&#123;</span><br><span class="line">           System.out.println(c);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//don't work fill()is not generic enough;</span></span><br><span class="line">       <span class="comment">//SimpleQueue&lt;Contract&gt; simpleQueue=new SimpleQueue&lt;&gt;();</span></span><br><span class="line">       <span class="comment">//Fill.fill(simpleQueue,Contract.class,3);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们使用java编写代码时，会陷入问题之中，因为没有任何像前面实例的Iterable接口那样的“Addable”便利接口，因此你不能说：“可以在任何事物上调用add()”,而必须说：“可以在Collection的子类型上调用add()”,这样产生的代码就不是特别泛化，因为它必须被限制为只能工作于Collection的实现，如果我试图使用没有实现Collection的类，那么我的泛化代码将不能工作<br>上面的情况中，因为java设计着（可以理解地）没有预见对“Addable()”接口的需要，所有我们被现在在Collection的继承层次结构之内，即便SimpleQueue有个add()方法，它也不能工作，因此这样的代码不是特别泛化，有了潜在类型机制，情况就会不同了</p>
<h3 id="用适配器仿真潜在类型机制"><a href="#用适配器仿真潜在类型机制" class="headerlink" title="用适配器仿真潜在类型机制"></a>用适配器仿真潜在类型机制</h3><p>java泛型并不是没有潜在类型机制，而我们需要使用潜在类型机制这样的东西去编写能够跨类边界应用的代码（也就是“泛化”代码），存在某种方式可以绕过这项限制吗？<br>潜在类型机制将在这里实现什么？它意味着你可以编写代码声明：“我不关心我在这里使用的类型，只要它们具有这些方法即可”，<strong>实际上，潜在类型机制创建了一个包含所需方法的隐式接口</strong>，因此它遵循这样的规则，如果我们手工编写了所需的接口（因为java并没有为我们做这些事），那么它就应该能够解决问题<br><strong>从我们拥有的接口中编写代码来产生我们需要的接口，这就是适配器设计模式的一个典型示例</strong>，我们可以使用适配器来适配已有的接口，以产生想要的接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Addable</span>&lt;<span class="title">T</span>&gt;</span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(T item)</span></span>;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fill2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(Addable&lt;T&gt; addable,Class&lt;? extends T&gt; type,<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                addable.add(type.newInstance());</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载的fill()的类型参数Generator&lt;T&gt; 确保了编译期的类型安全，所以将错误阻止在编译期，在运行时不会抛出</span></span><br><span class="line">    <span class="comment">//任何错误，这种方式比使用类型标记更安全</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(Addable&lt;T&gt; addable,Generator&lt;T&gt; generator,<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            addable.add(generator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//to adapter a base Type,you must use composition</span></span><br><span class="line"><span class="comment">//make any Collection Addable using composition</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddableCollectionAdapter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Addable</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Collection&lt;T&gt; c;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AddableCollectionAdapter</span><span class="params">(Collection&lt;T&gt; c)</span></span>&#123; c=c;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T item)</span></span>&#123; c.add(item); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//a Helper to capture the type automatically</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Addable&lt;T&gt; <span class="title">collectionAdapetr</span><span class="params">(Collection&lt;T&gt; c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AddableCollectionAdapter&lt;T&gt;(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//to adapt a specific type,you can use inheritance</span></span><br><span class="line"><span class="comment">//make a SimpleQueue Addable using inheritance</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddableSimpleQueue</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">SimpleQueue</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Addable</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T item)</span></span>&#123; <span class="keyword">super</span>.add(item);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fill2Test</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       List&lt;Coffee&gt; coffees=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       Fill2.fill(<span class="keyword">new</span> AddableCollectionAdapter&lt;&gt;(coffees),Coffee.class,<span class="number">3</span>);</span><br><span class="line">       Fill2.fill(Adapter.collectionAdapetr(coffees),Coffee.class,<span class="number">3</span>);</span><br><span class="line">       Fill2.fill(Adapter.collectionAdapetr(coffees),Latte.class,<span class="number">3</span>);</span><br><span class="line">       <span class="keyword">for</span>(Coffee coffee:coffees)&#123;</span><br><span class="line">           System.out.println(coffee);</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(<span class="string">"-------------------------------------------------------"</span>);</span><br><span class="line">       AddableSimpleQueue&lt;Coffee&gt; coffeeQueue=<span class="keyword">new</span> AddableSimpleQueue&lt;&gt;();</span><br><span class="line">       Fill2.fill(coffeeQueue,Coffee.class,<span class="number">3</span>);</span><br><span class="line">       Fill2.fill(coffeeQueue,Latte.class,<span class="number">3</span>);</span><br><span class="line">       <span class="keyword">for</span>(Coffee coffee:coffeeQueue)&#123;</span><br><span class="line">           System.out.println(coffee);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Fill2对Collection的要求与Fill不同，它只需要实现了Addable的对象，而Addable已经为Fill编写了——它是我希望编译器帮我创建的潜在类型的一种体现<br>在这个版本中，我还<strong>添加了一个重载的fill,它接受一个Generateor而不是类型标记，Generator在编译器是类型安全的，编译器将确保传递的是正确的Generator,因此不会抛出任何异常</strong><br>第一个适配器，AddableCollectionAdapter，可以工作与基类Collection，这意味着Collection的任何实现都可以使用，这个版本直接存储Collection引用，并使用它来实现Add();<br>如果一个具体类型而不是继承结构的基类，那么当使用继承来创建适配器时，你可以稍微少写一些代码，但是这个适配器只适用于为特定的类型适配所需的接口，这种适配器称为“预适配器”，也就是预先定义好的适配器，之间创建使用即可，而第一种适配器需要传递需要适配的接口才能创建，这就是两种适配器设计模式的不同</p>
<h2 id="将函数对象作为策略"><a href="#将函数对象作为策略" class="headerlink" title="将函数对象作为策略"></a>将函数对象作为策略</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Combiner</span>&lt;<span class="title">T</span>&gt;</span>&#123; <span class="function">T <span class="title">combine</span><span class="params">(T x, T y)</span></span>;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UnaryFunction</span>&lt;<span class="title">R</span>,<span class="title">T</span>&gt;</span>&#123; <span class="function">R <span class="title">function</span><span class="params">(T x)</span></span>;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Collector</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">UnaryFunction</span>&lt;<span class="title">T</span>,<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">result</span><span class="params">()</span></span>;<span class="comment">//extract result of collecting parameter</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UnaryPredicate</span>&lt;<span class="title">T</span>&gt;</span>&#123; <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T x)</span></span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Functional</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">reduce</span><span class="params">(Iterable&lt;T&gt; seq,Combiner&lt;T&gt; combiner)</span></span>&#123;</span><br><span class="line">        Iterator&lt;T&gt; it=seq.iterator();</span><br><span class="line">        <span class="keyword">if</span>(it.hasNext())&#123;</span><br><span class="line">            T result=it.next();</span><br><span class="line">            <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">                result=combiner.combine(result,it.next());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Collector&lt;T&gt; <span class="title">forEach</span><span class="params">(Iterable&lt;T&gt; seq,Collector&lt;T&gt; func)</span></span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(T item:seq)&#123;</span><br><span class="line">           func.function(item);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> func;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;R,T&gt; <span class="function">List&lt;R&gt; <span class="title">transform</span><span class="params">(Iterable&lt;T&gt; seq,UnaryFunction&lt;R,T&gt; func)</span></span>&#123;</span><br><span class="line">        List&lt;R&gt; result=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(T t:seq)&#123;</span><br><span class="line">            result.add(func.function(t));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">filter</span><span class="params">(Iterable&lt;T&gt; seq, UnaryPredicate&lt;T&gt; pred)</span></span>&#123;</span><br><span class="line">        List&lt;T&gt; result =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(T t:seq)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pred.test(t))&#123;</span><br><span class="line">                result.add(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerAdder</span> <span class="keyword">implements</span> <span class="title">Combiner</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">combine</span><span class="params">(Integer a,Integer b)</span></span>&#123;<span class="keyword">return</span> a + b;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerSubtracter</span> <span class="keyword">implements</span>  <span class="title">Combiner</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">combine</span><span class="params">(Integer a, Integer b)</span></span>&#123;<span class="keyword">return</span> a-b;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BigDecimalAdder</span> <span class="keyword">implements</span> <span class="title">Combiner</span>&lt;<span class="title">BigDecimal</span>&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> BigDecimal <span class="title">combine</span><span class="params">(BigDecimal x,BigDecimal y)</span></span>&#123;<span class="keyword">return</span> x.add(y);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BigIntegerAdder</span> <span class="keyword">implements</span> <span class="title">Combiner</span>&lt;<span class="title">BigInteger</span>&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> BigInteger <span class="title">combine</span><span class="params">(BigInteger x,BigInteger y)</span></span>&#123;<span class="keyword">return</span> x.add(y);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">GreaterThan</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; <span class="keyword">implements</span> <span class="title">UnaryPredicate</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> T bound;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">GreaterThan</span><span class="params">(T bound)</span></span>&#123; bound=bound;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T item)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> item.compareTo(bound)&gt;<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiplyingInteger</span> <span class="keyword">implements</span> <span class="title">Collector</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer val=<span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">function</span><span class="params">(Integer x)</span></span>&#123;</span><br><span class="line">            val*=x;</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">result</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; l1= Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>);</span><br><span class="line">       </span><br><span class="line">        Integer addResult=reduce(l1,<span class="keyword">new</span> IntegerAdder());</span><br><span class="line">        Integer substractResult=reduce(l1,<span class="keyword">new</span> IntegerSubtracter());</span><br><span class="line">        List&lt;Integer&gt; listResult=filter(l1,<span class="keyword">new</span> GreaterThan&lt;Integer&gt;(<span class="number">4</span>));</span><br><span class="line">        forEach(l1,<span class="keyword">new</span> MultiplyingInteger()).result();</span><br><span class="line">        <span class="comment">//省略不写</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>策略模式可以产生非常优雅得的代码，因为它将“变化的事物”完全隔离到一个函数对象<strong>，函数对象就是在某种程度上行为像函数的对象——一般地，会有一个相关的方法，函数对象的价值就在于，与普通的方法不同，它们可以传递出去，并且还可以拥有在多个调用之间持久化的状态，当然可以用类中的任何方法来实现与此相似的工作，但是（与使用任何设计模式一样）函数对象主要是由其目的来区别的</strong>这里的，目的即使要创建某种事物，使它的行为就像一个可以传递出去的单个方法一样，这样，它就和策略模式紧耦合了，有时甚至无法区分<br>其实各种设计模式之间的界限真的很模糊，有时很难区分，有时靠设计目的区分，所以没有绝对的模式</p>
<h2 id="总结：转型真的如此之糟吗？"><a href="#总结：转型真的如此之糟吗？" class="headerlink" title="总结：转型真的如此之糟吗？"></a>总结：转型真的如此之糟吗？</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/14/泛型/" data-id="cjnj9osis0037uwrzmqe5r80p" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/10/19/数组/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          数组
        
      </div>
    </a>
  
  
    <a href="/2018/10/12/类型信息/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">类型信息</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/学习心得/">学习心得</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML5/">HTML5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Maven/">Maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Oracle/">Oracle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-MVC/">Spring MVC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-boot/">Spring boot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-cloud/">Spring cloud</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/HTML5/" style="font-size: 10px;">HTML5</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/Node-js/" style="font-size: 10px;">Node.js</a> <a href="/tags/Oracle/" style="font-size: 10px;">Oracle</a> <a href="/tags/Spring/" style="font-size: 10px;">Spring</a> <a href="/tags/Spring-MVC/" style="font-size: 10px;">Spring MVC</a> <a href="/tags/Spring-boot/" style="font-size: 10px;">Spring boot</a> <a href="/tags/Spring-cloud/" style="font-size: 10px;">Spring cloud</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/10/19/注解/">注解</a>
          </li>
        
          <li>
            <a href="/2018/10/19/枚举类型/">枚举类型</a>
          </li>
        
          <li>
            <a href="/2018/10/19/Java-I-O系统/">Java I/O系统</a>
          </li>
        
          <li>
            <a href="/2018/10/19/容器深入研究/">容器深入研究</a>
          </li>
        
          <li>
            <a href="/2018/10/19/数组/">数组</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 EgbertDay<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>