<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>代海峰</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="eating my owner dog food">
<meta property="og:type" content="website">
<meta property="og:title" content="代海峰">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="代海峰">
<meta property="og:description" content="eating my owner dog food">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="代海峰">
<meta name="twitter:description" content="eating my owner dog food">
  
    <link rel="alternate" href="/atom.xml" title="代海峰" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">代海峰</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">个人博客</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-通过异常处理错误" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/11/通过异常处理错误/" class="article-date">
  <time datetime="2018-10-11T07:57:21.000Z" itemprop="datePublished">2018-10-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习心得/">学习心得</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/11/通过异常处理错误/">通过异常处理错误</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;java的理念是：结构不佳的代码不能运行<br>&emsp;&emsp;发现错误最好的时期是在编译阶段，也就是在你试图运行程序之前，然而，编译期间并不能找出所有的错误，余下的错误必须要在运行期间解决，这就需要错误源能够通过某种方式，将恰当的信息传递给某个对象——该接收者知道如何正确处理这个问题<br>&emsp;&emsp;改进的错误恢复机制是提供代码健壮性的最强有力的方式，错误恢复在我们所编写的每一个程序都是基本的元素，java使用异常来提供一直的错误报告模型，<strong>使得构件能与客户端代码可靠地沟通问题</strong>  </p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>&emsp;&emsp;C以及早期的语言常常具有多种错误处理模式，这些模式往往建立在约定俗成的基础之上，而这不属于语言的一部分，通常会返回某个特殊值或者设置某个标志，并且假定接收者将对这个返回值或者标志进行检查，以判断是否发生错误，但，随着时间的推移，人们发现很多的程序员更倾向于忽略对这些返回值和标志的检查，因为他们总是在想“这是别人的问题，不关我的事”，这对于构建大型的，健壮性，可维护的程序而言，这种错误处理机制已经成为阻碍<br>&emsp;&emsp;解决的办法是，用强制规定的形式来消除错误处理过程中随心所欲的因素<br>&emsp;&emsp;“异常”这个词有“我对此感到意外”的意思，问题出现了，你也许不清楚该如何处理，当你确实不该置之不理，你要停下来，看看是不是有别人或在别的地方，能够处理这个问题，只要是在当前环境中还没有足够的信息来解决这个问题，就将这个问题提交到一个更高的环境中，在这里将作出正确的决定<br>&emsp;&emsp;使用异常所带来的一个好处是，它往往能够降低错误处理代码的复杂度，如果不使用异常，那么就必须检查特定的错误，并在程序中的许多地方去处理它，而如果使用异常，那就不必再方法调用处进行检查，因为<strong>异常机制保证能够捕获这个错误</strong>，并且，只在一个地方处理错误，即所谓的异常处理程序中，这样不仅节省代码，而且把描述在<strong>正常情况下“执行过程中做什么事”的代码和“出了问题怎么办”的代码相分离</strong></p>
<h2 id="基本异常"><a href="#基本异常" class="headerlink" title="基本异常"></a>基本异常</h2><p>&emsp;&emsp;异常清晰（exceptional condition）是指阻止当前方法或作用域继续执行的问题，把异常情形与普通问题相区分很重要，普通问题是指，在当前环境下能够得到足够的信息，总能处理这个错误，而对异常情形，就不能继续下去了，因为当前环境下无法获得必要的信息来解决这个问题<br>&emsp;&emsp;当抛出异常后，有几件事会相继发生，甚至，同java中其他对象的创建一样，将使用new在堆上创建异常对象，然后，当前的执行路径（既不能继续下去了）被终止，并且从当前的环境中弹出异常对象的引用，此时，异常处理机制接管程序，并开始寻找一个恰当的地方继续执行程序，这个恰当的地方就是异常处理程序，它的任务是将程序从错误状态恢复<br>&emsp;&emsp;异常最重要的方面之一就是如果发生问题，它们将不允许程序沿着其正常的路径继续走下去  </p>
<h3 id="异常参数"><a href="#异常参数" class="headerlink" title="异常参数"></a>异常参数</h3><p>&emsp;&emsp;与使用java中的其他对象一样，我们总是用new在堆上创建异常对象，这也伴随着存储空间的分配和构造器的调用，所有的异常类都有两个构造器，一个是默认构造器，另一个是接收字符串作为参数，以便能够把相关信息放入到异常对象的构造器<br>&emsp;&emsp;关键字throw将产生很有趣的结果，一个是新生成的异常对象的引用通过throw关键字传递到更大的环境，另一个效果是通过抛出异常的方式退出方法或作用域 此外还能抛出任意类型的Throwable对象，它是异常类型的根类</p>
<h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><h3 id="监控区域"><a href="#监控区域" class="headerlink" title="监控区域"></a>监控区域</h3><p>&emsp;&emsp;<strong>如果在方法的内部抛出了异常（或者在方法调用的其他方式抛出了异常），这个方法将在抛出异常的过程中结束，如果不希望方法就此结束，可以在方法内部设置一个特殊的块来捕获异常</strong>  </p>
<h3 id="异常处理程序"><a href="#异常处理程序" class="headerlink" title="异常处理程序"></a>异常处理程序</h3><p>&emsp;&emsp;抛出的异常必须在某个地方得到处理，这个地点就是异常处理程序，而且针对每一个要捕获的异常准备相应的异常处理程序  </p>
<h3 id="终止与恢复"><a href="#终止与恢复" class="headerlink" title="终止与恢复"></a>终止与恢复</h3><p>&emsp;&emsp;异常处理理论有两种基本模型，java支持终止模型，在这种模型中，将假设错误非常关键，以至于无法回到错误发生的地方继续执行，一旦异常被抛出，就表明错误无法挽回，也不能回来继续执行<br>&emsp;&emsp;另一种是恢复模型，意思是异常处理程序的工作是修正错误，然后尝试调用出问题的方法，并认为第二次能成功，java也可实现这种错误处理，将异常处理程序一个while循环中吗，直到程序执行成功<br>&emsp;&emsp;虽然恢复模型很吸引人，但是这种错误恢复机制的代码非常难以编写，而且你真的了解错误的所有方方面面吗？所以后来大部分的语言选择转向程序终止模型  </p>
<h2 id="创建自定义异常"><a href="#创建自定义异常" class="headerlink" title="创建自定义异常"></a>创建自定义异常</h2><p>&emsp;&emsp;java提供的异常体系不可能预见所有的希望加以报告的错误，所以可以自己定义异常类来表示程序中可能会遇到的特定问题<br>&emsp;&emsp;要定义自己的异常类，必须从已有的异常类继承，最好是意思相近的，其实无所谓，异常最重要的是类名，建立新的异常类最简单的方式就是让编译器为你产生默认的构造器</p>
<h2 id="异常说明"><a href="#异常说明" class="headerlink" title="异常说明"></a>异常说明</h2><p>&emsp;&emsp;<strong>java鼓励人们把方法可能会抛出的异常告知使用此方法的客户端程序员</strong>，这是种优雅的做法，它使得调用者能确切地知道应该写什么代码借用捕获所有的异常，java提供了相应的语法（并强制这个语法）使得你能以礼貌的方式告知客户端程序员某个方法可能会抛出的异常，然后客户端程序员会进行相应的处理，这就是异常说明，它属于方法声明的一部分，紧跟在形式参数列表之后 <code>void f()throws TooBig,TooSmall{}</code><br>&emsp;&emsp;如果代码方法产生了异常却没有对此说明，编译器会发现这错误并提醒你，那么处理这个异常，要么声明这个方法将会抛出异常<br>&emsp;&emsp;这种在编译器就被强制检测的异常被称为<code>被检查的异常</code></p>
<h2 id="捕获所有的异常"><a href="#捕获所有的异常" class="headerlink" title="捕获所有的异常"></a>捕获所有的异常</h2><p>&emsp;&emsp;可以只写一个异常来捕获所有类型的异常，通过捕获异常类型的基类Exception可以做到这一点,因为Exception是与编程有关的所有异常类的基类，所有它不会包含太多的信息，可以调用它从其基类Throwable继承来的方法<br>&emsp;&emsp;String getMessage()<br>&emsp;&emsp;String getLocalizedMessage()<br>&emsp;&emsp;或用本地语言表示的详细信息<br>&emsp;&emsp;String toString()<br>&emsp;&emsp;void printStackTrace()<br>&emsp;&emsp;void printStackTrace(PrintStream)<br>&emsp;&emsp;void printStackTrace(java.io.PrintWriter)<br>&emsp;&emsp;打印Throwable和Throwable的<code>调用栈轨迹</code>，调用栈显式了“把你带到异常抛出地点”的方法调用序列，其中第一个版本输出到标准错误，后两个版本允许选择要输出的流<br>&emsp;&emsp;Throwable fillStackTrace()<br>&emsp;&emsp;<strong>用于在Throwable对象的内部记录栈帧的当前转态，这在程序重新抛出错误或者异常时很有用</strong><br>&emsp;&emsp;此外还可以使用继承自Object的方法，比如getClass()返回Class类型对象，可以获得更多关于这个异常对象的信息</p>
<h3 id="栈轨迹"><a href="#栈轨迹" class="headerlink" title="栈轨迹"></a>栈轨迹</h3><p>&emsp;&emsp;<code>printStrackTrace()</code>方法所提供的信息可以通过<code>StackTraceElement getStackTrace()</code>方法来直接访问，这个方法将<strong>返回一个由栈轨迹中的元素所组成的数组，其中每一个元素都表示栈中的一祯，元素0是栈顶元素，并且是调用序列中的最后一个方法调用（这个Throwable被创建和抛出之处）</strong>数组中的最后一个元素和栈底是调用序列中的第一个方法调用</p>
<h3 id="重新抛出异常"><a href="#重新抛出异常" class="headerlink" title="重新抛出异常"></a>重新抛出异常</h3><p>&emsp;&emsp;重抛异常会把异常抛给上一级环境中的异常处理程序，此外，异常的所有信息都会得以保持，所以上一级环境中捕获此异常的处理程序通过通过这个异常对象得到所有的信息<br>&emsp;&emsp;如果只是将当前的异常对象重新抛出，那么printStackTrace()方法显示的将是原来异常抛出的调用栈信息，而非重新抛出点的信息，要想更新这个信息，<strong>可以调用fillInStackTrace()方法，这个方法将返回一个Throwable对象，它是通过把当前调用栈信息填入原来那个异常对象而建立的,因此调用fillinStackTrace()的那一行就成了异常的新发地</strong><br>&emsp;&emsp;有可能在捕获异常之后抛出另一种异常，那么这么做，得到的效果就类似与使用finInStackTrace(),有关原来异常发生地点的信息就会丢失剩下的是与新的抛出点有关的信息</p>
<h3 id="异常链"><a href="#异常链" class="headerlink" title="异常链"></a>异常链</h3><p>&emsp;&emsp;常常会想要在捕获一种异常之后抛出另一种异常，并且希望把原始异常的信息保存下来，这被称为异常链，现在所有的Throwable的子类在构造器中都可以接受一个cause(因由)对象作为参数，这个cause就用来表示原始异常，<strong>这样通过把原始异常传递给新的异常，使得即使在当前创建并抛出新的异常，也能够通过这个异常链追踪到异常最初发生的位置</strong><br>&emsp;&emsp;语法: <code>throw new NewException(CauseException)</code></p>
<h2 id="java标准异常"><a href="#java标准异常" class="headerlink" title="java标准异常"></a>java标准异常</h2><p>&emsp;&emsp;Throwable这个类被用来表示任何可以作为异常抛出的类。Throwable对象，可以分为两种类型（指从Throwable继承中得到的类型），Error用来表示编译时和系统错误（除特殊情况，一般你不用关心），Exception是可以抛出的异常，在java类库，用户方法以及运行时故障中都可能抛出这个Exception异常，所有java程序员关心的异常类型通常是Exception  </p>
<h3 id="特例-RuntimeExcepton"><a href="#特例-RuntimeExcepton" class="headerlink" title="特例 RuntimeExcepton"></a>特例 RuntimeExcepton</h3><p>&emsp;&emsp;属于运行时的异常类型有很多，它们会自动被java虚拟机抛出，所有不必在异常说明中吧它们列出来，这些异常都是从RuntimeException类继承而来的，不需要再异常说明中声明的异常也被称为“不受检查的异常”，尽管通常不用捕获RuntimeException异常，但还是可以在代码中抛出RuntimeException异常<br>&emsp;&emsp;如果不主动捕获这种类型的异常会发生什么事情呢？因为编译器没有在这个问题上对遗产说明进行强制检查，RuntimeException类型的异常也许会穿越所有的执行过程直达main()方法，而不会被捕获</p>
<h2 id="使用finally进行清理"><a href="#使用finally进行清理" class="headerlink" title="使用finally进行清理"></a>使用finally进行清理</h2><p>&emsp;&emsp;对于一些代码，你可能希望，无论try块中的异常是否抛出，它们都能得到执行，<strong>这通常适用于内存回收之外的情况</strong>（因为内存回收由垃圾回收器完成），为了达到这个效果，可以在try块之后加上finally子句</p>
<h3 id="finally用来做什么"><a href="#finally用来做什么" class="headerlink" title="finally用来做什么"></a>finally用来做什么</h3><p>&emsp;&emsp;finally非常重要，它能使程序员保证，无论try块里发生什么，内存总能得到释放，但java有垃圾回收机制，所以内存释放不再是问题<br>&emsp;&emsp;<strong>当把除内存之外的资源恢复到它们的初始转态时，就要用到finally子句</strong>，这种需要清理的资源包括，已经打开的文件或网络连接，在屏幕上画的图形，甚至是外部世界的某个开关  </p>
<h3 id="缺憾：异常丢失"><a href="#缺憾：异常丢失" class="headerlink" title="缺憾：异常丢失"></a>缺憾：异常丢失</h3><p>&emsp;&emsp;遗憾的是，java的异常实现也有瑕疵，异常通常作为程序出错的标志，绝不应该被忽视，但是还是有可能被轻易忽视，用某些特殊方法的finally放肆使用子句，就会发生这种情况，这种情况的方式吗，一般是在finally子句抛出新的遗产替换了正常方法中抛出的异常，这是相当严重的缺陷</p>
<h2 id="异常的限制"><a href="#异常的限制" class="headerlink" title="异常的限制"></a>异常的限制</h2><p>&emsp;&emsp;当覆盖方法的时候只能抛出在基类方法的异常说明里列的那些异常，这个限制很有用，因为这意味着，当基类方法使用的代码应用到派生类对象的时候，一样能够工作，异常也不例外，这样的规则在java随处可见，比如，派生类覆盖基类的方法，访问权限一定不能比基类的要小，这些规则都保证了，能调用基类的方法就一定可以调用导出类的方法这个原则</p>
<h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p>&emsp;&emsp;如果异常发生了，所有的东西都能被正确清理吗？因为涉及到构造器，问题就出现了，构造器会把对象设置成安全的初始转态，但是还会有别的动作，比如打开一个文件，这样的动作只有在对象使用完毕并且用户调用了特殊的清理方法之后才能的已清理，如果构造器内抛出了异常，这些清理行为也许就不能正常工作了，这意味着编写构造器时要格外小心，其实我们很少会遇到这也的问题，我们遵循的一条原则就是用尽量简单的方法构建对象</p>
<h2 id="异常匹配"><a href="#异常匹配" class="headerlink" title="异常匹配"></a>异常匹配</h2><p>异常处理系统会按照代码书写的书信找出“最近”的处理程序，找到匹配的处理程序之后，就认为异常得到了处理，就不在继续查找了查找的时候并不要去抛出的异常同处理程序声明的异常完全匹配，派生类的对象也可以匹配其基类的处理程序，所有一个原则是将更加特定的异常类型放在最前面</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/11/通过异常处理错误/" data-id="cjnzv2psn003bcorzyiumodbr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-持有对象" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/10/持有对象/" class="article-date">
  <time datetime="2018-10-10T15:50:46.000Z" itemprop="datePublished">2018-10-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习心得/">学习心得</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/10/持有对象/">持有对象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;如果一个程序只包含固定数量的且其生命周期都是已知的对象，那么这是一个非常简单的程序<br>&emsp;&emsp;通常，程序总是根据运行时才知道的某些条件去创建对象，在此之前，不会知道所需对象的数量，甚至不知道确切的类型，为了解决这个普遍的编程问题，需要在任意时刻和任意位置创建任意数量的对象，所以，就不能依靠创建命名的引用<code>MyType aReference</code>来持有每一个对象<br>&emsp;&emsp;java有多种保存对象的方式，数组是个保存对象的最有效的方式之一，可是数组具有固定的尺寸，而在一般的情况中，你在写程序的时候根本不知道将需要多少的对象<br>&emsp;&emsp;Java实用类库提供了一整套完整的容器来来解决这个问题，其中基本的类型是List,Set,Queue和Map,这些对象也称为集合类，但是由于java的类库使用了Collection这个名字来指代该类库的一个特殊子集，所以我们使用范围更广的术语“容器”称呼它们<br>&emsp;&emsp;容器还有一些其他的特性，例如，Set对每个值都只保存一个对象，Map是允许你将某些对象与其他的一些对象关联起来的关联数组，java容器类都可以自动调整自己的尺寸，因此，与数组不同，在编程时，你可以将任意数量的对象放置在容器中，而且不需要担心容器应该设置为多大  </p>
<h2 id="泛型和类型安全的容器"><a href="#泛型和类型安全的容器" class="headerlink" title="泛型和类型安全的容器"></a>泛型和类型安全的容器</h2><p>&emsp;&emsp;在java SE5之前的容器有一个主要的问题就是编译器允许你向容器插入不正确的类型，而在之后，你可以通过预定义的泛型容器通过类型参数来指定你将要向容器中插入的数据类型，编译器将会放置错误的对象放置到容器中，而且不需要转型就可以从容器中取出正确类型的对象，因为容器知道自己保持的对象是什么类型</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>&emsp;&emsp;java容器类类库的用途就是“保存对象”，并将其划分为两个不同的概念  </p>
<ol>
<li>Collection 一个独立元素的序列，这些元素都服从一条或者多条规则  </li>
<li>Map 一组成对的“键值对”的对象，允许你通过键查找对象，ArrayList允许你使用数字来查找值，从某种意义上，它是将数字和对象关联在一起，映射表允许我们使用另一个对象查找另一个对象，它也被称为“关联数组”   <h2 id="添加一组元素"><a href="#添加一组元素" class="headerlink" title="添加一组元素"></a>添加一组元素</h2>&emsp;&emsp;在<code>java.util</code>包中的<code>Arrays</code>和<code>Collections</code>类中都有很多使用的方法，可以在一个<code>Collection</code>中添加一组元素，<code>Arrays.asList()</code>方法接受一个数组或者一个用逗号分隔的元素列表(可变参数)并将其转换为一个<code>List</code>对象，<code>Collections.addAll()</code>方法接受一个<code>Collection</code>对象，以及一个数组或是一个用逗号分隔的列表，将元素添加到<code>Collection</code>对象中  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddingGroup</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Collection&lt;Integer&gt; collection=<span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>));</span><br><span class="line">        Integer[] moreInt = &#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        Collections.addAll(collection,moreInt);</span><br><span class="line">        Collections.addAll(collection,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>);</span><br><span class="line">        List&lt;Integer&gt; list=Arrays.asList(<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">10</span>);</span><br><span class="line">        list.set(<span class="number">1</span>,<span class="number">99</span>);</span><br><span class="line">        <span class="comment">//list.add(21);runtime error because the underlying array connot be resized</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>&emsp;&emsp;Collection构造器可以接受另一个Collection，用它将自身初始化，Collection.addAll()和Collections.addAll()是两个完全不同的两个方法，前者是集合的通用接口中定义的方法，后者是Collections工具类定义的一个静态方法，Collection.addAll()方法只能接受另一个Collection对象作为参数，因此它不如Arrays.list()和Collections.addAll()来的灵活，这两个方法使用的都是可变参数列表<br>&emsp;&emsp;你可以直接使用ArrayList.asList()的输出，将其当做List,但是在这种情况下，其底层表示的是数组，因此不能调整尺寸，如果你试图用add()或delete()方法在这种列表中添加或删除元素，就有可能引发去改变数组尺寸的尝试，会得到一个运行时错误  </p>
<h2 id="容器的打印"><a href="#容器的打印" class="headerlink" title="容器的打印"></a>容器的打印</h2><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>&emsp;&emsp;List承诺可以将元素维护在特定的序列中，List接口在Collecton的基础上添加了大量的方法，使得可以在List中间插入和移除元素<br>&emsp;&emsp;有两种类型的List：</p>
<ul>
<li>基本的ArrayList，它长于随机访问元素，但在List的中间插入和移除元素时较慢</li>
<li>LinkedList，它通过代价较低的在List中间进行插入和删除操作，提供了优化的顺序访问，LinkedList在随机访问方面相对较慢，但是它的特性集叫ArrayList更大  </li>
<li>为什么ArrayList和LinkedList对于不同的操作的性能不同的原因是因为底层实现的不同  <img src="/2018/10/10/持有对象/绘图1.png" title="ArrayList">
<img src="/2018/10/10/持有对象/绘图2.png" title="LinkedList">
&emsp;&emsp;关于List接口api请查看<a href="http://tool.oschina.net/apidocs/apidoc?api=jdk-zh" target="_blank" rel="noopener">http://tool.oschina.net/apidocs/apidoc?api=jdk-zh</a><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2>&emsp;&emsp;任何容器类，都必须有某种方式可以插入元素并将它们取回，毕竟，持有事物是容器的基本工作<br>&emsp;&emsp;如果从更高层的角度思考，我们在对容器的确切类型进行编程方面有一个缺点，那就是如果原本是对List编码的，但是后来我想将相同的代码应用于Set，那会显得很不方便，此时应该怎么做呢？或者打算从头开始编写通用的代码，它们只是使用容器，不知道或者说不关心容器的类型，那么如何才能不重写代码就能应用于不同的容器呢？<br>&emsp;&emsp;迭代器（也是一种设计模式）的概念可以用于达成此目的，迭代器是一个对象，它的工作是遍历并选择序列中的对象，而客户端程序员不必知道或关心该序列底层的结构，java的Iterator只能呢个单向移动，这个Iterator只能用来  </li>
</ul>
<ol>
<li>使用iterator()方法要求容器返回一个Iterator，Iterator将准备返回序列的第一个元素</li>
<li>使用next()获得序列的下一个元素</li>
<li>使用hasNext()方法检查序列中是否还有元素</li>
<li>使用remove()将迭代器新返回的元素删除<br>&emsp;&emsp;注意:Iterator可以删除next()产生的最后一个元素，这意味着调用remove()之前必须先调用next()<br>&emsp;&emsp;<strong>接受对象容器并传递它，从而在每个对象上都执行某种操作，这种思想十分强大</strong><h3 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h3>ListIterator是一个更加强大的Iterator的子类型，它只能用于各种List类的访问，尽管Iterator只能向前移动，但是ListIterator可以双向移动，它还可以产生相对于迭代器在列表中指向的当前位置的前一个和后一个元素的索引，并且可以使用set()方法替换它访问过的最后一个元素,你可以通过listIterator()方法产生一个指向List开始处的ListIterator，并且还可以通过调用listIterator(n)方法创建一个一开始就指向列表索引为n的元素处的ListIterator<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2>&emsp;&emsp;LinkedList也像ArrayList一样实现了List接口，在删除和插入方面的效率比ArrayList更高效，但是在随机访问方面却要逊色一些<br>&emsp;&emsp;<strong>LinkedList还添加了可以使其用作栈，队列或者双端队列的方法</strong><br>&emsp;&emsp;这些方法有些彼此之间只是名称有些差异，后者只存在少许差异，以使得这些名称在特定用法的上下文环境中更加适用（特别是在Queue中）例如，getFirst()和element()完全一样，它们都是返回列表头元素，而并不移除它，如果List为空的话，则抛出NoSuchElementException,<br>peek()方法与这两个方法只是稍有差异，它在列表为空时返回null<br>&emsp;&emsp;removeFirst()和remove()也是完全一样，它们移除并返回列表的头，而在列表为空时，抛出NoSuchElementExcption，poll()稍有差异，它在列表为空的时候，返回null<br>&emsp;&emsp;addFirst()与add()和addLast()，它们都是将元素插入列表的尾（端）部<br>&emsp;&emsp;removerLast()移除并返回最后一个元素<br>&emsp;&emsp;因此我们在使用LinkedList这些方法时，要注意各种方法的不同，进而选择怎样去处理<h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2>&emsp;&emsp;“栈”通常是指“后进先出”(LIFO)的容器，有时栈也被称为叠加栈，如果用一种事物来形容的话，栈的行为就像是弹夹一样，有“压入”和“弹出”<br>&emsp;&emsp;LinkedList具有能实现栈的所有功能的方法，所有我们可以定义一个栈，通过组合的形式复用LinkedList，很简单，这里就不写了<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2>&emsp;&emsp;Set不保存重复的元素，如果你试图将相同对象的多个实例添加到Set中，那么它就会阻止这种重复的发生，Set最常用被使用的是<strong>测试归属性</strong>，你很容易地询问某个对象是否在某个Set中，因此，查找就成了Set中最重要的操作，因此，你可以选择HashSet的实现，它专门对快速查找进行优化<br>&emsp;&emsp;Set和Collection具有完全一样的接口，因此没有额外的功能，实际上Set就是Collection，只是行为不同<br>&emsp;&emsp;Set有不同的实现，HashSet使用了散列函数，使得更快速的保存和查找，TreeSet使用了红黑树数据结构中，LInkedHashSet因为查找的速度也使用了散列，但是看起来它使用了链表来维护元素的插入顺序<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2>&emsp;&emsp;将对象映射到其他对象的能力是一种解决编程问题的杀手锏<br>Map与数组和其他的Collection一样，可以很容易地扩展到多维，我们通过容器的组合，可以很容易生成强大的数据结构  <h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2>&emsp;&emsp;队列是一个“先进先出”（FIFO）的容器，即从容器的另一端放入元素，从容器的另一端取出，<strong>队列常被当作一种可靠的将对象从程序的一个区域传递到另一个区域的途径</strong><br>&emsp;&emsp;LinkedList提供了方法以支持队列的行为，它实现了Queue接口，因此可以将LinkedList作为Queue的一种实现，通过将LinkedList向上转型为Queue  <h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h3>&emsp;&emsp;x先进先出描述了最典型的队列规则，<strong>队列规则是指在给定一组队列中的元素的情况下，确定下一个弹出队列的元素的规则</strong><br>&emsp;&amp;emsp优先队列声明下一个弹出的元素是最需要的元素（具有最高的优先级），当你在PriorityQueue上调用offer()方法插入一个对象时，这个对象会在队里中被排序，默认的排序将使用对象在队列中的自然排序，但是你也可以通过提供自己的Comparator来修改这个顺序，PriorityQueue可以确保当你调用peek()，poll()和remove()方法时，获得的元素将是队列中优先级最高的元素  <h2 id="Collection和Iterator"><a href="#Collection和Iterator" class="headerlink" title="Collection和Iterator"></a>Collection和Iterator</h2>&emsp;&emsp;Collection是描述所有序列容器的共性的根接口，它可能被认为是一个“附属接口”，即因为要表示其他若干接口的共性而出现的接口<br>&emsp;&emsp;使用接口的一个理由就是它可以使我们能够创建更通用的代码，通过针对接口而非具体的实现类编写代码，那么我们的代码就可以应用于更多的类型，然后我们也可以看到有趣的事情是，我们一般是通过迭代器来表现这种共性的，在java中，这两种方式实际上绑定在一起了，如果要一个新类实现Collection接口，也要必须通过iterator()接口，但是如果让一个类去实现Collection接口，虽然可以通过继承AbstractCollection来提供一些默认的实现，但是必须还有提供iterator()，而且如果这个类本身已经继承了其他类，那么就不能再通过继承将其定义为一个Collection类型了，所有相比之下，使用通过迭代器的方式来提供容器的共性更加可取，我们也知道，迭代器模式实际上就是利用了内部类的特性，产生了一个能够访问外围类的闭包对象，我们就可以对外围的成员进行操作  <h3 id="Foreach与迭代器"><a href="#Foreach与迭代器" class="headerlink" title="Foreach与迭代器"></a>Foreach与迭代器</h3>&emsp;&emsp;在java SE5引入了新的被称为Iterable的接口，该接口包含了一个能够产生Iteratoer的Iterator()方法，并且Iterator接口被foreach用来在序列中移动，<strong>因此，如果你创建了任何实现了Iteratable的类，都可以将它用于foreach语法</strong></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/10/持有对象/" data-id="cjnzv2pr4002kcorzebjhfd9b" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-内部类" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/10/内部类/" class="article-date">
  <time datetime="2018-10-10T03:44:31.000Z" itemprop="datePublished">2018-10-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习心得/">学习心得</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/10/内部类/">内部类</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;<strong>可以将一个类的定义放在另一个类的定义内部，这就是内部类</strong><br>&emsp;&emsp;内部类是一种非常有用的特性，因为它允许你把一些逻辑相关的类组织在一起，并控制内部类的可视性，然而必须要了解，内部类与组合是完全不同的概念，这一点很重要<br>&emsp;&emsp;在最初，内部类看起来就像是一种代码隐藏机制，将类置于其他类的内部，但是，你将会了解到，内部类远不止如此，它了解外围类，并能与之通信，而且你用内部类写出的代码更加优雅而清晰，尽管并不总是如此  </p>
<h2 id="创建内部类"><a href="#创建内部类" class="headerlink" title="创建内部类"></a>创建内部类</h2><p>&emsp;&emsp;创建内部类的方法很简单，就是将类的定义置于外围类的内部<br>&emsp;&emsp;更典型的情况是，外部类将有一个方法，该方法返回一个指向内部类的引用，就像下面看到<code>to()</code>的<code>contens()</code>和一样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel1</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Contents</span></span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> i =<span class="number">11</span>;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> i;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Destination</span></span>&#123;</span><br><span class="line">      <span class="keyword">private</span> String label;</span><br><span class="line">      Destination(String label)&#123;</span><br><span class="line">          <span class="keyword">this</span>.label=label;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function">String <span class="title">readLable</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> label;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Destination <span class="title">to</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Destination(s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Contents <span class="title">conents</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Contents();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ship</span><span class="params">(String dest)</span></span>&#123;</span><br><span class="line">      Contents c=conents();</span><br><span class="line">      Destination d=to(<span class="string">"dest"</span>);</span><br><span class="line">      System.out.print(d.readLable());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      Parcel1 p=<span class="keyword">new</span> Parcel1();</span><br><span class="line">      p.ship(<span class="string">"Tasmania"</span>);</span><br><span class="line">      Parcel1 q=<span class="keyword">new</span> Parcel1();</span><br><span class="line">      Parcel1.Destination d=q.to(<span class="string">"Borneo"</span>);</span><br><span class="line">      Parcel1.Contents c = q.conents();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="链接到外部类"><a href="#链接到外部类" class="headerlink" title="链接到外部类"></a>链接到外部类</h2><p>&emsp;&emsp;到目前为止，内部类似乎还是一种名字隐藏和组织代码的模式，这些很有用，但还不是最引人注目的，它还有其他的用途，<strong>当生成一个内部类的对象时，此对象与制造它的外围类对象（enclosing object）之间就有了一种联系，所以它能访问其外围类的所有成员，而不需要任何特殊条件</strong>，此外，内部类还拥有外围类所有元素的访问权，内部类可以访问其外围类的的方法和字段，就像自己拥有它们似的<br>&emsp;&emsp;内部类自动拥有对其外围类所有成员的访问权，这是怎么做到的呢？当某个对象创建一个内部类对象的时候，此内部类对象必定会秘密捕获一个指向那个外围类对象的引用，然后，在你访问此外围类的成员时，就是用那个引用来选择外围类的成员，幸运的是，编译器会帮我们处理所有的细节，但你现在可以看到：内部类的对象只能在其外围类的对象相关联的情况下才能被创建（就像你应该看到的，在内部类是非static类时），构建内部类对象时，需要一个指向其外围类对象的引用</p>
<h2 id="使用-this和-new"><a href="#使用-this和-new" class="headerlink" title="使用.this和.new"></a>使用.this和.new</h2><p>&emsp;&emsp;<strong>如果你需要生成外部类对象的引用，可以使用外部类的名字后面紧跟原点和this</strong>，这样产生的引用自动地具有正确的类型，这一点在编译期就被知晓并受到检查，因此没有任何运行时开销<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dothis</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;System.out.print(<span class="string">"Dothis.f()"</span>);&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Dothis <span class="title">outer</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Dothis.<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Inner <span class="title">inner</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Inner();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Dothis dt=<span class="keyword">new</span> Dothis();</span><br><span class="line">        Dothis.Inner dti=dt.inner();</span><br><span class="line">        dti.outer().f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;有时你想要告知某些其他对象，去创建其某个内部类的对象，要实现此目的，你必须在new表达式中提供对其他外部类对象的引用，这就需要使用<code>.new</code>语法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DotNew</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        DotNew dotNew=<span class="keyword">new</span> DotNew();</span><br><span class="line">        DotNew.Inner di=dotNew.new Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&amp;emsp；要想创建内部类的对象，你不能按照你想象的方式，去引用外部类的名字DotNew,而是<strong>必须使用外部类的对象来创建内部类对象</strong>，像上面<code>newDot.new Inner()</code>那样,这也解决了内部类名字作用域的问题<br>&emsp;&amp;emsp；<strong>在拥有外部类对象之前是不能创建内部类对象的</strong>，这是因为内部类对象暗暗连接到它的外部类对象上，但是，如果你创建的是嵌套类（静态内部类），那么就不需要对外部类对象的引用  </p>
<h2 id="内部类和向上转型"><a href="#内部类和向上转型" class="headerlink" title="内部类和向上转型"></a>内部类和向上转型</h2><p>&emsp;&amp;emsp；当将内部类向上转型为其基类，尤其是转型为一个接口的时候，内部类就有了用武之地（从实现了某个接口的对象，得到对接口的引用，与向上转型为这个对象的基类，实际上效果是一样的），<strong>这是因为此内部类——某个接口的实现——能够完全不可见，并且不可用</strong>。所得到只是指向基类或则接口的引用，所以能够很方便地隐藏实现细节<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Destination</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">readLabel</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Contents</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parcel</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">PContents</span> <span class="keyword">implements</span> <span class="title">Contents</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> i;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">PDestination</span> <span class="keyword">implements</span> <span class="title">Destination</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String label;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PDestination</span><span class="params">(String toWhere)</span></span>&#123;</span><br><span class="line">            label=toWhere;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">(String s)</span></span>&#123;<span class="keyword">return</span> s;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Destination <span class="title">destination</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PDestination(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PContents();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestParcel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Parcel parcel=<span class="keyword">new</span> Parcel();</span><br><span class="line">        Contents c=parcel.contents();</span><br><span class="line">        <span class="comment">//向下转型为私有的内部类也是不可以的</span></span><br><span class="line">        <span class="comment">//Parcel.PContents pc=parcel.contents();</span></span><br><span class="line">        Destination d= parcel.destination(<span class="string">"tasmania"</span>);</span><br><span class="line">        <span class="comment">//illegal --can't access private class</span></span><br><span class="line">        <span class="comment">//Parcel.PContents ps=parcel.new PContents();</span></span><br><span class="line">        Parcel.PDestination pd=parcel.new PDestination(<span class="string">"同包可访问"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在上面的例子中，内部类PContents是private,所以除了Parcel，没人能够访问它，PDestination是protected的，所以只有Parcel及其子类，还有同包的类能够访问它，这意味着如果客户端程序员想要了解或访问这些成员，那是要受到限制的，实际上，甚至不能向下转型成private内部类（或是protect内部类，除非是继承自它的子类），因为不能访问其名称，就像上面看到的那样，也是，private内部类给类的设计者提供了一种途径，通过这种方式可以完全阻止任何依赖于类型的编码，并且完全隐藏了实现的细节，此外，从客户端程序员的角度来看，由于不嫩访问任何新增的，原本不属于公共接口的方法，所有扩展接口是没有价值的（也就是说我们对于private内部类，我们只能通过可访问的其向上转型的基类或者接口来访问这个内部类，因为同基类接口访问，任何通过内部类添加的新的方法都是无意义的）。这也给java编译器提供了生成更高效代码的机会<br>&emsp;&emsp;总结如下，对内部类的访问权限修饰同样有效，我们仅能对那些有权限访问的内部类进行访问，例如private内部类，我们无法访问（除了包含它的外部类），对于protected内部类，我们只能在外围类的子类或者同包类能访问，但是如果我们对内部类基类的接口具有访问权的时候，内部类还提供了一种机制，通过外围类的方法获得内部类的向上转型的引用，我们就可以对这个引用的接口进行访问，由此得到一个副作用是，通过向上转型的接口访问时对于那些在内部类中新添加的方法，我们是无法调用的</p>
<h2 id="在方法和作用域内的内部类"><a href="#在方法和作用域内的内部类" class="headerlink" title="在方法和作用域内的内部类"></a>在方法和作用域内的内部类</h2><p>&emsp;&emsp;我们还可以在方法里面或者在任意的作用域内定义内部类，这么做有两个理由：</p>
<ol>
<li>你实现了某类型的接口，于是可以创建并返回对其的引用  </li>
<li>你要解决一个复杂的问题，想创建一个类来辅助你解决问题，但是又不希望这个类是公共可用的<br>&emsp;&emsp;在后面的例子里，先前的代码将被修改，以用来实现  </li>
<li>一个定义在方法中的类  </li>
<li>一个定义在作用域内的类，此作用域在方法内部</li>
<li>一个实现接口的匿名类</li>
<li>一个匿名类，它扩展了有非默认构造器的类</li>
<li>一个匿名类，它执行字段初始化</li>
<li>一个匿名类，它通过实例初始化实现构造（匿名类不可能有构造器）<h4 id="在方法的作用域内"><a href="#在方法的作用域内" class="headerlink" title="在方法的作用域内"></a>在方法的作用域内</h4>&emsp;&emsp;在方法的作用域内，创建一个完整的类，这被称作局部内部类  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Destination <span class="title">destination</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">PDestination</span> <span class="keyword">implements</span> <span class="title">Destination</span></span>&#123;</span><br><span class="line">            <span class="keyword">private</span> String label;</span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="title">PDestination</span><span class="params">(String whereTo)</span></span>&#123;</span><br><span class="line">                label=whereTo;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> label;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PDestination(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>PDestination类是<code>destination()</code>方法的一部分，而不是<code>Parcel5</code>的一部分，所以destination()方法之外不能访问PDestination,注意出现在return语句中的向上转型——返回的类型是Destionation的引用，它是PDestination的基类，当然，在destination()中定义了内部PDestination，并不意味着一旦destination()方法执行完毕，PDestination就不可用了<br>&emsp;&emsp;你可以在同一个目录下的任意类中对某个内部类使用类标识符PDestination,这并不会引起命名冲突<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">internalTracking</span><span class="params">(<span class="keyword">boolean</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b)&#123;</span><br><span class="line">            <span class="class"><span class="keyword">class</span> <span class="title">TrackingSlip</span></span>&#123;</span><br><span class="line">                <span class="keyword">private</span> String id;</span><br><span class="line">                TrackingSlip(String s)&#123;</span><br><span class="line">                    id = s;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="function">String <span class="title">getSlip</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> id;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            TrackingSlip ts=<span class="keyword">new</span> TrackingSlip(<span class="string">"slip"</span>);</span><br><span class="line">            String s=ts.getSlip();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//con't use it here out of scope</span></span><br><span class="line">    <span class="comment">//TrackingSlip ts=new TrackingSlip();</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">track</span><span class="params">()</span></span>&#123;internalTracking(<span class="keyword">true</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Parcel6 p=<span class="keyword">new</span> Parcel6();</span><br><span class="line">        p.track();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;<strong>TrackingSlip类被嵌套入if语句的作用域中，这并不是说该类的创建是有条件的，它其实与别的类一起编译过了，然而，在定义TrackingSlip的作用之外，它是不可用的，除此之外，它与普通的类没什么分别</strong></p>
<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Contents() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Parcel7 parcel7=<span class="keyword">new</span> Parcel7();</span><br><span class="line">        Contents c=parcel7.contents();</span><br><span class="line">        c.value();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;contents()方法将返回值的生成与表达式这个返回值啊的类的定义结合在一起了，另外，这个类是匿名的，它没有名字，更糟糕的是：看起来似乎是你正在创建一个Contents对象<br>&emsp;&emsp;这种奇怪的语法指的是：“创建一个继承自Contents的匿名类的对象”，通过new表达式返回的引用被自动向上转型为对Contents的引用，上述匿名类的语法是下述形式的简化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel7b</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Mycontents</span> <span class="keyword">implements</span> <span class="title">Contents</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Mycontents();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在这个匿名内部类中，使用默认的构造器来生成Contents，下面的代码展示的是，如果你的基类需要一个有参数的构造器，应该怎么办？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wrapping</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Wrapping</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; i=x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> i;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel8</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Wrapping <span class="title">wrapping</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Wrapping(x)&#123;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">super</span>.value();</span><br><span class="line">          &#125;  </span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Parcel8 parcel8=<span class="keyword">new</span> Parcel8();</span><br><span class="line">        Wrapping wrapping=<span class="keyword">new</span> Wrapping(<span class="number">2</span>);</span><br><span class="line">        wrapping.value();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;只需要简单传递给基类的构造器即可，尽管Wrapping只是一个具有实现的普通类，但它还是被其导出类当作公共“接口”来使用<br>&emsp;&emsp;<strong>如果定义一个匿名类，并且希望它使用一个在其外部定义的对象，那么编译器会要求并其参数引用是final的</strong><br>&emsp;&emsp;如果只是简单给一个字段，那么普通的字段初始化方法就很好了，但是如果想做一些类似构造器的行为，那该怎么办？在匿名类中不可能含有命名构造器（因为它根本没有名字），但通过实例初始化，就能够达到为匿名内部类创建一个伪构造器的效果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Base</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"Base Constructor,i="</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousConstructor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Base <span class="title">getBase</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Base(x)&#123;</span><br><span class="line">            &#123;System.out.print(<span class="string">"Inside instance initializer"</span>);&#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;System.out.print(<span class="string">"in anonymous f()"</span>);&#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Base base=getBase(<span class="number">10</span>);</span><br><span class="line">        base.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在此例中，不要求变量一定是final的，因为i被传递给匿名类的基类的构造器，它并不会在匿名类内部被直接使用<br>&emsp;&emsp;下面是带实例初始化的“parcel”形式，注意destinaion的参数必须是final的，因为它们是在匿名类内部使用的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel10</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Destination <span class="title">destination</span><span class="params">(<span class="keyword">final</span> String dest,<span class="keyword">final</span> <span class="keyword">float</span> price)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Destination() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> cost;</span><br><span class="line">            &#123;</span><br><span class="line">                cost=Math.round(price);</span><br><span class="line">                <span class="keyword">if</span>(cost&gt;<span class="number">100</span>)</span><br><span class="line">                    System.out.print(<span class="string">"over Budget"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">private</span> String label=dest;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Parcel10 parcel10=<span class="keyword">new</span> Parcel10();</span><br><span class="line">        parcel10.destination(<span class="string">"houston"</span>,<span class="number">100.3f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在实例初始化操作的内部，可以看到有一段代码，它们不能作为字段初始化动作的一部分（就是if语句）所以对于匿名类而言，实例初始化的实际效果就是构造器，当然它受到了限制——<strong>你不能重载实例初始化，所以你仅有一个这样的构造器（实例初始化）</strong><br>&emsp;&emsp;匿名内部类与继承相比有些受限，因为<strong>匿名内部类既可以扩展类，也可以实现接口，但不能两者兼备，而且如果是实现接口，也只能实现一个</strong>  </p>
<h3 id="再访工厂方法"><a href="#再访工厂方法" class="headerlink" title="再访工厂方法"></a>再访工厂方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ServiceFactory</span></span>&#123;</span><br><span class="line">    <span class="function">Service <span class="title">getService</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceImpl1</span> <span class="keyword">implements</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ServiceImpl1</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123; System.out.print(<span class="string">"imple1.m1()"</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123; System.out.print(<span class="string">"impl1.m2()"</span>);&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ServiceFactory serviceFactory=<span class="keyword">new</span> ServiceFactory() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Service <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ServiceImpl1();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceImpl2</span> <span class="keyword">implements</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ServiceImpl2</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123; System.out.print(<span class="string">"imple2.m1()"</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123; System.out.print(<span class="string">"impl2.m2()"</span>);&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ServiceFactory serviceFactory=<span class="keyword">new</span> ServiceFactory() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Service <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ServiceImpl2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factories</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serviceConsumer</span><span class="params">(ServiceFactory factory)</span></span>&#123;</span><br><span class="line">        Service service = factory.getService();</span><br><span class="line">        service.m1();</span><br><span class="line">        service.m2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        serviceConsumer(ServiceImpl1.serviceFactory);</span><br><span class="line">        serviceConsumer(ServiceImpl2.serviceFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<strong>现在用于ServiceImpl1和ServiceImpl2的构造器都可以是private的，并且没有任何必要创建作为工厂的具名类</strong>，另外，你经常需要的是单一的工厂对象，因此在本例中它被创建为Service实现的static域，这样所产生的语法也更具有实际意义</p>
<h2 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h2><p>&emsp;&emsp;如果不需要内部类与外部类对象之间的联系，那么可以将内部类声明为static，这通常称为嵌套类，嵌套类意味着：</p>
<ol>
<li>要创建嵌套类的对象，并不需要其外围类的对象</li>
<li>不能从嵌套类的对象访问非静态的外围类对象<br>&emsp;&emsp;嵌套类与普通的内部类还有一个区别，<strong>普通内部类的字段与方法，只能放在类的外部层次上，所有普通的内部类不能有static数据和static字段，也不能包含嵌套类，但是嵌套类可以包含所有这些东西</strong><br>&emsp;&emsp;我对于上面问题的理解是，因为普通的内部类是依赖于外部类对象的初始化的，只有得到外部类对象的一个引用，内部类才能构建成功，这是内部类的特性，假设，允许内部类有static数据和static字段，当我们调用内部类的一个static成员时，就会引发内部类的加载，而这是不被推荐的行为，为了确保先外部类后内部类的加载和初始化顺序，编译器必须确保普通内部类中不能存在static成员，而static final是常量，在编译过程就已经存在常量池中，所有对常量没有约束，而嵌套类是static的，和外部类除了在命名空间上有些联系，其实可以将其看成一个独立的类，所以它的加载和初始化对外部类不会产生影响  <h3 id="接口内部的类"><a href="#接口内部的类" class="headerlink" title="接口内部的类"></a>接口内部的类</h3>&emsp;&emsp;正常情况下，不能在接口内部放置任何的代码，但嵌套内部类可以作为接口的一部分，你放在接口中的任何类都自动地是public和static的，因为是被static的，只要将嵌套类置于接口的命名空间内，这并不违反接口的规则，你甚至可以砸内部类中实现其外围类  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ClassInInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">howdy</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span>  <span class="title">ClassInInterface</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">howdy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.print(<span class="string">"Howdy!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">            Test test =<span class="keyword">new</span> Test();</span><br><span class="line">            test.howdy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>&emsp;&emsp;如果你想要创建某些公共代码，使得它们可以被某些接口的所有实现所共用，那么使用接口内部的嵌套类会很方便  </p>
<h3 id="从多层嵌套类中访问外部类的成员"><a href="#从多层嵌套类中访问外部类的成员" class="headerlink" title="从多层嵌套类中访问外部类的成员"></a>从多层嵌套类中访问外部类的成员</h3><p>&emsp;&emsp;一个内部类被嵌套多少层并不重要——它能透明地访问所有它所嵌入的外围类的所有成员（不包括静态内部类，静态内部类只能访问外部类的静态成员，和普通的类的访问权限一样）</p>
<h2 id="为什么需要内部类"><a href="#为什么需要内部类" class="headerlink" title="为什么需要内部类"></a>为什么需要内部类</h2><p>&emsp;&emsp;一般来说，内部类继承自某个类或实现某个接口，内部类的代码操作创建它的外围类的对象，所以认为<strong>内部类提供了某种进入外围类的方法</strong><br>&emsp;&emsp;内部类必须要回答的一个问题就是，如果只是需要一个对接口的引用，那么为什么不通过外围类实现那个接口呢？答案是：“如果这能满足要求，那么就应该这么做”，那么内部类实现的接口和外围类实现的这个接口有什么区别呢？答案是：后者不是总能享用到接口带来的便利，有时需要用到接口的实现，所以使用内部类是最吸引人的原因是：<br>&emsp;&emsp;每个接口都能独立地继承自一个（接口的）实现，所以无论外围类是否以及继承了某个（接口的）实现，对于内部类都没有影响<br>&emsp;&emsp;如果没有内部类提供的，可以继承多个具体的或者抽象的类的能力，一些设计与编程的问题就很难解决，从这个角度看，内部类使得多重继承的解决方案变得完美，接口解决了部分问题，而内部类有效地实现了“多重继承”，也就是说吗，内部类允许继承多个非接口类型（类或者抽象类）<br>&emsp;&emsp;使用内部类，还可以获得其他的一些特性：</p>
<ol>
<li>内部类可以有多个实例，每个内部类都有自己的状态信息，并且与其外围类对象的信息相互独立</li>
<li>在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类</li>
<li>创建内部类对象的时刻并不依赖于外围类对象的创建？</li>
<li>内部类并没有让人迷惑的“is-a”问题，它就是一个独立的实体<h3 id="闭包与回调"><a href="#闭包与回调" class="headerlink" title="闭包与回调"></a>闭包与回调</h3>&emsp;&emsp;<strong>闭包（closure）是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域</strong>，通过这个定义，可以看出内部类是面向对象的闭包，因为它不仅包含外围类对象（创建内部类的作用域）的信息，还自动拥有一个指向此外围类对象的引用，在此作用域内，内部类有权操作所有的成员，包括private成员<br>&emsp;&emsp;java做引人争议的问题之一就是，人们认为java应该包含某种指针机制，以允许回调（callback）,通过回调，对象能够携带一些信息，这些信息允许它在稍后的某个时候调用初始的对象，，如果回调是通过指针实现的话，那就期待程序员不会误用指针<br>&emsp;&emsp;通过内部类提供闭包的功能是优良的解决方案，它比指针更灵活，更安全  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Incrementtable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Callee1</span> <span class="keyword">implements</span> <span class="title">Incrementtable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">        System.out.print(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyIncrement</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;System.out.print(<span class="string">"Other operation"</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(MyIncrement mi)</span></span>&#123;mi.increment();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Callee2</span> <span class="keyword">extends</span> <span class="title">MyIncrement</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.increment();</span><br><span class="line">        i++;</span><br><span class="line">        System.out.print(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Closure</span> <span class="keyword">implements</span> <span class="title">Incrementtable</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</span><br><span class="line">            Cellee2.<span class="keyword">this</span>.increment();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Incrementtable <span class="title">getCallbackreference</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Closure();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Caller</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Incrementtable callbackReference;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Caller</span><span class="params">(Incrementtable ic)</span></span>&#123;callbackReference=ic;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">()</span></span>&#123;callbackReference.increment();&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallBack</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Callee1 c1=<span class="keyword">new</span> Callee1();</span><br><span class="line">        Callee2 c2=<span class="keyword">new</span> Callee2();</span><br><span class="line">        MyIncrement.f(c2);</span><br><span class="line">        Caller caller1=<span class="keyword">new</span> Caller(c1);</span><br><span class="line">        Caller caller2=<span class="keyword">new</span> Caller(c2.getCallbackreference());</span><br><span class="line">        caller1.go();</span><br><span class="line">        caller2.go(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>&emsp;&emsp;这个例子进一步展示了外围类实现一个接口与内部类实现此接口之间的区别，就代码而言，Callee1是简单的解决方案，Callee2继承自MyIncrement，后者已经有了一个不同的increment()方法，并且与Incrementable接口期望的increment()方法完全不相关，所以入股Cellee2继承了MyIncrement，就不能为了Incrementable的用途而覆盖increment()方法，于是只能使用内部类独立地实现Incrementable，还要主要，当创建一个内部类时，并没有在外围类的接口中添加东西，也没有修改外围类的接口<br>&emsp;&emsp;主要，在Callee2中除了getCallbackReference()方法之外，其他成员都是private的，要想建立与外部世界的任何连接，interface Incrementable都是必需的，在这里可以看到，interface是如何允许接口与接口的实现完全独立的<br>&emsp;&emsp;内部类Closure实现了InCrementable，以提供一个安全的“钩子（hook）”——而且这个钩子是一个安全的钩子，它只能允许调用者对外围类进行特定的操作</p>
<h3 id="内部类与框架"><a href="#内部类与框架" class="headerlink" title="内部类与框架"></a>内部类与框架</h3><p>&emsp;&emsp;控制框架<br>&emsp;&emsp;应用程序框架（application framework）就是被设计用以解决某类特定问题的一个类或者一组类，要运用某个应用程序框架，通常继承一个或者多个类，并覆盖某些方法，在覆盖后的方法中，编写代码定制应用程序框架提供的通用解决方案，以解决你的特定问题（这是设计模式中模板方法的一个例子）<br>&emsp;&emsp;控制框架是一类特殊的应用程序框架，它用来解决相应时间的需求，主要用来响应时间的系统被称为事件驱动系统，一般来说，我们会考虑使用内部类来设计控制框架系统，原因如下  </p>
<ol>
<li>控制框架的完整实现是由单个的类创建的，从而使得实现的细节被封装了起来，<strong>内部类的用来表示解决问题所需要的不同的动作</strong></li>
<li><strong>内部类能够很容易地访问外围类的任意成员</strong>，所有可以避免这种实现变得笨拙，如果没有这种能力，代码将变得使人讨厌<h2 id="内部类的继承"><a href="#内部类的继承" class="headerlink" title="内部类的继承"></a>内部类的继承</h2>&emsp;&emsp;因为内部类的构造器必须连接到指向其外围类的对象的引用，所有在继承内部类的时候，事情会变得有些复杂，问题在于，那个指向外围类对象的“秘密的”引用必须被初始化<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritInner</span>  <span class="keyword">extends</span> <span class="title">Outer</span>.<span class="title">Inner</span></span>&#123;</span><br><span class="line">    InheritInner(Outer outer)&#123;</span><br><span class="line">        outer.<span class="keyword">super</span>();<span class="comment">//表示的是调用outer的构造器</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Outer outer=<span class="keyword">new</span> Outer();</span><br><span class="line">        InheritInner i = <span class="keyword">new</span> InheritInner(outer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="内部类可以被覆盖吗？"><a href="#内部类可以被覆盖吗？" class="headerlink" title="内部类可以被覆盖吗？"></a>内部类可以被覆盖吗？</h2><p>&emsp;&emsp;如果构建一个内部类，然后继承外部类并重新定义此内部类时，会发生什么？内部类可以被覆盖吗？但是，<strong>“覆盖内部类就像好像它是外围类的一个方法，其实并不起什么作用</strong>”<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Egg</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Yolk y;</span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.print(<span class="string">"Egg.folk()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Egg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"new Egg()"</span>);</span><br><span class="line">        y=<span class="keyword">new</span> Yolk();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigEgg</span> <span class="keyword">extends</span> <span class="title">Egg</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span></span>&#123;System.out.print(<span class="string">"BigEgg.folk()"</span>);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> BigEgg();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//new Egg()</span></span><br><span class="line"><span class="comment">//Egg.folk()</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这说明了一件事情，内部类和外部类其实是两个不同的类，内部类需要外部类对象的引用来创建自己，内部类具有访问外部类成员的权限，<strong>但是当继承一个外部类的时候，并不继承内部类</strong></p>
<h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>前面提到过，可以在方法块里创建局部类，典型的方式是在一个方法的里面创建，<strong>局部内部类不能有访问说明符，因为它不是外围类的一部分，但是它可以访问当前代码块内的常量已经外围类的所有你成员</strong><br>&emsp;&emsp;既然局部内部类的名字在方法外是不可见的，那么我们我什么仍然使用局部内部类而不是匿名类呢？唯一的理由是：<strong>我们需要一个已命名的构造器，或者需要重载构造器，而匿名内部类只能用于实例初始化</strong></p>
<h2 id="内部类标识符"><a href="#内部类标识符" class="headerlink" title="内部类标识符"></a>内部类标识符</h2><p>&emsp;&emsp;由于每个类都会产生一个.class文件,其中包含了如何创建该类型的对象的全部信息（此信息产生一个meta-class，叫做Class对象），内部类也必须生成一个.class文件以包含他们的Class对象的信息。这些名字有严格的规定，外围类的名字，加上“$”,再加上内部类的名字，如果内部类时匿名的，编译器会简单地产生一个数字作为标识符</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/10/内部类/" data-id="cjnzv2poh001hcorzddtk6twm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-接口" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/09/接口/" class="article-date">
  <time datetime="2018-10-09T11:27:30.000Z" itemprop="datePublished">2018-10-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习心得/">学习心得</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/09/接口/">接口</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;接口和内部类为我们提供了一种将接口与实现分离的更加结构化的方法  </p>
<h2 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h2><p>&emsp;&emsp;我们创建这样一个类，这个类只提供通用的接口，我们希望通过这个通用接口可以操作一系列类，创建提供通用接口的对象有时是没有意义的，而且我们还希望禁止创建这样的一个类的对象，我们可以在这个抽象的类上写一些“哑”方法，当调用这个“抽象类”对象的“哑”方法时，能抛出错误，但是这样方式，只有在运行时才能被检测到<br>&emsp;&emsp;java提供了一个叫做抽象方法的机制，这种方法是不完整的，仅声明而没有方法体<br>&emsp;&emsp;包含抽象方法的类称为抽象类，如果一个类包含一个或者多个抽象方法，该类必须被限定为抽象的（否则，编译器会报错）<br>&emsp;&emsp;如果从一个抽象类继承，并想创建该新类的对象，那么就必须为基类的所有抽象方法定义，如果不这样做，那么导出类也必须是抽象的，而且编译器会强制我们使用abstract关键字来限定这个类<br>&emsp;&emsp;我们也可能会创建没有任何抽象方法的抽象类，考虑这种情况，这个类包含任何abstract方法都是没有意义的，而且我们也想阻止产生这个类的对象，那么这时这样做就是有意义的<br>&emsp;&emsp;创建抽象类和抽象方法时很有用的，因为它们可以使类的抽象性明确起来，并告诉用户和编译器打算怎样使用它们，抽闲类还是很有用的重构工具，因为它们使得我们可以很容易地将公共方法沿着继承层次结构向上移动</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>&emsp;&emsp;interface这个关键字产生一个完全抽象的类，它根本就没有提供任何具体实现，它允许创建者确定方法名，参数列表和返回类型，但是没有任何方法体<br>一个接口表示：“<strong>所有实现了该接口的类看起来都像是这样的</strong>”因此，任何使用某特定接口的代码都知道可以调用该接口的哪些方法，因此接口被用来建立类与类之间的协议<br>&emsp;&emsp;但是，interface是个极度抽象的类，因为它允许人们通过创建一个能够被向上转型为多积累的类型，来实现某种类似多重继变种的特性<br>&emsp;&emsp;接口的创建很简单，使用interface关键字替代class关键字，也可以在interface前面加上public（但仅限于该接口在与其同名的文件中被定义）如果不加public ，它只具有包权限，这样它只能在同一个包中可用，接口也可以包含域，但是这些域都是static和final的<br>&emsp;&emsp;可以在接口中显式地将方法声明为public，但即使你不这么做，它们也是public的，因此，当要实现一个接口时，在接口被定义的方法必须被定义为public，否则，它们只能得到包访问权限，这样在方法被继承的过程中，其可访问权限就被降低了，这是java编译器不允许的，所有接口中的方法必须是public的，即使不声明这些方法也会自动是public的</p>
<h2 id="完全解耦"><a href="#完全解耦" class="headerlink" title="完全解耦"></a>完全解耦</h2><p>&emsp;&emsp;只有一个方法操作的是类而非接口，那么你就只能使用这个类及子类，如果你想要将这个方法应用于不在此继承结构的某个类，那么就会很麻烦了，接口可以在很大程度上放宽这些限制，因此，它使得我们可以编写可复用更好的代码  </p>
<h2 id="java的多重继承"><a href="#java的多重继承" class="headerlink" title="java的多重继承"></a>java的多重继承</h2><p>&emsp;&emsp;接口不仅仅只是一种更纯粹形式的抽象类，它的目标比这更高。因为接口是根本没有任何具体实现的，也就是说，没有任何与接口相关的存储，因此也就无法阻止多个接口的组合，这一点很有价值，因为你需要表示“一个x是一个a和一个b以及一个c”，在C++中，组合多个类的接口的行为被称为<strong>多重继承</strong>它可能使你背负很沉重的负担，因为每个类都有一个具体实现<br>&emsp;&emsp;使用接口的核心原因：为了能够向上转型为多个基类型（以及由此带来的灵活性），然而，使用接口的第二个原因却是与抽象基类相同：防止客户端程序员创建该类的对象，并确保这仅仅是建立一个接口，这就带来了一个问题，我们应该使用接口还是抽象类？如果创建不带任何方法和成员变量的基类，那么你就选择接口而不是抽象类，事实上，如果知道某个事物应该成为一个基类，那么第一选择应该是使它成为一个接口</p>
<h2 id="通过继承来扩展接口"><a href="#通过继承来扩展接口" class="headerlink" title="通过继承来扩展接口"></a>通过继承来扩展接口</h2><p>接口与接口之间的继承很容易地创建一个新的接口，这个新的接口是这两个接口的并集</p>
<h3 id="组合接口时的命名冲突"><a href="#组合接口时的命名冲突" class="headerlink" title="组合接口时的命名冲突"></a>组合接口时的命名冲突</h3><p>&emsp;&emsp;组合接口拥有被组合接口的所有方法，所以判断组合接口时接口方法命名是否冲突的一个基本准则是，在新的接口中，被组合的接口能否共存  如下例：  </p>
<pre><code class="java"><span class="class"><span class="keyword">interface</span> <span class="title">I1</span> </span>{
    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>;
}
<span class="class"><span class="keyword">interface</span> <span class="title">I2</span></span>{
    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;
}
<span class="class"><span class="keyword">interface</span> <span class="title">I3</span></span>{
    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a )</span></span>;
}

<span class="comment">//interface I4 extends I1,I2{ }即使方法返回值不同，I1和I2包含的接口命名冲突，不能共存</span>
<span class="class"><span class="keyword">interface</span> <span class="title">I5</span> <span class="keyword">extends</span> <span class="title">I1</span>,<span class="title">I3</span></span>{ }

</code></pre>
<h2 id="适配接口"><a href="#适配接口" class="headerlink" title="适配接口"></a>适配接口</h2><p>&emsp;&emsp;接口最吸引人的原因之一就是允许同一个接口具有多个不同的具体实现，在简单的情况中，它的体现形式通常是一个接收接口类型的方法，而接口的实现和向该方法传递的对象则取决于方法的使用者<br>&emsp;&emsp;因此，<strong>接口的一种常见用法就是前面提到的策略设计模式</strong>，此时你编写一个执行某些操作的方法，而该方法将接受一个同样是你指定的接口，你主要就是声明：“你可以用任何你想要的对象来调用我的方法。只要你的对象遵守我的接口”</p>
<h2 id="接口中的域"><a href="#接口中的域" class="headerlink" title="接口中的域"></a>接口中的域</h2><p>&emsp;&emsp;因为你放入接口中的任何域都自动是static和final的，所以接口就成为了一种很便捷的用来创建常量组的工具，不过SE5之后，有了enum关键字之后，使用接口群组常量已经没什么意义了</p>
<h2 id="嵌套接口"><a href="#嵌套接口" class="headerlink" title="嵌套接口"></a>嵌套接口</h2><p>&emsp;&emsp;接口可以嵌套在类或者其他接口中，这揭示了许多非常有趣的特性  </p>
<figure class="highlight java"><figcaption><span>嵌套接口</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"><span class="comment">//在类中嵌套</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">B</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BImpl1</span> <span class="keyword">implements</span> <span class="title">B</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BImpl2</span> <span class="keyword">implements</span> <span class="title">B</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">C</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CImple1</span> <span class="keyword">implements</span> <span class="title">C</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>  <span class="class"><span class="keyword">class</span> <span class="title">CImple12</span> <span class="keyword">implements</span> <span class="title">C</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">D</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DImple1</span> <span class="keyword">implements</span>  <span class="title">D</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DImple2</span> <span class="keyword">implements</span>  <span class="title">D</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> D dRef;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> D <span class="title">getD</span><span class="params">()</span></span>&#123;<span class="keyword">return</span>  <span class="keyword">new</span> DImple1();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveD</span><span class="params">(D d)</span></span>&#123;</span><br><span class="line">        dRef=d;</span><br><span class="line">        d.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//在接口中嵌套</span></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">E</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">G</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//redundant public 多余的public</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">H</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NestingInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bimp</span> <span class="keyword">implements</span> <span class="title">A</span>.<span class="title">B</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CImpl</span> <span class="keyword">implements</span> <span class="title">A</span>.<span class="title">C</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    class DImpl implements  A.D&#123;</span></span><br><span class="line"><span class="comment">//        public void f()&#123;&#125;;</span></span><br><span class="line"><span class="comment">//    &#125;不能实现一个私有的接口</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">EImpl</span> <span class="keyword">implements</span>  <span class="title">E</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">EGImpl</span> <span class="keyword">implements</span> <span class="title">E</span>.<span class="title">G</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	        A a = <span class="keyword">new</span> A();</span><br><span class="line">	        <span class="comment">//Can't access A.D 不能访问A.D,因为A.D是私有的</span></span><br><span class="line">	        <span class="comment">//A.D ad=a.getD();</span></span><br><span class="line">	        <span class="comment">//除了A.D 也不能返回任何类型的引用 Doesn't return nothing but A.D</span></span><br><span class="line">	        <span class="comment">//A.DImple2 dImple2=a.getD();</span></span><br><span class="line">	        <span class="comment">//也不能访问这个接口的成员 connot access a member of the interface</span></span><br><span class="line">	        <span class="comment">//a.getD().f();</span></span><br><span class="line">	        <span class="comment">//可以让另一个A对getD()返回的对象进行操作。Only another A can do anything with getD()</span></span><br><span class="line">	        A a2 = <span class="keyword">new</span> A();</span><br><span class="line">	        a2.receiveD(a.getD()); </span><br><span class="line">	    &#125;</span><br><span class="line">    </span><br><span class="line">      &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在类中嵌套接口是相当常见的语法，就像非嵌套接口一样，可以拥有publi和包访问权限，两种可视性，<br>&emsp;&emsp;作为一种新添加的方式，接口也可以被实现为private的，就像<code>A.D</code>中看到的那样（相同的方法，既可以适用于嵌套接口，也可以使用于嵌套类），那么private的嵌套接口能够带来什么好处呢？实现一个private接口只是一种方式，它可以强制接口中定义的定义的方法不要添加任何类型信息（也就是说，不能进行向上转型）<br>&emsp;&emsp;getD()方法陷入了一个两难的境地，这个问题与private接口有关，它是一个返回对private接口引用的public方法，你对这个方法返回值能做什么呢？在main方法时，我们尝试了很多行为都失败了，只有一种方式能够成功，那就是将返回值交给有权使用它的对象，在这个例子中，是另一个A通过<code>receiveD()</code>方法实现的<br>&emsp;&emsp;接口E说明接口彼此之间也是可以嵌套的，与在类嵌套接口不同，被嵌套在接口中的所有接口元素都是public的，，即使不声明，也会自动为public<br>&emsp;&emsp;注意的是，当实现某个接口的时候，并不需要实现嵌套在内部的任何接口，而且private接口也不能在定义它的类之外被实现</p>
<h2 id="接口和工厂"><a href="#接口和工厂" class="headerlink" title="接口和工厂"></a>接口和工厂</h2><p>&emsp;&emsp;接口是实现多重继承的途径，而生成遵循某个接口的对象的典型方式就是工厂方法设计模式，<strong>这与直接使用构造器不同，我们在工厂对象上调用的是创建方法</strong>，而该工厂对象将生成接口的某个实现的对象，通过这种方式，我们的代码将完全与接口的实现分离，这就使得我们可以透明地将某个实现替换成另一个实现<br><figure class="highlight java"><figcaption><span>工厂方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.egbertday;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ServiceFactory</span></span>&#123;</span><br><span class="line">    <span class="function">Service <span class="title">getService</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceImp1</span> <span class="keyword">implements</span>  <span class="title">Service</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServcieImp1Factory</span> <span class="keyword">implements</span> <span class="title">ServiceFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  Service <span class="title">getService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServiceImp1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceImp2</span> <span class="keyword">implements</span>  <span class="title">Service</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServcieImp2Factory</span> <span class="keyword">implements</span> <span class="title">ServiceFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  Service <span class="title">getService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServiceImp2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factories</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serviceConsumer</span><span class="params">(ServiceFactory serviceFactory)</span></span>&#123;</span><br><span class="line">        Service service=serviceFactory.getService();</span><br><span class="line">        service.m1();</span><br><span class="line">        service.m2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        serviceConsumer(<span class="keyword">new</span> ServcieImp1Factory());</span><br><span class="line">        serviceConsumer(<span class="keyword">new</span> ServcieImp2Factory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果不是工厂方法，你的代码就必须要在某处指定将要创建的Service的确切类型，以便调用合适的构造器<br>&emsp;&emsp;为什么我们要增加这种额外级别的间接性呢？一个常见的原因是想要创建框架  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/09/接口/" data-id="cjnzv2pr9002ncorzmix1nz36" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-多态" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/09/多态/" class="article-date">
  <time datetime="2018-10-09T06:34:58.000Z" itemprop="datePublished">2018-10-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习心得/">学习心得</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/09/多态/">多态</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;在面向对象的程序设计语言，多态是数据抽象和继承之后的第三种基本特征<br>&emsp;&emsp;多态通过分离做什么和怎么做，从另一个角度将接口和实现相分离，多态不但能够改善代码的组织结构和可读性，还能够创建可扩展的程序——即无论在项目最初创建时还是在需要新功能时都可以“生长”的程序<br>&emsp;&emsp;“封装”通过合并特征和行为来创建新的数据类型，“实现隐藏”则通过将细节“私有化”，把接口和实现分离开来。而多态的作用是消除类型之间的耦合关系，多态方法调用允许一种类型表现出与其他相似类型之间的区别，只要它们都是从一个基类中导出来的，这种区别是根据方法行为的不同而表示出来的，虽然这些方法都是可以通过同一个基类来调用  </p>
<h2 id="再论向上转型"><a href="#再论向上转型" class="headerlink" title="再论向上转型"></a>再论向上转型</h2><p>&emsp;&emsp;把某个对象的引用类型视为对基类的引用的做法就被称为向上转型  </p>
<h3 id="忘记对象类型"><a href="#忘记对象类型" class="headerlink" title="忘记对象类型"></a>忘记对象类型</h3><p>&emsp;&emsp;我们在程序的编写时，如果一个方法接受的是一个特定类型的参数，这样就产生了一个问题，我们是不是要为每一种特定类型写一个接受其特定类型的方法？我们有没有更通用的办法，使得方法接收一个更加通用的类型，而不在意具体的类型是什么，只要我们可以将这个特定类型当作通用类型的看待即可  </p>
<h2 id="转机"><a href="#转机" class="headerlink" title="转机"></a>转机</h2><p>&emsp;&emsp;将一个具体的类型当作向上转型类型的时候，编译器怎么知道它调用的是那个方法呢？实际上，编译器不知道，为了研究这个问题，先来看下绑定的定义<br>&emsp;&emsp;将一个方法调用同一个方法主体关联起来就被称为绑定，例如 <code>f()</code>是一个方法，a是A类型的对象，当a调用<code>f()</code>方法的时候，我们a调用的其实是<code>f()</code>方法,这就叫绑定，或者称作f()和A类型的对象进行了绑定,若在程序执行前进行绑定的话，由编译器和连接程序实现，就做前期绑定，我们没有听过则个术语，因为它是面向对象不需要选择就默认使用的绑定方式<br>&emsp;&emsp;我们对于多态的迷惑，主要是因为前期绑定，那么编译器应该知道调用那个方法才对，为什么不同的具体类型又会有不同的调用结果，不同的调用结果，就表明调用的不是同一个方法<br>&emsp;&emsp;解决的办法就是后期绑定，它的含义就是根据运行是根据对象的类型进行绑定吧，后期绑定也称为动态绑定或者运行期绑定，如果一种语言要想实现后期绑定，就必须具有某种机制，以便在运行时能判断对象的类型，从而调用恰当的方法，也就是说编译器不知道对象的类型，但是方法调用机制能够找到正确的方法体<br>&emsp;&emsp;java中除了static方法和final方法（private方法也属于final方法）之外，其他所有的方法都是后期绑定<br>&emsp;&emsp;为什么要将一个方法声明为final呢？除了之前讲到的原因之外，更重要的一点也许是：这样可以有效地“关闭”动态绑定，或者说，告诉编译器不需要对其进行动态绑定  </p>
<h3 id="产生正确的行为"><a href="#产生正确的行为" class="headerlink" title="产生正确的行为"></a>产生正确的行为</h3><p>&emsp;&emsp;一旦知道java中所有的方法都是通过动态绑定实现多态这个事实之后，我们就可以编写只与基类打交道的程序代码了，并且这些代码对所有导出类都可以正确运行，由于有多态机制，这样我们可以在系统当中添加任意多的新类型，而不需要改变基于基类编写的代码，这样的程序是可扩展的  </p>
<h3 id="缺陷：“覆盖”私有方法"><a href="#缺陷：“覆盖”私有方法" class="headerlink" title="缺陷：“覆盖”私有方法"></a>缺陷：“覆盖”私有方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">		package xyz.egbertday;</span><br><span class="line">		class Derived extends PrivateOverride&#123;</span><br><span class="line">		    public void f()&#123;</span><br><span class="line">		        System.out.print(&quot;publi.f()&quot;);</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		public class PrivateOverride &#123;</span><br><span class="line">		    private void f()&#123;</span><br><span class="line">		        System.out.print(&quot;private.f()&quot;);</span><br><span class="line">		    &#125;</span><br><span class="line">		    </span><br><span class="line">		    public static void main(String[] args)&#123;</span><br><span class="line">		        PrivateOverride derived=new Derived();</span><br><span class="line">		        derived.f();</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;</span><br><span class="line">~~~ </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">我们期望的是输出`public.f()`，但是由于private方法被自动地认为是final方法，在这里对private方法的调用是前期绑定  </span><br><span class="line">### 缺陷：域和静态方法 ###</span><br><span class="line">&amp;emsp;&amp;emsp;任何域访问操作都将由编译器解析，因此不是多态的，对静态方法的调用也不是多态的  </span><br><span class="line">## 构造器和多态 ##</span><br><span class="line">通常，构造器不同于其他种类的方法，设计到多态时也是如此，尽管构造器并不具有多态性（它们实际上是static方法，只不过该static声明的是隐式的），但还是有必要理解构造器怎么通过多态在复杂的层次结构中运作</span><br><span class="line">### 构造器的调用顺序 ###</span><br><span class="line">&amp;emsp;&amp;emsp;基类的构造器总是在导出类的构造过程中被调用，而且按照继承层次逐渐向上链接，以确保内个基类的构造器都能得到调用</span><br><span class="line">### 继承与清理 ###</span><br><span class="line">&amp;emsp;&amp;emsp;通过组合和继承方法创建新类时，方法永远不必担心对象的清理问题，子对象通常都会留给垃圾回收器进行，如果确实遇到清理的问题，那么必须用心为新类创建`dispose()`方法（这是个假设的名字）并且由于继承的缘故，如果我们有其他作为垃圾回收部分的特殊清理动作，必须现在导出类中覆盖`dispose()`方法，当覆盖被继承的`dispose()`方法时，务必调用基类版本的`dispose()`方法，否则，基类的清理动作就不会发生  </span><br><span class="line">~~~java</span><br><span class="line">package xyz.egbertday;</span><br><span class="line">class SuperClass&#123;</span><br><span class="line">    public void dispose()&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">public class SubClass extends SuperClass&#123;</span><br><span class="line">    public void dispose()&#123;</span><br><span class="line">        super.dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构造器内部的多态方法的行为"><a href="#构造器内部的多态方法的行为" class="headerlink" title="构造器内部的多态方法的行为"></a>构造器内部的多态方法的行为</h3><p>&emsp;&emsp;构造器调用的层次问题带来了一个有趣的两难问题，如果在一个构造器的内部调用正在构造对象的某个动态绑定，那么会发生什么情况呢？<br>&emsp;&emsp;在一般的方法内部，动态绑定是在运行时才决定的，因为对象无法知道它是属于方法所在的类，还是属于那个类的导出类<br>&emsp;&emsp;如果要调用构造器内部的一个动态绑定方法，就要用到那个方法的被覆盖之后的定义，然而，这个调用的效果可能相当难预料，因为被覆盖的方法在对象被完全构建之前就会被调用，这可能会出现一些难以预料的隐藏错误<br>&emsp;&emsp;从概念上将，构造器的工作实际上是创建对象（这不是一件平常的事情），在任何构造器内部，整个构造器可能只是部分形成，如果构造器只是在构建对象过程中的一个步骤，并且该对象所属的类是从这个构造器所属的类导出的，那么导出部分在当前构造器正在被调用的时刻仍旧没有被初始化，然而，一个动态绑定的方法调用可能会向外深入到继承层次结构内部，它可以调用导出类里的方法,如果我们是在构造器内部这样做，那么就可能会调用这个方法，而这个方法所操作的成员可能还未进行初始化——这肯定会招致灾难<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"SuperClass"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    SuperClass()&#123;</span><br><span class="line">        printA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.print(<span class="string">"SubClass"</span>+a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SubClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolyConstructor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        SubClass subClass = <span class="keyword">new</span> SubClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;我们预期，当创建基类的时候，会先调用基类的构造器，在基类的构造器方法中调用了<code>print()</code>,因为动态代理的缘故，实际上调用的是导出类的<code>printA()</code>我们预期结果会是“SubClass1”,可是因为当调用基类的构造器时，还没有对导出类进行初始化，i仍然是0值<br>&emsp;&emsp;以前讲的初始化顺序并不十分完整，而这正是立即谜题的关键，初始化的实际过程是  </p>
<ol>
<li>在其他任意事物发生之前，将分配给对象的存储空间初始化成二进制的零</li>
<li>如前所述那样调用基类构造器，此时，调用被覆盖后的<code>printA()</code>方法（要在调用导出类的构造器之前），由于步骤1的关系，我们此时会发现i的值为0 </li>
<li>按照声明的顺序调用成员的初始化方法<br>&emsp;&emsp;这样做有一个优点，那就是所有东西至少初始化为零<br>&emsp;&emsp;编写构造器的时候有一条有效地准则“用尽可能简单的方法使对象进入正常状态，如果可以的话，避免调用其他方法”在构造器中唯一能够安全调用的方法是基类的那些final方法（private也是final方法），这些方法不能被覆盖，因此也就不不会发生动态绑定（多态）的问题了<h2 id="协变返回类型"><a href="#协变返回类型" class="headerlink" title="协变返回类型"></a>协变返回类型</h2>&emsp;&emsp;协变返回类型，它表示在导出类中的被覆盖的方法可以返回基类方法返回类型的某种导出类型<h2 id="用继承进行设计"><a href="#用继承进行设计" class="headerlink" title="用继承进行设计"></a>用继承进行设计</h2>&emsp;&emsp;多态特性很容易诱使我们继承现有的类，以实现多态的特性，实际的开发当中，如果首先考虑继承技术，反而会加重我们的设计负担<br>&emsp;&emsp;更好的方式是首先选择“组合”，尤其是不能十分确定应该使用哪一种方式时，组合不会强制我们的程序设计进入继承的层次结构，而且，组合更加灵活，它可以动态选择类型（因此也就选择了行为），相反，继承在编译时就需要知道确切类型。看看下面的经典案例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Actor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">act</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HappyActor</span> <span class="keyword">extends</span> <span class="title">Actor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">act</span><span class="params">()</span></span>&#123;System.out.print(<span class="string">"happy"</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SadActor</span> <span class="keyword">extends</span> <span class="title">Actor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">act</span><span class="params">()</span></span>&#123;System.out.print(<span class="string">"sad"</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stage</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Actor actor=<span class="keyword">new</span> HappyActor();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">()</span></span>&#123;</span><br><span class="line">        actor=<span class="keyword">new</span> SadActor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line">        actor.act();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transmogrify</span> </span>&#123;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>&emsp;&emsp;在这里，Stage对象包含一个对Actor的引用，而Actor被初始化为一个HappyActor对象，这意味着play()会产生某种特殊行为，既然引用在运行时可以与另一个不同对象重新绑定（”<code>change()</code>“），所以SadActor对象的引用可以在actor中被替换，然后由<code>play()</code>产生的行为也随之改变，这样一来，我们在运行期间获得了动态的灵活性（这也称为“状态模式”），与此相反，我们不能再运行期间决定继承不同的对象，因为它要求在编译器间完全确定下来<br>&emsp;&emsp;一条通用的法则是：用继承表达行为之间的差异，并用字段表达状态上的变化，在上面例子，两者都用到了，通过继承得到了两个不同的类，用于表达<code>act()</code>方法的差异，而Stage通过运用组合使自己的状态发生变化，在这情况下，这种状态的改变也就产生了行为的改变</p>
<h3 id="纯继承与扩展"><a href="#纯继承与扩展" class="headerlink" title="纯继承与扩展"></a>纯继承与扩展</h3><p>&emsp;&emsp;“纯粹”的继承表示导出类和基类的接口完全一致<br>&emsp;&emsp;扩展表示在基类的基础上添加导出类自己所特有的方法</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/09/多态/" data-id="cjnzv2pqv002fcorzqwmu0no4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-复用类" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/07/复用类/" class="article-date">
  <time datetime="2018-10-06T17:41:58.000Z" itemprop="datePublished">2018-10-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习心得/">学习心得</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/07/复用类/">复用类</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>&emsp;&emsp;复用代码是java众多引人注目的功能之一，但要想成为极具革命性的语言，仅仅能够复制代码并对之加以改变是不够的，它还必须能够做更多的事情<br>&emsp;&emsp;正如Java中所有事物一样，问题的解决都是围绕着类展开的，可以通过创建新类来复用代码，而不必再从头开始编写，可以使用别人业已开发并调试好的类。<br>&emsp;&emsp;此方法的窍门在于使用类而不破坏现有程序的代码，有两种方式可以达到这种目的，组合和继承  </p>
</blockquote>
<h2 id="继承语法"><a href="#继承语法" class="headerlink" title="继承语法"></a>继承语法</h2><p>&emsp;&emsp;当创建一个类的时候，总是在继承，因为除非已经明确指出要从其他类继承，否则都是隐式地从Java的标准跟类Object继承<br>&emsp;&emsp;在继承的过程，需要先声明“新类与基本相似”。这种声明是通过extends关键字完成的  </p>
<h3 id="初始化基类"><a href="#初始化基类" class="headerlink" title="初始化基类"></a>初始化基类</h3><p>&emsp;&emsp;从外部看，导出类就像一个与基类具有相同接口的新类，或许还会有一些额外的方法和域，但继承并不只是复制基类的接口，当创建一个导出来类的对象时，该对象包含一个基类的子对象，这个子对象和你用基类直接创建的对象是一样的，二者之间的区别在于，后者来自于外部，而基类的子对象被包装在导出类对象的内部，其实来说，整个导出类对象的创建过程并没有产生父类的对象，我们只是利用了父类的构造函数来初始化导出类的属性，对基类子对象的初始化必须得到保证，所以就是在导出类的构造器中通过调用基类构造器来执行初始化，而基类构造器具有执行基类初始化所需的所有知识和能力，Java会自动在导出类的构造器中插入对基类构造器的调用，其为什么导出类不能直接访问这些由基类初始化的属性，我们之后再谈<br>&emsp;&emsp;所以我们也会发现，整个创建过程是从导出类依次上溯，构造函数执行的初始化动作依次向下</p>
<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>&emsp;&emsp;第三种关系称为代理，java并没有提供对它的直接支持，这是继承和组合的中庸之道，因为我们将一个对象置于所要构造的类中（就像组合），但与此同时我们在新类中暴露该成员的所有方法（就像继承）</p>
<h2 id="结合使用组合和继承"><a href="#结合使用组合和继承" class="headerlink" title="结合使用组合和继承"></a>结合使用组合和继承</h2><p>&emsp;&emsp;同时使用组合和继来创建复杂的类是很常见的，因为新类能够同时可以对继承和组合的类的功能进行复用</p>
<h2 id="在组合和继承之间选择"><a href="#在组合和继承之间选择" class="headerlink" title="在组合和继承之间选择"></a>在组合和继承之间选择</h2><p>&emsp;&emsp;组合和继承都允许在新类中放置子对象，组合是显式地这样做，而继承则是隐式地这样做，那当我们创建的新类想要使用另一个类的服务（接口）时，该如何选择？<br>&emsp;&emsp;组合技术通常用于想要使用现有类的功能而不是它的接口这种情形，在新类中嵌入某个类的对象，让其实现所需的功能，但新类的用户看到的只是新类所定义的接口，而非所嵌入对象的接口，为取得此效果，需要在新类中嵌入一个现有类的private对象<br>&emsp;&emsp;有时，运行累的用户直接访问新类中的组合成分是及其有意思的，也就是说，将成员对象声明为public，如果成员对象自身隐藏了具体实现，那么这样做也是安全的，当用户能够了解你正在组装一组部件，会使得端口更加易于理解，比如组装一辆车Car，<code>car.left.window.roolup()</code>这样的代码很容易让人理解，但是，一般情况下，我们还是会将一个对象声明为private，并通过公开的接口来获得这个成员对象<br>&emsp;&emsp;在继承的时候，使用现有的类，并开发一个它的特殊版本，通常，这意味着你在使用一个通用类，为了某种特性需要而对其特殊化</p>
<h2 id="protected关键字"><a href="#protected关键字" class="headerlink" title="protected关键字"></a>protected关键字</h2><p>&emsp;&emsp;在理想世界中，关键字private就足够了，但在实际项目中，经常会将某些事物尽可能对整个世界隐藏，但仍然运行导出类的成员访问它们<br>&emsp;&emsp;关键字protected就是起到这个作用，它指明“就类用户而言，这是private的，但对于任何继承于此类的导出类或任何位于同一个包的类来说，它确实可以访问的（protected也提供了包访问权限）”<br>&emsp;&emsp;尽管可以创建protected域，但是最好的方式还是将域保持为private，你应当一致保留“要更改底层实现”的权利，然后通过protected方法来控制类的继承者的访问权限</p>
<h2 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h2><p>“为新的类提供方法”并不是继承的最重要的方面，其最重要的方面是用来表现新类和基类之间的关系，这种关系可以用“新类是现有类的一种类型”，这句话加以概括<br>这个描述并不只是一种解释继承的华丽方式，这直接是由语言所支撑的，由于继承可以确保基类中所有的方法在导出类中也同样有效，所有能够向基类发送的所有信息同样也可以向导出类发送<br>&emsp;&emsp;由导出类转型成基类，在继承图上是向上移动的，因此一般称为向上转型，由于向上转型是从一个较专用类型向一个较通用类型转换，所以总是安全的，也就是说，导出类是基类的一个超集，在向上转型的过程中，类接口中唯一可能发生的事情是丢失方法，而不是获取它们，这也是为什么编译器在“未曾明确表示转型”或“未曾指定特殊标记”情况下，仍然允许向上转型的原因  </p>
<h3 id="再论组合和继承"><a href="#再论组合和继承" class="headerlink" title="再论组合和继承"></a>再论组合和继承</h3><p>&emsp;&emsp;在面向对象时，生成和使用程序代码最有可能的方法就是直接将数据和方法包装进一个类中，并使用该类的对象，也可以运用组合和继承使用现有类来开发新的类，而继承技术其实是不太常用，即使在学习过程中，过多的强调继承，对于这个技术，也是要谨慎使用，那在一个场合下如何确定你应该使用继承还是组合呢？一个最清晰的判断方法就是要问一问你自己是否需要从新类向基类进行向上转型，如果必须向上转型，则继承是必要的，如果不需要，最好使用组合  </p>
<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p>&emsp;&emsp;根据上下文关系，java的关键字final含义存在着细微的区别，但通常它指的是“这是无法改变的”，不想改变可能出于两个理由：设计和效率，由于这两个理由相差很远，所以关键字final有可能被误用</p>
<h3 id="final数据"><a href="#final数据" class="headerlink" title="final数据"></a>final数据</h3><p>&emsp;&emsp;很多编程语言都有某种方法，来向编译器告知一块数据是恒定不变的，有时数据的恒定不变是很有用的，比如  </p>
<ol>
<li>一个永不改变的编译时常量  </li>
<li><p>一个在运行时被初始化的值，而你不希望它被改变<br>&emsp;&emsp;对于编译器常量这种情况，编译器可以将该常量带入任何可能用到它的计算式中，也就是说，可以在编译时执行计算，这样减轻了运行时的负担，在java中，这类常量必须是基本数据类型，并且以关键字final表示，在对这个常量进行定义时，必须对其进行赋值<br>&emsp;&emsp;一个既是static又是final的域只占据一段不能改变的存储空间<br>&emsp;&emsp;当对对象引用而不是基本类型引用final时，含义有一些令人迷惑，对于基本变量，final使其数值恒定不变，而对于对象引用，final使其引用恒定不变，一旦引用被初始化指向一个对象，就无法再将它改为指向另一个对象，然而对象自身是可以被修改的，java并没有提供使任何对象恒定不变的途径（但可以编写类以取得使对象恒定不变的效果），这一个限制也适用数组，它也是对象<br>&emsp;&emsp;还有一个要注意的是，我们不能因为某数据是final的就认为在编译时就可以知道它的值，但是我们知道一旦这个数据被初始化之后就恒定不变，所以说，final关键字修饰的数据，是在数据被初始化之后保持不变  </p>
<h3 id="空白final"><a href="#空白final" class="headerlink" title="空白final"></a>空白final</h3><p>&emsp;&emsp;java允许生成“空白final” 所谓空白final是被声明为final，但是又为给定初值的域，无论什么情况，编译器确保空白final在使用之前必须被初始化，但是空白final在关键字final的使用上提供了更大的灵活性，为此一个类中的final域可以做到根据对象而不同，却又保持着恒定不变的特性  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">			package xyz.egbert  </span><br><span class="line">			class ProPet&#123;</span><br><span class="line">			    private int i;</span><br><span class="line">			</span><br><span class="line">			    public ProPet(int i) &#123;</span><br><span class="line">			        this.i = i;</span><br><span class="line">			    &#125;</span><br><span class="line">			&#125;</span><br><span class="line">			public class BlankFinal &#123;</span><br><span class="line">			    private final int i=0;</span><br><span class="line">			    private final int j;</span><br><span class="line">			    private final ProPet proPet;</span><br><span class="line">			</span><br><span class="line">			    public BlankFinal()&#123;</span><br><span class="line">			        this.j=0;</span><br><span class="line">			        this.proPet=new ProPet(1);</span><br><span class="line">			    &#125;</span><br><span class="line">			    public BlankFinal(int x)&#123;</span><br><span class="line">			        this.j=x;</span><br><span class="line">			        this.proPet=new ProPet(x);</span><br><span class="line">			    &#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">~~~ </span><br><span class="line">从上面代码示例中可以看到，必须在域定义处或者每个构造器内对final进行赋值，否则IDE工具会提示编译错误，进行源码的编译时也会发生编译失败  </span><br><span class="line">### final参数 ###</span><br><span class="line">&amp;emsp;&amp;emsp;java允许在参数列表以声明的方式将指数指名为final，这意味着你无法在方法中更改参数引用所指向的对象</span><br><span class="line">### final方法 ###</span><br><span class="line">&amp;emsp;&amp;emsp;使用final方法的原因有两个，第一个原因是把方法锁定，以防任何继承类修改它的含义，这是出于设计的考虑，想要确保在继承中使方法行为保存不变，并且不会被覆盖  </span><br><span class="line">在过去第二个原因是效率，在java的早期实现中，如果将一个方法指名为final,就是同意编译器将针对该方法的所有调用都转为内嵌调用，但是在最近的java版本中，已经不再需要使用final方法进行优化了，事实上，这种做法正逐渐受到阻止</span><br><span class="line">#### final和private关键字 ####</span><br><span class="line">&amp;emsp;&amp;emsp;类中的所有private方法都隐式地指定为final的，由于无法取用private方法，所以也就无法覆盖它，可以给private添加final修饰词，但这并不能给该方法增加任何额外的意义</span><br><span class="line">这一问题会造成困扰，我们知道final修饰的方法禁止了继承类的覆盖，如果在继承类中重写基类的final方法，则会引发编译错误，它会提示你这个方法以及在基类中被定义了，可是如果你试图覆盖一个private方法（隐含是final的），似乎是奏效的，而且编译器也不会给出错误信息</span><br></pre></td></tr></table></figure>
<pre><code>package xyz.egbertday;

public class Type {
    private final void f(){
        System.out.print(&quot;Type&quot;);
    }
}

public class SubType extends Type{

    public void f(){
        System.out.print(&quot;subType&quot;);
    }

    public static void main(String[] args){
        SubType subType=new SubType();
        subType.f();
        Type type=subType;
        //type.f();
    }
}
</code></pre><p>~~~</p>
</li>
</ol>
<p>&emsp;&emsp;”覆盖”只是在某个方法是<strong>基类的接口</strong>的一部分时才会出现，即，必须能将一个对象向上转型为它的基类型并调用相同的方法，如果某个方法为private,它就不是基类的接口的一部分，它仅是一些隐藏于类中的程序代码，只不过是具有相同的名字而已，但如果在导出类中以相似的名称生成为一个public，protected或者包访问权限方法的话，该方法就不会产生在基类中出现的“仅具有相同名称”的情况，此时你并没有覆盖该方法，仅是生成了一个新的方法，由于private方法无法触及而且能够有效隐藏，所有<strong>除了把它看成因为它所归属的累的组织结构的原因而存在外，其他任何事物都不需要考虑到它</strong>  </p>
<h3 id="final类"><a href="#final类" class="headerlink" title="final类"></a>final类</h3><p>&emsp;&emsp;当将某个类整体定义成final时，就表明了你不打算继承该类，而且也不允许别人这么做，换句话说，出于某种考虑，你对该类的设计永不需要做任何改动，或者出于安全的考虑，你不希望它有子类</p>
<h2 id="初始化和类的加载"><a href="#初始化和类的加载" class="headerlink" title="初始化和类的加载"></a>初始化和类的加载</h2><p>&emsp;&emsp;在很多传统语言，程序是作为启动过程的一部分立刻被加载的，然后初始化，紧接着程序开始运行    ，这些语言的初始化必须小心控制，以确保定义为static的东西，其初始化的顺序不会造成麻烦<br>&emsp;&emsp;java就不会出现这种问题，因为它采用了不同的加载方式，我喜欢称为（动态加载），加载是众多变得更加容易的动作之一，因为<strong>java中的所有事物都是对象</strong>，请记住，<strong>每个类的编译代码都存在与它自己的独立文件中</strong>    该文件之一在需要使用程序时才会被加载，一般来说，类的代码在初次使用时才加载，这通常是指加载发生在类的第一个对象被创建之时，也会发生当访问static域或static方法时，也会发生加载<br>&emsp;&emsp;初次使用之处也是static初始化发生之处，所有的static对象和static代码都会在加载时依程序中的顺序（即，定义类时的书写顺序）而依次初始化，当然，定义为static的东西只会被初始化一次 </p>
<h3 id="继承和初始化"><a href="#继承和初始化" class="headerlink" title="继承和初始化"></a>继承和初始化</h3><p>导出类的对象创建过程就是，依继承链向上一次进行加载，加载完成之后，根基类中的static初始化即会被执行，然后是下一个导出类，以此类推，这种方式很重要，因为导出类的static初始化可能会依赖于基类成员能否被正确初始化<br>&emsp;&emsp;至此，必要的类都被加载完毕，对象就可以被创建了，首先，对象中所有的基本类型都被设为默认值，对象引用都被设为null——这是通过将对象内存设为二进制零值而一举生成的，然后，基类的构造器就会被调用，它是被自动调用的，但也可以用super来指定对基类构造器的调用，基类构造器和导出类的构造器一样，以同样的顺序来经历相同的过程，在基类构造器完成之后，实例变量按其次序依次被初始化，然后构造器的其余部分被执行  </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;继承和组合都能从现有类型生成新类型，组合一般是将现有类型作为新类型底层实现的一部分加以复用，而继承复用的是接口<br>&emsp;&emsp;在使用继承时，由于导出类具有基类接口，因此它可以向上转型至基类，这对多态来讲至关重要<br>&emsp;&emsp;尽管面向对象编程对继承极力强调，但是开始一个设计时，一般有限选择使用组合（或者可能是代理），只有确实有必要时才使用继承，因为组合更具有灵活性，此外对成员类型使用继承技巧的添加技巧，可以在运行时改变那些成员对象的类型和行为，因此可以在运行时改变组合而成的对象的行为<br>&emsp;&emsp;在设计一个系统时，目标应该是找到或者创建某些类，其中每个类都有具体的用途，而且既不会太大（包含太多的功能而难以复用）。也不会太小（不添加其他功能就不能用），如果你的设计过于复杂，通过将现有类拆分为更小的部分而添加更多的对象，通常这是有帮助的                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/07/复用类/" data-id="cjnzv2pql002ccorz6wlld0kr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-访问权限控制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/06/访问权限控制/" class="article-date">
  <time datetime="2018-10-06T06:39:23.000Z" itemprop="datePublished">2018-10-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习心得/">学习心得</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/06/访问权限控制/">访问权限控制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>访问控制（或隐藏具体实现）与“最初的实现并不恰当”有关  </p>
</blockquote>
<p>几乎所有的代码某些部分经过一段时间再回头看，可能会发现有更好的方式来去实现相同的功能，这正是重构的原动力之一，重构或者重写代码，以使得它更可读，更易理解，更具有可维护性<br>&emsp;&emsp;但是，在这种修改和完善代码的愿望下，也存在着巨大的压力，通常总会有一些消费者（客户端程序员）需要你的代码在某些方面不变，由此产生了面向对象设计中需要考虑的一个基本问题：“如何把变动的事物与保持不变的事物区分开来”<br>这一目标可以通过约定达成，例如，类库的开发者必须保证不得删除任何现有的方法，因为那样会破坏客户端程序员的代码，但是，与之相反的情况更加棘手，在域（数据成员）存在的情况下，类库开发者要怎么知道究竟都有哪些已经被客户端程序员所调用了呢？<br>&emsp;&emsp;为了解决这一问题，java提供了访问权限修饰符，以供类库开发人员指明了哪些是可用的，哪些是不可用的<br>&emsp;&emsp;不过，构件类库的概念已经对于谁有权取用该类库构件的控制问题还是不完善的，其中仍然存在着如何将构件捆绑到一个内聚的类库单元中的问题，对于这一点，java用关键字package加以控制，而访问权限修饰词会因类是存在于一个相同的包还是存在于一个单独的包而受到影响，所以要理解理解访问权限修饰符的全部含义，要先学习如何将类库构件置于包中  </p>
<h2 id="包：库单元"><a href="#包：库单元" class="headerlink" title="包：库单元"></a>包：库单元</h2><p>&emsp;&emsp;由于名字之间的潜在冲突，在java中对名称空间进行完全控制并为每个类创建唯一的标识符组合就成为了非常重要的事情<br>&emsp;&emsp;当编写一个java源代码文件时，此文件通常被称为编译单元（有时也被称为转译单元），每个编译单元都必须要有一个后缀名.java，而在编译单元内则可以有一个public类，该类的名称必须要与源文件名称相同，否则编译器就不会接受，如果在编译单元之中还有额外的类的话，那么包之外的世界是无法看见这些类的，这是因为他们不是public类，而且他们主要是用来为主public类提供支持的  </p>
<h3 id="代码组织"><a href="#代码组织" class="headerlink" title="代码组织"></a>代码组织</h3><p>&emsp;&emsp;当编译一个java文件时，在java文件中的每一个类都会有一个输出文件，而输出文件的名称与.java文件的名称相同，只是多了后缀名.class,因此少量的编译.java文件，就会得到大量的<code>.class</code>文件<br>&emsp;&emsp;java可运行程序时一组可以打包并压缩为一个java文档文件（Jar，使用java的jar文档生成器）的.class文件，java解释器负责这些文件的查找，装载和解释<br>&emsp;&emsp;类库实际上是一组类文件，其中每个文件都有一个public类，以及任意数量的非public类，因此每一个文件都有一个构件，如果希望这些构件（每一个都有它们自己的独立的<code>.java</code>和<code>.class</code>文件）从属同一个群组，就可以使用关键字package<br>    package access;<br>&emsp;&emsp;这表明你在声明该编译单元是名为access的类库的一部分，或者换种说法，你正在声明该编译单元中的public类名称位于access名称的保护伞下，任何想要使用该名称的人都必须使用该类库构件的全名或者使用import关键  </p>
<h3 id="创建独一无二的包名"><a href="#创建独一无二的包名" class="headerlink" title="创建独一无二的包名"></a>创建独一无二的包名</h3><p>&emsp;&emsp;其实一个包从未真正将被打包的东西包装成一个单一的文件，并且一个包可以由许多.class文件构成，也就是说，我们只是定义了类是在哪个命名空间下，通过命名空间和类名唯一地标识这个类，那么情况有点复杂，当我们的程序在运行的时候，应该去哪里找到某个特定类的定义信息（就是<code>.class</code>文件）呢？<br>&emsp;&emsp;为了避免这种情况的发生，一种合乎逻辑的做法就是将特定包内的所有<code>.class</code>文件都置于一个目录下，也就是说，利用操作系统的层次化的文件结构来解决这个问题<br>&emsp;&emsp;将所有文件收入一个子目录还可以解决另外两个问题：创建独一无二的名称已经怎么查找有可能隐藏于目录结构中的某处的类<br>第一个问题是，通过域名反写的形式创建独一无二的类<br>第二个问题是：把package名称分解为你机器上的一个目录，所以java程序运行并需要加载<code>.class</code>文件的时候，它就可以确定<code>.class</code>文件在目录上所处的目录<br>&emsp;&emsp;java解释器的运行过程如下：首先，找到环境变量CLASSPATH，CLASSPATH包含一个或多个目录，用作查找<code>.class</code>文件的根目录，从根目录开始，解释器将包名解析成目录，得到的目录与CLASSPATH中的各个不同的项相连接，解释器就在这些目录下查找与你所要创建的类名称相关的<code>.class</code>文件，所要我们要想使用某个类库，一定要在将类库放在CLASSPATH变量中指定的目录的任意一个，或者也可以将类库的当前目录添加到CLASSPATH变量中，JAR文件有些许变化，必须要在类路径中将JAR文件的实际名称写清楚，而不仅仅只是指出它所在的目录  </p>
<h2 id="java访问权限修饰符"><a href="#java访问权限修饰符" class="headerlink" title="java访问权限修饰符"></a>java访问权限修饰符</h2><table>
<thead>
<tr>
<th>权限修饰词</th>
<th>权限说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>允许任意的类对其修饰的成员访问</td>
</tr>
<tr>
<td>private</td>
<td>只有包含该成员的类才能对其访问</td>
</tr>
<tr>
<td>protected</td>
<td>只有派生类和同包的类才能对其进行访问</td>
</tr>
<tr>
<td>默认包访问权限</td>
<td>只有同一个类库下的类才能对其访问  </td>
</tr>
</tbody>
</table>
<p>&emsp;&emsp;我想对访问权限多说一些，对于初学者对访问权限并不是很清楚，即使是工作多年的java工程师对访问权限控制也没有很清晰的认识，即使认知如此，好像也不太影响完成项目的任务，可是我还是想把这些事情讲清楚说明白些<br>&emsp;&emsp;我们都知道java是门面向对象的语言，以面向对象的思维编程很符合人类的思维习惯，可是我们应该清楚的是，java之所以有面向对象的特性,要感谢编译器，我们之前描述方法的执行往往是说发送消息给对象，这是面向对象的说法，真正的过程应该是对这个对象的数据执行方法定义的程序，具有过程，比较复杂，这里牵扯到cpu和内存，指令之间的关系，不过我们只需要知道对对象数据进行操作就足够理解权限控制的含义了，由此我们也知道，同一个类型的所有对象的方法代码只有一份，放在方法区，每个对象都有自己独有的数据放在堆中，方法代码和数据分离，理解下面四个问题，就能明白访问权限控制的全部含义</p>
<ol>
<li>什么是“权限”？ </li>
<li>权限是限制谁的？   </li>
<li>权限可以修饰哪些元素？</li>
<li>访问权限修饰符是给谁用的<br>&emsp;&emsp;“权限”中文的含义很简单，就是权力的限制，直接讲就是可以做什么<br>&emsp;&emsp;权限是限制其他类的，对于被访问修饰符修饰的元素来说，其他的类对于它来讲，只有三个身份，分别是其他的类，同类库的类，派生的类，对于这三种身份，不同的权限修饰符给与他们的访问权限不同，举例来说，对于protected修饰的元素来说，其他类型的类不能对其访问，同类库和派生类可以对其访问<br>&emsp;&emsp;访问权限修饰符可以修饰哪些元素，类，域和方法<br>&emsp;&emsp;访问权限修饰符是给编译器使用的，编译过程保证了互相调用的正确性，访问权限会被编译器编译进类的字节码文件（<code>.class</code>文件）中，以供编译器编译新代码时作为权限检查的信息来使用<br>&emsp;&emsp;在讲一些小的细节吧，如果A能访问B,B能够访问C,但是A不能访问C,那么A可以“调用”C中的方法吗？答案是不可以，C中的方法能否被访问，要查看调用它的类对于它的权限，但是A却可以通过B来调用C,我喜欢称为委托，也就是说方法的调用是两个类之间的事情，有点绕，但是很有意思<h2 id="接口和实现"><a href="#接口和实现" class="headerlink" title="接口和实现"></a>接口和实现</h2>&emsp;&emsp;访问权限的控制常被称为具体实现的隐藏，把数据和方法包装进类中，以及具体实现的隐藏，常共同被称作时封装，其结果是一个同时用于特征和行为的数据类型<br>&emsp;&emsp;出于两个很重要的原因，访问权限控制的边界划在了数据类型的内部，第一个原因时要设定客户端程序员可以使用和不可以使用的界限，这个原因直接引出了第二个原因，实现接口和实现的分离  <h2 id="类的访问权限"><a href="#类的访问权限" class="headerlink" title="类的访问权限"></a>类的访问权限</h2>&emsp;&emsp;在java中，权限控制符也可以用于确定库中的哪些类对于库的使用者是可用的，如果希望某个客户端程序员能够使用这个类，就使用public来定义这个类，这样做甚至可以控制客户端程序员能否创建一个该类的对象<br>&emsp;&emsp;这里有一些限制  </li>
<li>每个编译单元（<code>.java</code>文件）都只能有一个public类，这表示，每个编译单元只能有一个公共接口  </li>
<li>public类必须完全与含有编译单元的文件名相匹配  </li>
<li>虽然不是很常用，但编译单元内完全不带public类也是可能的，在这种情况下，可以随意对文件命名，但是不建议<br>&emsp;&emsp;还有需要注意的是：类的定义一定不能是private或者protected的，只能是public或者不加任何修饰符的包访问权限</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/06/访问权限控制/" data-id="cjnzv2psg0038corz1nedft25" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-初始化与清理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/05/初始化与清理/" class="article-date">
  <time datetime="2018-10-05T15:57:28.000Z" itemprop="datePublished">2018-10-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习心得/">学习心得</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/05/初始化与清理/">初始化与清理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>随着计算机革命的发展，“不安全”的编程方式已逐渐成为编程代价高昂的主要原因<br>&emsp;&emsp;初始化和清理（cleanup）正是涉及安全的两个问题，许多C程序的错误都源于程序员忘了初始化变量，特别是在使用程序时，如果用户不知道如何初始化库的构件（或者是用户必须要初始化的其他东西）更是如此，清理也是一个特殊问题，当使用一个元素时，它对你不会有什么影响了，所有很容易把它忘掉，这样一来，这个元素占用的资源得不到释放  </p>
</blockquote>
<h2 id="用构造器确保初始化"><a href="#用构造器确保初始化" class="headerlink" title="用构造器确保初始化"></a>用构造器确保初始化</h2><p>&emsp;&emsp;假想为每个类都定义一个初始化方法，命名为<code>intialize()</code>好了，所以你在向对象发送消息之前，为了确保对象被恰当地初始化了，你应该先主动去调用这个<code>initialize()</code>方法，可是如果你忘了怎么办呢？如果我们咋创建对象的时候能够自动进行对象的初始化工作就好了，这样就确保了我们创建的对象一定被正确地初始化了<br>&emsp;&emsp;接下来的问题是如何命名这个初始化方法，有两个问题  </p>
<ol>
<li>所取的任何名字都可能会与方法名冲突</li>
<li>调用构造器是编译器的责任，编译器应该要调用这一个方法<br>我们的解决的方法很简单，构造器的名称和类名相同，这是一种约定，即解决了和方法名字的冲突问题，又解决了编译器识别的问题，构建哪个类的对象就调用那个类的与方法名相同的构造函数  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Rock();</span><br></pre></td></tr></table></figure>
&emsp;&emsp;上述创建对象的过程可以被拆解成两步，第一步，为对象分配内存空间，第二步，调用相对应的构造函数，理论上讲，“初始化”和“创建”是彼此独立的，然而在java代码中你找不到两者之间的界限，也看不到对构造的显式调用，java将“初始化”和“创建”捆绑在了一起，两者不能分离<br>&emsp;&emsp;构造函数是一种特殊的函数，说特殊，是因为它在对象创建的过程中就被自动调用了，而且只能被调用一次，且构造函数的代码中没有返回值，这与void不同，其实构造函数被调用之后会返回新对象的一个引用，只是我们在构造函数中不写返回类型，这是一种规定，你只需遵守就行了<h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2>&emsp;&emsp;大多数程序设计语言要求为每个方法（在有些语言中经常成为函数）都提供一个独一无二的标识符，在java（和C++）里，构造器是强制重载方法名的一个很重要的一个原因，既然构造器的方法名由类名决定，那就只能有一个构造器，可是如果我想以多种方式来创建一个对象时该怎么办呢？为了让方法名相同而参数不同的构造器同时存在，必须要用到方法的重载  <h3 id="区分方法重载"><a href="#区分方法重载" class="headerlink" title="区分方法重载"></a>区分方法重载</h3>要是有几个方法都要相同的方法，java如何知道你指的是哪个方法呢？其实规则很简单，每个重载的方法都必须要有一个独一无二的参数类型列表，注意返回值类型不作为方法重载的依据，因为如果我们只是利用方法的副作用而不使用方法的返回值的话，编译器还是没办法判断应该调用哪一个方法例如<br> void say(){};<br> String say(){};<br> a.say();<br>&emsp;&emsp;这样你能判断a调用的是哪个方法吗？不能，所有为了避免java的困扰，返回值类型不能作为方法重载的依据<h3 id="涉及基本类型的重载"><a href="#涉及基本类型的重载" class="headerlink" title="涉及基本类型的重载"></a>涉及基本类型的重载</h3>&emsp;&emsp;基本类型的重载是，先找那些方法的参数类型最符合自己类型的方法，如果找不到以此向上提升，注意，有一个特殊，如基本类型为char，先找参数类型为char的方法，若找不到，则直接提升到int类型<h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2>&emsp;&emsp;我觉得《Thinking in java》的作者Bruce Eckel对方法调用解释的很清楚，我们看下他是如何解释代码调用的：<br>&emsp;&emsp;如果有同一个类型的两个对象a,b，如何让才能这两个对象都能调用peel()方法呢？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Banana&#123; void peel(int i)&#123;/* */&#125;&#125;</span><br><span class="line">public class BananaPeel&#123;</span><br><span class="line">   public static void main(String[] args)&#123;</span><br><span class="line">   Banana a=new Banana(),b=new Banana();</span><br><span class="line">   a.peel(1);</span><br><span class="line">   b.peel(2); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>&emsp;&emsp;如果只有一个peel()方法，它如何知道是被a还是被b调用呢？<br>&emsp;&emsp;为了能用简单，面向对象的语法编写代码——即“发送消息给对象”，编译器做了一些某后工作，它暗自把“操作对象的引用”作为第一个参数传递给peel()，所以上述两个方法的调用就变成了这样：<br>    Banana.peel(a,1);<br>    Banana.peel(b,2);<br>&emsp;&emsp;这是内部表示，我们并不能这样写代码，上面这行的意思时，执行Banana类中定义的<code>peel()</code>方法，方法的参数是a,1,这才是代码底层做的事情，不过为了满足我们面向对象的思维，我们使用<code>a.peel()</code>这种形式，而其他的事情，编译器帮我们摆平<br>&emsp;&emsp;如何在方法内部获得对当前对象的引用？由于这个引用是编译器“偷偷”地帮我们加的，所以没有标识符可用，但是为此有一个专门的关键字this,this关键字只能在方法内部使用，表示“调用方法的那个对象”<br>&emsp;&emsp;this关键字的用法：</p>
<ol>
<li>可以将当前对象传递给其他方法使用</li>
<li>在构造器调用构造器时使用<h3 id="static的含义"><a href="#static的含义" class="headerlink" title="static的含义"></a>static的含义</h3>&emsp;&emsp;了解this关键字之后，就能全面理解static(静态)方法的含义了，static方法就是没有this的方法，在static方法的内部不能调用非静态方法，因为那些非静态类的方法都需要this类型的参数，而static方法并不能提供给它们，反过来，非静态类的方法是可以调用静态方法的<br>&emsp;&emsp;有些人认为static方法不是“面向对象的”，因为它的确具有全局函数的语义，使用static方法时，由于不存在this，所有不是通过“向对象发送消息”的方式执行的，这种说法还是有些道理的，所有，如果你的代码中存在大量的static方法，就该重新考虑自己的程序了  <h2 id="清理：终结处理和垃圾回收"><a href="#清理：终结处理和垃圾回收" class="headerlink" title="清理：终结处理和垃圾回收"></a>清理：终结处理和垃圾回收</h2><h2 id="成员初始化"><a href="#成员初始化" class="headerlink" title="成员初始化"></a>成员初始化</h2>&emsp;&emsp;java尽力保证，所有的变量在使用之前都能得到适当的初始化，对于方法的局部变量，java以编译时错误的形式来贯彻这项保证·<h2 id="构造器初始化"><a href="#构造器初始化" class="headerlink" title="构造器初始化"></a>构造器初始化</h2>&emsp;&emsp;可以用构造器来初始化，在运行时刻，可以调用方法或执行某些动作来确认该值，这为编程带来了更大的灵活性，但是要记住，无法阻止自动初始化的进行，它将在构造器被调用之前发生<h3 id="初始化的顺序"><a href="#初始化的顺序" class="headerlink" title="初始化的顺序"></a>初始化的顺序</h3>&emsp;&emsp;在类的内部，变量定义的顺序决定了初始化的顺序，即使变量定义散布于方法定义之间，它们仍然会在任何方法（包括构造器）之前得到初始化<h3 id="静态数据的初始化"><a href="#静态数据的初始化" class="headerlink" title="静态数据的初始化"></a>静态数据的初始化</h3>无论创建多少个对象，静态数据都只占一份存储区域，static关键字不能应用于局部变量，因此它只能作用于域，如果一个域时静态的基本类型域，且也没有对它进行初始化，那么它就会获得基本类型的标准初值，如果它是一个对象，那么它的默认值就是null<br>&emsp;&emsp;静态初始化只有在必要的时刻才会进行，什么是必要时刻？就是一切触发包含静态成员类的加载的行为都是必要时刻<br>&emsp;&emsp;初始化的顺序是先静态变量（如果它们尚未因前面的对象创建过程而被初始化的话，记住静态初始化只会进行一次，那就是在类第一次被加载的时刻）<br>，而后时非静态变量<br>&emsp;&emsp;总结一下对象的创建过程，假设一个Dog类  </li>
<li>即使没有显式地使用static关键字，构造器实际上也是静态方法，因此，当首次创建Dog对象时（构造器可以看成静态方法），或者Dog类的静态方法被调用时，解释器必须查找类路径，以定位Dog.class文件</li>
<li>然后载入Dog.class,创建一个Class对象，有关静态初始化的所有动作都会被执行，因此，静态初始化只在Class对象首次加载的时候进行一次</li>
<li>当用new Dog()创建对象的时候，首先将在堆上为Dog对象分配足够的内存空间</li>
<li>这块存储空间会被清零，这就自动地将Dog对象中的所有类型数据都设成默认值</li>
<li>执行所有出现在字段定义初的初始化</li>
<li>执行构造器  <h3 id="显示的静态初始化"><a href="#显示的静态初始化" class="headerlink" title="显示的静态初始化"></a>显示的静态初始化</h3>&emsp;&emsp;java允许将多个静态初始化动作组织成一个特殊的“静态子句”，有时也叫做静态块，静态块先其他的静态成员一样，也是在类被首次加载的时候被执行一次  <h3 id="非静态实例初始化"><a href="#非静态实例初始化" class="headerlink" title="非静态实例初始化"></a>非静态实例初始化</h3>&emsp;&emsp;非静态实例初始化很像静态块，只是在代码块前面没有static关键字，这种语法对于支持“匿名内部类”的初始化时必须的，但是它也可以使你保证无论使用那个构造器，某些操作都会发生，而且是在构造器执行之前执行  <h2 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h2>&emsp;&emsp;数组只是相同类型的，用一个标识符名称封装到一起的一个对象序列或基本类型数据序列，记住，数组也是对象，在java中除了基本类型 一起皆对象，数据可以通过方括号下标操作符<code>[]</code>来定义和使用，要定义一个数组，只需要在类型名后面加上一对中括号即可<br> int[] a;<br> int a[];<br>&emsp;&emsp;两种格式都一样，我更喜欢第一种方式，上述两种方式都只是让我们拥有一个引用，并且指出了这个引用所代表的数据类型，随便说一句，java是强类型语言，标识符前面的类型往往是为了类型检查的需要<br>&emsp;&emsp;数组类型主要分为两种，一种是基本数据类型数值，一种时引用类型数值，基本数据类型数组内部持有着基本数据类型的值，而引用类型数值元素是引用，如图：</li>
</ol>
<p>&emsp;&emsp;所有数组（无论它们的元素时对象还是引用）都有一个固定成员，可以通过它获知数组内包含了多少元素，但不能对其修改，这个成员就是length,数值索引从0开始</p>
<h3 id="可变参数列表"><a href="#可变参数列表" class="headerlink" title="可变参数列表"></a>可变参数列表</h3><pre><code>void variableList(String... args);
</code></pre><p>&emsp;&emsp;上述语法就是从在java SE5新添加的可变参数列表的特性，有了可变参数，就不用显式地编写数组语法了<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">argsList</span><span class="params">(String[] args)</span></span>;</span><br></pre></td></tr></table></figure>，当你指定参数时，编译器实际上会为你去填充数组，你获取的仍旧是一个数组</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/05/初始化与清理/" data-id="cjnzv2pon001kcorzsmtrjsmt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-操作符" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/05/操作符/" class="article-date">
  <time datetime="2018-10-05T12:24:07.000Z" itemprop="datePublished">2018-10-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习心得/">学习心得</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/05/操作符/">操作符</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/05/操作符/" data-id="cjnzv2prg002qcorzxngianzw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-一切都是对象" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/05/一切都是对象/" class="article-date">
  <time datetime="2018-10-05T02:40:48.000Z" itemprop="datePublished">2018-10-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习心得/">学习心得</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/05/一切都是对象/">一切都是对象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="用引用操作对象"><a href="#用引用操作对象" class="headerlink" title="用引用操作对象"></a>用引用操作对象</h2><p>&emsp;&emsp;每种语言都有自己的操作内存元素的方式，有时候，程序员必须注意将要处理的数据类型是什么。你是直接操作元素，还是用某种基于特殊语法的间间接表示（例如C和C++里的指针）来操作对象<br>&emsp;&emsp;所有的一切在java这里得到了简化，一切都被视为对象，因此可采用单一固定的语法，尽管一切都看作对象，但操作的标识符实际上是对象的一个“引用”（reference）。</p>
<h2 id="必须由你创建所有对象"><a href="#必须由你创建所有对象" class="headerlink" title="必须由你创建所有对象"></a>必须由你创建所有对象</h2><h3 id="存储到什么地方"><a href="#存储到什么地方" class="headerlink" title="存储到什么地方"></a>存储到什么地方</h3><p>程序运行的时候，对象是怎么进行放置安排的呢？特别是内存时怎样分配的呢？有五个不同的地方可以存储数据  </p>
<ol>
<li>寄存器。这是最快的存储区，因为它位于不同于其他存储区的地方——处理器内部，但是寄存器的数量有限，所以寄存器根据需求进行分配，你不能直接控制，也不能在程序中感觉到寄存器存在的任何迹象（一方面，C和C++允许你向编译器建议寄存器的分配方式）  </li>
<li>堆栈：位于通用RAM(随机访问存储器)中，但通过堆栈指针可以从处理器那里获得直接支持，堆栈指针若向下移动，则分配新的内存，若向上移动，则释放那些内存，这是一种快速有效的分配存储方法，创建程序时，Java系统必须知道存储在堆栈内所有的确切生命周期，以便上下移动堆栈指针，这一约束限制了程序的灵活性，所以虽然某些java数据存储在堆栈中——特别是对象引用，但是java对象并不存储于其中  </li>
<li>堆，一种通用的内存池（也位于RAM区），用于存放所有的java对象，堆不同于堆栈的好处是：编译器不需要知道存储的数据在堆中存活多少时间，因此，在堆中分配有很大的灵活性  </li>
<li>常量存储：常量值通常直接存放在程序代码内部，这样做是安全的，因为它们永远不会被改变，有时，在嵌入式系统中，常量本身和其他部分分割离开，所以在这种情况下，可以选择将其存放在ROM（只读存储器）中  </li>
<li>非RAM存储。如果数据完全存活于程序之外，那么它可以不受程序的任何控制，在程序没有运行时也可以存在，其中两个基本的例子时流对象和持久化对象  </li>
</ol>
<h3 id="特例：基本类型"><a href="#特例：基本类型" class="headerlink" title="特例：基本类型"></a>特例：基本类型</h3><p>&emsp;&emsp;在程序设计中经常用到一系列类型，它们需要特殊对待，可以把它们想象成“基本”类型<br>之所以特殊对待，是因为new将对象存储在“堆”里，故用new创建一个对象——特别是小的，简单的变量，往往不是很有效，因此，对于这些类型，java采取与C和C++相同的方法，也就是说，不用new来创建对象，而是创建一个并非是引用的“自动”变量，这个变量直接存储“值”，并置于堆栈中，因此更加高效<br>&emsp;&emsp;java要确定每种基本类型所占存储空间的大小，它们的大小并不像其他大多数语言那样随机器架构的变化而变化，所以java所编写的程序比其他语言更具有可移植性  </p>
<h3 id="高精度数字"><a href="#高精度数字" class="headerlink" title="高精度数字"></a>高精度数字</h3><p>&emsp;&emsp;java提供了两个用于高精度计算的类：BigInteger和BigDecimal,可以将它们看成是包装器类，但是它们并没有相应的基本类型，它们都支持任意精度的数字，其实很好理解，因为它们的数据类型使得它们可以接受更多的位来表示数值  </p>
<h3 id="java中的数组"><a href="#java中的数组" class="headerlink" title="java中的数组"></a>java中的数组</h3><p>&emsp;&emsp;几乎所有的程序设计语言都支持数组，在C和C++中使用数组时危险的，因为它们的数组就是内存块，如果一个程序要访问其自身内存块之外的数组，或在数组初始化前使用内存，将产生难以预料的后果<br>&emsp;&emsp;java的一个主要目标之一就是安全性，java确保数组会被初始化，而且不能在它的范围外被访问，这种范围检查，是以每个数组上少量的内存开销及运行时的范围检查为代价的，但由此换来的是安全性和效率的提高  </p>
<h2 id="永远不需要销毁对象"><a href="#永远不需要销毁对象" class="headerlink" title="永远不需要销毁对象"></a>永远不需要销毁对象</h2><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>&emsp;&emsp;大多数过程型语言都有作用域(scope)的概念,作用域决定了在其内定义的变量名的可见性和生命周期</p>
<h3 id="对象的作用域"><a href="#对象的作用域" class="headerlink" title="对象的作用域"></a>对象的作用域</h3><p>&emsp;&emsp;java对象不具备和基本数据类型一样的生命周期，当new创建一个java对象时，它可以存活于作用域之外<br>&emsp;&emsp;如果java让对象一直存在，那么靠什么才能防止这些对象填满内存空间，进而阻塞你的程序呢？这正是C++里可能会发生的问题，这也是java的神奇之处，java有一个垃圾回收器，用来监视用new创建的所有对象，并辨别那些不会再被引用的对象。随后，释放这些对象的内存空间，以便供其他新的对象使用</p>
<h2 id="创建新的数据类型：类"><a href="#创建新的数据类型：类" class="headerlink" title="创建新的数据类型：类"></a>创建新的数据类型：类</h2><p>&emsp;&emsp;如果一切都是对象，那么是什么决定了某一类对象的外观和行为呢？换句话说，是什么确定了对象的类型</p>
<h3 id="字段和方法"><a href="#字段和方法" class="headerlink" title="字段和方法"></a>字段和方法</h3><p>&emsp;&emsp;一旦定义了一个类（在java中你所做的全部工作就是定义类，产生那些类的对象，以及发送消息给这些对象）就可以在类中设置两种类型的元素，字段（有时称做数据成员）和方法（有时称作函数成员）  </p>
<h3 id="基本成员默认值"><a href="#基本成员默认值" class="headerlink" title="基本成员默认值"></a>基本成员默认值</h3><p><table><tr><th>基本类型</th><th>默认值</th></tr><tr><td>boolean</td><td>fasle</td></tr><tr><td>char</td><td>‘\u0000’(null)</td></tr><tr><td>byte</td><td>(byte)0</td></tr><tr><td>short</td><td>(short)0</td></tr><tr><td>int</td><td>0</td></tr><tr><td>long</td><td>0L</td></tr><tr><td>float</td><td>0.0f</td></tr><tr><td>double</td><td>0.0d</td></tr></table></p>
<h2 id="方法，参数和返回值"><a href="#方法，参数和返回值" class="headerlink" title="方法，参数和返回值"></a>方法，参数和返回值</h2><p>&emsp;&emsp;返回类型描述的是在调用方法之后从方法返回的值，参数列表给出了要传递个方法的信息的类型和名称，方法名和参数列表（它们合起来被称为“方法签名”），唯一地标识出某个方法</p>
<h2 id="java程序"><a href="#java程序" class="headerlink" title="java程序"></a>java程序</h2><h3 id="名字的可见性"><a href="#名字的可见性" class="headerlink" title="名字的可见性"></a>名字的可见性</h3><p>&emsp;&emsp;名字管理对任何程序设计语言都是一个重要的问题，如果在程序的某个模块里使用了一个名字，而其他人在这个程序的另一个模块里也使用了相同的名字，那么怎么区分这两个名字并防止二者互相冲突<br>&emsp;&emsp;java采用了一种全新的方法来避免上述的问题。为了给每一个类库生成不会与其他名字混淆的名字，java设计者希望程序员反过来使用自己的internet域名</p>
<h3 id="运用其他构件"><a href="#运用其他构件" class="headerlink" title="运用其他构件"></a>运用其他构件</h3><p>&emsp;&emsp;如果想在自己的程序使用预先定义好的类，那么编译器就必须知道怎么定位它们，当然这个类可能就在发生调用的那个<strong>源文件</strong>中，在这种情况下，就可以直接使用这个类<br>&emsp;&emsp;如果那个类位于其他文件中呢？又会怎样？编译器没有那么聪明知道你要使用的类应该在哪里查找，所以你要明确地告诉编译器你想要的类是什么，import指示编译器导入一个包，也就是一个类库</p>
<h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><p>&emsp;&emsp;通常来说，当创建类时，就是在描述那个类的对象的外观和行为，除非用new创建那个类的对象，否则，实际上并未获得任何对象，执行new来创建对象时，数据存储空间才被分配，其方法才供外部调用<br>&emsp;&emsp;有两种情况是上述方法无法解决的  </p>
<ol>
<li>只想为某特定域分配单一存储空间，而不去考虑究竟要创建多少对象吗，甚至根本就不创建对象</li>
<li>希望某个方法不与包含它的类的任何对象关联在一起，也就是说，寄生不创建对象，也能调用这个方法<br>&emsp;&emsp;通过static关键字可以满足这两方面的要求，有些面向对象的语言采用类数据和类方法两个术语，代表那些数据和方法是作为整个类，而不是类的某个特定对象而存在的<br>&emsp;&emsp;尽管当static作用在某个字段时，肯定会改变数据创建的方式（因为一个static字段对每一个类来说都只是一份存储空间，而非static字段则是每个对象有一个存储空间），但是如果static作用于方法上，差别就没有那么大   <h3 id="编译和运行"><a href="#编译和运行" class="headerlink" title="编译和运行"></a>编译和运行</h3>&emsp;&emsp;要编译，运行一个程序，首先必须要有一个java开发环境，目前，有相当多的第三方厂商提供开发环境，我们当前使用的是SUN免费提供的JDK（java Developer’s Kit）开发环境为例<br>&emsp;&emsp;安装好JDK之后，还要设定好路径信息，以确保计算机能够找到javac和java这两个文件  </li>
</ol>
<h2 id="注释和嵌入式文档"><a href="#注释和嵌入式文档" class="headerlink" title="注释和嵌入式文档"></a>注释和嵌入式文档</h2><p>先来看一下注释，在java中有三种方式的注释  </p>
<ol>
<li>单行注释 //</li>
<li>多行注释 /**/</li>
<li>文档注释 /<strong>  </strong>/   <h3 id="注释文档"><a href="#注释文档" class="headerlink" title="注释文档"></a>注释文档</h3>&emsp;&emsp;文档撰写的最大问题，大概就是对文档的维护了，如果文档与代码是分离的，修改代码时，同时也要修改相应的文档，相当的麻烦啊，解决办法很简单，就是将代码和文档“链接”起来，为了达到这个目的，最简单的方法就是将所有的东西都放在同一个文件内，为了实现这个目的，就必须使用一种特使的注释语法来标记文档，此外还需要一个能够提取文档信息的工具<br>&emsp;&emsp;javadoc就是这样的一个工具，它是jdk安装的一部分，它采用了java编译器的某些技术，查找程序内特殊注释标签，它不仅解析由这些标签标记的信息，也将毗邻的类名或方法名提取出来，因此，我们可以用最少的工作量，生成相当好的程序文档，生成的文档是HTML格式<br>&emsp;&emsp;需要注意的是，能够生成文档的工具不止javadoc，使用时应该要遵守对应工具的语法规则，不过，如果没有什么特别的需求，javadoc已经很好了<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3>使用javadoc的方式有两种   </li>
</ol>
<ol>
<li>一种是HTML,可在文档注释中直接写HTML，并没有什么特殊的，只是要注意不要在嵌入式HTML重使用标题标签，因为javadoc会插入自己的标题，而你的标题可能会同它们冲突  </li>
<li>一种是使用注释标签下面是这些标签的一些示例</li>
</ol>
<table>
<thead>
<tr>
<th>标签</th>
<th>语法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>@see</td>
<td>@see classname<br>@see classname<br>@see fully-qualfied-classname#method-nam</td>
<td>会在生成的文档中添加一个具有超链接的“see also”</td>
</tr>
<tr>
<td>{@link package.class#member label}</td>
<td></td>
<td>该标签与@see及其类似，只是它用于行内，并且文档使用“label”作为超链接文本而不是“see also”</td>
</tr>
<tr>
<td>{@docRoot}</td>
<td></td>
<td>该标签产生到文档根目录的相对路径，用于文档树页面的显式超链接</td>
</tr>
<tr>
<td>{@inheritDoc}</td>
<td></td>
<td>该标签从当前这个类的最直接的基类中继承相关文档到当前的文档注释</td>
</tr>
<tr>
<td>@version</td>
<td>@version version-information</td>
<td>版本信息</td>
</tr>
<tr>
<td>@author</td>
<td>@author author-information</td>
<td>作者信息</td>
</tr>
<tr>
<td>@since</td>
<td></td>
<td>允许你指定程序代码最早使用的版本，可以在HTML,java文档中看到它被用来指定所用的JDK版本的情况</td>
</tr>
<tr>
<td>@param</td>
<td>@param param-name discripton</td>
<td>可以多次使用这个标签，大约每个参数都有一个这样的标签</td>
</tr>
<tr>
<td>@return</td>
<td>return description</td>
<td>用来描述返回值的含义</td>
</tr>
<tr>
<td>@throws</td>
<td>@throws fully-qualified-class-name descripton</td>
<td>可以多次使用，异常的全限定名和引发异常的原因</td>
</tr>
<tr>
<td>@deprecated</td>
<td></td>
<td>该标签用于指出一些旧特性已由改进的新特性所取代，建议用户不要再使用这些旧特性</td>
</tr>
</tbody>
</table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/05/一切都是对象/" data-id="cjnzv2pol001jcorz670h0hee" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/学习心得/">学习心得</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML5/">HTML5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Maven/">Maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Oracle/">Oracle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Servlet-JSP/">Servlet&JSP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-MVC/">Spring MVC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-boot/">Spring boot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-cloud/">Spring cloud</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/HTML5/" style="font-size: 10px;">HTML5</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/Node-js/" style="font-size: 10px;">Node.js</a> <a href="/tags/Oracle/" style="font-size: 10px;">Oracle</a> <a href="/tags/Servlet-JSP/" style="font-size: 10px;">Servlet&JSP</a> <a href="/tags/Spring/" style="font-size: 10px;">Spring</a> <a href="/tags/Spring-MVC/" style="font-size: 10px;">Spring MVC</a> <a href="/tags/Spring-boot/" style="font-size: 10px;">Spring boot</a> <a href="/tags/Spring-cloud/" style="font-size: 10px;">Spring cloud</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/11/02/Servlets/">Servlets</a>
          </li>
        
          <li>
            <a href="/2018/10/27/并发/">并发</a>
          </li>
        
          <li>
            <a href="/2018/10/19/注解/">注解</a>
          </li>
        
          <li>
            <a href="/2018/10/19/枚举类型/">枚举类型</a>
          </li>
        
          <li>
            <a href="/2018/10/19/Java-I-O系统/">Java I/O系统</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 EgbertDay<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>